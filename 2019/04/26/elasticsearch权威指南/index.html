<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="elasticsearch,">










<meta name="description" content="本文引用自Elasticsearch:权威指南,基于 Elasticsearch 2.x 版本。书中既有对原理的介绍，也有对es使用的说明，非常值得一读。">
<meta name="keywords" content="elasticsearch">
<meta property="og:type" content="article">
<meta property="og:title" content="elasticsearch(2.x)教程">
<meta property="og:url" content="http://yoursite.com/2019/04/26/elasticsearch权威指南/index.html">
<meta property="og:site_name" content="小光的博客">
<meta property="og:description" content="本文引用自Elasticsearch:权威指南,基于 Elasticsearch 2.x 版本。书中既有对原理的介绍，也有对es使用的说明，非常值得一读。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/1.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/2.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/3.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/4.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/5.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/6.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/7.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/8.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/9.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/10.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/11.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/12.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/13.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/14.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/15.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/16.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/17.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/18.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/19.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/20.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/21.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/22.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/23.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/24.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/25.jpg">
<meta property="og:image" content="https://mfaying.github.io/images/elasticsearch2.x/26.jpg">
<meta property="og:updated_time" content="2019-11-11T05:06:28.324Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="elasticsearch(2.x)教程">
<meta name="twitter:description" content="本文引用自Elasticsearch:权威指南,基于 Elasticsearch 2.x 版本。书中既有对原理的介绍，也有对es使用的说明，非常值得一读。">
<meta name="twitter:image" content="https://mfaying.github.io/images/elasticsearch2.x/1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/26/elasticsearch权威指南/">





  <title>elasticsearch(2.x)教程 | 小光的博客</title>
  








  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?bacbd4424722e498fac9ea507f3a8807";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  window.onload=function(){
    if (!sessionStorage.getItem('homePgCount')) {
      sessionStorage.setItem('homePgCount', Math.floor(new Date().getSeconds() % 11));
    }
    $('.header-inner').css("backgroundImage", 'url("https://mfaying.github.io/images/bg' + (sessionStorage.getItem('homePgCount') || 0) + '.jpg")')
    $('.blur-bg').css("backgroundImage", 'url("https://mfaying.github.io/images/bg' + (sessionStorage.getItem('homePgCount') || 0) + '.jpg")')
  }

  </script>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="blur-bg"></div>
  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小光的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/26/elasticsearch权威指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小光">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小光的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">elasticsearch(2.x)教程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-26T12:42:04+08:00">
                2019-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/26/elasticsearch权威指南/" class="leancloud_visitors" data-flag-title="elasticsearch(2.x)教程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文引用自<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/docvalues-intro.html" target="_blank" rel="noopener">Elasticsearch:权威指南</a>,基于 Elasticsearch 2.x 版本。书中既有对原理的介绍，也有对es使用的说明，非常值得一读。</p>
<a id="more"></a>
<p>现有的技术都集中在如何解决数据仓库存储以及如何结构化这些数据。 这些看上去都挺美好，直到你实际需要基于这些数据实时做决策分析的时候才发现根本不是那么一回事。Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。</p>
<h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><p>Elasticsearch 是一个实时的分布式搜索分析引擎， 它能让你以一个之前从未有过的速度和规模，去探索你的数据。 它被用作全文检索、结构化搜索、分析以及这三个功能的组合。</p>
<p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可能是目前存在的，不论开源还是私有的，拥有最先进，高性能和全功能搜索引擎功能的库。</p>
<p>Elasticsearch 是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目标是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p>
<p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p>
<p>1.一个分布式的实时文档存储，每个字段 可以被索引与搜索<br>2.一个分布式实时分析搜索引擎<br>3.能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</p>
<p>就 Elasticsearch 而言，起步很简单。对于初学者来说，它预设了一些适当的默认值，并隐藏了复杂的搜索理论知识。 它 开箱即用 。只需最少的理解，你很快就能具有生产力。</p>
<p>随着你知识的积累，你可以利用 Elasticsearch 更多的高级特性，它的整个引擎是可配置并且灵活的。 从众多高级特性中，挑选恰当去修饰的 Elasticsearch，使它能解决你本地遇到的问题。</p>
<h2 id="安装并运行Elasticsearch"><a href="#安装并运行Elasticsearch" class="headerlink" title="安装并运行Elasticsearch"></a>安装并运行Elasticsearch</h2><p>安装 Elasticsearch 之前，你需要先安装一个较新的版本的 Java。博主安装的是java8。</p>
<p>之后，你可以从 elastic 的官网 elastic.co/downloads/elasticsearch 获取Elasticsearch(2.x)。</p>
<p>下载并解压适合你操作系统的 Elasticsearch 版本，按照下面的操作，在前台(foregroud)启动 Elasticsearch：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch-&lt;version&gt;</span><br><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure>
<p>如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 -d</p>
<p>测试 Elasticsearch 是否启动成功，可以打开另一个终端，执行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 'http://localhost:9200/?pretty'</span><br></pre></td></tr></table></figure>
<p>你应该得到和下面类似的响应(response)：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"Tom Foster"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"2.1.0"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"72cd1f1a3eee09505e036106146dc1949dc5dc87"</span>,</span><br><span class="line">    <span class="attr">"build_timestamp"</span> : <span class="string">"2015-11-18T22:40:03Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"5.3.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单个 节点 可以作为一个运行中的 Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 </p>
<p>elasticsearch-head是一款专门针对于elasticsearch的客户端工具，使用比较方便。</p>
<h2 id="和-Elasticsearch-交互"><a href="#和-Elasticsearch-交互" class="headerlink" title="和 Elasticsearch 交互"></a>和 Elasticsearch 交互</h2><p>所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch 。事实上，正如你所看到的，你甚至可以使用 curl 命令来和 Elasticsearch 交互。</p>
<p>一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成：</p>
<p>curl -X<verb> ‘<protocol>://<host>:<port>/<path>?&lt;QUERY_STRING&gt;’ -d ‘<body>‘</body></path></port></host></protocol></verb></p>
<p>被 &lt; &gt; 标记的部件：</p>
<p>VERB：适当的 HTTP 方法 或 谓词 : GET<code>、</code>POST<code>、</code>PUT<code>、</code>HEAD 或者 <code>DELETE</code>。</p>
<p>PROTOCOL：http 或者 https<code>（如果你在 Elasticsearch 前面有一个</code>https 代理）</p>
<p>HOST：Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点。</p>
<p>PORT：运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。</p>
<p>PATH：API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm 。</p>
<p>QUERY_STRING：任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读)</p>
<p>BODY：一个 JSON 格式的请求体 (如果请求需要的话)</p>
<p>例如，计算集群中文档的数量，我们可以用这个:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'http://localhost:9200/_count?pretty' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match_all": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure></p>
<p>Elasticsearch 返回一个 HTTP 状态码（例如：200 OK<code>）和（除</code>HEAD<code>请求）一个 JSON 格式的返回值。前面的</code>curl 请求将返回一个像下面一样的 JSON 体：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"count"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">        <span class="attr">"total"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"failed"</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在返回结果中没有看到 HTTP 头信息是因为我们没有要求curl<code>显示它们。想要看到头信息，需要结合</code>-i 参数来使用 curl 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XGET 'localhost:9200/'</span><br></pre></td></tr></table></figure></p>
<p>在书中剩余的部分，我们将用缩写格式来展示这些 curl 示例，所谓的缩写格式就是省略请求中所有相同的部分，例如主机名、端口号以及 curl 命令本身。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_count</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match_all": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h2><p>使用关系型数据库的行和列存储，相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将这个对象扁平化来适应表结构–通常一个字段&gt;对应一列–而且又不得不在每次查询时重新构造对象。</p>
<p>Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档_。Elasticsearch 不仅存储文档，而且 _索引 每个文档的内容使之可以被检索。在 Elasticsearch 中，你 对文档进行索引、检索、排序和过滤–而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p>
<p>Elasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。JSON 序列化被大多数编程语言所支持，并且已经成为 NoSQL 领域的标准格式。 它简单、简洁、易于阅读。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>为了对 Elasticsearch 能实现什么及其上手容易程度有一个基本印象，让我们从一个简单的教程开始并介绍索引、搜索及聚合等基础概念。</p>
<p>我们的任务是为此创建一个雇员目录，有一些业务需求：</p>
<p>1.支持包含多值标签、数值、以及全文本的数据<br>2.检索任一雇员的完整信息<br>3.允许结构化搜索，比如查询 30 岁以上的员工<br>4.允许简单的全文搜索以及较复杂的短语搜索<br>5.支持在匹配文档内容中高亮显示搜索片段<br>6.支持基于数据创建和管理分析仪表盘</p>
<p>第一个业务需求就是存储雇员数据。 这将会以 雇员文档 的形式存储：一个文档代表一个雇员。存储数据到 Elasticsearch 的行为叫做 索引 ，但在索引一个文档之前，需要确定将文档存储在哪里。</p>
<p>一个 Elasticsearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。</p>
<p>你也许已经注意到 索引 这个词在 Elasticsearch 语境中包含多重意思， 所以有必要做一点儿说明：</p>
<p>索引（名词）：如前所述，一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes 。</p>
<p>索引（动词）：索引一个文档 就是存储一个文档到一个 索引 （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换旧文档情况之外。</p>
<p>倒排索引：关系型数据库通过增加一个 索引 比如一个 B树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 倒排索引 的结构来达到相同的目的。默认的，一个文档中的每一个属性都是 被索引 的（有一个倒排索引）和可搜索的。一个没有倒排索引的属性是不能被搜索到的。</p>
<p>实践中这非常简单<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">    "first_name" : "John",</span><br><span class="line">    "last_name" :  "Smith",</span><br><span class="line">    "age" :        25,</span><br><span class="line">    "about" :      "I love to go rock climbing",</span><br><span class="line">    "interests": [ "sports", "music" ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>路径 /megacorp/employee/1 包含了三部分的信息：<br>megacorp 索引名称<br>employee 类型名称<br>1 特定雇员的ID<br>请求体 JSON 文档</p>
<p>进行下一步前，让我们增加更多的员工信息到目录中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PUT /megacorp/employee/2</span><br><span class="line">&#123;</span><br><span class="line">    "first_name" :  "Jane",</span><br><span class="line">    "last_name" :   "Smith",</span><br><span class="line">    "age" :         32,</span><br><span class="line">    "about" :       "I like to collect rock albums",</span><br><span class="line">    "interests":  [ "music" ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /megacorp/employee/3</span><br><span class="line">&#123;</span><br><span class="line">    "first_name" :  "Douglas",</span><br><span class="line">    "last_name" :   "Fir",</span><br><span class="line">    "age" :         35,</span><br><span class="line">    "about":        "I like to build cabinets",</span><br><span class="line">    "interests":  [ "forestry" ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检索文档</p>
<p>简单地执行 一个 HTTP GET 请求并指定文档的地址——索引库、类型和ID。 使用这三个信息可以返回原始的 JSON 文档：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/1</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"megacorp"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"employee"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> :  &#123;</span><br><span class="line">      <span class="attr">"first_name"</span> :  <span class="string">"John"</span>,</span><br><span class="line">      <span class="attr">"last_name"</span> :   <span class="string">"Smith"</span>,</span><br><span class="line">      <span class="attr">"age"</span> :         <span class="number">25</span>,</span><br><span class="line">      <span class="attr">"about"</span> :       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">      <span class="attr">"interests"</span>:  [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果包含了文档的一些元数据，以及 _source 属性，内容是 John Smith 雇员的原始 JSON 文档。</p>
<p>将 HTTP 命令由 PUT 改为 GET 可以用来检索文档，同样的，可以使用 DELETE 命令来删除文档，以及使用 HEAD 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 PUT 。</p>
<p>现在尝试点儿稍微高级的功能，比如一个简单的搜索！</p>
<p>我们使用下列请求来搜索所有雇员：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们仍然使用索引库 megacorp 以及类型 employee<code>，但与指定一个文档 ID 不同，这次使用</code>_search 。返回结果包括了所有三个文档，放在数组 hits 中。一个搜索默认返回十条结果。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"took"</span>:      <span class="number">6</span>,</span><br><span class="line">   <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">   "_shards": &#123; ... &#125;,</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      3,</span><br><span class="line">      "max_score":  1,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:         <span class="string">"megacorp"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:          <span class="string">"employee"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:            <span class="string">"3"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>:         <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">               <span class="attr">"first_name"</span>:  <span class="string">"Douglas"</span>,</span><br><span class="line">               <span class="attr">"last_name"</span>:   <span class="string">"Fir"</span>,</span><br><span class="line">               <span class="attr">"age"</span>:         <span class="number">35</span>,</span><br><span class="line">               <span class="attr">"about"</span>:       <span class="string">"I like to build cabinets"</span>,</span><br><span class="line">               <span class="attr">"interests"</span>: [ <span class="string">"forestry"</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:         <span class="string">"megacorp"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:          <span class="string">"employee"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:            <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>:         <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">               <span class="attr">"first_name"</span>:  <span class="string">"John"</span>,</span><br><span class="line">               <span class="attr">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="attr">"age"</span>:         <span class="number">25</span>,</span><br><span class="line">               <span class="attr">"about"</span>:       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">               <span class="attr">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:         <span class="string">"megacorp"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:          <span class="string">"employee"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:            <span class="string">"2"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>:         <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">               <span class="attr">"first_name"</span>:  <span class="string">"Jane"</span>,</span><br><span class="line">               <span class="attr">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="attr">"age"</span>:         <span class="number">32</span>,</span><br><span class="line">               <span class="attr">"about"</span>:       <span class="string">"I like to collect rock albums"</span>,</span><br><span class="line">               <span class="attr">"interests"</span>: [ <span class="string">"music"</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尝试下搜索姓氏为 <code>Smith</code> 的雇员。为此，我们将使用一个 高亮 搜索，很容易通过命令行完成。这个方法一般涉及到一个 查询字符串 （<em>query-string</em>） 搜索，因为我们通过一个URL参数来传递查询信息给搜索接口：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search?q=last_name:Smith</span><br></pre></td></tr></table></figure></p>
<p>返回结果给出了所有的 Smith：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      2,</span><br><span class="line">      "max_score":  0.30685282,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "John",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         25,</span><br><span class="line">               "about":       "I love to go rock climbing",</span><br><span class="line">               "interests": [ "sports", "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "Jane",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         32,</span><br><span class="line">               "about":       "I like to collect rock albums",</span><br><span class="line">               "interests": [ "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性。Elasticsearch 提供一个丰富灵活的查询语言叫做 查询表达式 ， 它支持构建更加复杂和健壮的查询。<br>领域特定语言 （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">            "last_name" : "Smith"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在尝试下更复杂的搜索<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "bool": &#123;</span><br><span class="line">            "must": &#123;</span><br><span class="line">                "match" : &#123;</span><br><span class="line">                    "last_name" : "smith" </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "filter": &#123;</span><br><span class="line">                "range" : &#123;</span><br><span class="line">                    "age" : &#123; "gt" : 30 &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们添加了一个 过滤器 用于执行一个范围查询，并复用之前的 match 查询。现在结果只返回了一个雇员，叫 Jane Smith，32 岁。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      1,</span><br><span class="line">      "max_score":  0.30685282,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "Jane",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         32,</span><br><span class="line">               "about":       "I like to collect rock albums",</span><br><span class="line">               "interests": [ "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在尝试下稍微高级点儿的全文搜索——一项 传统数据库确实很难搞定的任务。<br>搜索下所有喜欢攀岩（rock climbing）的雇员：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">            "about" : "rock climbing"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然我们依旧使用之前的 match 查询在about 属性上搜索 “rock climbing” 。得到两个匹配的文档：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      2,</span><br><span class="line">      "max_score":  0.16273327,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_score":         0.16273327, </span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "John",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         25,</span><br><span class="line">               "about":       "I love to go rock climbing",</span><br><span class="line">               "interests": [ "sports", "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_score":         0.016878016, </span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "Jane",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         32,</span><br><span class="line">               "about":       "I like to collect rock albums",</span><br><span class="line">               "interests": [ "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相关性得分<br>Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。第一个最高得分的结果很明显：John Smith 的 about 属性清楚地写着 “rock climbing” 。</p>
<p>但为什么 Jane Smith 也作为结果返回了呢？原因是她的 about 属性里提到了 “rock” 。因为只有 “rock” 而没有 “climbing” ，所以她的相关性得分低于 John 的。</p>
<p>短语搜索</p>
<p>有时候想要精确匹配一系列单词或者短语 。 比如， 我们想执行这样一个查询，仅匹配同时包含 “rock” 和 “climbing” ，并且 二者以短语 “rock climbing” 的形式紧挨着的雇员记录。这时候需要使用一个叫做 match_phrase 的查询：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match_phrase" : &#123;</span><br><span class="line">            "about" : "rock climbing"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回结果仅有 John Smith 的文档。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      1,</span><br><span class="line">      "max_score":  0.23013961,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_score":         0.23013961,</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "John",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         25,</span><br><span class="line">               "about":       "I love to go rock climbing",</span><br><span class="line">               "interests": [ "sports", "music" ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>高亮搜索<br>再次执行前面的查询，并增加一个新的 highlight 参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match_phrase" : &#123;</span><br><span class="line">            "about" : "rock climbing"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "highlight": &#123;</span><br><span class="line">        "fields" : &#123;</span><br><span class="line">            "about" : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果中还多了一个叫做 highlight 的部分。这个部分包含了 about 属性匹配的文本片段，并以 HTML 标签 <em></em> 封装：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "total":      1,</span><br><span class="line">      "max_score":  0.23013961,</span><br><span class="line">      "hits": [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            "_score":         0.23013961,</span><br><span class="line">            "_source": &#123;</span><br><span class="line">               "first_name":  "John",</span><br><span class="line">               "last_name":   "Smith",</span><br><span class="line">               "age":         25,</span><br><span class="line">               "about":       "I love to go rock climbing",</span><br><span class="line">               "interests": [ "sports", "music" ]</span><br><span class="line">            &#125;,</span><br><span class="line">            "highlight": &#123;</span><br><span class="line">               "about": [</span><br><span class="line">                  <span class="string">"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;"</span> </span><br><span class="line">               ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析<br>Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。<br>举个例子，挖掘出雇员中最受欢迎的兴趣爱好：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "all_interests": &#123;</span><br><span class="line">      "terms": &#123; "field": "interests" &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看看结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   "hits": &#123; ... &#125;,</span><br><span class="line">   "aggregations": &#123;</span><br><span class="line">      "all_interests": &#123;</span><br><span class="line">         "buckets": [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>:       <span class="string">"music"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>:       <span class="string">"forestry"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>:       <span class="string">"sports"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些聚合并非预先统计，而是从匹配当前查询的文档中即时生成。如果想知道叫 Smith 的雇员中最受欢迎的兴趣爱好，可以直接添加适当的查询来组合查询：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123;</span><br><span class="line">      "last_name": "smith"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "all_interests": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "interests"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>all_interests 聚合已经变为只包含匹配查询的文档：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">"all_interests": &#123;</span><br><span class="line">   "buckets": [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"music"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"sports"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>聚合还支持分级汇总 。比如，查询特定兴趣爱好员工的平均年龄：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    "aggs" : &#123;</span><br><span class="line">        "all_interests" : &#123;</span><br><span class="line">            "terms" : &#123; "field" : "interests" &#125;,</span><br><span class="line">            "aggs" : &#123;</span><br><span class="line">                "avg_age" : &#123;</span><br><span class="line">                    "avg" : &#123; "field" : "age" &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到的聚合结果有点儿复杂，但理解起来还是很简单的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">"all_interests": &#123;</span><br><span class="line">   "buckets": [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"music"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">         <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">28.5</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"forestry"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">35</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"key"</span>: <span class="string">"sports"</span>,</span><br><span class="line">         <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">25</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出基本是第一次聚合的加强版。依然有一个兴趣及数量的列表，只不过每个兴趣都有了一个附加的 avg_age 属性，代表有这个兴趣爱好的所有员工的平均年龄。</p>
<h2 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h2><p>我们提到过 Elasticsearch 可以横向扩展至数百（甚至数千）的服务器节点，同时可以处理PB级数据。我们的教程给出了一些使用 Elasticsearch 的示例，但并不涉及任何内部机制。Elasticsearch 天生就是分布式的，并且在设计时屏蔽了分布式的复杂性。</p>
<p>Elasticsearch 尽可能地屏蔽了分布式系统的复杂性。这里列举了一些在后台自动执行的操作：</p>
<p>1.分配文档到不同的容器 或 分片 中，文档可以储存在一个或多个节点中<br>2.按集群节点来均衡分配这些分片，从而对索引和搜索过程进行负载均衡<br>3.复制每个分片以支持数据冗余，从而防止硬件故障导致的数据丢失<br>4.将集群中任一节点的请求路由到存有相关数据的节点<br>5.集群扩容时无缝整合新节点，重新分配分片以便从离群节点恢复</p>
<h2 id="集群内的原理"><a href="#集群内的原理" class="headerlink" title="集群内的原理"></a>集群内的原理</h2><p>ElasticSearch 的主旨是随时可用和按需扩容。 而扩容可以通过购买性能更强大（ 垂直扩容 ，或 纵向扩容 ） 或者数量更多的服务器（ 水平扩容 ，或 横向扩容 ）来实现。</p>
<p>虽然 Elasticsearch 可以获益于更强大的硬件设备，但是垂直扩容是有极限的。 真正的扩容能力是来自于水平扩容–为集群添加更多的节点，并且将负载压力和稳定性分散到这些节点中。</p>
<p>对于大多数的数据库而言，通常需要对应用程序进行非常大的改动，才能利用上横向扩容的新增资源。 与之相反的是，ElastiSearch天生就是 分布式的 ，它知道如何通过管理多节点来提高扩容性和可用性。 这也意味着你的应用无需关注这个问题。</p>
<h2 id="空集群"><a href="#空集群" class="headerlink" title="空集群"></a>空集群</h2><p>如果我们启动了一个单独的节点，里面不包含任何的数据和 索引，那我们的集群看起来就是一个 Figure 1, “包含空内容节点的集群”。</p>
<p><img src="https://mfaying.github.io/images/elasticsearch2.x/1.jpg" alt="avatar"><br>(图)包含空内容节点的集群</p>
<p>一个运行中的 Elasticsearch 实例称为一个 节点，而集群是由一个或者多个拥有相同 cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p>
<p>当一个节点被选举成为 主 节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p>
<p>作为用户，我们可以将请求发送到 集群中的任何节点 ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。</p>
<h2 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h2><p>Elasticsearch 的集群监控信息中包含了许多的统计数据，其中最为重要的一项就是 集群健康 ， 它在 status 字段中展示为 green 、 yellow 或者 red 。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_cluster/health</span><br></pre></td></tr></table></figure></p>
<p>在一个不包含任何索引的空集群中，它将会有一个类似于如下所示的返回内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"cluster_name"</span>:          <span class="string">"elasticsearch"</span>,</span><br><span class="line">   <span class="attr">"status"</span>:                <span class="string">"green"</span>, </span><br><span class="line">   <span class="attr">"timed_out"</span>:             <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">"number_of_nodes"</span>:       <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"number_of_data_nodes"</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"active_primary_shards"</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"active_shards"</span>:         <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"relocating_shards"</span>:     <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"initializing_shards"</span>:   <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"unassigned_shards"</span>:     <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>status 字段是我们最关心的。status 字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：</p>
<p>1.green 所有的主分片和副本分片都正常运行。<br>2.yellow 所有的主分片都正常运行，但不是所有的副本分片都正常运行。<br>3.red 有主分片没能正常运行。</p>
<h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>我们往 Elasticsearch 添加数据时需要用到 索引 —— 保存相关数据的地方。 索引实际上是指向一个或者多个物理 分片 的 逻辑命名空间 。</p>
<p>一个 分片 是一个底层的 工作单元 ，它仅保存了 全部数据中的一部分。一个分片是一个 Lucene 的实例，以及它本身就是一个完整的搜索引擎。 我们的文档被存储和索引到分片内，但是应用程序是直接与索引而不是与分片进行交互。</p>
<p>Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。</p>
<p>一个分片可以是 主 分片或者 副本 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。</p>
<p>技术上来说，一个主分片最大能够存储 Integer.MAX_VALUE - 128 个文档，但是实际最大值还需要参考你的使用场景：包括你使用的硬件， 文档的大小和复杂程度，索引和查询文档的方式以及你期望的响应时长。</p>
<p>一个副本分片只是一个主分片的拷贝。 副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p>
<p>在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。</p>
<p>让我们在包含一个空节点的集群内创建名为 blogs 的索引。 索引在默认情况下会被分配5个主分片， 但是为了演示目的，我们将分配3个主分片和一份副本（每个主分片拥有一个副本分片）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs</span><br><span class="line">&#123;</span><br><span class="line">   "settings" : &#123;</span><br><span class="line">      "number_of_shards" : 3,</span><br><span class="line">      "number_of_replicas" : 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的集群现在是Figure 2, “拥有一个索引的单节点集群”。所有3个主分片都被分配在 Node 1 。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/2.jpg" alt="avatar"><br>(图)拥有一个索引的单节点集群</p>
<p>我们现在查看集群健康：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"yellow"</span>, </span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"number_of_nodes"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"number_of_data_nodes"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"active_primary_shards"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"active_shards"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"relocating_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"initializing_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"unassigned_shards"</span>: <span class="number">3</span>, </span><br><span class="line">  <span class="attr">"delayed_unassigned_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_pending_tasks"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_in_flight_fetch"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"task_max_waiting_in_queue_millis"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"active_shards_percent_as_number"</span>: <span class="number">50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>“status”: “yellow” -&gt; 集群 status 值为 yellow 。<br>“unassigned_shards”: 3 -&gt; 没有被分配到任何节点的副本数。</p>
<p>集群的健康状况为 yellow 则表示全部 主 分片都正常运行（集群可以正常服务所有请求），但是 副本 分片没有全部处在正常状态。 实际上，所有3个副本分片都是 unassigned —— 它们都没有被分配到任何节点。 在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。</p>
<h2 id="添加故障转移"><a href="#添加故障转移" class="headerlink" title="添加故障转移"></a>添加故障转移</h2><p>启动第二个节点</p>
<p>你可以在同一个目录内，完全依照启动第一个节点的方式来启动一个新节点（参考安装并运行 Elasticsearch）。多个节点可以共享同一个目录。</p>
<p>当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。 但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。</p>
<p>如果启动了第二个节点，我们的集群将会如下图3所示<br><img src="https://mfaying.github.io/images/elasticsearch2.x/3.jpg" alt="avatar"><br>图3.拥有两个节点的集群——所有主分片和副本分片都已被分配</p>
<p>当第二个节点加入到集群后，3个 副本分片 将会分配到这个节点上——每个主分片对应一个副本分片。 这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。</p>
<p>所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。</p>
<p>cluster-health 现在展示的状态为 green ，这表示所有6个分片（包括3个主分片和3个副本分片）都在正常运行。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"green"</span>, </span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"number_of_nodes"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"number_of_data_nodes"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"active_primary_shards"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"active_shards"</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"relocating_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"initializing_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"unassigned_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"delayed_unassigned_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_pending_tasks"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_in_flight_fetch"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"task_max_waiting_in_queue_millis"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"active_shards_percent_as_number"</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h2><p>怎样为我们的正在增长中的应用程序按需扩容呢？ 当启动了第三个节点，我们的集群将会看起来如图4所示。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/4.jpg" alt="avatar"><br>图4.拥有三个节点的集群——为了分散负载而对分片进行重新分配</p>
<p>Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有2个分片，而不是之前的3个。 这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片的性能将会得到提升。</p>
<p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有6个分片（3个主分片和3个副本分片）的索引可以最大扩容到6个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。</p>
<p>更多的扩容</p>
<p>但是如果我们想要扩容超过6个节点怎么办呢？</p>
<p>主分片的数目在索引创建时 就已经确定了下来。实际上，这个数目定义了这个索引能够 存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。</p>
<p>在运行中的集群上是可以动态调整副本分片数目的 ，我们可以按需伸缩集群。让我们把副本数从默认的 1 增加到 2 ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs/_settings</span><br><span class="line">&#123;</span><br><span class="line">   "number_of_replicas" : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如图5所示， blogs 索引现在拥有9个分片：3个主分片和6个副本分片。 这意味着我们可以将集群扩容到9个节点，每个节点上一个分片。相比原来3个节点时，集群搜索性能可以提升 3 倍。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/5.jpg" alt="avatar"><br>将参数 number_of_replicas 调大到 2</p>
<p>当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每个分片从节点上获得的资源会变少。 你需要增加更多的硬件资源来提升吞吐量。</p>
<p>但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去2个节点的情况下不丢失任何数据。</p>
<h2 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h2><p>如果我们关闭第一个节点，这时集群的状态为图6。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/6.jpg" alt="avatar"><br>图6 关闭了一个节点后的集群</p>
<p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。</p>
<p>在我们关闭 Node 1 的同时也失去了主分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。</p>
<p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为 yellow 。 这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p>
<p>为什么我们集群状态是 yellow 而不是 green 呢？ 虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应2份副本分片，而此时只存在一份副本分片。 所以集群不能为 green 的状态，不过我们不必过于担心：如果我们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为 Node 3 为每一个分片都保留着一份副本。</p>
<p>如果我们重新启动 Node 1 ，集群可以将缺失的副本分片再次进行分配，那么集群的状态也将如图5所示。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p>
<h2 id="数据输入和输出"><a href="#数据输入和输出" class="headerlink" title="数据输入和输出"></a>数据输入和输出</h2><p>面向对象编程语言如此流行的原因之一是对象帮我们表示和处理现实世界具有潜在的复杂的数据结构的实体，到目前为止，一切都很完美！</p>
<p>但是当我们需要存储这些实体时问题来了，传统上，我们以行和列的形式存储数据到关系型数据库中，相当于使用电子表格。 正因为我们使用了这种不灵活的存储媒介导致所有我们使用对象的灵活性都丢失了。</p>
<p>一个 对象 是基于特定语言的内存的数据结构。 为了通过网络发送或者存储它，我们需要将它表示成某种标准的格式。 JSON 是一种以人可读的文本表示对象的方法。 它已经变成 NoSQL 世界交换数据的事实标准。当一个对象被序列化成为 JSON，它被称为一个 JSON 文档 。</p>
<p>Elastcisearch 是分布式的 文档 存储。它能存储和检索复杂的数据结构–序列化成为JSON文档–以 实时 的方式。 换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。</p>
<p>在 Elasticsearch 中， 每个字段的所有数据 都是 默认被索引的 。 即每个字段都有为了快速检索设置的专用倒排索引。而且，不像其他多数的数据库，它能在 相同的查询中 使用所有这些倒排索引，并以惊人的速度返回结果。</p>
<h2 id="什么是文档"><a href="#什么是文档" class="headerlink" title="什么是文档?"></a>什么是文档?</h2><p>在大多数应用中，多数实体或对象可以被序列化为包含键值对的 JSON 对象。 一个 键 可以是一个字段或字段的名称，一个 值 可以是一个字符串，一个数字，一个布尔值， 另一个对象，一些数组值，或一些其它特殊类型诸如表示日期的字符串，或代表一个地理位置的对象：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:         <span class="string">"John Smith"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:          <span class="number">42</span>,</span><br><span class="line">    <span class="attr">"confirmed"</span>:    <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"join_date"</span>:    <span class="string">"2014-06-01"</span>,</span><br><span class="line">    <span class="attr">"home"</span>: &#123;</span><br><span class="line">        <span class="attr">"lat"</span>:      <span class="number">51.5</span>,</span><br><span class="line">        <span class="attr">"lon"</span>:      <span class="number">0.1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"accounts"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"facebook"</span>,</span><br><span class="line">            <span class="attr">"id"</span>:   <span class="string">"johnsmith"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"twitter"</span>,</span><br><span class="line">            <span class="attr">"id"</span>:   <span class="string">"johnsmith"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常情况下，我们使用的术语 对象 和 文档 是可以互相替换的。不过，有一个区别： 一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。 对象可能包含了另外一些对象。在 Elasticsearch 中，术语 文档 有着特定的含义。它是指最顶层或者根对象, 这个根对象被序列化成 JSON 并存储到 Elasticsearch 中，指定了唯一 ID。</p>
<p>字段的名字可以是任何合法的字符串，但不可以包含时间段。</p>
<h2 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h2><p>元数据 —— 有关 文档的信息。 三个必须的元数据元素如下:<br>_index 文档在哪存放<br>_type 文档表示的对象类别<br>_id 文档唯一标识</p>
<p>_index</p>
<p>一个 索引 应该是因共同的特性被分组到一起的文档集合。 例如，你可能存储所有的产品在索引 products 中，而存储所有销售的交易到索引 sales 中。 </p>
<p>实际上，在 Elasticsearch 中，我们的数据是被存储和索引在 分片 中，而一个索引仅仅是逻辑上的命名空间， 这个命名空间由一个或者多个分片组合在一起。 然而，这是一个内部细节，我们的应用程序根本不应该关心分片，对于应用程序而言，只需知道文档位于一个 索引 内。 Elasticsearch 会处理所有的细节。</p>
<p>我们让 Elasticsearch 帮我们创建索引。 所有需要我们做的就是选择一个索引名，这个名字必须小写，不能以下划线开头，不能包含逗号。</p>
<p>_type</p>
<p>数据可能在索引中只是松散的组合在一起，但是通常明确定义一些数据中的子分区是很有用的。 例如，所有的产品都放在一个索引中，但是你有许多不同的产品类别，比如 “electronics” 、 “kitchen” 和 “lawn-care”。</p>
<p>这些文档共享一种相同的（或非常相似）的模式：他们有一个标题、描述、产品代码和价格。他们只是正好属于“产品”下的一些子类。</p>
<p>Elasticsearch 公开了一个成为 types （类型）的特性，它允许您在索引中对数据进行逻辑分区。不同 types 的文档可能有不同的字段，但最好能够非常相似。</p>
<p>一个 _type 命名可以是大写或者小写，但是不能以下划线或者句号开头，不应该包含逗号， 并且长度限制为256个字符.</p>
<p>_id</p>
<p>ID 是一个字符串， 当它和 _index 以及 _type 组合就可以唯一确定 Elasticsearch 中的一个文档。 当你创建一个新的文档，要么提供自己的 _id ，要么让 Elasticsearch 帮你生成。</p>
<p>其他元数据</p>
<p>还有一些其他的元数据元素，他们在 类型和映射 进行了介绍。通过前面已经列出的元数据元素， 我们已经能存储文档到 Elasticsearch 中并通过 ID 检索它–换句话说，使用 Elasticsearch 作为文档的存储介质。</p>
<h2 id="索引文档"><a href="#索引文档" class="headerlink" title="索引文档"></a>索引文档</h2><p>通过使用 index API ，文档可以被 索引 —— 存储和使文档可被搜索 。 但是首先，我们要确定文档的位置。正如我们刚刚讨论的，一个文档的 _index 、 _type 和 _id 唯一标识一个文档。 我们可以提供自定义的 _id 值，或者让 index API 自动生成。</p>
<p>使用自定义的 ID</p>
<p>如果你的文档有一个自然的 标识符 （例如，一个 user_account 字段或其他标识文档的值），你应该使用如下方式的 index API 并提供你自己 _id ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "field": "value",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举个例子，如果我们的索引称为 website ，类型称为 blog ，并且选择 123 作为 ID<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "Just trying this out...",</span><br><span class="line">  "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Elasticsearch 响应体如下所示：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"123"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"created"</span>:   <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该响应表明文档已经成功创建，该索引包括 _index 、 _type 和 _id 元数据， 以及一个新元素： _version 。</p>
<p>在 Elasticsearch 中每个文档都有一个版本号。当每次对文档进行修改时（包括删除）， _version 的值会递增。 在 处理冲突 中，我们讨论了怎样使用 _version 号码确保你的应用程序中的一部分修改不会覆盖另一部分所做的修改。</p>
<p>如果你的数据没有自然的 ID， Elasticsearch 可以帮我们自动生成 ID 。 请求的结构调整为： 不再使用 PUT 谓词(“使用这个 URL 存储这个文档”)， 而是使用 POST 谓词(“存储文档在这个 URL 命名空间下”)。</p>
<p>现在该 URL 只需包含 _index 和 _type :<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My second blog entry",</span><br><span class="line">  "text":  "Still trying this out...",</span><br><span class="line">  "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了 _id 是 Elasticsearch 自动生成的，响应的其他部分和前面的类似：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"AVFgSgVHUP18jI2wRx0w"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"created"</span>:   <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自动生成的 ID 是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串。 这些 GUID 字符串由可修改的 FlakeID 模式生成，这种模式允许多个节点并行生成唯一 ID ，且互相之间的冲突概率几乎为零。</p>
<h2 id="取回一个文档"><a href="#取回一个文档" class="headerlink" title="取回一个文档"></a>取回一个文档</h2><p>为了从 Elasticsearch 中检索出文档 ，我们仍然使用相同的 _index , _type , 和 _id ，但是 HTTP 谓词 更改为 GET :<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?pretty</span><br></pre></td></tr></table></figure></p>
<p>响应体包括目前已经熟悉了的元数据元素，再加上 _source 字段，这个字段包含我们索引数据时发送给 Elasticsearch 的原始 JSON 文档：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> :  &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">      <span class="attr">"text"</span>:  <span class="string">"Just trying this out..."</span>,</span><br><span class="line">      <span class="attr">"date"</span>:  <span class="string">"2014/01/01"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注:在请求的查询串参数中加上 pretty 参数， 正如前面的例子中看到的，这将会调用 Elasticsearch 的 pretty-print 功能，该功能 使得 JSON 响应体更加可读。但是， _source 字段不能被格式化打印出来。相反，我们得到的 _source 字段中的 JSON 串，刚好是和我们传给它的一样。</p>
<p>GET 请求的响应体包括 {“found”: true} ，这证实了文档已经被找到。 如果我们请求一个不存在的文档，我们仍旧会得到一个 JSON 响应体，但是 found 将会是 false 。 此外， HTTP 响应码将会是 404 Not Found ，而不是 200 OK 。</p>
<p>我们可以通过传递 -i 参数给 curl 命令，该参数 能够显示响应的头部：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XGET http://localhost:9200/website/blog/124?pretty</span><br></pre></td></tr></table></figure></p>
<p>显示响应头部的响应体现在类似这样：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Length: 83</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :  <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :    <span class="string">"124"</span>,</span><br><span class="line">  <span class="attr">"found"</span> :  <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回文档的一部分</p>
<p>默认情况下， GET 请求 会返回整个文档，这个文档正如存储在 _source 字段中的一样。但是也许你只对其中的 title 字段感兴趣。单个字段能用 _source 参数请求得到，多个字段也能使用逗号分隔的列表来指定。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?_source=title,text</span><br></pre></td></tr></table></figure>
<p>该 _source 字段现在包含的只是我们请求的那些字段，并且已经将 date 字段过滤掉了。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> :   <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> : &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span> ,</span><br><span class="line">      <span class="attr">"text"</span>:  <span class="string">"Just trying this out..."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者，如果你只想得到 _source 字段，不需要任何元数据，你能使用 _source 端点：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123/_source</span><br></pre></td></tr></table></figure></p>
<p>那么返回的的内容如下所示：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">   <span class="attr">"text"</span>:  <span class="string">"Just trying this out..."</span>,</span><br><span class="line">   <span class="attr">"date"</span>:  <span class="string">"2014/01/01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="检查文档是否存在"><a href="#检查文档是否存在" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h2><p>HEAD 方法检查一个文档是否存在,HEAD 请求没有返回体，只返回一个 HTTP 请求报头：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XHEAD http://localhost:9200/website/blog/123</span><br></pre></td></tr></table></figure></p>
<p>如果文档存在， Elasticsearch 将返回一个 200 ok 的状态码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure></p>
<p>若文档不存在， Elasticsearch 将返回一个 404 Not Found 的状态码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XHEAD http://localhost:9200/website/blog/124</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>
<p>当然，一个文档仅仅是在检查的时候不存在，并不意味着一毫秒之后它也不存在：也许同时正好另一个进程就创建了该文档。</p>
<h2 id="更新整个文档"><a href="#更新整个文档" class="headerlink" title="更新整个文档"></a>更新整个文档</h2><p>在 Elasticsearch 中文档是 不可改变 的，不能修改它们。 相反，如果想要更新现有的文档，需要 重建索引 或者进行替换， 我们可以使用相同的 index API 进行实现，在 索引文档 中已经进行了讨论。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "I am starting to get the hang of this...",</span><br><span class="line">  "date":  "2014/01/02"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在响应体中，我们能看到 Elasticsearch 已经增加了 _version 字段值：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"created"</span>:   <span class="literal">false</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>created 标志设置成 false ，是因为相同的索引、类型和 ID 的文档已经存在。</p>
<p>在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。 尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档。</p>
<p>在本章的后面部分，我们会介绍 update API, 这个 API 可以用于 partial updates to a document 。 虽然它似乎对文档直接进行了修改，但实际上 Elasticsearch 按前述完全相同方式执行以下过程：</p>
<p>1.从旧文档构建 JSON<br>2.更改该 JSON<br>3.删除旧文档<br>4.索引一个新文档</p>
<p>唯一的区别在于, update API 仅仅通过一个客户端请求来实现这些步骤，而不需要单独的 get 和 index 请求。</p>
<h2 id="创建新文档"><a href="#创建新文档" class="headerlink" title="创建新文档"></a>创建新文档</h2><p>当我们索引一个文档， 怎么确认我们正在创建一个完全新的文档，而不是覆盖现有的呢？</p>
<p>_index 、 _type 和 _id 的组合可以唯一标识一个文档。所以，确保创建一个新文档的最简单办法是，使用索引请求的 POST 形式让 Elasticsearch 自动生成唯一 _id :<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，如果已经有自己的 _id ，那么我们必须告诉 Elasticsearch ，只有在相同的 _index 、 _type 和 _id 不存在时才接受我们的索引请求。这里有两种方式，他们做的实际是相同的事情。使用哪种，取决于哪种使用起来更方便。</p>
<p>第一种方法使用 op_type 查询 -字符串参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123?op_type=create</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是在 URL 末端使用 /_create :<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123/_create</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 201 Created 的 HTTP 响应码。</p>
<p>另一方面，如果具有相同的 _index 、 _type 和 _id 的文档已经存在，Elasticsearch 将会返回 409 Conflict 响应码，以及如下的错误信息：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"error"</span>: &#123;</span><br><span class="line">      <span class="attr">"root_cause"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"document_already_exists_exception"</span>,</span><br><span class="line">            <span class="attr">"reason"</span>: <span class="string">"[blog][123]: document already exists"</span>,</span><br><span class="line">            <span class="attr">"shard"</span>: <span class="string">"0"</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="string">"website"</span></span><br><span class="line">         &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"document_already_exists_exception"</span>,</span><br><span class="line">      <span class="attr">"reason"</span>: <span class="string">"[blog][123]: document already exists"</span>,</span><br><span class="line">      <span class="attr">"shard"</span>: <span class="string">"0"</span>,</span><br><span class="line">      <span class="attr">"index"</span>: <span class="string">"website"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"status"</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>使用 DELETE 方法：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /website/blog/123</span><br></pre></td></tr></table></figure></p>
<p>如果找到该文档，Elasticsearch 将要返回一个 200 ok 的 HTTP 响应码，和一个类似以下结构的响应体。注意，字段 _version 值已经增加:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果文档没有 找到，我们将得到 404 Not Found 的响应码和类似这样的响应体：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即使文档不存在（ Found 是 false ）， _version 值仍然会增加。这是 Elasticsearch 内部记录本的一部分，用来确保这些改变在跨多节点时以正确的顺序执行。</p>
<p>正如已经在更新整个文档中提到的，删除文档不会立即将文档从磁盘中删除，只是将文档标记为已删除状态。随着你不断的索引更多的数据，Elasticsearch 将会在后台清理标记为已删除的文档。</p>
<h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><p>当我们使用 index API 更新文档 ，可以一次性读取原始文档，做我们的修改，然后重新索引 整个文档 。 最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。</p>
<p>但有时丢失了一个变更就是 非常严重的 。试想我们使用 Elasticsearch 存储我们网上商城商品库存的数量， 每次我们卖一个商品的时候，我们在 Elasticsearch 中将库存数量减少。</p>
<p>有一天，我们一秒要卖好几个商品。 假设有两个 web 程序并行运行，每一个都同时处理所有商品的销售，如图7所示。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/7.jpg" alt="avatar"><br>图7 Consequence of no concurrency control<br>web_1 对 stock_count 所做的更改已经丢失，因为 web_2 不知道它的 stock_count 的拷贝已经过期。 </p>
<p>变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。</p>
<p>在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p>
<p>1.悲观并发控制<br>这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</p>
<p>2.乐观并发控制<br>Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</p>
<h2 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h2><p>Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p>
<p>当我们之前讨论 index ， GET 和 delete 请求时，我们指出每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p>
<p>我们可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。</p>
<p>让我们创建一个新的博客文章：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/1/_create</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "Just trying this out..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>响应体告诉我们，这个新创建的文档 _version 版本号是 1 。现在假设我们想编辑这个文档：我们加载其数据到 web 表单中，做一些修改，然后保存新的版本。</p>
<p>首先我们检索文档:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/1</span><br></pre></td></tr></table></figure></p>
<p>响应体包含相同的 _version 版本号 1 ：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> :  &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">      <span class="attr">"text"</span>:  <span class="string">"Just trying this out..."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，当我们尝试通过重建文档的索引来保存修改，我们指定 version 为我们的修改会被应用的版本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/1?version=1 </span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "Starting to get the hang of this..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个在我们索引中的文档只有现在的 _version 为 1 时，本次更新才能成功。</p>
<p>此请求成功，并且响应体告诉我们 _version 已经递增到 2 ：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>:      <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，如果我们重新运行相同的索引请求，仍然指定 version=1 ， Elasticsearch 返回 409 Conflict HTTP 响应码，和一个如下所示的响应体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"error"</span>: &#123;</span><br><span class="line">      <span class="attr">"root_cause"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">            <span class="attr">"reason"</span>: <span class="string">"[blog][1]: version conflict, current [2], provided [1]"</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"shard"</span>: <span class="string">"3"</span></span><br><span class="line">         &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">      <span class="attr">"reason"</span>: <span class="string">"[blog][1]: version conflict, current [2], provided [1]"</span>,</span><br><span class="line">      <span class="attr">"index"</span>: <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"shard"</span>: <span class="string">"3"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"status"</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这告诉我们在 Elasticsearch 中这个文档的当前 _version 号是 2 ，但我们指定的更新版本号为 1 。</p>
<p>我们现在怎么做取决于我们的应用需求。我们可以告诉用户说其他人已经修改了文档，并且在再次保存之前检查这些修改内容。 或者，在之前的商品 stock_count 场景，我们可以获取到最新的文档并尝试重新应用这些修改。</p>
<p>所有文档的更新或删除 API，都可以接受 version 参数，这允许你在代码中使用乐观的并发控制。</p>
<p>通过外部系统使用版本控制编辑</p>
<p>一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。</p>
<p>如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp — 那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号， 版本号必须是大于零的整数， 且小于 9.2E+18 — 一个 Java 中 long 类型的正值。</p>
<p>外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前 _version 是否 小于 指定的版本号。 如果请求成功，外部的版本号作为文档的新 _version 进行存储。</p>
<p>外部版本号不仅在索引和删除请求是可以指定，而且在 创建 新文档时也可以指定。</p>
<p>例如，要创建一个新的具有外部版本号 5 的博客文章，我们可以按以下方法进行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/2?version=5&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first external blog entry",</span><br><span class="line">  "text":  "Starting to get the hang of this..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在响应中，我们能看到当前的 _version 版本号是 5 ：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>:      <span class="string">"2"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"created"</span>:  <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们更新这个文档，指定一个新的 version 号是 10 ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/2?version=10&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first external blog entry",</span><br><span class="line">  "text":  "This is a piece of cake..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>:      <span class="string">"2"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"created"</span>:  <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你要重新运行此请求时，它将会失败，并返回像我们之前看到的同样的冲突错误， 因为指定的外部版本号不大于 Elasticsearch 的当前版本号。</p>
<h2 id="文档的部分更新"><a href="#文档的部分更新" class="headerlink" title="文档的部分更新"></a>文档的部分更新</h2><p>在 更新整个文档 , 我们已经介绍过 更新一个文档的方法是检索并修改它，然后重新索引整个文档，这的确如此。然而，使用 update API 我们还可以部分更新文档，例如在某个请求时对计数器进行累加。</p>
<p>我们也介绍过文档是不可变的：他们不能被修改，只能被替换。 update API 必须遵循同样的规则。 从外部来看，我们在一个文档的某个位置进行部分更新。然而在内部， update API 简单使用与之前描述相同的 检索-修改-重建索引 的处理过程。 区别在于这个过程发生在分片内部，这样就避免了多次请求的网络开销。通过减少检索和重建索引步骤之间的时间，我们也减少了其他进程的变更带来冲突的可能性。</p>
<p>update 请求最简单的一种形式是接收文档的一部分作为 doc 的参数， 它只是与现有的文档进行合并。对象被合并到一起，覆盖现有的字段，增加新的字段。 例如，我们增加字段 tags 和 views 到我们的博客文章，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "doc" : &#123;</span><br><span class="line">      "tags" : [ "testing" ],</span><br><span class="line">      "views": 0</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">   <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_version"</span> : <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检索文档显示了更新后的 _source 字段：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"1"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">3</span>,</span><br><span class="line">   <span class="attr">"found"</span>:     <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"_source"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>:  <span class="string">"My first blog entry"</span>,</span><br><span class="line">      <span class="attr">"text"</span>:   <span class="string">"Starting to get the hang of this..."</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [ <span class="string">"testing"</span> ], </span><br><span class="line">      <span class="attr">"views"</span>:  <span class="number">0</span> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用脚本部分更新文档编辑</p>
<p>脚本可以在 update API中用来改变 _source 的字段内容， 它在更新脚本中称为 ctx._source 。 例如，我们可以使用脚本来增加博客文章中 views 的数量：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx._source.views+=1"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用 Groovy 脚本编程</p>
<p>对于那些 API 不能满足需求的情况，Elasticsearch 允许你使用脚本编写自定义的逻辑。 许多API都支持脚本的使用，包括搜索、排序、聚合和文档更新。 脚本可以作为请求的一部分被传递，从特殊的 .scripts 索引中检索，或者从磁盘加载脚本。</p>
<p>默认的脚本语言 是 Groovy，一种快速表达的脚本语言，在语法上与 JavaScript 类似。 它在 Elasticsearch V1.3.0 版本首次引入并运行在 沙盒 中，然而 Groovy 脚本引擎存在漏洞， 允许攻击者通过构建 Groovy 脚本，在 Elasticsearch Java VM 运行时脱离沙盒并执行 shell 命令。</p>
<p>因此，在版本 v1.3.8 、 1.4.3 和 V1.5.0 及更高的版本中，它已经被默认禁用。 此外，您可以通过设置集群中的所有节点的 config/elasticsearch.yml 文件来禁用动态 Groovy 脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script.groovy.sandbox.enabled: false</span><br></pre></td></tr></table></figure></p>
<p>这将关闭 Groovy 沙盒，从而防止动态 Groovy 脚本作为请求的一部分被接受， 或者从特殊的 .scripts 索引中被检索。当然，你仍然可以使用存储在每个节点的 config/scripts/ 目录下的 Groovy 脚本。</p>
<p>我们也可以通过使用脚本给 tags 数组添加一个新的标签。在这个例子中，我们指定新的标签作为参数，而不是硬编码到脚本内部。 这使得 Elasticsearch 可以重用这个脚本，而不是每次我们想添加标签时都要对新脚本重新编译：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx._source.tags+=new_tag",</span><br><span class="line">   "params" : &#123;</span><br><span class="line">      "new_tag" : "search"</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取文档并显示最后两次请求的效果：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"1"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">5</span>,</span><br><span class="line">   <span class="attr">"found"</span>:     <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"_source"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>:  <span class="string">"My first blog entry"</span>,</span><br><span class="line">      <span class="attr">"text"</span>:   <span class="string">"Starting to get the hang of this..."</span>,</span><br><span class="line">      <span class="attr">"tags"</span>:  [<span class="string">"testing"</span>, <span class="string">"search"</span>], </span><br><span class="line">      <span class="attr">"views"</span>:  <span class="number">1</span> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们甚至可以选择通过设置 ctx.op 为 delete 来删除基于其内容的文档：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx.op = ctx._source.views == count ? 'delete' : 'none'",</span><br><span class="line">    "params" : &#123;</span><br><span class="line">        "count": 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更新的文档可能尚不存在</p>
<p>假设我们需要 在 Elasticsearch 中存储一个页面访问量计数器。 每当有用户浏览网页，我们对该页面的计数器进行累加。但是，如果它是一个新网页，我们不能确定计数器已经存在。 如果我们尝试更新一个不存在的文档，那么更新操作将会失败。</p>
<p>在这样的情况下，我们可以使用 upsert 参数，指定如果文档不存在就应该先创建它：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/pageviews/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx._source.views+=1",</span><br><span class="line">   "upsert": &#123;</span><br><span class="line">       "views": 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们第一次运行这个请求时， upsert 值作为新文档被索引，初始化 views 字段为 1 。 在后续的运行中，由于文档已经存在， script 更新操作将替代 upsert 进行应用，对 views 计数器进行累加。</p>
<p>更新和冲突</p>
<p>在本节的介绍中，我们说明 检索 和 重建索引 步骤的间隔越小，变更冲突的机会越小。 但是它并不能完全消除冲突的可能性。 还是有可能在 update 设法重新索引之前，来自另一进程的请求修改了文档。</p>
<p>为了避免数据丢失， update API 在 检索 步骤时检索得到文档当前的 _version 号，并传递版本号到 重建索引 步骤的 index 请求。 如果另一个进程修改了处于检索和重新索引步骤之间的文档，那么 _version 号将不匹配，更新请求将会失败。</p>
<p>对于部分更新的很多使用场景，文档已经被改变也没有关系。 例如，如果两个进程都对页面访问量计数器进行递增操作，它们发生的先后顺序其实不太重要； 如果冲突发生了，我们唯一需要做的就是尝试再次更新。</p>
<p>这可以通过 设置参数 retry_on_conflict 来自动完成， 这个参数规定了失败之前 update 应该重试的次数，它的默认值为 0 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/pageviews/1/_update?retry_on_conflict=5 </span><br><span class="line">&#123;</span><br><span class="line">   "script" : "ctx._source.views+=1",</span><br><span class="line">   "upsert": &#123;</span><br><span class="line">       "views": 0</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>失败之前重试该更新5次。</p>
<p>在增量操作无关顺序的场景，例如递增计数器等这个方法十分有效，但是在其他情况下变更的顺序 是 非常重要的。 类似 index API ， update API 默认采用 最终写入生效 的方案，但它也接受一个 version 参数来允许你使用 optimistic concurrency control 指定想要更新文档的版本。</p>
<p>取回多个文档</p>
<p>Elasticsearch 的速度已经很快了，但甚至能更快。 将多个请求合并成一个，避免单独处理每个请求花费的网络延时和开销。 如果你需要从 Elasticsearch 检索很多文档，那么使用 multi-get 或者 mget API 来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p>
<p>mget API 要求有一个 docs 数组作为参数，每个 元素包含需要检索文档的元数据， 包括 _index 、 _type 和 _id 。如果你想检索一个或者多个特定的字段，那么你可以通过 _source 参数来指定这些字段的名字：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">   "docs" : [</span><br><span class="line">      &#123;</span><br><span class="line">         "_index" : "website",</span><br><span class="line">         "_type" :  "blog",</span><br><span class="line">         "_id" :    2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         "_index" : "website",</span><br><span class="line">         "_type" :  "pageviews",</span><br><span class="line">         "_id" :    1,</span><br><span class="line">         "_source": "views"</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该响应体也包含一个 docs 数组 ， 对于每一个在请求中指定的文档，这个数组中都包含有一个对应的响应，且顺序与请求中的顺序相同。 其中的每一个响应都和使用单个 get request 请求所得到的响应体相同：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"docs"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">         <span class="attr">"_id"</span> :      <span class="string">"2"</span>,</span><br><span class="line">         <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">         <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">         <span class="attr">"_source"</span> : &#123;</span><br><span class="line">            <span class="attr">"text"</span> :  <span class="string">"This is a piece of cake..."</span>,</span><br><span class="line">            <span class="attr">"title"</span> : <span class="string">"My first external blog entry"</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"_version"</span> : <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">         <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">         <span class="attr">"_type"</span> :    <span class="string">"pageviews"</span>,</span><br><span class="line">         <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">         <span class="attr">"_version"</span> : <span class="number">2</span>,</span><br><span class="line">         <span class="attr">"_source"</span> : &#123;</span><br><span class="line">            <span class="attr">"views"</span> : <span class="number">2</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想检索的数据都在相同的 _index 中（甚至相同的 _type 中），则可以在 URL 中指定默认的 /_index 或者默认的 /_index/_type 。<br>你仍然可以通过单独请求覆盖这些值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   "docs" : [</span><br><span class="line">      &#123; "_id" : 2 &#125;,</span><br><span class="line">      &#123; "_type" : "pageviews", "_id" :   1 &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，如果所有文档的 _index 和 _type 都是相同的，你可以只传一个 ids 数组，而不是整个 docs 数组：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   "ids" : [ "2", "1" ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们请求的第二个文档是不存在的。我们指定类型为 blog ，但是文档 ID 1 的类型是 pageviews ，这个不存在的情况将在响应体中被报告：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"docs"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> :      <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"_version"</span> : <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"found"</span> :    <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"_source"</span> : &#123;</span><br><span class="line">        <span class="attr">"title"</span>:   <span class="string">"My first external blog entry"</span>,</span><br><span class="line">        <span class="attr">"text"</span>:    <span class="string">"This is a piece of cake..."</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> :      <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"found"</span> :    <span class="literal">false</span>  </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上第二个文档未能找到并不妨碍第一个文档被检索到。每个文档都是单独检索和报告的。</p>
<p>即使有某个文档没有找到，上述请求的 HTTP 状态码仍然是 200 。事实上，即使请求 没有 找到任何文档，它的状态码依然是 200 –因为 mget 请求本身已经成功执行。 为了确定某个文档查找是成功或者失败，你需要检查 found 标记。</p>
<h2 id="代价较小的批量操作"><a href="#代价较小的批量操作" class="headerlink" title="代价较小的批量操作"></a>代价较小的批量操作</h2><p>与 mget 可以使我们一次取回多个文档同样的方式， bulk API 允许在单个步骤中进行多次 create 、 index 、 update 或 delete 请求。 如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。</p>
<p>bulk 与其他的请求体格式稍有不同，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body        &#125;\n</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body        &#125;\n</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这种格式类似一个有效的单行 JSON 文档 流 ，它通过换行符(\n)连接到一起。注意两个要点：</p>
<p>1.每行一定要以换行符(\n)结尾， 包括最后一行 。这些换行符被用作一个标记，可以有效分隔行。<br>2.这些行不能包含未转义的换行符，因为他们将会对解析造成干扰。这意味着这个 JSON 不 能使用 pretty 参数打印。<br>action/metadata 行指定 哪一个文档 做 什么操作 。<br>action 必须是以下选项之一:<br>   create 如果文档不存在，那么就创建它。详情请见 创建新文档。<br>   index 创建一个新文档或者替换一个现有的文档。详情请见 索引文档 和 更新整个文档。<br>   update 部分更新一个文档。详情请见 文档的部分更新。<br>   delete 删除一个文档。详情请见 删除文档。<br>   metadata 应该 指定被索引、创建、更新或者删除的文档的 _index 、 _type 和 _id 。</p>
<p>例如，一个 delete 请求看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>request body 行由文档的 _source 本身组成–文档包含的字段和值。它是 index 和 create 操作所必需的，这是有道理的：你必须提供文档以索引。</p>
<p>它也是 update 操作所必需的，并且应该包含你传递给 update API 的相同请求体： doc 、 upsert 、 script 等等。 删除操作不需要 request body 行。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; "create":  &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "My first blog post" &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不指定 _id ，将会自动生成一个 ID ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; "index": &#123; "_index": "website", "_type": "blog" &#125;&#125;</span><br><span class="line">&#123; "title":    "My second blog post" &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了把所有的操作组合在一起，一个完整的 bulk 请求 有以下形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; "delete": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125; </span><br><span class="line">&#123; "create": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "My first blog post" &#125;</span><br><span class="line">&#123; "index":  &#123; "_index": "website", "_type": "blog" &#125;&#125;</span><br><span class="line">&#123; "title":    "My second blog post" &#125;</span><br><span class="line">&#123; "update": &#123; "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict" : 3&#125; &#125;</span><br><span class="line">&#123; "doc" : &#123;"title" : "My updated blog post"&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 Elasticsearch 响应包含 items 数组， 这个数组的内容是以请求的顺序列出来的每个请求的结果。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"took"</span>: <span class="number">4</span>,</span><br><span class="line">   <span class="attr">"errors"</span>: <span class="literal">false</span>, </span><br><span class="line">   <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;  <span class="attr">"delete"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">200</span>,</span><br><span class="line">            <span class="attr">"found"</span>:    <span class="literal">true</span></span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &#123;  <span class="attr">"create"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">201</span></span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &#123;  <span class="attr">"create"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"EiwfApScQiiy7TIKFxRCTw"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">201</span></span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &#123;  <span class="attr">"update"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">200</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。 如果其中任何子请求失败，最顶层的 error 标志被设置为 true ，并且在相应的请求报告出错误明细：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; "create": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "Cannot create - it already exists" &#125;</span><br><span class="line">&#123; "index":  &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "But we can update it" &#125;</span><br></pre></td></tr></table></figure></p>
<p>在响应中，我们看到 create 文档 123 失败，因为它已经存在。但是随后的 index 请求，也是对文档 123 操作，就成功了：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"took"</span>: <span class="number">3</span>,</span><br><span class="line">   <span class="attr">"errors"</span>: <span class="literal">true</span>, </span><br><span class="line">   <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;  <span class="attr">"create"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">409</span>, </span><br><span class="line">            <span class="attr">"error"</span>:    <span class="string">"DocumentAlreadyExistsException </span></span><br><span class="line"><span class="string">                        [[website][4] [blog][123]:</span></span><br><span class="line"><span class="string">                        document already exists]"</span></span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &#123;  <span class="attr">"index"</span>: &#123;</span><br><span class="line">            <span class="attr">"_index"</span>:   <span class="string">"website"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>:    <span class="string">"blog"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>:      <span class="string">"123"</span>,</span><br><span class="line">            <span class="attr">"_version"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"status"</span>:   <span class="number">200</span> </span><br><span class="line">      &#125;&#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这也意味着 bulk 请求不是原子的： 不能用它来实现事务控制。每个请求是单独处理的，因此一个请求的成功或失败不会影响其他的请求。</p>
<p>不要重复指定Index和Type</p>
<p>也许你正在批量索引日志数据到相同的 index 和 type 中。 但为每一个文档指定相同的元数据是一种浪费。相反，可以像 mget API 一样，在 bulk 请求的 URL 中接收默认的 /_index 或者 /_index/_type ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /website/_bulk</span><br><span class="line">&#123; "index": &#123; "_type": "log" &#125;&#125;</span><br><span class="line">&#123; "event": "User logged in" &#125;</span><br></pre></td></tr></table></figure></p>
<p>你仍然可以覆盖元数据行中的 _index 和 _type , 但是它将使用 URL 中的这些元数据值作为默认值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /website/log/_bulk</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "event": "User logged in" &#125;</span><br><span class="line">&#123; "index": &#123; "_type": "blog" &#125;&#125;</span><br><span class="line">&#123; "title": "Overriding the default type" &#125;</span><br></pre></td></tr></table></figure></p>
<p>多大是太大了？</p>
<p>整个批量请求都需要由接收到请求的节点加载到内存中，因此该请求越大，其他请求所能获得的内存就越少。 批量请求的大小有一个最佳值，大于这个值，性能将不再提升，甚至会下降。 但是最佳值不是一个固定的值。它完全取决于硬件、文档的大小和复杂度、索引和搜索的负载的整体情况。</p>
<p>幸运的是，很容易找到这个 最佳点 ：通过批量索引典型文档，并不断增加批量大小进行尝试。 当性能开始下降，那么你的批量大小就太大了。一个好的办法是开始时将 1,000 到 5,000 个文档作为一个批次, 如果你的文档非常大，那么就减少批量的文档个数。</p>
<h2 id="分布式文档存储"><a href="#分布式文档存储" class="headerlink" title="分布式文档存储"></a>分布式文档存储</h2><p>在这个章节中，我们将帮助你更好地理解数据如何被存储到这个分布式系统中。</p>
<h2 id="路由一个文档到一个分片中"><a href="#路由一个文档到一个分片中" class="headerlink" title="路由一个文档到一个分片中"></a>路由一个文档到一个分片中</h2><p>当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？</p>
<p>实际上，这个过程是根据下面这个公式决定的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure></p>
<p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
<p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p>
<p>所有的文档 API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。我们也会在扩容设计这一章中详细讨论为什么会有这样一种需求。</p>
<h2 id="主分片和副本分片如何交互"><a href="#主分片和副本分片如何交互" class="headerlink" title="主分片和副本分片如何交互"></a>主分片和副本分片如何交互</h2><p>为了说明目的, 我们 假设有一个集群由三个节点组成。 它包含一个叫 blogs 的索引，有两个主分片，每个主分片有两个副本分片。相同分片的副本不会放在同一节点，所以我们的集群看起来像 图 8所示。</p>
<p>图8 有三个节点和一个索引的集群<br><img src="https://mfaying.github.io/images/elasticsearch2.x/8.jpg" alt="avatar"></p>
<p>我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。 在下面的例子中，将所有的请求发送到 Node 1 ，我们将其称为 协调节点(coordinating node) 。</p>
<p>当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。</p>
<h2 id="新建、索引和删除文档"><a href="#新建、索引和删除文档" class="headerlink" title="新建、索引和删除文档"></a>新建、索引和删除文档</h2><p>新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片，如下图所示 图 9所示<br><img src="https://mfaying.github.io/images/elasticsearch2.x/9.jpg" alt="avatar"><br>图 9. 新建、索引和删除单个文档</p>
<p>以下是在主副分片和任何副本分片上面 成功新建，索引和删除文档所需要的步骤顺序：</p>
<p>1.客户端向 Node 1 发送新建、索引或者删除请求。<br>2.节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。<br>3.Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。</p>
<p>有一些可选的请求参数允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为Elasticsearch已经很快，但是为了完整起见，在这里阐述如下：</p>
<p>consistency</p>
<p>consistency，即一致性。在默认设置下，即使仅仅是在试图执行一个_写_操作之前，主分片都会要求 必须要有 <em>规定数量(quorum)</em>（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行_写<em>操作(其中分片副本可以是主分片或者副本分片)。这是为了避免在发生网络分区故障（network partition）的时候进行</em>写<em>操作，进而导致数据不一致。</em>规定数量_即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int( (primary + number_of_replicas) / 2 ) + 1</span><br></pre></td></tr></table></figure></p>
<p>consistency 参数的值可以设为 one （只要主分片状态 ok 就允许执行_写<em>操作）,all`（必须要主分片和所有副本分片的状态没问题才允许执行</em>写<em>操作）, 或 `quorum 。默认值为 quorum , 即大多数的分片副本状态没问题就允许执行</em>写_操作。</p>
<p>注意，规定数量 的计算公式中 number_of_replicas 指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有三个副本分片，那规定数量的计算结果即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int( (primary + 3 replicas) / 2 ) + 1 = 3</span><br></pre></td></tr></table></figure></p>
<p>如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法索引和删除任何文档。</p>
<p>timeout<br>如果没有足够的副本分片会发生什么？ Elasticsearch会等待，希望更多的分片出现。默认情况下，它最多等待1分钟。 如果你需要，你可以使用 timeout 参数 使它更早终止： 100 100毫秒，30s 是30秒。</p>
<p>注：新索引默认有 1 个副本分片，这意味着为满足 规定数量 应该 需要两个活动的分片副本。 但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当 number_of_replicas 大于1的时候，规定数量才会执行。</p>
<h2 id="取回一个文档-1"><a href="#取回一个文档-1" class="headerlink" title="取回一个文档"></a>取回一个文档</h2><p>可以从主分片或者从其它任意副本分片检索文档 ，如图10所示<br><img src="https://mfaying.github.io/images/elasticsearch2.x/10.jpg" alt="avatar"><br>图 10. 取回单个文档</p>
<p>以下是从主分片或者副本分片检索文档的步骤顺序：<br>1、客户端向 Node 1 发送获取请求。<br>2、节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node 2 。<br>3、Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。</p>
<p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p>
<p>在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
<h2 id="局部更新文档"><a href="#局部更新文档" class="headerlink" title="局部更新文档"></a>局部更新文档</h2><p>如图11所示，update API 结合了先前说明的读取和写入模式 。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/11.jpg" alt="avatar"><br>图 11. 局部更新文档</p>
<p>以下是部分更新一个文档的步骤：</p>
<p>1.客户端向 Node 1 发送更新请求。<br>2.它将请求转发到主分片所在的 Node 3 。<br>3.Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。<br>4.如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成功。</p>
<p>update API 还接受在 新建、索引和删除文档 章节中介绍的 routing 、 replication 、 consistency 和 timeout 参数。</p>
<p>基于文档的复制</p>
<p>当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p>
<h2 id="多文档模式"><a href="#多文档模式" class="headerlink" title="多文档模式"></a>多文档模式</h2><p>mget 和 bulk API 的 模式类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成 每个分片 的多文档请求，并且将这些请求并行转发到每个参与节点。</p>
<p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端，如图12所示。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/12.jpg" alt="avatar"><br>图12. 使用 mget 取回多个文档</p>
<p>以下是使用单个 mget 请求取回多个文档所需的步骤顺序：</p>
<p>1.客户端向 Node 1 发送 mget 请求。<br>2.Node 1 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， Node 1 构建响应并将其返回给客户端。</p>
<p>可以对 docs 数组中每个文档设置 routing 参数。</p>
<p>bulk API， 如 图 13 所示， 允许在单个批量请求中执行多个创建、索引、删除和更新请求。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/13.jpg" alt="avatar"><br>图 13. 使用 bulk 修改多个文档</p>
<p>bulk API 按如下步骤顺序执行：</p>
<p>1.客户端向 Node 1 发送 bulk 请求。<br>2.Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。<br>3.主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</p>
<p>bulk API 还可以在整个批量请求的最顶层使用 consistency 参数，以及在每个请求中的元数据中使用 routing 参数。</p>
<h2 id="为什么是有趣的格式？"><a href="#为什么是有趣的格式？" class="headerlink" title="为什么是有趣的格式？"></a>为什么是有趣的格式？</h2><p>当我们早些时候在代价较小的批量操作章节了解批量请求时， 您可能会问自己， “为什么 bulk API 需要有换行符的有趣格式，而不是发送包装在 JSON 数组中的请求，例如 mget API？” 。</p>
<p>为了回答这一点，我们需要解释一点背景：在批量请求中引用的每个文档可能属于不同的主分片， 每个文档可能被分配给集群中的任何节点。这意味着批量请求 bulk 中的每个 操作 都需要被转发到正确节点上的正确分片。</p>
<p>如果单个请求被包装在 JSON 数组中，那就意味着我们需要执行以下操作：</p>
<p>1.将 JSON 解析为数组（包括文档数据，可以非常大）<br>2.查看每个请求以确定应该去哪个分片<br>3.为每个分片创建一个请求数组<br>4.将这些数组序列化为内部传输格式<br>5.将请求发送到每个分片</p>
<p>这是可行的，但需要大量的 RAM 来存储原本相同的数据的副本，并将创建更多的数据结构，Java虚拟机（JVM）将不得不花费时间进行垃圾回收。</p>
<p>相反，Elasticsearch可以直接读取被网络缓冲区接收的原始数据。 它使用换行符字符来识别和解析小的 action/metadata 行来决定哪个分片应该处理每个请求。</p>
<p>这些原始请求会被直接转发到正确的分片。没有冗余的数据复制，没有浪费的数据结构。整个请求尽可能在最小的内存中处理。</p>
<h2 id="搜索——最基本的工具"><a href="#搜索——最基本的工具" class="headerlink" title="搜索——最基本的工具"></a>搜索——最基本的工具</h2><p>Elasticsearch 真正强大之处在于可以从无规律的数据中找出有意义的信息——从“大数据”到“大信息”。</p>
<p>Elasticsearch 不只会存储（stores） 文档，为了能被搜索到也会为文档添加索引（indexes） ，这也是为什么我们使用结构化的 JSON 文档，而不是无结构的二进制数据。</p>
<p>文档中的每个字段都将被索引并且可以被查询 。不仅如此，在简单查询时，Elasticsearch 可以使用 所有（all）这些索引字段，以惊人的速度返回结果。这是你永远不会考虑用传统数据库去做的一些事情。</p>
<p>搜索（search） 可以做到：<br>1.在类似于 gender 或者 age 这样的字段 上使用结构化查询，join_date 这样的字段上使用排序，就像SQL的结构化查询一样。<br>2.全文检索，找出所有匹配关键字的文档并按照相关性（relevance） 排序后返回结果。<br>3.以上二者兼而有之。</p>
<p>很多搜索都是开箱即用的，为了充分挖掘 Elasticsearch 的潜力，你需要理解以下三个概念：</p>
<p>1.映射（Mapping） 描述数据在每个字段内如何存储<br>2.分析（Analysis） 全文是如何处理使之可以被搜索的<br>3.领域特定查询语言（Query DSL） Elasticsearch 中强大灵活的查询语言</p>
<h2 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h2><p>搜索API的最基础的形式是没有指定任何查询的空搜索 ，它简单地返回集群中所有索引下的所有文档：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure></p>
<p>返回的结果（为了界面简洁编辑过的）像这样：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"hits"</span> : &#123;</span><br><span class="line">      <span class="attr">"total"</span> :       <span class="number">14</span>,</span><br><span class="line">      <span class="attr">"hits"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"_index"</span>:   <span class="string">"us"</span>,</span><br><span class="line">          <span class="attr">"_type"</span>:    <span class="string">"tweet"</span>,</span><br><span class="line">          <span class="attr">"_id"</span>:      <span class="string">"7"</span>,</span><br><span class="line">          <span class="attr">"_score"</span>:   <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"_source"</span>: &#123;</span><br><span class="line">             <span class="attr">"date"</span>:    <span class="string">"2014-09-17"</span>,</span><br><span class="line">             <span class="attr">"name"</span>:    <span class="string">"John Smith"</span>,</span><br><span class="line">             <span class="attr">"tweet"</span>:   <span class="string">"The Query DSL is really powerful and flexible"</span>,</span><br><span class="line">             <span class="attr">"user_id"</span>: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        ... <span class="number">9</span> RESULTS REMOVED ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"max_score"</span> :   <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"took"</span> :           <span class="number">4</span>,</span><br><span class="line">   <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">      <span class="attr">"failed"</span> :      <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"successful"</span> :  <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"total"</span> :       <span class="number">10</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"timed_out"</span> :      <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hits</p>
<p>返回结果中最重要的部分是 hits ，它 包含 total 字段来表示匹配到的文档总数，并且一个 hits 数组包含所查询结果的前十个文档。</p>
<p>在 hits 数组中每个结果包含文档的 _index 、 _type 、 _id ，加上 _source 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。</p>
<p>每个结果还有一个 _score ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 _score 降序排列的。在这个例子中，我们没有指定任何查询，故所有的文档具有相同的相关性，因此对所有的结果而言 1 是中性的 _score 。</p>
<p>max_score 值是与查询所匹配文档的 _score 的最大值。</p>
<p>took</p>
<p>took值告诉我们执行整个搜索请求耗费了多少毫秒。</p>
<p>shards<br>_shards 部分 告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。</p>
<p>timeout编辑<br>timed_out 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 timeout 为 10 或者 10ms（10毫秒），或者 1s（1秒）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?timeout=10ms</span><br></pre></td></tr></table></figure></p>
<p>在请求超时之前，Elasticsearch 将会返回已经成功从每个分片获取的结果。</p>
<p>应当注意的是 timeout 不是停止执行查询，它仅仅是告知正在协调的节点返回到目前为止收集的结果并且关闭连接。在后台，其他的分片可能仍在执行查询即使是结果已经被发送了。</p>
<p>使用超时是因为 SLA(服务等级协议)对你是很重要的，而不是因为想去中止长时间运行的查询。</p>
<h2 id="多索引，多类型"><a href="#多索引，多类型" class="headerlink" title="多索引，多类型"></a>多索引，多类型</h2><p>如果不对某一特殊的索引或者类型做限制，就会搜索集群中的所有文档。Elasticsearch 转发搜索请求到每一个主分片或者副本分片，汇集查询出的前10个结果，并且返回给我们。</p>
<p>然而，经常的情况下，你 想在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。我们可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：</p>
<p>/_search<br>   在所有的索引中搜索所有的类型<br>/gb/_search<br>   在 gb 索引中搜索所有的类型<br>/gb,us/_search<br>   在 gb 和 us 索引中搜索所有的文档<br>/g<em>,u</em>/_search<br>   在任何以 g 或者 u 开头的索引中搜索所有的类型<br>/gb/user/_search<br>   在 gb 索引中搜索 user 类型<br>/gb,us/user,tweet/_search<br>   在 gb 和 us 索引中搜索 user 和 tweet 类型<br>/_all/user,tweet/_search<br>   在所有的索引中搜索 user 和 tweet 类型</p>
<p>当在单一的索引下进行搜索的时候，Elasticsearch 转发请求到索引的每个分片中，可以是主分片也可以是副本分片，然后从每个分片中收集结果。多索引搜索恰好也是用相同的方式工作的–只是会涉及到更多的分片。</p>
<p>注：搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>和 SQL 使用 LIMIT 关键字返回单个 page 结果的方法相同，Elasticsearch 接受 from 和 size 参数：<br>size<br>   显示应该返回的结果数量，默认是 10<br>from<br>   显示应该跳过的初始结果数量，默认是 0</p>
<p>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?size=5</span><br><span class="line">GET /_search?size=5&amp;from=5</span><br><span class="line">GET /_search?size=5&amp;from=10</span><br></pre></td></tr></table></figure></p>
<p>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。</p>
<p>在分布式系统中深度分页</p>
<p>为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p>
<p>现在假设我们请求第 1000 页–结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p>
<p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。</p>
<p>轻量搜索</p>
<p>有两种形式的 搜索 API：一种是 “轻量的” 查询字符串 版本，要求在查询字符串中传递所有的 参数，另一种是更完整的 请求体 版本，要求使用 JSON 格式和更丰富的查询表达式作为搜索语言。</p>
<p>查询字符串搜索非常适用于通过命令行做即席查询。例如，查询在 tweet 类型中 tweet 字段包含 elasticsearch 单词的所有文档：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_all/tweet/_search?q=tweet:elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>下一个查询在 name 字段中包含 john 并且在 tweet 字段中包含 mary 的文档。实际的查询就是这样<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+name:john +tweet:mary</span><br></pre></td></tr></table></figure></p>
<p>但是查询字符串参数所需要的URL编码实际上更加难懂：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary</span><br></pre></td></tr></table></figure></p>
<p>+前缀表示必须与查询条件匹配。类似地， - 前缀表示一定不与查询条件匹配。没有 + 或者 - 的所有其他条件都是可选的——匹配的越多，文档就越相关。</p>
<p>_all字段</p>
<p>这个简单搜索返回包含 mary 的所有文档：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=mary</span><br></pre></td></tr></table></figure></p>
<p>之前的例子中，我们在 tweet 和 name 字段中搜索内容。然而，这个查询的结果在三个地方提到了 mary ：</p>
<p>1.有一个用户叫做 Mary<br>2.6条微博发自 Mary<br>3.一条微博直接 @mary</p>
<p>Elasticsearch 是如何在三个不同的字段中查找到结果的呢？</p>
<p>当索引一个文档的时候，Elasticsearch 取出所有字段的值拼接成一个大的字符串，作为 _all 字段进行索引。例如，当索引这个文档时：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>:    <span class="string">"However did I manage before Elasticsearch?"</span>,</span><br><span class="line">    <span class="attr">"date"</span>:     <span class="string">"2014-09-14"</span>,</span><br><span class="line">    <span class="attr">"name"</span>:     <span class="string">"Mary Jones"</span>,</span><br><span class="line">    <span class="attr">"user_id"</span>:  <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就好似增加了一个名叫 _all 的额外字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1&quot;</span><br></pre></td></tr></table></figure></p>
<p>除非设置特定字段，否则查询字符串就使用 _all 字段进行搜索。</p>
<p>在刚开始开发一个应用时，_all 字段是一个很实用的特性。之后，你会发现如果搜索时用指定字段来代替 _all 字段，将会更好控制搜索结果。当 _all 字段不再有用的时候，可以将它置为失效，正如在 元数据: _all 字段 中所解释的。</p>
<p>更复杂的查询</p>
<p>下面的查询针对tweents类型，并使用以下的条件：</p>
<p>1.name 字段中包含 mary 或者 john<br>2.date 值大于 2014-09-10<br>3._all 字段包含 aggregations 或者 geo</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)</span><br></pre></td></tr></table></figure>
<p>查询字符串在做了适当的编码后，可读性很差：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?q=%2Bname%3A(mary+john)+%2Bdate%3A%3E2014-09-10+%2B(aggregations+geo)</span><br></pre></td></tr></table></figure></p>
<p>这种 轻量 的查询字符串对于通过命令做一次性查询，或者是在开发阶段，都非常方便。但同时也可以看到，这种精简让调试更加晦涩和困难。而且很脆弱，一些查询字符串中很小的语法错误，像 - ， : ， / 或者 “ 不匹配等，将会返回错误而不是搜索结果。</p>
<p>最后，查询字符串搜索允许任何用户在索引的任意字段上执行可能较慢且重量级的查询，这可能会暴露隐私信息，甚至将集群拖垮。</p>
<p>相反，我们经常在生产环境中更多地使用功能全面的 request body 查询API，除了能完成以上所有功能，还有一些附加功能。</p>
<h2 id="映射和分析"><a href="#映射和分析" class="headerlink" title="映射和分析"></a>映射和分析</h2><p>当摆弄索引里面的数据时，我们发现一些奇怪的事情。一些事情看起来被打乱了：在我们的索引中有12条推文，其中只有一条包含日期 2014-09-15 ，但是看一看下面查询命中的 总数 （total）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=2014              # 12 results</span><br><span class="line">GET /_search?q=2014-09-15        # 12 results !</span><br><span class="line">GET /_search?q=date:2014-09-15   # 1  result</span><br><span class="line">GET /_search?q=date:2014         # 0  results !</span><br></pre></td></tr></table></figure></p>
<p>为什么在 _all 字段查询日期返回所有推文，而在 date 字段只查询年份却没有返回结果？为什么我们在 _all 字段和 date 字段的查询结果有差别？</p>
<p>推测起来，这是因为数据在 <em>all 字段与 date 字段的索引方式不同。所以，通过请求 gb 索引中 tweet 类型的</em>映射_（或模式定义），让我们看一看 Elasticsearch 是如何解释我们文档结构的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_mapping/tweet</span><br></pre></td></tr></table></figure></p>
<p>这将得到如下结果：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"gb"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">         <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"date"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">                  <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time||epoch_millis"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"user_id"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于对字段类型的猜测， Elasticsearch 动态为我们产生了一个映射。这个响应告诉我们 date 字段被认为是 date 类型的。由于 _all 是默认字段，所以没有提及它。但是我们知道 _all 字段是 string 类型的。</p>
<p>所以 date 字段和 string 字段 索引方式不同，因此搜索结果也不一样。这完全不令人吃惊。你可能会认为 核心数据类型 strings、numbers、Booleans 和 dates 的索引方式有稍许不同。没错，他们确实稍有不同。</p>
<p>但是，到目前为止，最大的差异在于 代表 精确值 （它包括 string 字段）的字段和代表 全文 的字段。这个区别非常重要——它将搜索引擎和所有其他数据库区别开来。</p>
<h2 id="精确值-VS-全文"><a href="#精确值-VS-全文" class="headerlink" title="精确值 VS 全文"></a>精确值 VS 全文</h2><p>Elasticsearch 中的数据可以概括的分为两类：精确值和全文。</p>
<p>精确值 如它们听起来那样精确。例如日期或者用户 ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，Foo 和 foo 是不同的，2014 和 2014-09-15 也是不同的。</p>
<p>另一方面，全文是指文本数据（通常以人类容易识别的语言书写），例如一个推文的内容或一封邮件的内容。全文通常是指非结构化的数据，但这里有一个误解：自然语言是高度结构化的。问题在于自然语言的规则是复杂的，导致计算机难以正确解析。例如，考虑这条语句:May is fun but June bores me.它指的是月份还是人？</p>
<p>精确值很容易查询。结果是二进制的：要么匹配查询，要么不匹配。这种查询很容易用 SQL 表示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHERE name    = "John Smith"</span><br><span class="line">  AND user_id = 2</span><br><span class="line">  AND date    &gt; "2014-09-15"</span><br></pre></td></tr></table></figure>
<p>查询全文数据要微妙的多。我们问的不只是“这个文档匹配查询吗”，而是“该文档匹配查询的程度有多大？”换句话说，该文档与给定查询的相关性如何？</p>
<p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的 意图 ：</p>
<p>1.搜索 UK ，会返回包含 United Kindom 的文档。<br>2.搜索 jump ，会匹配 jumped ， jumps ， jumping ，甚至是 leap 。<br>3.搜索 johnny walker 会匹配 Johnnie Walker ， johnnie depp 应该匹配 Johnny Depp 。<br>4.fox news hunting 应该返回福克斯新闻（ Foxs News ）中关于狩猎的故事，同时， fox hunting news 应该返回关于猎狐的故事。</p>
<p>为了促进这类在全文域中的查询，Elasticsearch 首先 分析 文档，之后根据结果创建 倒排索引。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。</p>
<p>例如，假设我们有两个文档，每个文档的 content 域包含如下内容：</p>
<p>1.The quick brown fox jumped over the lazy dog<br>2.Quick brown foxes leap over lazy dogs in summer</p>
<p>为了创建倒排索引，我们首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">Quick   |       |  X</span><br><span class="line">The     |   X   |</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">dog     |   X   |</span><br><span class="line">dogs    |       |  X</span><br><span class="line">fox     |   X   |</span><br><span class="line">foxes   |       |  X</span><br><span class="line">in      |       |  X</span><br><span class="line">jumped  |   X   |</span><br><span class="line">lazy    |   X   |  X</span><br><span class="line">leap    |       |  X</span><br><span class="line">over    |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">summer  |       |  X</span><br><span class="line">the     |   X   |</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure></p>
<p>现在，如果我们想搜索 quick brown ，我们只需要查找包含每个词条的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">------------------------</span><br><span class="line">Total   |   2   |  1</span><br></pre></td></tr></table></figure></p>
<p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p>
<p>但是，我们目前的倒排索引有一些问题：<br>1.Quick 和 quick 以独立的词条出现，然而用户可能认为它们是相同的词。<br>2.fox 和 foxes 非常相似, 就像 dog 和 dogs ；他们有相同的词根。<br>3.jumped 和 leap, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。</p>
<p>使用前面的索引搜索 +Quick +fox 不会得到任何匹配文档。（记住，+ 前缀表明这个词必须存在。）只有同时出现 Quick 和 fox 的文档才满足这个查询条件，但是第一个文档包含 quick fox ，第二个文档包含 Quick foxes 。</p>
<p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p>
<p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p>
<p>Quick 可以小写化为 quick 。<br>foxes 可以 词干提取 –变为词根的格式– 为 fox 。类似的， dogs 可以为提取为 dog 。<br>jumped 和 leap 是同义词，可以索引为相同的单词 jump 。</p>
<p>现在索引看上去像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">dog     |   X   |  X</span><br><span class="line">fox     |   X   |  X</span><br><span class="line">in      |       |  X</span><br><span class="line">jump    |   X   |  X</span><br><span class="line">lazy    |   X   |  X</span><br><span class="line">over    |   X   |  X</span><br><span class="line">quick   |   X   |  X</span><br><span class="line">summer  |       |  X</span><br><span class="line">the     |   X   |  X</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure>
<p>这还远远不够。我们搜索 +Quick +fox 仍然 会失败，因为在我们的索引中，已经没有 Quick 了。但是，如果我们对搜索的字符串使用与 content 域相同的标准化规则，会变成查询 +quick +fox ，这样两个文档都会匹配！</p>
<p>这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。</p>
<p>分词和标准化的过程称为 分析 ， 我们会在下个章节讨论。</p>
<h2 id="分析与分析器"><a href="#分析与分析器" class="headerlink" title="分析与分析器"></a>分析与分析器</h2><p>分析 包含下面的过程：<br>首先，将一块文本分成适合于倒排索引的独立的 词条 ，<br>之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall</p>
<p>分析器执行上面的工作。 分析器 实际上是将三个功能封装到了一个包里：<br>字符过滤器<br>   首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 <code>and</code>。<br>分词器<br>   其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。<br>Token 过滤器<br>   最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a<code>，</code>and<code>，</code>the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。</p>
<p>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。我们会在 自定义分析器 章节详细讨论。</p>
<p>内置分析器<br>但是， Elasticsearch还附带了可以直接使用的预包装的分析器。 接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</span><br></pre></td></tr></table></figure></p>
<p>标准分析器<br>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。它会产生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set, the, shape, to, semi, transparent, by, calling, set_trans, 5</span><br></pre></td></tr></table></figure></p>
<p>简单分析器<br>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set, the, shape, to, semi, transparent, by, calling, set, trans</span><br></pre></td></tr></table></figure></p>
<p>空格分析器<br>空格分析器在空格的地方划分文本。它会产生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</span><br></pre></td></tr></table></figure></p>
<p>语言分析器<br>特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 。英语分词器会产生下面的词条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set, shape, semi, transpar, call, set_tran, 5</span><br></pre></td></tr></table></figure></p>
<p>注意看 transparent、calling 和 set_trans 已经变为词根格式</p>
<p>什么时候使用分析器</p>
<p>当我们 索引 一个文档，它的全文域被分析成词条以用来创建倒排索引。 但是，当我们在全文域 搜索 的时候，我们需要将查询字符串通过 相同的分析过程 ，以保证我们搜索的词条格式与索引中的词条格式一致。</p>
<p>全文查询，理解每个域是如何定义的，因此它们可以做 正确的事：<br>.当你查询一个 全文 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。<br>.当你查询一个 精确值 域时，不会分析查询字符串， 而是搜索你指定的精确值。</p>
<p>现在你可以理解在 开始章节 的查询为什么返回那样的结果：<br>.date 域包含一个精确值：单独的词条 2014-09-15。<br>._all 域是一个全文域，所以分词进程将日期转化为三个词条： 2014，09和15。</p>
<p>当我们在 _all 域查询 2014，它匹配所有的12条推文，因为它们都含有 2014 ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=2014              # 12 results</span><br></pre></td></tr></table></figure></p>
<p>当我们在 _all 域查询 2014-09-15，它首先分析查询字符串，产生匹配2014，09， 或 15 中 任意 词条的查询。这也会匹配所有12条推文，因为它们都含有 2014 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=2014-09-15        # 12 results !</span><br></pre></td></tr></table></figure></p>
<p>当我们在 date 域查询 2014-09-15，它寻找 精确 日期，只找到一个推文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=date:2014-09-15   # 1  result</span><br></pre></td></tr></table></figure></p>
<p>当我们在 date 域查询 <code>2014</code>，它找不到任何文档，因为没有文档含有这个精确日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=date:2014         # 0  results !</span><br></pre></td></tr></table></figure></p>
<p>测试分析器<br>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触 Elasticsearch。为了理解发生了什么，你可以使用 analyze API 来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "analyzer": "standard",</span><br><span class="line">  "text": "Text to analyze"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果中每个元素代表一个单独的词条：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"tokens"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"text"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">4</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"to"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">5</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">7</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"analyze"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">8</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">15</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>token 是实际存储到索引中的词条。 position 指明词条在原始文本中出现的位置。 start_offset 和 end_offset 指明字符在原始字符串中的位置。</p>
<p>每个分析器的 type 值都不一样，可以忽略它们。它们在Elasticsearch中的唯一作用在于keep_types token 过滤器。</p>
<p>指定分析器编辑</p>
<p>当Elasticsearch在你的文档中检测到一个新的字符串域 ，它会自动设置其为一个全文 字符串 域，使用 标准 分析器对它进行分析。</p>
<p>你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域–不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。要做到这一点，我们必须手动指定这些域的映射。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>为了能够将时间域视为时间，数字域视为数字，字符串域视为全文或精确值字符串， Elasticsearch 需要知道每个域中数据的类型。这个信息包含在映射中。</p>
<p>如 数据输入和输出 中解释的， 索引中每个文档都有 类型 。每种类型都有它自己的 映射 ，或者 模式定义 。映射定义了类型中的域，每个域的数据类型，以及Elasticsearch如何处理这些域。映射也用于配置与类型有关的元数据。</p>
<p>核心简单域类型编辑</p>
<p>Elasticsearch 支持 如下简单域类型：<br>字符串: string<br>整数 : byte, short, integer, long<br>浮点数: float, double<br>布尔型: boolean<br>日期: date</p>
<p>当你索引一个包含新域的文档–之前未曾出现– Elasticsearch 会使用 动态映射 ，通过JSON中基本数据类型，尝试猜测域类型，使用如下规则：</p>
<table>
<thead>
<tr>
<th>JSON type</th>
<th>域 type</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型: true 或者 false</td>
<td>boolean</td>
</tr>
<tr>
<td>整数: 123</td>
<td>long</td>
</tr>
<tr>
<td>浮点数: 123.45</td>
<td>double</td>
</tr>
<tr>
<td>字符串，有效日期: 2014-09-15</td>
<td>date</td>
</tr>
<tr>
<td>字符串: foo bar</td>
<td>string</td>
</tr>
</tbody>
</table>
<p>这意味着如果你通过引号( “123” )索引一个数字，它会被映射为 string 类型，而不是 long 。但是，如果这个域已经映射为 long ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。</p>
<p>查看映射编辑</p>
<p>通过 /_mapping ，我们可以查看 Elasticsearch 在一个或多个索引中的一个或多个类型的映射 。在开始章节 ，我们已经取得索引 gb 中类型 tweet 的映射：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_mapping/tweet</span><br></pre></td></tr></table></figure></p>
<p>Elasticsearch 根据我们索引的文档，为域(称为 属性 )动态生成的映射。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"gb"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">         <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"date"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">                  <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time||epoch_millis"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"user_id"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误的映射，例如 将 age 域映射为 string 类型，而不是 integer ，会导致查询出现令人困惑的结果。检查一下！而不是假设你的映射是正确的。</p>
<p>自定义域映射编辑</p>
<p>尽管在很多情况下基本域数据类型 已经够用，但你经常需要为单独域自定义映射 ，特别是字符串域。自定义映射允许你执行下面的操作：</p>
<p>.全文字符串域和精确值字符串域的区别<br>.使用特定语言分析器<br>.优化域以适应部分匹配<br>.指定自定义数据格式<br>.还有更多</p>
<p>域最重要的属性是 type 。对于不是 string 的域，你一般只需要设置 type ：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"number_of_clicks"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"integer"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认， string 类型域会被认为包含全文。就是说，它们的值在索引前，会通过一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p>
<p>string 域映射的两个最重要 属性是 index 和 analyzer 。</p>
<p>index</p>
<p>index 属性控制怎样索引字符串。它可以是下面三个值：</p>
<p>1.analyzed<br>   首先分析字符串，然后索引它。换句话说，以全文索引这个域。<br>2.not_analyzed<br>   索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。<br>3.no<br>   不索引这个域。这个域不会被搜索到。</p>
<p>string 域 index 属性默认是 analyzed 。如果我们想映射这个字段为一个精确值，我们需要设置它为 not_analyzed<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tag"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">        <span class="attr">"index"</span>:    <span class="string">"not_analyzed"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他简单类型（例如 long ， double ， date 等）也接受 index 参数，但有意义的值只有 no 和 not_analyzed ， 因为它们永远不会被分析。</p>
<p>analyzer</p>
<p>对于analyzed字符串域，用analyzer属性指定在搜索和索引时使用的分析器。默认，Elasticsearch 使用 standard 分析器， 但你可以指定一个内置的分析器替代它，例如 whitespace 、 simple 和 english：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更新映射<br>当你首次 创建一个索引的时候，可以指定类型的映射。你也可以使用 /_mapping 为新类型（或者为存在的类型更新映射）增加映射。</p>
<p>注意,尽管你可以增加一个存在的映射，你不能修改存在的域映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。</p>
<p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 analyzed 改为 not_analyzed 。为了描述指定映射的两种方式，我们先删除 gd 索引：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /gb</span><br></pre></td></tr></table></figure></p>
<p>然后创建一个新索引，指定 tweet 域使用 english 分析器：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb </span><br><span class="line">&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "tweet" : &#123;</span><br><span class="line">      "properties" : &#123;</span><br><span class="line">        "tweet" : &#123;</span><br><span class="line">          "type" :    "string",</span><br><span class="line">          "analyzer": "english"</span><br><span class="line">        &#125;,</span><br><span class="line">        "date" : &#123;</span><br><span class="line">          "type" :   "date"</span><br><span class="line">        &#125;,</span><br><span class="line">        "name" : &#123;</span><br><span class="line">          "type" :   "string"</span><br><span class="line">        &#125;,</span><br><span class="line">        "user_id" : &#123;</span><br><span class="line">          "type" :   "long"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>稍后，我们决定在 tweet 映射增加一个新的名为 tag 的 not_analyzed 的文本域，使用 _mapping ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">  "properties" : &#123;</span><br><span class="line">    "tag" : &#123;</span><br><span class="line">      "type" :    "string",</span><br><span class="line">      "index":    "not_analyzed"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们不需要再次列出所有已存在的域，因为无论如何我们都无法改变它们。新域已经被合并到存在的映射中。</p>
<p>测试映射</p>
<p>你可以使用 analyze API 测试字符串域的映射。比较下面两个请求的输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "field": "tweet",</span><br><span class="line">  "text": "Black-cats" </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "field": "tag",</span><br><span class="line">  "text": "Black-cats" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tweet 域产生两个词条 black 和 cat ， tag 域产生单独的词条 Black-cats 。换句话说，我们的映射正常工作。</p>
<h2 id="复杂核心域类型"><a href="#复杂核心域类型" class="headerlink" title="复杂核心域类型"></a>复杂核心域类型</h2><p>除了我们提到的简单标量数据类型,JSON还有null值，数组，和对象，这些 Elasticsearch 都是支持的。</p>
<p>多值域</p>
<p>很有可能，我们希望 tag 域 包含多个标签。我们可以以数组的形式索引标签：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"tag"</span>: [ <span class="string">"search"</span>, <span class="string">"nosql"</span> ]&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于数组，没有特殊的映射需求。任何域都可以包含0、1或者多个值，就像全文域分析得到多个词条。</p>
<p>这暗示 数组中所有的值必须是相同数据类型的 。你不能将日期和字符串混在一起。如果你通过索引数组来创建新的域，Elasticsearch 会用数组中第一个值的数据类型作为这个域的 类型 。</p>
<p>当你从 Elasticsearch 得到一个文档，每个数组的顺序和你当初索引文档时一样。你得到的 _source 域，包含与你索引的一模一样的 JSON 文档。</p>
<p>但是，数组是以多值域 索引的—可以搜索，但是无序的。 在搜索的时候，你不能指定 “第一个” 或者 “最后一个”。 </p>
<p>空域</p>
<p>当然，数组可以为空。这相当于存在零值。事实上，在Lucene中是不能存储 null 值的，所以我们认为存在 null 值的域为空域。下面三种域被认为是空的，它们将不会被索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;null_value&quot;:               null,</span><br><span class="line">&quot;empty_array&quot;:              [],</span><br><span class="line">&quot;array_with_null_value&quot;:    [ null ]</span><br></pre></td></tr></table></figure></p>
<p>多层级对象</p>
<p>我们讨论的最后一个 JSON 原生数据类是 对象 – 在其他语言中称为哈希，哈希 map，字典或者关联数组。</p>
<p>内部对象 经常用于 嵌入一个实体或对象到其它对象中。例如，与其在 tweet 文档中包含 user_name 和 user_id 域，我们也可以这样写：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>:            <span class="string">"Elasticsearch is very flexible"</span>,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>:           <span class="string">"@johnsmith"</span>,</span><br><span class="line">        <span class="attr">"gender"</span>:       <span class="string">"male"</span>,</span><br><span class="line">        <span class="attr">"age"</span>:          <span class="number">26</span>,</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"full"</span>:     <span class="string">"John Smith"</span>,</span><br><span class="line">            <span class="attr">"first"</span>:    <span class="string">"John"</span>,</span><br><span class="line">            <span class="attr">"last"</span>:     <span class="string">"Smith"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部对象的映射</p>
<p>Elasticsearch 会动态 监测新的对象域并映射它们为 对象 ，在 properties 属性下列出内部域：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"gb"</span>: &#123;</span><br><span class="line">    <span class="attr">"tweet"</span>: &#123; </span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"tweet"</span>:            &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">        <span class="attr">"user"</span>: &#123; </span><br><span class="line">          <span class="attr">"type"</span>:             <span class="string">"object"</span>,</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"id"</span>:           &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">            <span class="attr">"gender"</span>:       &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">            <span class="attr">"age"</span>:          &#123; <span class="attr">"type"</span>: <span class="string">"long"</span>   &#125;,</span><br><span class="line">            <span class="attr">"name"</span>:   &#123; </span><br><span class="line">              <span class="attr">"type"</span>:         <span class="string">"object"</span>,</span><br><span class="line">              <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"full"</span>:     &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">                <span class="attr">"first"</span>:    &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">                <span class="attr">"last"</span>:     &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>user 和 name 域的映射结构与 tweet 类型的相同。事实上， type 映射只是一种特殊的 对象 映射，我们称之为 根对象 。除了它有一些文档元数据的特殊顶级域，例如 _source 和 _all 域，它和其他对象一样。</p>
<p>内部对象是如何索引的</p>
<p>Lucene 不理解内部对象。 Lucene 文档是由一组键值对列表组成的。为了能让 Elasticsearch 有效地索引内部类，它把我们的文档转化成这样：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>:            [elasticsearch, flexible, very],</span><br><span class="line">    <span class="attr">"user.id"</span>:          [@johnsmith],</span><br><span class="line">    <span class="attr">"user.gender"</span>:      [male],</span><br><span class="line">    <span class="attr">"user.age"</span>:         [<span class="number">26</span>],</span><br><span class="line">    <span class="attr">"user.name.full"</span>:   [john, smith],</span><br><span class="line">    <span class="attr">"user.name.first"</span>:  [john],</span><br><span class="line">    <span class="attr">"user.name.last"</span>:   [smith]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部域 可以通过名称引用（例如， first ）。为了区分同名的两个域，我们可以使用全 路径 （例如， user.name.first ） 或 type 名加路径（ tweet.user.name.first ）。</p>
<p>内部对象数组</p>
<p>最后，考虑包含 内部对象的数组是如何被索引的。 假设我们有个 followers 数组：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"followers"</span>: [</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">35</span>, <span class="attr">"name"</span>: <span class="string">"Mary White"</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">26</span>, <span class="attr">"name"</span>: <span class="string">"Alex Jones"</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">19</span>, <span class="attr">"name"</span>: <span class="string">"Lisa Smith"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个文档会像我们之前描述的那样被扁平化处理，结果如下所示：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"followers.age"</span>:    [<span class="number">19</span>, <span class="number">26</span>, <span class="number">35</span>],</span><br><span class="line">    <span class="attr">"followers.name"</span>:   [alex, jones, lisa, smith, mary, white]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>{age: 35} 和 {name: Mary White} 之间的相关性已经丢失了，因为每个多值域只是一包无序的值，而不是有序数组。这足以让我们问，“有一个26岁的追随者？”</p>
<p>但是我们不能得到一个准确的答案：“是否有一个26岁 名字叫 Alex Jones 的追随者？”</p>
<p>相关内部对象被称为 nested 对象，可以回答上面的查询，我们稍后会在嵌套对象中介绍它。</p>
<h1 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h1><p>简易 查询 —query-string search— 对于用命令行进行即席查询（ad-hoc）是非常有用的。 然而，为了充分利用查询的强大功能，你应该使用 请求体 search API， 之所以称之为请求体查询(Full-Body Search)，因为大部分参数是通过 Http 请求体而非查询字符串来传递的。</p>
<p>请求体查询 —下文简称 查询—不仅可以处理自身的查询请求，还允许你对结果进行片段强调（高亮）、对所有或部分结果进行聚合分析，同时还可以给出 你是不是想找 的建议，这些建议可以引导使用者快速找到他想要的结果。</p>
<h2 id="空查询编辑"><a href="#空查询编辑" class="headerlink" title="空查询编辑"></a>空查询编辑</h2><p>让我们以 最简单的 search API 的形式开启我们的旅程，空查询将返回所有索引库（indices)中的所有文档：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>只用一个查询字符串，你就可以在一个、多个或者 _all 索引库（indices）和一个、多个或者所有types中查询：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index_2014*/type1,type2/_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时你可以使用 from 和 size 参数来分页：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  "from": 30,</span><br><span class="line">  "size": 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：一个带请求体的 GET 请求？</p>
<p>某些特定语言（特别是 JavaScript）的 HTTP 库是不允许 GET 请求带有请求体的。 事实上，一些使用者对于 GET 请求可以带请求体感到非常的吃惊。</p>
<p>而事实是这个RFC文档 RFC 7231— 一个专门负责处理 HTTP 语义和内容的文档 — 并没有规定一个带有请求体的 GET 请求应该如何处理！结果是，一些 HTTP 服务器允许这样子，而有一些 — 特别是一些用于缓存和代理的服务器 — 则不允许。</p>
<p>对于一个查询请求，Elasticsearch 的工程师偏向于使用 GET 方式，因为他们觉得它比 POST 能更好的描述信息检索（retrieving information）的行为。然而，因为带请求体的 GET 请求并不被广泛支持，所以 search API 同时支持 POST 请求：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_search</span><br><span class="line">&#123;</span><br><span class="line">  "from": 30,</span><br><span class="line">  "size": 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的规则可以应用于任何需要带请求体的 GET API。</p>
<p>相对于使用晦涩难懂的查询字符串的方式，一个带请求体的查询允许我们使用 查询领域特定语言（query domain-specific language） 或者 Query DSL 来写查询语句。</p>
<h2 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h2><p>Elasticsearch 使用查询表达式(Query DSL)可以以简单的 JSON 接口来展现 Lucene 功能的绝大部分。在你的应用中，你应该用它来编写你的查询语句。它可以使你的查询语句更灵活、更精确、易读和易调试。</p>
<p>要使用这种查询表达式，只需将查询语句传递给 query 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: YOUR_QUERY_HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>空查询（empty search） —{}— 在功能上等价于使用 match_all 查询， 正如其名字一样，匹配所有文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查询语句的结构<br>一个查询语句 的典型结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QUERY_NAME: &#123;</span><br><span class="line">        ARGUMENT: VALUE,</span><br><span class="line">        ARGUMENT: VALUE,...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是针对某个字段，那么它的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QUERY_NAME: &#123;</span><br><span class="line">        FIELD_NAME: &#123;</span><br><span class="line">            ARGUMENT: VALUE,</span><br><span class="line">            ARGUMENT: VALUE,...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举个例子，你可以使用 match 查询语句 来查询 tweet 字段中包含 elasticsearch 的 tweet：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">        &quot;tweet&quot;: &quot;elasticsearch&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的查询请求如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;tweet&quot;: &quot;elasticsearch&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="合并查询语句"><a href="#合并查询语句" class="headerlink" title="合并查询语句"></a>合并查询语句</h2><p>查询语句(Query clauses) 就像一些简单的组合块 ，这些组合块可以彼此之间合并组成更复杂的查询。这些语句可以是如下形式：<br>.叶子语句（Leaf clauses） (就像 match 语句) 被用于将查询字符串和一个字段（或者多个字段）对比。<br>.复合(Compound) 语句 主要用于 合并其它查询语句。 比如，一个 bool 语句 允许在你需要的时候组合其它语句，无论是 must 匹配、 must_not 匹配还是 should 匹配，同时它可以包含不评分的过滤器（filters）：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"elasticsearch"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>:  <span class="string">"mary"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"full text"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:   &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"age"</span> : &#123; <span class="attr">"gt"</span> : <span class="number">30</span> &#125;&#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一条复合语句可以合并 任何 其它查询语句，包括复合语句，了解这一点是很重要的。这就意味着，复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。</p>
<p>例如，以下查询是为了找出信件正文包含 business opportunity 的星标邮件，或者在收件箱正文包含 business opportunity 的非垃圾邮件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>: &#123; <span class="attr">"match"</span>:   &#123; <span class="attr">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>:       &#123; <span class="attr">"starred"</span>: <span class="literal">true</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                <span class="attr">"must"</span>:      &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</span><br><span class="line">                <span class="attr">"must_not"</span>:  &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"spam"</span>: <span class="literal">true</span> &#125;&#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"minimum_should_match"</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h2><p>Elasticsearch 使用的查询语言（DSL） 拥有一套查询组件，这些组件可以以无限组合的方式进行搭配。这套组件可以在以下两种情况下使用：过滤情况（filtering context）和查询情况（query context）。</p>
<p>当使用于 过滤情况 时，查询被设置成一个“不评分”或者“过滤”查询。即，这个查询只是简单的问一个问题：“这篇文档是否匹配？”。回答也是非常的简单，yes 或者 no ，二者必居其一。</p>
<p>当使用于 查询情况 时，查询就变成了一个“评分”的查询。和不评分的查询类似，也要去判断这个文档是否匹配，同时它还需要判断这个文档匹配的有 _多好_（匹配程度如何）。</p>
<p>一个评分查询计算每一个文档与此查询的 <em>相关程度</em>，同时将这个相关程度分配给表示相关性的字段 <code>_score</code>，并且按照相关性对匹配到的文档进行排序。这种相关性的概念是非常适合全文搜索的情况，因为全文搜索几乎没有完全 “正确” 的答案。</p>
<p>注：<br>自 Elasticsearch 问世以来，查询与过滤（queries and filters）就独自成为 Elasticsearch 的组件。但从 Elasticsearch 2.0 开始，过滤（filters）已经从技术上被排除了，同时所有的查询（queries）拥有变成不评分查询的能力。</p>
<p>然而，为了明确和简单，我们用 “filter” 这个词表示不评分、只过滤情况下的查询。你可以把 “filter” 、 “filtering query” 和 “non-scoring query” 这几个词视为相同的。</p>
<p>相似的，如果单独地不加任何修饰词地使用 “query” 这个词，我们指的是 “scoring query” 。</p>
<h2 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h2><p>过滤查询（Filtering queries）只是简单的检查包含或者排除，这就使得计算起来非常快。考虑到至少有一个过滤查询（filtering query）的结果是 “稀少的”（很少匹配的文档），并且经常使用不评分查询（non-scoring queries），结果会被缓存到内存中以便快速读取，所以有各种各样的手段来优化查询结果。</p>
<p>相反，评分查询（scoring queries）不仅仅要找出 匹配的文档，还要计算每个匹配文档的相关性，计算相关性使得它们比不评分查询费力的多。同时，查询结果并不缓存。</p>
<p>多亏倒排索引（inverted index），一个简单的评分查询在匹配少量文档时可能与一个涵盖百万文档的filter表现的一样好，甚至会更好。但是在一般情况下，一个filter 会比一个评分的query性能更优异，并且每次都表现的很稳定。</p>
<p>过滤（filtering）的目标是减少那些需要通过评分查询（scoring queries）进行检查的文档。</p>
<h2 id="如何选择查询与过滤"><a href="#如何选择查询与过滤" class="headerlink" title="如何选择查询与过滤"></a>如何选择查询与过滤</h2><p>通常的规则是，使用 查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)。</p>
<h1 id="最重要的查询"><a href="#最重要的查询" class="headerlink" title="最重要的查询"></a>最重要的查询</h1><p>虽然 Elasticsearch 自带了很多的查询，但经常用到的也就那么几个。</p>
<h2 id="match-all-查询"><a href="#match-all-查询" class="headerlink" title="match_all 查询"></a>match_all 查询</h2><p>match_all 查询简单的 匹配所有文档。在没有指定查询方式时，它是默认的查询：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"match_all"</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="match-查询"><a href="#match-查询" class="headerlink" title="match 查询"></a>match 查询</h2><p>无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。</p>
<p>如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"About Search"</span> &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"age"</span>:    <span class="number">26</span>           &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"date"</span>:   <span class="string">"2014-09-01"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"public"</span>: <span class="literal">true</span>         &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:    <span class="string">"full_text"</span>  &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：对于精确值的查询，你可能需要使用 filter 语句来取代 query，因为 filter 将会被缓存。接下来，我们将看到一些关于 filter 的例子。</p>
<p>不像我们在 轻量 搜索 章节介绍的字符串查询（query-string search）， match 查询不使用类似 +user_id:2 +tweet:search 的查询语法。它只是去查找给定的单词。这就意味着将查询字段暴露给你的用户是安全的；你需要控制那些允许被查询字段，不易于抛出语法异常。</p>
<h2 id="multi-match-查询"><a href="#multi-match-查询" class="headerlink" title="multi_match 查询"></a>multi_match 查询</h2><p>multi_match 查询可以在多个字段上执行相同的 match 查询：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>:    <span class="string">"full text search"</span>,</span><br><span class="line">        <span class="attr">"fields"</span>:   [ <span class="string">"title"</span>, <span class="string">"body"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="range-查询"><a href="#range-查询" class="headerlink" title="range 查询"></a>range 查询</h2><p>range 查询找出那些落在指定区间内的数字或者时间：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">        <span class="attr">"age"</span>: &#123;</span><br><span class="line">            <span class="attr">"gte"</span>:  <span class="number">20</span>,</span><br><span class="line">            <span class="attr">"lt"</span>:   <span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被允许的操作符如下：<br>gt<br>   大于<br>gte<br>   大于等于<br>lt<br>   小于<br>lte<br>   小于等于</p>
<h2 id="term-查询"><a href="#term-查询" class="headerlink" title="term 查询"></a>term 查询</h2><p>term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"age"</span>:    <span class="number">26</span>           &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"date"</span>:   <span class="string">"2014-09-01"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"public"</span>: <span class="literal">true</span>         &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"tag"</span>:    <span class="string">"full_text"</span>  &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>term 查询对于输入的文本不 分析 ，所以它将给定的值进行精确查询。</p>
<h2 id="terms-查询"><a href="#terms-查询" class="headerlink" title="terms 查询"></a>terms 查询</h2><p>terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"terms"</span>: &#123; <span class="attr">"tag"</span>: [ <span class="string">"search"</span>, <span class="string">"full_text"</span>, <span class="string">"nosql"</span> ] &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>和 term 查询一样，terms 查询对于输入的文本不分析。它查询那些精确匹配的值（包括在大小写、重音、空格等方面的差异）。</p>
<h2 id="exists-查询和-missing-查询"><a href="#exists-查询和-missing-查询" class="headerlink" title="exists 查询和 missing 查询"></a>exists 查询和 missing 查询</h2><p>exists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"exists"</span>:   &#123;</span><br><span class="line">        <span class="attr">"field"</span>:    <span class="string">"title"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些查询经常用于某个字段有值的情况和某个字段缺值的情况。</p>
<h1 id="组合多查询"><a href="#组合多查询" class="headerlink" title="组合多查询"></a>组合多查询</h1><p>现实的查询需求从来都没有那么简单；它们需要在多个字段上查询多种多样的文本，并且根据一系列的标准来过滤。为了构建类似的高级查询，你需要一种能够将多查询组合成单一查询的查询方法。</p>
<p>你可以用 bool 查询来实现你的需求。这种查询将多查询组合在一起，成为用户自己想要的布尔查询。它接收以下参数：</p>
<p>must<br>   文档 必须 匹配这些条件才能被包含进来。<br>must_not<br>   文档 必须不 匹配这些条件才能被包含进来。<br>should<br>   如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。<br>filter<br>   必须 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</p>
<p>由于这是我们看到的第一个包含多个查询的查询，所以有必要讨论一下相关性得分是如何组合的。每一个子查询都独自地计算文档的相关性得分。一旦他们的得分被计算出来， bool 查询就将这些得分进行合并并且返回一个代表整个布尔操作的得分。</p>
<p>下面的查询用于查找 title 字段匹配 how to make millions 并且不被标识为 spam 的文档。那些被标识为 starred 或在2014之后的文档，将比另外那些文档拥有更高的排名。如果 _两者_ 都满足，那么它排名将更高：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有 must 语句，那么至少需要能够匹配其中的一条 should 语句。但，如果存在至少一条 must 语句，则对 should 语句的匹配没有要求。</p>
<h2 id="增加带过滤器（filtering）的查询"><a href="#增加带过滤器（filtering）的查询" class="headerlink" title="增加带过滤器（filtering）的查询"></a>增加带过滤器（filtering）的查询</h2><p>如果我们不想因为文档的时间而影响得分，可以用 filter 语句来重写前面的例子：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>range 查询已经从 should 语句中移到 filter 语句</p>
<p>通过将 range 查询移到 filter 语句中，我们将它转成不评分的查询，将不再影响文档的相关性排名。由于它现在是一个不评分的查询，可以使用各种对 filter 查询有效的优化手段来提升性能。</p>
<p>所有查询都可以借鉴这种方式。将查询移到 bool 查询的 filter 语句中，这样它就自动的转成一个不评分的 filter 了。</p>
<p>如果你需要通过多个不同的标准来过滤你的文档，bool 查询本身也可以被用做不评分的查询。简单地将它放置到 filter 语句中并在内部构建布尔逻辑：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123; </span><br><span class="line">              <span class="attr">"must"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;,</span><br><span class="line">                  &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"price"</span>: &#123; <span class="attr">"lte"</span>: <span class="number">29.99</span> &#125;&#125;&#125;</span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">"must_not"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"category"</span>: <span class="string">"ebooks"</span> &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注 将 bool 查询包裹在 filter 语句中，我们可以在过滤标准中增加布尔逻辑</p>
<p>通过混合布尔查询，我们可以在我们的查询请求中灵活地编写 scoring 和 filtering 查询逻辑。</p>
<h2 id="constant-score-查询"><a href="#constant-score-查询" class="headerlink" title="constant_score 查询"></a>constant_score 查询</h2><p>尽管没有 bool 查询使用这么频繁，constant_score 查询也是你工具箱里有用的查询工具。它将一个不变的常量评分应用于所有匹配的文档。它被经常用于你只需要执行一个 filter 而没有其它查询（例如，评分查询）的情况下。</p>
<p>可以使用它来取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"constant_score"</span>:   &#123;</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123; <span class="attr">"category"</span>: <span class="string">"ebooks"</span> &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：term 查询被放置在 constant_score 中，转成不评分的 filter。这种方式可以用来取代只有 filter 语句的 bool 查询。</p>
<h2 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h2><p>查询可以变得非常的复杂，尤其 和不同的分析器与不同的字段映射结合时，理解起来就有点困难了。不过 validate-query API 可以用来验证查询是否合法。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/tweet/_validate/query</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"tweet"</span> : &#123;</span><br><span class="line">         <span class="string">"match"</span> : <span class="string">"really powerful"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上 validate 请求的应答告诉我们这个查询是不合法的：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"valid"</span> :         <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> :       <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successful"</span> :  <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span> :      <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="理解错误信息"><a href="#理解错误信息" class="headerlink" title="理解错误信息"></a>理解错误信息</h2><p>为了找出 查询不合法的原因，可以将 explain 参数 加到查询字符串中：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/tweet/_validate/query?explain </span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"tweet"</span> : &#123;</span><br><span class="line">         <span class="string">"match"</span> : <span class="string">"really powerful"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，我们将查询类型(match)与字段名称 (tweet)搞混了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"valid"</span> :     <span class="literal">false</span>,</span><br><span class="line">  "_shards" :   &#123; ... &#125;,</span><br><span class="line">  "explanations" : [ &#123;</span><br><span class="line">    "index" :   "gb",</span><br><span class="line">    "valid" :   false,</span><br><span class="line">    "error" :   "org.elasticsearch.index.query.QueryParsingException:</span><br><span class="line">                 [gb] No query registered for [tweet]"</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="理解查询语句"><a href="#理解查询语句" class="headerlink" title="理解查询语句"></a>理解查询语句</h2><p>对于合法查询，使用 explain 参数将返回可读的描述，这对准确理解 Elasticsearch 是如何解析你的 query 是非常有用的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"match"</span> : &#123;</span><br><span class="line">         <span class="string">"tweet"</span> : <span class="string">"really powerful"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们查询的每一个 index 都会返回对应的 explanation ，因为每一个 index 都有自己的映射和分析器：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"valid"</span> :         <span class="literal">true</span>,</span><br><span class="line">  "_shards" :       &#123; ... &#125;,</span><br><span class="line">  "explanations" : [ &#123;</span><br><span class="line">    "index" :       "us",</span><br><span class="line">    "valid" :       true,</span><br><span class="line">    "explanation" : "tweet:really tweet:powerful"</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    "index" :       "gb",</span><br><span class="line">    "valid" :       true,</span><br><span class="line">    "explanation" : "tweet:realli tweet:power"</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从 explanation 中可以看出，匹配 really powerful 的 match 查询被重写为两个针对 tweet 字段的 single-term 查询，一个single-term查询对应查询字符串分出来的一个term。</p>
<p>当然，对于索引 us ，这两个 term 分别是 really 和 powerful ，而对于索引 gb ，term 则分别是 realli 和 power 。之所以出现这个情况，是由于我们将索引 gb 中 tweet 字段的分析器修改为 english 分析器。</p>
<h1 id="排序与相关性"><a href="#排序与相关性" class="headerlink" title="排序与相关性"></a>排序与相关性</h1><p>默认情况下，返回的结果是按照 相关性 进行排序的——最相关的文档排在最前。 在本章的后面部分，我们会解释 相关性 意味着什么以及它是如何计算的， 不过让我们首先看看 sort 参数以及如何使用它。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>为了按照相关性来排序，需要将相关性表示为一个数值。在 Elasticsearch 中， 相关性得分 由一个浮点数进行表示，并在搜索结果中通过 _score 参数返回， 默认排序是 _score 降序。</p>
<p>有时，相关性评分对你来说并没有意义。例如，下面的查询返回所有 user_id 字段包含 1 的结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"bool"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123;</span><br><span class="line">                    <span class="string">"user_id"</span> : 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里没有一个有意义的分数：因为我们使用的是 filter （过滤），这表明我们只希望获取匹配 user_id: 1 的文档，并没有试图确定这些文档的相关性。 实际上文档将按照随机顺序返回，并且每个文档都会评为零分。</p>
<p>注：如果评分为零对你造成了困扰，你可以使用 constant_score 查询进行替代：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123;</span><br><span class="line">                    <span class="string">"user_id"</span> : 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这将让所有文档应用一个恒定分数（默认为 1 ）。它将执行与前述查询相同的查询，并且所有的文档将像之前一样随机返回，这些文档只是有了一个分数而不是零分。</p>
<h2 id="按照字段的值排序"><a href="#按照字段的值排序" class="headerlink" title="按照字段的值排序"></a>按照字段的值排序</h2><p>在这个案例中，通过时间来对 tweets 进行排序是有意义的，最新的 tweets 排在最前。 我们可以使用 sort 参数进行实现：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"bool"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 1 &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sort"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会注意到结果中的两个不同点：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">"hits" : &#123;</span><br><span class="line">    "total" :           6,</span><br><span class="line">    "max_score" :       null, </span><br><span class="line">    "hits" : [ &#123;</span><br><span class="line">        "_index" :      "us",</span><br><span class="line">        "_type" :       "tweet",</span><br><span class="line">        "_id" :         "14",</span><br><span class="line">        "_score" :      null, </span><br><span class="line">        "_source" :     &#123;</span><br><span class="line">             "date":    "2014-09-24",</span><br><span class="line">             ...</span><br><span class="line">        &#125;,</span><br><span class="line">        "sort" :        [ 1411516800000 ] </span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>_score 不被计算, 因为它并没有用于排序。</p>
<p>date 字段的值表示为自 epoch (January 1, 1970 00:00:00 UTC)以来的毫秒数，通过 sort 字段的值进行返回。</p>
<p>首先我们在每个结果中有一个新的名为 sort 的元素，它包含了我们用于排序的值。 在这个案例中，我们按照 date 进行排序，在内部被索引为 自 epoch 以来的毫秒数 。 long 类型数 1411516800000 等价于日期字符串 2014-09-24 00:00:00 UTC 。</p>
<p>其次 _score 和 max_score 字段都是 null 。 计算 _score 的花销巨大，通常仅用于排序； 我们并不根据相关性排序，所以记录 _score 是没有意义的。如果无论如何你都要计算 _score ， 你可以将 track_scores 参数设置为 true 。</p>
<p>注：一个简便方法是, 你可以 指定一个字段用来排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot;: &quot;number_of_children&quot;</span><br></pre></td></tr></table></figure></p>
<p>字段将会默认升序排序 ，而按照 _score 的值进行降序排序。</p>
<h2 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h2><p>假定我们想要结合使用 date 和 _score 进行查询，并且匹配的结果首先按照日期排序，然后按照相关性排序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"bool"</span> : &#123;</span><br><span class="line">            <span class="string">"must"</span>:   &#123; <span class="string">"match"</span>: &#123; <span class="string">"tweet"</span>: <span class="string">"manage text search"</span> &#125;&#125;,</span><br><span class="line">            <span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sort"</span>: [</span><br><span class="line">        &#123; <span class="string">"date"</span>:   &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="string">"_score"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>排序条件的顺序是很重要的。结果首先按第一个条件排序，仅当结果集的第一个 sort 值完全相同时才会按照第二个条件进行排序，以此类推。</p>
<p>多级排序并不一定包含 _score 。你可以根据一些不同的字段进行排序， 如地理距离或是脚本计算的特定值。</p>
<p>注：Query-string 搜索 也支持自定义排序，可以在查询字符串中使用 sort 参数：<br>GET /_search?sort=date:desc&amp;sort=_score&amp;q=search</p>
<h2 id="多值字段的排序"><a href="#多值字段的排序" class="headerlink" title="多值字段的排序"></a>多值字段的排序</h2><p>一种情形是字段有多个值的排序， 需要记住这些值并没有固有的顺序；一个多值的字段仅仅是多个值的包装，这时应该选择哪个进行排序呢？</p>
<p>对于数字或日期，你可以将多值字段减为单值，这可以通过使用 min 、 max 、 avg 或是 sum 排序模式 。 例如你可以按照每个 date 字段中的最早日期进行排序，通过以下方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"sort": &#123;</span><br><span class="line">    "dates": &#123;</span><br><span class="line">        "order": "asc",</span><br><span class="line">        "mode":  "min"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串排序与多字段"><a href="#字符串排序与多字段" class="headerlink" title="字符串排序与多字段"></a>字符串排序与多字段</h2><p>被解析的字符串字段也是多值字段， 但是很少会按照你想要的方式进行排序。如果你想分析一个字符串，如 fine old art ， 这包含 3 项。我们很可能想要按第一项的字母排序，然后按第二项的字母排序，诸如此类，但是 Elasticsearch 在排序过程中没有这样的信息。</p>
<p>你可以使用 min 和 max 排序模式（默认是 min ），但是这会导致排序以 art 或是 old ，任何一个都不是所希望的。</p>
<p>为了以字符串字段进行排序，这个字段应仅包含一项： 整个 not_analyzed 字符串。 但是我们仍需要 analyzed 字段，这样才能以全文进行查询</p>
<p>一个简单的方法是用两种方式对同一个字符串进行索引，这将在文档中包括两个字段： analyzed 用于搜索， not_analyzed 用于排序</p>
<p>但是保存相同的字符串两次在 _source 字段是浪费空间的。 我们真正想要做的是传递一个 单字段 但是却用两种方式索引它。所有的 _core_field 类型 (strings, numbers, Booleans, dates) 接收一个 fields 参数</p>
<p>该参数允许你转化一个简单的映射如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"tweet": &#123;</span><br><span class="line">    "type":     "string",</span><br><span class="line">    "analyzer": "english"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为一个多字段映射如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"tweet": &#123; </span><br><span class="line">    "type":     "string",</span><br><span class="line">    "analyzer": "english",</span><br><span class="line">    "fields": &#123;</span><br><span class="line">        "raw": &#123; </span><br><span class="line">            "type":  "string",</span><br><span class="line">            "index": "not_analyzed"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tweet 主字段与之前的一样: 是一个 analyzed 全文字段。新的 tweet.raw 子字段是 not_analyzed.</p>
<p>现在，至少只要我们重新索引了我们的数据，使用 tweet 字段用于搜索，tweet.raw 字段用于排序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sort"</span>: <span class="string">"tweet.raw"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以全文 analyzed 字段排序会消耗大量的内存。获取更多信息请看 聚合与分析 。</p>
<h1 id="什么是相关性"><a href="#什么是相关性" class="headerlink" title="什么是相关性?"></a>什么是相关性?</h1><p>每个文档都有相关性评分，用一个正浮点数字段 _score 来表示 。 _score 的评分越高，相关性越高。</p>
<p>查询语句会为每个文档生成一个 _score 字段。评分的计算方式取决于查询类型 不同的查询语句用于不同的目的： fuzzy 查询会计算与关键词的拼写相似程度，terms 查询会计算 找到的内容与关键词组成部分匹配的百分比，但是通常我们说的 relevance 是我们用来计算全文本字段的值相对于全文本检索词相似程度的算法。</p>
<p>Elasticsearch 的相似度算法 被定义为检索词频率/反向文档频率， TF/IDF ，包括以下内容：</p>
<p>检索词频率<br>   检索词在该字段出现的频率？出现频率越高，相关性也越高。 字段中出现过 5 次要比只出现过 1 次的相关性高。<br>反向文档频率<br>   每个检索词在索引中出现的频率？频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。<br>字段长度准则<br>   字段的长度是多少？长度越长，相关性越低。 检索词出现在一个短的 title 要比同样的词出现在一个长的 content 字段权重更大。</p>
<p>单个查询可以联合使用 TF/IDF 和其他方式，比如短语查询中检索词的距离或模糊查询里的检索词相似度。</p>
<p>相关性并不只是全文本检索的专利。也适用于 yes|no 的子句，匹配的子句越多，相关性评分越高。</p>
<p>如果多条查询子句被合并为一条复合查询语句 ，比如 bool 查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
<p>注：我们有一️整章着眼于相关性计算和如何让其配合你的需求 控制相关度。</p>
<h2 id="理解评分标准"><a href="#理解评分标准" class="headerlink" title="理解评分标准"></a>理解评分标准</h2><p>当调试一条复杂的查询语句时， 想要理解 _score 究竟是如何计算是比较困难的。Elasticsearch 在 每个查询语句中都有一个 explain 参数，将 explain 设为 true 就可以得到更详细的信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?explain </span><br><span class="line">&#123;</span><br><span class="line">   "query"   : &#123; "match" : &#123; "tweet" : "honeymoon" &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>explain 参数可以让返回结果添加一个 _score 评分的得来依据。</p>
<p>注：增加一个 explain 参数会为每个匹配到的文档产生一大堆额外内容，但是花时间去理解它是很有意义的。 如果现在看不明白也没关系 — 等你需要的时候再来回顾这一节就行。下面我们来一点点的了解这块知识点。</p>
<p>首先，我们看一下普通查询返回的元数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_index"</span> :      <span class="string">"us"</span>,</span><br><span class="line">    <span class="attr">"_type"</span> :       <span class="string">"tweet"</span>,</span><br><span class="line">    <span class="attr">"_id"</span> :         <span class="string">"12"</span>,</span><br><span class="line">    <span class="attr">"_score"</span> :      <span class="number">0.076713204</span>,</span><br><span class="line">    "_source" :     &#123; ... trimmed ... &#125;,</span><br></pre></td></tr></table></figure></p>
<p>这里加入了该文档来自于哪个节点哪个分片上的信息，这对我们是比较有帮助的，因为词频率和 文档频率是在每个分片中计算出来的，而不是每个索引中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;_shard&quot; :      1,</span><br><span class="line">&quot;_node&quot; :       &quot;mzIVYCsqSWCG_M_ZffSs9Q&quot;,</span><br></pre></td></tr></table></figure></p>
<p>然后它提供了 _explanation 。每个 入口都包含一个 description 、 value 、 details 字段，它分别告诉你计算的类型、计算结果和任何我们需要的计算细节。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">"_explanation": &#123; (1)</span><br><span class="line">   "description": "weight(tweet:honeymoon in 0)</span><br><span class="line">                  [PerFieldSimilarity], result of:",</span><br><span class="line">   "value":       0.076713204,</span><br><span class="line">   "details": [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"description"</span>: <span class="string">"fieldWeight in 0, product of:"</span>,</span><br><span class="line">         <span class="attr">"value"</span>:       <span class="number">0.076713204</span>,</span><br><span class="line">         <span class="attr">"details"</span>: [</span><br><span class="line">            &#123; (2)</span><br><span class="line">               "description": "tf(freq=1.0), with freq of:",</span><br><span class="line">               "value":       1,</span><br><span class="line">               "details": [</span><br><span class="line">                  &#123;</span><br><span class="line">                     <span class="attr">"description"</span>: <span class="string">"termFreq=1.0"</span>,</span><br><span class="line">                     <span class="attr">"value"</span>:       <span class="number">1</span></span><br><span class="line">                  &#125;</span><br><span class="line">               ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123; (3)</span><br><span class="line">               "description": "idf(docFreq=1, maxDocs=1)",</span><br><span class="line">               "value":       0.30685282</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123; (4)</span><br><span class="line">               "description": "fieldNorm(doc=0)",</span><br><span class="line">               "value":        0.25,</span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.honeymoon 相关性评分计算的总结<br>2.检索词频率<br>3.反向文档频率<br>4.字段长度准则</p>
<p>注：输出 explain 结果代价是十分昂贵的，它只能用作调试工具 。千万不要用于生产环境。</p>
<p>第一部分是关于计算的总结。告诉了我们 honeymoon 在 tweet 字段中的检索词频率/反向文档频率或 TF/IDF， （这里的文档 0 是一个内部的 ID，跟我们没有关系，可以忽略。）</p>
<p>然后它提供了权重是如何计算的细节：</p>
<p>检索词频率:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">检索词 `honeymoon` 在这个文档的 `tweet` 字段中的出现次数。</span><br></pre></td></tr></table></figure></p>
<p>反向文档频率:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">检索词 `honeymoon` 在索引上所有文档的 `tweet` 字段中出现的次数。</span><br></pre></td></tr></table></figure></p>
<p>字段长度准则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这个文档中， `tweet` 字段内容的长度 -- 内容越长，值越小。</span><br></pre></td></tr></table></figure></p>
<p>复杂的查询语句解释也非常复杂，但是包含的内容与上面例子大致相同。 通过这段信息我们可以了解搜索结果是如何产生的。</p>
<p>注：JSON 形式的 explain 描述是难以阅读的， 但是转成 YAML 会好很多，只需要在参数中加上 format=yaml 。</p>
<h2 id="理解文档是如何被匹配到的"><a href="#理解文档是如何被匹配到的" class="headerlink" title="理解文档是如何被匹配到的"></a>理解文档是如何被匹配到的</h2><p>当 explain 选项加到某一文档上时， explain api 会帮助你理解为何这个文档会被匹配，更重要的是，一个文档为何没有被匹配。</p>
<p>请求路径为 /index/type/id/_explain ，如下所示：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /us/tweet/12/_explain</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span> : &#123;</span><br><span class="line">      <span class="string">"bool"</span> : &#123;</span><br><span class="line">         <span class="string">"filter"</span> : &#123; <span class="string">"term"</span> :  &#123; <span class="string">"user_id"</span> : 2           &#125;&#125;,</span><br><span class="line">         <span class="string">"must"</span> :  &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> :   <span class="string">"honeymoon"</span> &#125;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不只是我们之前看到的充分解释 ，我们现在有了一个 description 元素，它将告诉我们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;failure to match filter: cache(user_id:[2 TO 2])&quot;</span><br></pre></td></tr></table></figure></p>
<p>也就是说我们的 user_id 过滤子句使该文档不能匹配到。</p>
<h2 id="Doc-Values-介绍"><a href="#Doc-Values-介绍" class="headerlink" title="Doc Values 介绍"></a>Doc Values 介绍</h2><p>当你对一个字段进行排序时，Elasticsearch 需要访问每个匹配到的文档得到相关的值。倒排索引的检索性能是非常快的，但是在字段值排序时却不是理想的结构。</p>
<p>.在搜索的时候，我们能通过搜索关键词快速得到结果集。<br>.当排序的时候，我们需要倒排索引里面某个字段值的集合。换句话说，我们需要 转置 倒排索引。</p>
<p>转置 结构在其他系统中经常被称作 列存储 。实质上，它将所有单字段的值存储在单数据列中，这使得对其进行操作是十分高效的，例如排序。</p>
<p>在 Elasticsearch 中，Doc Values 就是一种列式存储结构，默认情况下每个字段的 Doc Values 都是激活的，Doc Values 是在索引时创建的，当字段索引时，Elasticsearch 为了能够快速检索，会把字段的值加入倒排索引中，同时它也会存储该字段的 <code>Doc Values</code>。</p>
<p>Elasticsearch 中的 Doc Values 常被应用到以下场景：</p>
<p>.对一个字段进行排序<br>.对一个字段进行聚合<br>.某些过滤，比如地理位置过滤<br>.某些与字段相关的脚本计算</p>
<p>因为文档值被序列化到磁盘，我们可以依靠操作系统的帮助来快速访问。当 working set 远小于节点的可用内存，系统会自动将所有的文档值保存在内存中，使得其读写十分高速； 当其远大于可用内存，操作系统会自动把 Doc Values 加载到系统的页缓存中，从而避免了 jvm 堆内存溢出异常。</p>
<p>稍后会深入讨论 <code>Doc Values</code>。现在所有你需要知道的是排序发生在索引时建立的平行数据结构中。</p>
<h1 id="执行分布式检索"><a href="#执行分布式检索" class="headerlink" title="执行分布式检索"></a>执行分布式检索</h1><p>一个 CRUD 操作只对单个文档进行处理，文档的唯一性由 _index, _type, 和 routing values （通常默认是该文档的 _id ）的组合来确定。 这表示我们确切的知道集群中哪个分片含有此文档。</p>
<p>搜索需要一种更加复杂的执行模型因为我们不知道查询会命中哪些文档: 这些文档有可能在集群的任何分片上。 一个搜索请求必须询问我们关注的索引（index or indices）的所有分片的某个副本来确定它们是否含有任何匹配的文档。</p>
<p>但是找到所有的匹配文档仅仅完成事情的一半。 在 search 接口返回一个 page 结果之前，多分片中的结果必须组合成单个排序列表。 为此，搜索被执行成一个两阶段过程，我们称之为 query then fetch 。</p>
<h2 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h2><p>在初始 查询阶段 时， 查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的 <em>优先队列</em>。</p>
<p>一个 优先队列 仅仅是一个存有 top-n 匹配文档的有序列表。优先队列的大小取决于分页参数 from 和 size 。例如，如下搜索请求将需要足够大的优先队列来放入100条文档。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"from"</span>: 90,</span><br><span class="line">    <span class="string">"size"</span>: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个查询阶段的过程如图 图 14 “查询过程分布式搜索” 所示。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/14.jpg" alt="avatar"><br>图 14. 查询过程分布式搜索<br>查询阶段包含以下三个步骤:<br>1.客户端发送一个 search 请求到 Node 3 ， Node 3 会创建一个大小为 from + size 的空优先队列。<br>2.Node 3 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 from + size 的本地有序优先队列中。<br>3.每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 Node 3 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
<p>当一个搜索请求被发送到某个节点时，这个节点就变成了协调节点。 这个节点的任务是广播查询请求到所有相关分片并将它们的响应整合成全局排序后的结果集合，这个结果集合会返回给客户端。</p>
<p>第一步是广播请求到索引中每一个节点的分片拷贝。就像 document GET requests 所描述的， 查询请求可以被某个主分片或某个副本分片处理， 这就是为什么更多的副本（当结合更多的硬件）能够增加搜索吞吐率。 协调节点将在之后的请求中轮询所有的分片拷贝来分摊负载。</p>
<p>每个分片在本地执行查询请求并且创建一个长度为 from + size 的优先队列—也就是说，每个分片创建的结果集足够大，均可以满足全局的搜索请求。 分片返回一个轻量级的结果列表到协调节点，它仅包含文档 ID 集合以及任何排序需要用到的值，例如 _score 。</p>
<p>协调节点将这些分片级的结果合并到自己的有序优先队列里，它代表了全局排序结果集合。至此查询过程结束。</p>
<p>注:一个索引可以由一个或几个主分片组成， 所以一个针对单个索引的搜索请求需要能够把来自多个分片的结果组合起来。 针对 multiple 或者 all 索引的搜索工作方式也是完全一致的–仅仅是包含了更多的分片而已。</p>
<h2 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h2><p>查询阶段标识哪些文档满足 搜索请求，但是我们仍然需要取回这些文档。这是取回阶段的任务, 正如 图 15 “分布式搜索的取回阶段” 所展示的。<br>图 15. 分布式搜索的取回阶段<br><img src="https://mfaying.github.io/images/elasticsearch2.x/15.jpg" alt="avatar"><br>分布式阶段由以下步骤构成：<br>1.协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。<br>2.每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。<br>3.一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
<p>协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { “from”: 90, “size”: 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。</p>
<p>协调节点给持有相关文档的每个分片创建一个 multi-get request ，并发送请求给同样处理查询阶段的分片副本。</p>
<p>分片加载文档体– _source 字段–如果有需要，用元数据和 search snippet highlighting 丰富结果文档。 一旦协调节点接收到所有的结果文档，它就组装这些结果为单个响应返回给客户端。</p>
<p>深分页（Deep Pagination）</p>
<p>先查后取的过程支持用 from 和 size 参数分页，但是这是 有限制的 。 要记住需要传递信息给协调节点的每个分片必须先创建一个 from + size 长度的队列，协调节点需要根据 number_of_shards * (from + size) 排序文档，来找到被包含在 size 里的文档。</p>
<p>取决于你的文档的大小，分片的数量和你使用的硬件，给 10,000 到 50,000 的结果文档深分页（ 1,000 到 5,000 页）是完全可行的。但是使用足够大的 from 值，排序过程可能会变得非常沉重，使用大量的CPU、内存和带宽。因为这个原因，我们强烈建议你不要使用深分页。</p>
<p>实际上， “深分页” 很少符合人的行为。当2到3页过去以后，人会停止翻页，并且改变搜索标准。而不会不知疲倦地一页一页的获取网页直到你的服务崩溃。</p>
<p>如果你 确实 需要从你的集群取回大量的文档，你可以通过用 scroll 查询禁用排序使这个取回行为更有效率，我们会在 later in this chapter 进行讨论。</p>
<h1 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h1><p>有几个 查询参数可以影响搜索过程。</p>
<h2 id="偏好"><a href="#偏好" class="headerlink" title="偏好"></a>偏好</h2><p>偏好这个参数 preference 允许 用来控制由哪些分片或节点来处理搜索请求。 它接受像 _primary, _primary_first, _local, _only_node:xyz, _prefer_node:xyz, 和 _shards:2,3 这样的值, 这些值在 search preference 文档页面被详细解释。</p>
<p>但是最有用的值是某些随机字符串，它可以避免 bouncing results 问题。</p>
<p>Bouncing Results</p>
<p>想象一下有两个文档有同样值的时间戳字段，搜索结果用 timestamp 字段来排序。 由于搜索请求是在所有有效的分片副本间轮询的，那就有可能发生主分片处理请求时，这两个文档是一种顺序， 而副本分片处理请求时又是另一种顺序。</p>
<p>这就是所谓的 bouncing results 问题: 每次用户刷新页面，搜索结果表现是不同的顺序。 让同一个用户始终使用同一个分片，这样可以避免这种问题， 可以设置 preference 参数为一个特定的任意值比如用户会话ID来解决。</p>
<h2 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h2><p>通常分片处理完它所有的数据后再把结果返回给协同节点，协同节点把收到的所有结果合并为最终结果。</p>
<p>这意味着花费的时间是最慢分片的处理时间加结果合并的时间。如果有一个节点有问题，就会导致所有的响应缓慢。</p>
<p>参数 timeout 告诉 分片允许处理数据的最大时间。如果没有足够的时间处理所有数据，这个分片的结果可以是部分的，甚至是空数据。</p>
<p>搜索的返回结果会用属性 timed_out 标明分片是否返回的是部分结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">"timed_out"</span>:     <span class="literal">true</span>,  (1)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>(1)这个搜索请求超时了。</p>
<p>超时仍然是一个最有效的操作，知道这一点很重要； 很可能查询会超过设定的超时时间。这种行为有两个原因：<br>1.超时检查是基于每文档做的。 但是某些查询类型有大量的工作在文档评估之前需要完成。 这种 “setup” 阶段并不考虑超时设置，所以太长的建立时间会导致超过超时时间的整体延迟。<br>2.因为时间检查是基于每个文档的，一次长时间查询在单个文档上执行并且在下个文档被评估之前不会超时。 这也意味着差的脚本（比如带无限循环的脚本）将会永远执行下去。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在 路由一个文档到一个分片中 中, 我们解释过如何定制参数 routing ，它能够在索引时提供来确保相关的文档，比如属于某个用户的文档被存储在某个分片上。 在搜索的时候，不用搜索索引的所有分片，而是通过指定几个 routing 值来限定只搜索几个相关的分片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?routing=user_1,user2</span><br></pre></td></tr></table></figure></p>
<p>这个技术在设计大规模搜索系统时就会派上用场，我们在 扩容设计 中详细讨论它。</p>
<h2 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h2><p>缺省的搜索类型是 query_then_fetch 。 在某些情况下，你可能想明确设置 search_type 为 dfs_query_then_fetch 来改善相关性精确度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?search_type=dfs_query_then_fetch</span><br></pre></td></tr></table></figure></p>
<p>搜索类型 dfs_query_then_fetch 有预查询阶段，这个阶段可以从所有相关分片获取词频来计算全局词频。 我们在 被破坏的相关度！ 会再讨论它。</p>
<h1 id="游标查询-Scroll"><a href="#游标查询-Scroll" class="headerlink" title="游标查询 Scroll"></a>游标查询 Scroll</h1><p>scroll 查询 可以用来对 Elasticsearch 有效地执行大批量的文档查询，而又不用付出深度分页那种代价。</p>
<p>游标查询允许我们 先做查询初始化，然后再批量地拉取结果。 这有点儿像传统数据库中的 cursor 。</p>
<p>游标查询会取某个时间点的快照数据。 查询初始化之后索引上的任何变化会被它忽略。 它通过保存旧的数据文件来实现这个特性，结果就像保留初始化时的索引 视图 一样。</p>
<p>深度分页的代价根源是结果集全局排序，如果去掉全局排序的特性的话查询结果的成本就会很低。 游标查询用字段 _doc 来排序。 这个指令让 Elasticsearch 仅仅从还有结果的分片返回下一批结果。</p>
<p>启用游标查询可以通过在查询的时候设置参数 scroll 的值为我们期望的游标查询的过期时间。 游标查询的过期时间会在每次做查询的时候刷新，所以这个时间只需要足够处理当前批的结果就可以了，而不是处理查询结果的所有文档的所需时间。 这个过期时间的参数很重要，因为保持这个游标查询窗口需要消耗资源，所以我们期望如果不再需要维护这种资源就该早点儿释放掉。 设置这个超时能够让 Elasticsearch 在稍后空闲的时候自动释放这部分资源。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /old_index/_search?scroll=1m (1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123; <span class="string">"match_all"</span>: &#123;&#125;&#125;,</span><br><span class="line">    <span class="string">"sort"</span> : [<span class="string">"_doc"</span>], (2)</span><br><span class="line">    <span class="string">"size"</span>:  1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) 保持游标查询窗口一分钟。<br>(2) 关键字 _doc 是最有效的排序顺序。</p>
<p>这个查询的返回结果包括一个字段 _scroll_id<code>， 它是一个base64编码的长字符串 (((&quot;scroll_id&quot;))) 。 现在我们能传递字段</code>_scroll_id 到 _search/scroll 查询接口获取下一批结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scroll"</span>: <span class="string">"1m"</span>, (1)</span><br><span class="line">    <span class="string">"scroll_id"</span> : <span class="string">"cXVlcnlUaGVuRmV0Y2g7NTsxMDk5NDpkUmpiR2FjOFNhNnlCM1ZDMWpWYnRROzEwOTk1OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MTA5OTM6ZFJqYkdhYzhTYTZ5QjNWQzFqVmJ0UTsxMTE5MDpBVUtwN2lxc1FLZV8yRGVjWlI2QUVBOzEwOTk2OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MDs="</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 注意再次设置游标查询过期时间为一分钟。</p>
<p>这个游标查询返回的下一批结果。 尽管我们指定字段 size 的值为1000，我们有可能取到超过这个值数量的文档。 当查询的时候， 字段 size 作用于单个分片，所以每个批次实际返回的文档数量最大为 size * number_of_primary_shards 。</p>
<p>注意游标查询每次返回一个新字段 _scroll_id<code>。每次我们做下一次游标查询， 我们必须把前一次查询返回的字段</code>_scroll_id 传递进去。 当没有更多的结果返回的时候，我们就处理完所有匹配的文档了。</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><p>要不了多久你就会开始想要优化索引和搜索过程，以便更好地适合您的特定用例。 这些定制几乎围绕着索引和类型的方方面面，在本章，我们将介绍管理索引和类型映射的 API 以及一些最重要的设置。</p>
<h2 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h2><p>到目前为止, 我们已经通过索引一篇文档创建了一个新的索引 。这个索引采用的是默认的配置，新的字段通过动态映射的方式被添加到类型映射。现在我们需要对这个建立索引的过程做更多的控制：我们想要确保这个索引有数量适中的主分片，并且在我们索引任何数据 之前 ，分析器和映射已经被建立好。</p>
<p>为了达到这个目的，我们需要手动创建索引，在请求体里面传入设置或类型映射，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123; ... any settings ... &#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;type_one&quot;: &#123; ... any mappings ... &#125;,</span><br><span class="line">        &quot;type_two&quot;: &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你想禁止自动创建索引，你 可以通过在 config/elasticsearch.yml 的每个节点下添加下面的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.auto_create_index: false</span><br></pre></td></tr></table></figure></p>
<p>我们会在之后讨论你怎么用 索引模板 来预配置开启自动创建索引。这在索引日志数据的时候尤其有用：你将日志数据索引在一个以日期结尾命名的索引上，子夜时分，一个预配置的新索引将会自动进行创建。</p>
<h2 id="删除一个索引"><a href="#删除一个索引" class="headerlink" title="删除一个索引"></a>删除一个索引</h2><p>用以下的请求来 删除索引:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /my_index</span><br></pre></td></tr></table></figure></p>
<p>你也可以这样删除多个索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE /index_one,index_two</span><br><span class="line">DELETE /index_*</span><br></pre></td></tr></table></figure></p>
<p>你甚至可以这样删除 全部 索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE /_all</span><br><span class="line">DELETE /*</span><br></pre></td></tr></table></figure></p>
<p>能够用单个命令来删除所有数据可能会导致可怕的后果。如果你想要避免意外的大量删除, 你可以在你的 elasticsearch.yml 做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.destructive_requires_name: true</span><br></pre></td></tr></table></figure></p>
<p>这个设置使删除只限于特定名称指向的数据, 而不允许通过指定 _all 或通配符来删除指定索引库。你同样可以通过 Cluster State API 动态的更新这个设置。</p>
<h2 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h2><p>你可以通过修改配置来自定义索引行为，详细配置参照 索引模块<br>Elasticsearch 提供了优化好的默认配置。 除非你理解这些配置的作用并且知道为什么要去修改，否则不要随意修改。<br>下面是两个 最重要的设置：<br>number_of_shards<br>   每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。<br>number_of_replicas<br>   每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。<br>例如，我们可以创建只有 一个主分片，没有副本的小索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_temp_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot; :   1,</span><br><span class="line">        &quot;number_of_replicas&quot; : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以用 update-index-settings API 动态修改副本数：<br>PUT /my_temp_index/_settings<br>{<br>    “number_of_replicas”: 1<br>}</p>
<h2 id="配置分析器"><a href="#配置分析器" class="headerlink" title="配置分析器"></a>配置分析器</h2><p>第三个重要的索引设置是 analysis 部分， 用来配置已存在的分析器或针对你的索引创建新的自定义分析器。<br>在 分析与分析器 ，我们介绍了一些内置的 分析器，用于将全文字符串转换为适合搜索的倒排索引。<br>standard 分析器是用于全文字段的默认分析器， 对于大部分西方语系来说是一个不错的选择。 它包括了以下几点：</p>
<p>1.standard 分词器，通过单词边界分割输入的文本。<br>2.standard 语汇单元过滤器，目的是整理分词器触发的语汇单元（但是目前什么都没做）。<br>3.lowercase 语汇单元过滤器，转换所有的语汇单元为小写。<br>4.stop 语汇单元过滤器，删除停用词–对搜索相关性影响不大的常用词，如 a ， the ， and ， is 。</p>
<p>默认情况下，停用词过滤器是被禁用的。如需启用它，你可以通过创建一个基于 standard 分析器的自定义分析器并设置 stopwords 参数。 可以给分析器提供一个停用词列表，或者告知使用一个基于特定语言的预定义停用词列表。</p>
<p>在下面的例子中，我们创建了一个新的分析器，叫做 es_std ， 并使用预定义的 西班牙语停用词列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /spanish_docs</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;analysis&quot;: &#123;</span><br><span class="line">            &quot;analyzer&quot;: &#123;</span><br><span class="line">                &quot;es_std&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;:      &quot;standard&quot;,</span><br><span class="line">                    &quot;stopwords&quot;: &quot;_spanish_&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>es_std 分析器不是全局的–它仅仅存在于我们定义的 spanish_docs 索引中。 为了使用 analyze API来对它进行测试，我们必须使用特定的索引名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /spanish_docs/_analyze?analyzer=es_std</span><br><span class="line">El veloz zorro marrón</span><br></pre></td></tr></table></figure></p>
<p>简化的结果显示西班牙语停用词 El 已被正确的移除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123; &quot;token&quot; :    &quot;veloz&quot;,   &quot;position&quot; : 2 &#125;,</span><br><span class="line">    &#123; &quot;token&quot; :    &quot;zorro&quot;,   &quot;position&quot; : 3 &#125;,</span><br><span class="line">    &#123; &quot;token&quot; :    &quot;marrón&quot;,  &quot;position&quot; : 4 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h2><p>你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。</p>
<p>在 分析与分析器 我们说过，一个 分析器 就是在一个包里面组合了三种函数的一个包装器， 三种函数按照顺序被执行:<br>字符过滤器<br>字符过滤器 用来 整理 一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像 </p><p> 或者 <div> 这样的HTML标签，这些标签是我们不想索引的。我们可以使用 html清除 字符过滤器 来移除掉所有的HTML标签，并且像把 &Aacute; 转换为相对应的Unicode字符 Á 这样，转换HTML实体。</div></p>
<p>一个分析器可能有0个或者多个字符过滤器。</p>
<p>分词器<br>一个分析器 必须 有一个唯一的分词器。 分词器把字符串分解成单个词条或者词汇单元。 标准 分析器里使用的 标准 分词器 把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。</p>
<p>例如， 关键词 分词器 完整地输出 接收到的同样的字符串，并不做任何分词。 空格 分词器 只根据空格分割文本 。 正则 分词器 根据匹配正则表达式来分割文本 。</p>
<p>词单元过滤器<br>经过分词，作为结果的 词单元流 会按照指定的顺序通过指定的词单元过滤器 。</p>
<p>词单元过滤器可以修改、添加或者移除词单元。我们已经提到过 lowercase 和 stop 词过滤器 ，但是在 Elasticsearch 里面还有很多可供选择的词单元过滤器。 词干过滤器 把单词 遏制 为 词干。 ascii_folding 过滤器移除变音符，把一个像 “très” 这样的词转换为 “tres” 。 ngram 和 edge_ngram 词单元过滤器 可以产生 适合用于部分匹配或者自动补全的词单元。</p>
<h2 id="创建一个自定义分析器编辑"><a href="#创建一个自定义分析器编辑" class="headerlink" title="创建一个自定义分析器编辑"></a>创建一个自定义分析器编辑</h2><p>和我们之前配置 es_std 分析器一样，我们可以在 analysis 下的相应位置设置字符过滤器、分词器和词单元过滤器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;analysis&quot;: &#123;</span><br><span class="line">            &quot;char_filter&quot;: &#123; ... custom character filters ... &#125;,</span><br><span class="line">            &quot;tokenizer&quot;:   &#123; ...    custom tokenizers     ... &#125;,</span><br><span class="line">            &quot;filter&quot;:      &#123; ...   custom token filters   ... &#125;,</span><br><span class="line">            &quot;analyzer&quot;:    &#123; ...    custom analyzers      ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作为示范，让我们一起来创建一个自定义分析器吧，这个分析器可以做到下面的这些事:<br>1.使用 html清除 字符过滤器移除HTML部分。<br>2.使用一个自定义的 映射 字符过滤器把 &amp; 替换为 “ and “ ：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"char_filter": &#123;</span><br><span class="line">    "&amp;_to_and": &#123;</span><br><span class="line">        "type":       "mapping",</span><br><span class="line">        "mappings": [ "&amp;=&gt; and "]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.使用 标准 分词器分词。<br>4.小写词条，使用 小写 词过滤器处理。<br>5.使用自定义 停止 词过滤器移除自定义的停止词列表中包含的词：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"filter": &#123;</span><br><span class="line">    "my_stopwords": &#123;</span><br><span class="line">        "type":        "stop",</span><br><span class="line">        "stopwords": [ "the", "a" ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的分析器定义用我们之前已经设置好的自定义过滤器组合了已经定义好的分词器和过滤器：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"analyzer": &#123;</span><br><span class="line">    "my_analyzer": &#123;</span><br><span class="line">        "type":           "custom",</span><br><span class="line">        "char_filter":  [ "html_strip", "&amp;_to_and" ],</span><br><span class="line">        "tokenizer":      "standard",</span><br><span class="line">        "filter":       [ "lowercase", "my_stopwords" ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>汇总起来，完整的 创建索引 请求 看起来应该像这样：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="string">"&amp;_to_and"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:       <span class="string">"mapping"</span>,</span><br><span class="line">                    <span class="string">"mappings"</span>: [ <span class="string">"&amp;=&gt; and "</span>]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"my_stopwords"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:       <span class="string">"stop"</span>,</span><br><span class="line">                    <span class="string">"stopwords"</span>: [ <span class="string">"the"</span>, <span class="string">"a"</span> ]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:         <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="string">"char_filter"</span>:  [ <span class="string">"html_strip"</span>, <span class="string">"&amp;_to_and"</span> ],</span><br><span class="line">                    <span class="string">"tokenizer"</span>:    <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"filter"</span>:       [ <span class="string">"lowercase"</span>, <span class="string">"my_stopwords"</span> ]</span><br><span class="line">            &#125;&#125;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>索引被创建以后，使用 analyze API 来 测试这个新的分析器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_analyzer</span><br><span class="line">The quick &amp; brown fox</span><br></pre></td></tr></table></figure></p>
<p>下面的缩略结果展示出我们的分析器正在正确地运行：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"quick"</span>,    <span class="attr">"position"</span> : <span class="number">2</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"and"</span>,      <span class="attr">"position"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"brown"</span>,    <span class="attr">"position"</span> : <span class="number">4</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"fox"</span>,      <span class="attr">"position"</span> : <span class="number">5</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个分析器现在是没有多大用处的，除非我们告诉 Elasticsearch在哪里用上它。我们可以像下面这样把这个分析器应用在一个 string 字段上：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"properties"</span>: &#123;</span><br><span class="line">        <span class="string">"title"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>:      <span class="string">"string"</span>,</span><br><span class="line">            <span class="string">"analyzer"</span>:  <span class="string">"my_analyzer"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型和映射"><a href="#类型和映射" class="headerlink" title="类型和映射"></a>类型和映射</h2><p>类型 在 Elasticsearch 中表示一类相似的文档。 类型由 名称 —比如 user 或 blogpost —和 映射 组成。</p>
<p>映射, 就像数据库中的 schema ，描述了文档可能具有的字段或 属性 、 每个字段的数据类型—比如 string, integer 或 date —以及Lucene是如何索引和存储这些字段的。</p>
<p>类型可以很好的抽象划分相似但不相同的数据。但由于 Lucene 的处理方式，类型的使用有些限制。</p>
<h2 id="Lucene-如何处理文档编辑"><a href="#Lucene-如何处理文档编辑" class="headerlink" title="Lucene 如何处理文档编辑"></a>Lucene 如何处理文档编辑</h2><p>在 Lucene 中，一个文档由一组简单的键值对组成。 每个字段都可以有多个值，但至少要有一个值。 类似的，一个字符串可以通过分析过程转化为多个值。Lucene 不关心这些值是字符串、数字或日期–所有的值都被当做 不透明字节 。</p>
<p>当我们在 Lucene 中索引一个文档时，每个字段的值都被添加到相关字段的倒排索引中。你也可以将未处理的原始数据 存储 起来，以便这些原始数据在之后也可以被检索到。</p>
<h2 id="类型是如何实现的"><a href="#类型是如何实现的" class="headerlink" title="类型是如何实现的"></a>类型是如何实现的</h2><p>Elasticsearch 类型是 以 Lucene 处理文档的这个方式为基础来实现的。一个索引可以有多个类型，这些类型的文档可以存储在相同的索引中。</p>
<p>Lucene 没有文档类型的概念，每个文档的类型名被存储在一个叫 _type 的元数据字段上。 当我们要检索某个类型的文档时, Elasticsearch 通过在 _type 字段上使用过滤器限制只返回这个类型的文档。</p>
<p>Lucene 也没有映射的概念。 映射是 Elasticsearch 将复杂 JSON 文档 映射 成 Lucene 需要的扁平化数据的方式。</p>
<p>例如，在 user 类型中， name 字段的映射可以声明这个字段是 string 类型，并且它的值被索引到名叫 name 的倒排索引之前，需要通过 whitespace 分词器分析：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"name": &#123;</span><br><span class="line">    "type":     "string",</span><br><span class="line">    "analyzer": "whitespace"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="避免类型陷阱"><a href="#避免类型陷阱" class="headerlink" title="避免类型陷阱"></a>避免类型陷阱</h2><p>这导致了一个有趣的思想实验： 如果有两个不同的类型，每个类型都有同名的字段，但映射不同（例如：一个是字符串一个是数字），将会出现什么情况？</p>
<p>简单回答是，Elasticsearch 不会允许你定义这个映射。当你配置这个映射时，将会出现异常。</p>
<p>详细回答是，每个 Lucene 索引中的所有字段都包含一个单一的、扁平的模式。一个特定字段可以映射成 string 类型也可以是 number 类型，但是不能两者兼具。因为类型是 Elasticsearch 添加的 优于 Lucene 的额外机制（以元数据 _type 字段的形式），在 Elasticsearch 中的所有类型最终都共享相同的映射。</p>
<p>以 data 索引中两种类型的映射为例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">         <span class="attr">"people"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"address"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"transactions"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"timestamp"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">                  <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"message"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个类型定义两个字段 (分别是 “name”/“address” 和 “timestamp”/“message” )。它们看起来是相互独立的，但在后台 Lucene 将创建一个映射，如:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"_type"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"address"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"timestamp"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"message"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注: 这不是真实有效的映射语法，只是用于演示</p>
<p>对于整个索引，映射在本质上被 扁平化 成一个单一的、全局的模式。这就是为什么两个类型不能定义冲突的字段：当映射被扁平化时，Lucene 不知道如何去处理。</p>
<h2 id="类型结论"><a href="#类型结论" class="headerlink" title="类型结论"></a>类型结论</h2><p>那么，这个讨论的结论是什么？技术上讲，多个类型可以在相同的索引中存在，只要它们的字段不冲突（要么因为字段是互为独占模式，要么因为它们共享相同的字段）。</p>
<p>重要的一点是: 类型可以很好的区分同一个集合中的不同细分。在不同的细分中数据的整体模式是相同的（或相似的）。</p>
<p>类型不适合 完全不同类型的数据 。如果两个类型的字段集是互不相同的，这就意味着索引中将有一半的数据是空的（字段将是 稀疏的 ），最终将导致性能问题。在这种情况下，最好是使用两个单独的索引。</p>
<p>总结：</p>
<p>1.正确: 将 kitchen 和 lawn-care 类型放在 products 索引中, 因为这两种类型基本上是相同的模式<br>2.错误: 将 products 和 logs 类型放在 data 索引中, 因为这两种类型互不相同。应该将它们放在不同的索引中。</p>
<h2 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h2><p>映射的最高一层被称为 根对象 ，它可能包含下面几项：<br>1.一个 properties 节点，列出了文档中可能包含的每个字段的映射<br>2.各种元数据字段，它们都以一个下划线开头，例如 _type 、 _id 和 _source<br>3.设置项，控制如何动态处理新的字段，例如 analyzer 、 dynamic_date_formats 和 dynamic_templates<br>4.其他设置，可以同时应用在根对象和其他 object 类型的字段上，例如 enabled 、 dynamic 和 include_in_all</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>我们已经在 核心简单域类型 和 复杂核心域类型 章节中介绍过文档字段和属性的三个 最重要的设置：</p>
<p>type<br>字段的数据类型，例如 string 或 date<br>index<br>字段是否应当被当成全文来搜索（ analyzed ），或被当成一个准确的值（ not_analyzed ），还是完全不可被搜索（ no ）<br>analyzer<br>确定在索引和搜索时全文字段使用的 analyzer</p>
<h2 id="元数据-source-字段"><a href="#元数据-source-字段" class="headerlink" title="元数据: _source 字段"></a>元数据: _source 字段</h2><p>默认地，Elasticsearch 在 _source 字段存储代表文档体的JSON字符串。和所有被存储的字段一样， _source 字段在被写入磁盘之前先会被压缩。</p>
<p>这个字段的存储几乎总是我们想要的，因为它意味着下面的这些：</p>
<p>1.搜索结果包括了整个可用的文档——不需要额外的从另一个的数据仓库来取文档。<br>2.如果没有 _source 字段，部分 update 请求不会生效。<br>3.当你的映射改变时，你需要重新索引你的数据，有了_source字段你可以直接从Elasticsearch这样做，而不必从另一个（通常是速度更慢的）数据仓库取回你的所有文档。<br>4.当你不需要看到整个文档时，单个字段可以从 _source 字段提取和通过 get 或者 search 请求返回。<br>5.调试查询语句更加简单，因为你可以直接看到每个文档包括什么，而不是从一列id猜测它们的内容。</p>
<p>然而，存储 _source 字段的确要使用磁盘空间。如果上面的原因对你来说没有一个是重要的，你可以用下面的映射禁用 _source 字段：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"_source"</span>: &#123;</span><br><span class="line">                <span class="string">"enabled"</span>:  <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一个搜索请求里，你可以通过在请求体中指定 _source 参数，来达到只获取特定的字段的效果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>:   &#123; <span class="string">"match_all"</span>: &#123;&#125;&#125;,</span><br><span class="line">    <span class="string">"_source"</span>: [ <span class="string">"title"</span>, <span class="string">"created"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些字段的值会从 _source 字段被提取和返回，而不是返回整个 _source 。</p>
<p>Stored Fields 被存储字段</p>
<p>为了之后的检索，除了索引一个字段的值，你 还可以选择 存储 原始字段值。有 Lucene 使用背景的用户使用被存储字段来选择他们想要在搜索结果里面返回的字段。事实上， _source 字段就是一个被存储的字段。</p>
<p>在Elasticsearch中，对文档的个别字段设置存储的做法通常不是最优的。整个文档已经被存储为 _source 字段。使用 _source 参数提取你需要的字段总是更好的。</p>
<h2 id="元数据-all-字段"><a href="#元数据-all-字段" class="headerlink" title="元数据: _all 字段"></a>元数据: _all 字段</h2><p>在 轻量 搜索 中，我们介绍了 _all 字段：一个把其它字段值 当作一个大字符串来索引的特殊字段。 query_string 查询子句(搜索 ?q=john )在没有指定字段时默认使用 _all 字段。</p>
<p>_all 字段在新应用的探索阶段，当你还不清楚文档的最终结构时是比较有用的。你可以使用这个字段来做任何查询，并且有很大可能找到需要的文档：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">        <span class="string">"_all"</span>: <span class="string">"john smith marketing"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随着应用的发展，搜索需求变得更加明确，你会发现自己越来越少使用 _all 字段。 _all 字段是搜索的应急之策。通过查询指定字段，你的查询更加灵活、强大，你也可以对相关性最高的搜索结果进行更细粒度的控制。</p>
<p>relevance algorithm 考虑的一个最重要的原则是字段的长度：字段越短越重要。 在较短的 title 字段中出现的短语可能比在较长的 content 字段中出现的短语更加重要。字段长度的区别在 _all 字段中不会出现。</p>
<p>如果你不再需要 _all 字段，你可以通过下面的映射来禁用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"my_type"</span>: &#123;</span><br><span class="line">        <span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 include_in_all 设置来逐个控制字段是否要包含在 _all 字段中，默认值是 true<code>。在一个对象(或根对象)上设置</code>include_in_all 可以修改这个对象中的所有字段的默认行为。</p>
<p>你可能想要保留 _all 字段作为一个只包含某些特定字段的全文字段，例如只包含 title<code>，</code>overview<code>，</code>summary 和 tags<code>。 相对于完全禁用</code>_all 字段，你可以为所有字段默认禁用 include_in_all 选项，仅在你选择的字段上启用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"my_type"</span>: &#123;</span><br><span class="line">        <span class="string">"include_in_all"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"properties"</span>: &#123;</span><br><span class="line">            <span class="string">"title"</span>: &#123;</span><br><span class="line">                <span class="string">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                <span class="string">"include_in_all"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>记住，_all 字段仅仅是一个 经过分词的 string 字段。它使用默认分词器来分析它的值，不管这个值原本所在字段指定的分词器。就像所有 string 字段，你可以配置 _all 字段使用的分词器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"my_type"</span>: &#123;</span><br><span class="line">        <span class="string">"_all"</span>: &#123; <span class="string">"analyzer"</span>: <span class="string">"whitespace"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="元数据：文档标识"><a href="#元数据：文档标识" class="headerlink" title="元数据：文档标识"></a>元数据：文档标识</h2><p>文档标识与四个元数据字段 相关：</p>
<p>_id<br>文档的 ID 字符串<br>_type<br>文档的类型名<br>_index<br>文档所在的索引<br>_uid<br>_type 和 _id 连接在一起构造成 type#id<br>默认情况下， _uid 字段是被存储（可取回）和索引（可搜索）的。 _type 字段被索引但是没有存储， _id 和 _index 字段则既没有被索引也没有被存储，这意味着它们并不是真实存在的。</p>
<p>尽管如此，你仍然可以像真实字段一样查询 _id 字段。Elasticsearch 使用 _uid 字段来派生出 _id 。 虽然你可以修改这些字段的 index 和 store 设置，但是基本上不需要这么做。</p>
<h2 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h2><p>当 Elasticsearch 遇到文档中以前 未遇到的字段，它用 dynamic mapping 来确定字段的数据类型并自动把新的字段添加到类型映射。</p>
<p>有时这是想要的行为有时又不希望这样。通常没有人知道以后会有什么新字段加到文档，但是又希望这些字段被自动的索引。也许你只想忽略它们。如果Elasticsearch是作为重要的数据存储，可能就会期望遇到新字段就会抛出异常，这样能及时发现问题。</p>
<p>幸运的是可以用 dynamic 配置来控制这种行为 ，可接受的选项如下：</p>
<p>true<br>   动态添加新的字段–缺省<br>false<br>   忽略新的字段<br>strict<br>   如果遇到新字段抛出异常</p>
<p>配置参数 dynamic 可以用在根 object 或任何 object 类型的字段上。你可以将 dynamic 的默认值设置为 strict , 而只在指定的内部对象中开启它, 例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"dynamic"</span>:      <span class="string">"strict"</span>, (1)</span><br><span class="line">            <span class="string">"properties"</span>: &#123;</span><br><span class="line">                <span class="string">"title"</span>:  &#123; <span class="string">"type"</span>: <span class="string">"string"</span>&#125;,</span><br><span class="line">                <span class="string">"stash"</span>:  &#123;</span><br><span class="line">                    <span class="string">"type"</span>:     <span class="string">"object"</span>,</span><br><span class="line">                    <span class="string">"dynamic"</span>:  <span class="literal">true</span> (2)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.如果遇到新字段，对象 my_type 就会抛出异常。<br>2.而内部对象 stash 遇到新字段就会动态创建新字段。</p>
<p>使用上述动态映射， 你可以给 stash 对象添加新的可检索的字段：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>:   <span class="string">"This doc adds a new field"</span>,</span><br><span class="line">    <span class="string">"stash"</span>: &#123; <span class="string">"new_field"</span>: <span class="string">"Success!"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是对根节点对象 my_type 进行同样的操作会失败：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>:     <span class="string">"This throws a StrictDynamicMappingException"</span>,</span><br><span class="line">    <span class="string">"new_field"</span>: <span class="string">"Fail!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把 dynamic 设置为 false 一点儿也不会改变 _source 的字段内容。 _source 仍然包含被索引的整个JSON文档。只是新的字段不会被加到映射中也不可搜索。</p>
<h1 id="自定义动态映射"><a href="#自定义动态映射" class="headerlink" title="自定义动态映射"></a>自定义动态映射</h1><h2 id="日期检测"><a href="#日期检测" class="headerlink" title="日期检测"></a>日期检测</h2><p>当 Elasticsearch 遇到一个新的字符串字段时，它会检测这个字段是否包含一个可识别的日期，比如 2014-01-01 。 如果它像日期，这个字段就会被作为 date 类型添加。否则，它会被作为 string 类型添加。</p>
<p>有些时候这个行为可能导致一些问题。想象下，你有如下这样的一个文档：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"note"</span>: <span class="string">"2014-01-01"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>假设这是第一次识别 note 字段，它会被添加为 date 字段。但是如果下一个文档像这样：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"note"</span>: <span class="string">"Logged out"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这显然不是一个日期，但为时已晚。这个字段已经是一个日期类型，这个 不合法的日期 将会造成一个异常。</p>
<p>日期检测可以通过在根对象上设置 date_detection 为 false 来关闭：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"date_detection"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这个映射，字符串将始终作为 string 类型。如果你需要一个 date 字段，你必须手动添加。</p>
<p>Elasticsearch 判断字符串为日期的规则可以通过 dynamic_date_formats setting 来设置。</p>
<h2 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h2><p>使用 dynamic_templates ，你可以完全控制 新检测生成字段的映射。你甚至可以通过字段名称或数据类型来应用不同的映射。</p>
<p>每个模板都有一个名称， 你可以用来描述这个模板的用途， 一个 mapping 来指定映射应该怎样使用，以及至少一个参数 (如 match) 来定义这个模板适用于哪个字段。</p>
<p>模板按照顺序来检测；第一个匹配的模板会被启用。例如，我们给 string 类型字段定义两个模板：</p>
<p>es ：以 _es 结尾的字段名需要使用 spanish 分词器。<br>en ：所有其他字段使用 english 分词器。<br>我们将 es 模板放在第一位，因为它比匹配所有字符串字段的 en 模板更特殊：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"dynamic_templates"</span>: [</span><br><span class="line">                &#123; <span class="string">"es"</span>: &#123;</span><br><span class="line">                      <span class="string">"match"</span>:              <span class="string">"*_es"</span>, (1)</span><br><span class="line">                      <span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                      <span class="string">"mapping"</span>: &#123;</span><br><span class="line">                          <span class="string">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                          <span class="string">"analyzer"</span>:       <span class="string">"spanish"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;&#125;,</span><br><span class="line">                &#123; <span class="string">"en"</span>: &#123;</span><br><span class="line">                      <span class="string">"match"</span>:              <span class="string">"*"</span>, (2)</span><br><span class="line">                      <span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                      <span class="string">"mapping"</span>: &#123;</span><br><span class="line">                          <span class="string">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                          <span class="string">"analyzer"</span>:       <span class="string">"english"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)匹配字段名以 _es 结尾的字段。<br>(2)匹配其他所有字符串类型字段。</p>
<p>match_mapping_type 允许你应用模板到特定类型的字段上，就像有标准动态映射规则检测的一样， (例如 string 或 long)。</p>
<p>match 参数只匹配字段名称， path_match 参数匹配字段在对象上的完整路径，所以 address.*.name 将匹配这样的字段：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"address"</span>: &#123;</span><br><span class="line">        <span class="attr">"city"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"New York"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>unmatch 和 path_unmatch将被用于未被匹配的字段。<br>更多的配置选项见 动态映射文档 。</p>
<h1 id="缺省映射"><a href="#缺省映射" class="headerlink" title="缺省映射"></a>缺省映射</h1><p>通常，一个索引中的所有类型共享相同的字段和设置。 <em>default</em> 映射更加方便地指定通用设置，而不是每次创建新类型时都要重复设置。 <em>default</em> 映射是新类型的模板。在设置 <em>default</em> 映射之后创建的所有类型都将应用这些缺省的设置，除非类型在自己的映射中明确覆盖这些设置。</p>
<p>例如，我们可以使用 <em>default</em> 映射为所有的类型禁用 _all 字段， 而只在 blog 类型启用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"_default_"</span>: &#123;</span><br><span class="line">            <span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>:  <span class="literal">false</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"blog"</span>: &#123;</span><br><span class="line">            <span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>:  <span class="literal">true</span>  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>default</em> 映射也是一个指定索引 dynamic templates 的好方法。</p>
<h2 id="重新索引你的数据"><a href="#重新索引你的数据" class="headerlink" title="重新索引你的数据"></a>重新索引你的数据</h2><p>尽管可以增加新的类型到索引中，或者增加新的字段到类型中，但是不能添加新的分析器或者对现有的字段做改动。 如果你那么做的话，结果就是那些已经被索引的数据就不正确， 搜索也不能正常工作。</p>
<p>对现有数据的这类改变最简单的办法就是重新索引：用新的设置创建新的索引并把文档从旧的索引复制到新的索引。</p>
<p>字段 _source 的一个优点是在Elasticsearch中已经有整个文档。你不必从源数据中重建索引，而且那样通常比较慢。</p>
<p>为了有效的重新索引所有在旧的索引中的文档，用 scroll 从旧的索引检索批量文档 ， 然后用 bulk API 把文档推送到新的索引中。</p>
<p>从Elasticsearch v2.3.0开始， Reindex API 被引入。它能够对文档重建索引而不需要任何插件或外部工具。</p>
<p>批量重新索引</p>
<p>同时并行运行多个重建索引任务，但是你显然不希望结果有重叠。正确的做法是按日期或者时间 这样的字段作为过滤条件把大的重建索引分成小的任务：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /old_index/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"range"</span>: &#123;</span><br><span class="line">            <span class="string">"date"</span>: &#123;</span><br><span class="line">                <span class="string">"gte"</span>:  <span class="string">"2014-01-01"</span>,</span><br><span class="line">                <span class="string">"lt"</span>:   <span class="string">"2014-02-01"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sort"</span>: [<span class="string">"_doc"</span>],</span><br><span class="line">    <span class="string">"size"</span>:  1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果旧的索引会持续变化，你希望新的索引中也包括那些新加的文档。那就可以对新加的文档做重新索引， 但还是要用日期类字段过滤来匹配那些新加的文档。</p>
<h1 id="索引别名和零停机"><a href="#索引别名和零停机" class="headerlink" title="索引别名和零停机"></a>索引别名和零停机</h1><p>在前面提到的，重建索引的问题是必须更新应用中的索引名称。 索引别名就是用来解决这个问题的！</p>
<p>索引 别名 就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何一个需要索引名的API来使用。别名 带给我们极大的灵活性，允许我们做下面这些：</p>
<p>在运行的集群中可以无缝的从一个索引切换到另一个索引<br>给多个索引分组 (例如， last_three_months)<br>给索引的一个子集创建 视图</p>
<p>在后面我们会讨论更多关于别名的使用。现在，我们将解释怎样使用别名在零停机下从旧索引切换到新索引。</p>
<p>有两种方式管理别名： _alias 用于单个操作， _aliases 用于执行多个原子级操作。</p>
<p>在本章中，我们假设你的应用有一个叫 my_index 的索引。事实上， my_index 是一个指向当前真实索引的别名。真实索引包含一个版本号： my_index_v1 ， my_index_v2 等等。</p>
<p>首先，创建索引 my_index_v1 ，然后将别名 my_index 指向它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index_v1 (1)</span><br><span class="line">PUT /my_index_v1/_alias/my_index (2)</span><br></pre></td></tr></table></figure></p>
<p>(1)创建索引 my_index_v1 。<br>(2)设置别名 my_index 指向 my_index_v1 。</p>
<p>你可以检测这个别名指向哪一个索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /*/_alias/my_index</span><br></pre></td></tr></table></figure></p>
<p>或哪些别名指向这个索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index_v1/_alias/*</span><br></pre></td></tr></table></figure></p>
<p>两者都会返回下面的结果：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"my_index_v1"</span> : &#123;</span><br><span class="line">        <span class="attr">"aliases"</span> : &#123;</span><br><span class="line">            <span class="attr">"my_index"</span> : &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们决定修改索引中一个字段的映射。当然，我们不能修改现存的映射，所以我们必须重新索引数据。 首先, 我们用新映射创建索引 my_index_v2 ：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index_v2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"properties"</span>: &#123;</span><br><span class="line">                <span class="string">"tags"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:   <span class="string">"string"</span>,</span><br><span class="line">                    <span class="string">"index"</span>:  <span class="string">"not_analyzed"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们将数据从 my_index_v1 索引到 my_index_v2 ，下面的过程在 重新索引你的数据 中已经描述过。一旦我们确定文档已经被正确地重索引了，我们就将别名指向新的索引。</p>
<p>一个别名可以指向多个索引，所以我们在添加别名到新索引的同时必须从旧的索引中删除它。这个操作需要原子化，这意味着我们需要使用 _aliases 操作：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"actions"</span>: [</span><br><span class="line">        &#123; <span class="string">"remove"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v1"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="string">"add"</span>:    &#123; <span class="string">"index"</span>: <span class="string">"my_index_v2"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你的应用已经在零停机的情况下从旧索引迁移到新索引了。</p>
<p>即使你认为现在的索引设计已经很完美了，在生产环境中，还是有可能需要做一些修改的。<br>做好准备：在你的应用中使用别名而不是索引名。然后你就可以在任何时候重建索引。别名的开销很小，应该广泛使用。</p>
<h1 id="分片内部原理"><a href="#分片内部原理" class="headerlink" title="分片内部原理"></a>分片内部原理</h1><p>在 集群内的原理, 我们介绍了 分片, 并将它 描述成最小的 工作单元 。但是究竟什么 是 一个分片，它是如何工作的？ 在这个章节，我们回答以下问题:</p>
<ol>
<li>为什么搜索是 近 实时的？</li>
<li>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 实时 的?</li>
<li>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?</li>
<li>为什么删除文档不会立刻释放空间？</li>
<li>refresh, flush, 和 optimize API 都做了什么, 你什么情况下应该使用他们？</li>
</ol>
<p>最简单的理解一个分片如何工作的方式是上一堂历史课。 我们将要审视提供一个带近实时搜索和分析的 分布式持久化数据存储需要解决的问题。</p>
<p>本章展示的这些信息仅供您兴趣阅读。为了使用 Elasticsearch 您并不需要理解和记忆所有的细节。 读这个章节是为了了解工作机制，并且为了将来您需要这些信息时，知道这些信息在哪里。但是不要被这些细节所累。</p>
<h1 id="使文本可被搜索"><a href="#使文本可被搜索" class="headerlink" title="使文本可被搜索"></a>使文本可被搜索</h1><p>必须解决的第一个挑战是如何 使文本可被搜索。 传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值(这里指单词)的能力。</p>
<p>最好的支持 一个字段多个值 需求的数据结构是我们在 倒排索引 章节中介绍过的 倒排索引 。 倒排索引包含一个有序列表，列表包含所有文档出现过的不重复个体，或称为 词项 ，对于每一个词项，包含了它所有曾出现过文档的列表。</p>
<h2 id="Term-Doc-1-Doc-2-Doc-3-…"><a href="#Term-Doc-1-Doc-2-Doc-3-…" class="headerlink" title="Term  | Doc 1 | Doc 2 | Doc 3 | …"></a>Term  | Doc 1 | Doc 2 | Doc 3 | …</h2><p>brown |   X   |       |  X    | …</p>
<p>fox   |   X   |   X   |  X    | …</p>
<p>quick |   X   |   X   |       | …</p>
<p>the   |   X   |       |  X    | …</p>
<p>当讨论倒排索引时，我们会谈到 文档 标引，因为历史原因，倒排索引被用来对整个非结构化文本文档进行标引。 Elasticsearch 中的 文档 是有字段和值的结构化 JSON 文档。事实上，在 JSON 文档中， 每个被索引的字段都有自己的倒排索引。</p>
<p>这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。它会保存每一个词项出现过的文档总数， 在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度，等等。这些统计信息允许 Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，这些内容在 什么是相关性? 中有描述。</p>
<p>为了能够实现预期功能，倒排索引需要知道集合中的 所有 文档，这是需要认识到的关键问题。</p>
<p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>倒排索引被写入磁盘后是 不可改变 的:它永远不会修改。 不变性有重要的价值：</p>
<ol>
<li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。</li>
</ol>
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h1 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h1><p>下一个需要被解决的问题是怎样在保留不变性的前提下实现倒排索引的更新？ 答案是: 用更多的索引。</p>
<p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到–从最早的开始–查询完后再对结果进行合并。</p>
<p>Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件，就像在 图 16 “一个 Lucene 索引包含一个提交点和三个段” 中描绘的那样。 如 图 17 “一个在内存缓存中包含新文档的 Lucene 索引” 所示，新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，如 图 18 “在一次提交后，一个新的段被添加到提交点而且缓存被清空。” 所示。<br>图 16. 一个 Lucene 索引包含一个提交点和三个段<br><img src="https://mfaying.github.io/images/elasticsearch2.x/16.jpg" alt="avatar"></p>
<p>索引与分片的比较</p>
<p>被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个 Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 执行分布式检索 提到的那样，合并每个分片的结果到一个全局的结果集。</p>
<p>逐段搜索会以如下流程进行工作：</p>
<ol>
<li>新文档被收集到内存索引缓存， 见 图 17 “一个在内存缓存中包含新文档的 Lucene 索引” 。</li>
<li>不时地, 缓存被 提交 ：</li>
</ol>
<p>一个新的段–一个追加的倒排索引–被写入磁盘。<br>一个新的包含新段名字的 提交点 被写入磁盘。<br>磁盘进行 同步 — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。</p>
<ol start="3">
<li>新的段被开启，让它包含的文档可见以被搜索。</li>
<li>内存缓存被清空，等待接收新的文档。</li>
</ol>
<p>图 17. 一个在内存缓存中包含新文档的 Lucene 索引<br><img src="https://mfaying.github.io/images/elasticsearch2.x/17.jpg" alt="avatar"></p>
<p>在一次提交后，一个新的段被添加到提交点而且缓存被清空。<br><img src="https://mfaying.github.io/images/elasticsearch2.x/18.jpg" alt="avatar"></p>
<p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。 这种方式可以用相对较低的成本将新文档添加到索引。</p>
<h2 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h2><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。</p>
<p>当一个文档被 “删除” 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</p>
<p>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<p>在 段合并 , 我们展示了一个被删除的文档是怎样被文件系统移除的。</p>
<h2 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h2><p>随着按段（per-segment）搜索的发展， 一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。</p>
<p>磁盘在这里成为了瓶颈。 提交（Commiting）一个新的段到磁盘需要一个 fsync 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 fsync 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p>
<p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着 fsync 要从整个过程中被移除。</p>
<p>在Elasticsearch和磁盘之间是文件系统缓存。 像之前描述的一样， 在内存索引缓冲区（ 图 19 “在内存缓冲区中包含了新文档的 Lucene 索引” ）中的文档会被写入到一个新的段中（ 图 20 “缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交” ）。 但是这里新段会被先写入到文件系统缓存–这一步代价会比较低，稍后再被刷新到磁盘–这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。<br>图 19. 在内存缓冲区中包含了新文档的 Lucene 索引<br><img src="https://mfaying.github.io/images/elasticsearch2.x/19.jpg" alt="avatar"><br>Lucene 允许新段被写入和打开–使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<p>图 20. 缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交<br><img src="https://mfaying.github.io/images/elasticsearch2.x/20.jpg" alt="avatar"></p>
<h2 id="refresh-API"><a href="#refresh-API" class="headerlink" title="refresh API"></a>refresh API</h2><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 refresh 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是 近 实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
<p>这些行为可能会对新用户造成困惑: 他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 refresh API 执行一次手动刷新:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /_refresh (1)</span><br><span class="line">POST /blogs/_refresh (2)</span><br></pre></td></tr></table></figure></p>
<p>(1)刷新（Refresh）所有的索引。<br>(2)只刷新（Refresh） blogs 索引。</p>
<p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。 当写测试的时候， 手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。 相反，你的应用需要意识到 Elasticsearch 的近实时的性质，并接受它的不足。</p>
<p>并不是所有的情况都需要每秒刷新。可能你正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 refresh_interval ， 降低每个索引的刷新频率：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_logs</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>: &#123;</span><br><span class="line">    <span class="string">"refresh_interval"</span>: <span class="string">"30s"</span> (1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)每30秒刷新 my_logs 索引。</p>
<p>refresh_interval 可以在既存索引上进行动态更新。 在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123; <span class="string">"refresh_interval"</span>: -1 &#125; (1)</span><br><span class="line"></span><br><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123; <span class="string">"refresh_interval"</span>: <span class="string">"1s"</span> &#125; (2)</span><br></pre></td></tr></table></figure></p>
<p>(1) 关闭自动刷新。<br>(2) 每秒自动刷新。</p>
<p>refresh_interval 需要一个 持续时间 值， 例如 1s （1 秒） 或 2m （2 分钟）。 一个绝对值 1 表示的是 1毫秒 –无疑会使你的集群陷入瘫痪。</p>
<h1 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h1><p>如果没有用 fsync 把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证 Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。</p>
<p>在 动态更新索引，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p>
<p>即使通过每秒刷新（refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办？我们也不希望丢失掉这些数据。</p>
<p>Elasticsearch 增加了一个 translog ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录。通过 translog ，整个流程看起来是下面这样：</p>
<ol>
<li>一个文档被索引之后，就会被添加到内存缓冲区，并且 追加到了 translog ，正如 图 21 “新的文档被添加到内存缓冲区并且被追加到了事务日志” 描述的一样。</li>
</ol>
<p>新的文档被添加到内存缓冲区并且被追加到了事务日志<br><img src="https://mfaying.github.io/images/elasticsearch2.x/21.jpg" alt="avatar"></p>
<p>刷新（refresh）使分片处于 图 22 “刷新（refresh）完成后, 缓存被清空但是事务日志不会” 描述的状态，分片每秒被刷新（refresh）一次：</p>
<ol>
<li>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行 fsync 操作。</li>
<li>这个段被打开，使其可被搜索。</li>
<li>内存缓冲区被清空。</li>
</ol>
<p>图 22. 刷新（refresh）完成后, 缓存被清空但是事务日志不会<br><img src="https://mfaying.github.io/images/elasticsearch2.x/22.jpg" alt="avatar"></p>
<ol start="3">
<li><p>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志（见 图 23 “事务日志不断积累文档” ）。<br>图 23. 事务日志不断积累文档<br><img src="https://mfaying.github.io/images/elasticsearch2.x/23.jpg" alt="avatar"></p>
</li>
<li><p>每隔一段时间–例如 translog 变得越来越大–索引被刷新（flush）；一个新的 translog 被创建，并且一个全量提交被执行（见 图 24 “在刷新（flush）之后，段被全量提交，并且事务日志被清空” ）：</p>
</li>
<li>所有在内存缓冲区的文档都被写入一个新的段。</li>
<li>缓冲区被清空。</li>
<li>一个提交点被写入硬盘。</li>
<li>文件系统缓存通过 fsync 被刷新（flush）。</li>
<li>老的 translog 被删除。<br>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当 Elasticsearch 启动的时候， 它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放 translog 中所有在最后一次提交后发生的变更操作。</li>
</ol>
<p>translog 也被用来提供实时 CRUD 。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前， 首先检查 translog 任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p>
<p>图 24. 在刷新（flush）之后，段被全量提交，并且事务日志被清空<br><img src="https://mfaying.github.io/images/elasticsearch2.x/24.jpg" alt="avatar"></p>
<h2 id="flush-API"><a href="#flush-API" class="headerlink" title="flush API"></a>flush API</h2><p>这个执行一个提交并且截断 translog 的行为在 Elasticsearch 被称作一次 flush 。 分片每30分钟被自动刷新（flush），或者在 translog 太大的时候也会刷新。请查看 translog 文档 来设置，它可以用来 控制这些阈值：<br>flush API 可以 被用来执行一个手工的刷新（flush）:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /blogs/_flush (1)</span><br><span class="line"></span><br><span class="line">POST /_flush?wait_for_ongoing (2)</span><br></pre></td></tr></table></figure></p>
<p>(1) 刷新（flush） blogs 索引。<br>(2) 刷新（flush）所有的索引并且等待所有刷新在返回前完成。</p>
<p>你很少需要自己手动执行 flush 操作；通常情况下，自动刷新就足够了。</p>
<p>这就是说，在重启节点或关闭索引之前执行 flush 有益于你的索引。当 Elasticsearch 尝试恢复或重新打开一个索引， 它需要重放 translog 中所有的操作，所以如果日志越短，恢复越快。</p>
<p>Translog 有多安全?</p>
<p>translog 的目的是保证操作不会丢失。这引出了这个问题： Translog 有多安全 ？</p>
<p>在文件被 fsync 到磁盘前，被写入的文件在重启之后就会丢失。默认 translog 是每 5 秒被 fsync 刷新到硬盘， 或者在每次写请求完成之后执行(e.g. index, delete, update, bulk)。这个过程在主分片和复制分片都会发生。最终， 基本上，这意味着在整个请求被 fsync 到主分片和复制分片的translog之前，你的客户端不会得到一个 200 OK 响应。</p>
<p>在每次请求后都执行一个 fsync 会带来一些性能损失，尽管实践表明这种损失相对较小（特别是bulk导入，它在一次请求中平摊了大量文档的开销）。</p>
<p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync 还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次 fsync 。</p>
<p>这个行为可以通过设置 durability 参数为 async 来启用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"index.translog.durability"</span>: <span class="string">"async"</span>,</span><br><span class="line">    <span class="string">"index.translog.sync_interval"</span>: <span class="string">"5s"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个选项可以针对索引单独设置，并且可以动态进行修改。如果你决定使用异步 translog 的话，你需要 保证 在发生crash时，丢失掉 sync_interval 时间段的数据也无所谓。请在决定前知晓这个特性。</p>
<p>如果你不确定这个行为的后果，最好是使用默认的参数（ “index.translog.durability”: “request” ）来避免数据丢失。</p>
<h1 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h1><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p>
<p>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
<p>段合并的时候会将那些旧的已删除文档 从文件系统中清除。 被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</p>
<p>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。这个流程像在 图 25 “两个提交了的段和一个未提交的段正在被合并到一个更大的段” 中提到的一样工作：</p>
<p>1、 当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。<br>2、 合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。<br>图 25. 两个提交了的段和一个未提交的段正在被合并到一个更大的段<br><img src="https://mfaying.github.io/images/elasticsearch2.x/25.jpg" alt="avatar"></p>
<p>3、 图 26 “一旦合并结束，老的段被删除” 说明合并完成时的活动：<br>新的段被刷新（flush）到了磁盘。   ** 写入一个包含新段且排除旧的和较小的段的新提交点。<br>新的段被打开用来搜索。<br>老的段被删除。<br>图 26. 一旦合并结束，老的段被删除<br><img src="https://mfaying.github.io/images/elasticsearch2.x/26.jpg" alt="avatar"><br>合并大的段需要消耗大量的I/O和CPU资源，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然 有足够的资源很好地执行。</p>
<p>查看 段和合并 来为你的实例获取关于合并调整的建议。</p>
<h2 id="optimize-API"><a href="#optimize-API" class="headerlink" title="optimize API"></a>optimize API</h2><p>optimize API大可看做是 强制合并 API 。它会将一个分片强制合并到 max_num_segments 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</p>
<p>optimize API 不应该 被用在一个活跃的索引————一个正积极更新的索引。后台合并流程已经可以很好地完成工作。 optimizing 会阻碍这个进程。不要干扰它！</p>
<p>在特定情况下，使用 optimize API 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中。 老的索引实质上是只读的；它们也并不太可能会发生变化。</p>
<p>在这种情况下，使用optimize优化老的索引，将每一个分片合并为一个单独的段就很有用了；这样既可以节省资源，也可以使搜索更加快速：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</span><br></pre></td></tr></table></figure></p>
<p>合并索引中的每个分片为一个单独的段</p>
<p>请注意，使用 optimize API 触发段合并的操作不会受到任何资源上的限制。这可能会消耗掉你节点上全部的I/O资源, 使其没有余裕来处理搜索请求，从而有可能使集群失去响应。 如果你想要对索引执行 <code>optimize</code>，你需要先使用分片分配（查看 迁移旧索引）把索引移到一个安全的节点，再执行。</p>
<h1 id="深入搜索"><a href="#深入搜索" class="headerlink" title="深入搜索"></a>深入搜索</h1><p>在 基础入门 中涵盖了基本工具并对它们有足够详细的描述，这让我们能够开始用 Elasticsearch 搜索数据。 用不了多长时间，就会发现我们想要的更多：希望查询匹配更灵活，排名结果更精确，不同问题域下搜索更具体。</p>
<p>想要进阶，只知道如何使用 match 查询是不够的，我们需要理解数据以及如何能够搜索到它们。本章会解释如何索引和查询我们的数据让我们能利用词的相似度（word proximity）、部分匹配（partial matching）、模糊匹配（fuzzy matching）以及语言感知（language awareness）这些优势。</p>
<p>理解每个查询如何贡献相关度评分 _score 有助于调试我们的查询：确保我们认为的最佳匹配文档出现在结果首页，以及削减结果中几乎不相关的 “长尾（long tail）”。</p>
<p>搜索不仅仅是全文搜索：我们很大一部分数据都是结构化的，如日期和数字。 我们会以说明结构化搜索与全文搜索最高效的结合方式开始本章的内容。</p>
<h1 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h1><p>结构化搜索（Structured search） 是指有关探询那些具有内在结构数据的过程。比如日期、时间和数字都是结构化的：它们有精确的格式，我们可以对这些格式进行逻辑操作。比较常见的操作包括比较数字或时间的范围，或判定两个值的大小。</p>
<p>文本也可以是结构化的。如彩色笔可以有离散的颜色集合： 红（red） 、 绿（green） 、 蓝（blue） 。一个博客可能被标记了关键词 分布式（distributed） 和 搜索（search） 。电商网站上的商品都有 UPCs（通用产品码 Universal Product Codes）或其他的唯一标识，它们都需要遵从严格规定的、结构化的格式。</p>
<p>在结构化查询中，我们得到的结果 总是 非是即否，要么存于集合之中，要么存在集合之外。结构化查询不关心文件的相关度或评分；它简单的对文档包括或排除处理。</p>
<p>这在逻辑上是能说通的，因为一个数字不能比其他数字 更 适合存于某个相同范围。结果只能是：存于范围之中，抑或反之。同样，对于结构化文本来说，一个值要么相等，要么不等。没有 更似 这种概念。</p>
<h1 id="精确值查找"><a href="#精确值查找" class="headerlink" title="精确值查找"></a>精确值查找</h1><p>当进行精确值查找时， 我们会使用过滤器（filters）。过滤器很重要，因为它们执行速度非常快，不会计算相关度（直接跳过了整个评分阶段）而且很容易被缓存。我们会在本章后面的 过滤器缓存 中讨论过滤器的性能优势，不过现在只要记住：请尽可能多的使用过滤式查询。</p>
<h2 id="term-查询数字"><a href="#term-查询数字" class="headerlink" title="term 查询数字"></a>term 查询数字</h2><p>我们首先来看最为常用的 term 查询， 可以用它处理数字（numbers）、布尔值（Booleans）、日期（dates）以及文本（text）。</p>
<p>让我们以下面的例子开始介绍，创建并索引一些表示产品的文档，文档里有字段 <code>price</code> 和 <code>productID</code> （ <code>价格</code> 和 <code>产品ID</code> ）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /my_store/products/_bulk</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 1 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 10, <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 2 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 20, <span class="string">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 3 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 30, <span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 4 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 30, <span class="string">"productID"</span> : <span class="string">"QQPX-R-3956-#aD8"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想要做的是查找具有某个价格的所有产品，有关系数据库背景的人肯定熟悉 SQL，如果我们将其用 SQL 形式表达，会是下面这样：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">document</span></span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  price = <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>在 Elasticsearch 的查询表达式（query DSL）中，我们可以使用 term 查询达到相同的目的。 term 查询会查找我们指定的精确值。作为其本身， term 查询是简单的。它接受一个字段名以及我们希望查找的数值：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"term"</span> : &#123;</span><br><span class="line">        <span class="attr">"price"</span> : <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常当查找一个精确值的时候，我们不希望对查询进行评分计算。只希望对文档进行包括或排除的计算，所以我们会使用 constant_score 查询以非评分模式来执行 term 查询并以一作为统一评分。</p>
<p>最终组合的结果是一个 constant_score 查询，它包含一个 term 查询：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123; (1)</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123; (2)</span><br><span class="line">                    <span class="string">"price"</span> : 20</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)我们用 constant_score 将 term 查询转化成为过滤器<br>(2)我们之前看到过的 term 查询<br>执行后，这个查询所搜索到的结果与我们期望的一致：只有文档 2 命中并作为结果返回（因为只有 2 的价格是 20 ）:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"hits" : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"my_store"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> :  <span class="string">"products"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> :    <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>, <span class="comment">//(1)</span></span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :     <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>(1)查询置于 filter 语句内不进行评分或相关度的计算，所以所有的结果都会返回一个默认评分 1 。</p>
<h2 id="term-查询文本"><a href="#term-查询文本" class="headerlink" title="term 查询文本"></a>term 查询文本</h2><p>如本部分开始处提到过的一样 ，使用 term 查询匹配字符串和匹配数字一样容易。如果我们想要查询某个具体 UPC ID 的产品，使用 SQL 表达式会是如下这样：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product</span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  productID = <span class="string">"XHDK-A-1293-#fJ3"</span></span><br></pre></td></tr></table></figure></p>
<p>转换成查询表达式（query DSL），同样使用 term 查询，形式如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123;</span><br><span class="line">                    <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这里有个小问题：我们无法获得期望的结果。为什么呢？问题不在 term 查询，而在于索引数据的方式。 如果我们使用 analyze API (分析 API)，我们可以看到这里的 UPC 码被拆分成多个更小的 token ：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"field"</span>: <span class="string">"productID"</span>,</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"XHDK-A-1293-#fJ3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [ &#123;</span><br><span class="line">    <span class="attr">"token"</span> :        <span class="string">"xhdk"</span>,</span><br><span class="line">    <span class="attr">"start_offset"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"end_offset"</span> :   <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"type"</span> :         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">    <span class="attr">"position"</span> :     <span class="number">1</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">"token"</span> :        <span class="string">"a"</span>,</span><br><span class="line">    <span class="attr">"start_offset"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"end_offset"</span> :   <span class="number">6</span>,</span><br><span class="line">    <span class="attr">"type"</span> :         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">    <span class="attr">"position"</span> :     <span class="number">2</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">"token"</span> :        <span class="string">"1293"</span>,</span><br><span class="line">    <span class="attr">"start_offset"</span> : <span class="number">7</span>,</span><br><span class="line">    <span class="attr">"end_offset"</span> :   <span class="number">11</span>,</span><br><span class="line">    <span class="attr">"type"</span> :         <span class="string">"&lt;NUM&gt;"</span>,</span><br><span class="line">    <span class="attr">"position"</span> :     <span class="number">3</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">"token"</span> :        <span class="string">"fj3"</span>,</span><br><span class="line">    <span class="attr">"start_offset"</span> : <span class="number">13</span>,</span><br><span class="line">    <span class="attr">"end_offset"</span> :   <span class="number">16</span>,</span><br><span class="line">    <span class="attr">"type"</span> :         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">    <span class="attr">"position"</span> :     <span class="number">4</span></span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几点需要注意：</p>
<ol>
<li>Elasticsearch 用 4 个不同的 token 而不是单个 token 来表示这个 UPC 。</li>
<li>所有字母都是小写的。</li>
<li>丢失了连字符和哈希符（ # ）。</li>
</ol>
<p>所以当我们用 term 查询查找精确值 XHDK-A-1293-#fJ3 的时候，找不到任何文档，因为它并不在我们的倒排索引中，正如前面呈现出的分析结果，索引里有四个 token 。</p>
<p>显然这种对 ID 码或其他任何精确值的处理方式并不是我们想要的。</p>
<p>为了避免这种问题，我们需要告诉 Elasticsearch 该字段具有精确值，要将其设置成 not_analyzed 无需分析的。 我们可以在 自定义字段映射 中查看它的用法。为了修正搜索结果，我们需要首先删除旧索引（因为它的映射不再正确）然后创建一个能正确映射的新索引：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELETE /my_store (1)</span><br><span class="line"></span><br><span class="line">PUT /my_store (2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span> : &#123;</span><br><span class="line">        <span class="string">"products"</span> : &#123;</span><br><span class="line">            <span class="string">"properties"</span> : &#123;</span><br><span class="line">                <span class="string">"productID"</span> : &#123;</span><br><span class="line">                    <span class="string">"type"</span> : <span class="string">"string"</span>,</span><br><span class="line">                    <span class="string">"index"</span> : <span class="string">"not_analyzed"</span> (3)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 删除索引是必须的，因为我们不能更新已存在的映射。<br>(2) 在索引被删除后，我们可以创建新的索引并为其指定自定义映射。<br>(3) 这里我们告诉 Elasticsearch ，我们不想对 productID 做任何分析。</p>
<p>现在我们可以为文档重建索引：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /my_store/products/_bulk</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 1 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 10, <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 2 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 20, <span class="string">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 3 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 30, <span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span> &#125;</span><br><span class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_id"</span>: 4 &#125;&#125;</span><br><span class="line">&#123; <span class="string">"price"</span> : 30, <span class="string">"productID"</span> : <span class="string">"QQPX-R-3956-#aD8"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>此时， term 查询就能搜索到我们想要的结果，让我们再次搜索新索引过的数据（注意，查询和过滤并没有发生任何改变，改变的是数据映射的方式）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"term"</span> : &#123;</span><br><span class="line">                    <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为 productID 字段是未分析过的， term 查询不会对其做任何分析，查询会进行精确查找并返回文档 1 。成功！</p>
<h2 id="内部过滤器的操作"><a href="#内部过滤器的操作" class="headerlink" title="内部过滤器的操作"></a>内部过滤器的操作</h2><p>在内部，Elasticsearch 会在运行非评分查询的时执行多个操作：</p>
<ol>
<li>查找匹配文档.<br>term 查询在倒排索引中查找 XHDK-A-1293-#fJ3 然后获取包含该 term 的所有文档。本例中，只有文档 1 满足我们要求。</li>
<li>创建 bitset.<br>过滤器会创建一个 bitset （一个包含 0 和 1 的数组），它描述了哪个文档会包含该 term 。匹配文档的标志位是 1 。本例中，bitset 的值为 [1,0,0,0] 。在内部，它表示成一个 “roaring bitmap”，可以同时对稀疏或密集的集合进行高效编码。</li>
<li>迭代 bitset(s)<br>一旦为每个查询生成了 bitsets ，Elasticsearch 就会循环迭代 bitsets 从而找到满足所有过滤条件的匹配文档的集合。执行顺序是启发式的，但一般来说先迭代稀疏的 bitset （因为它可以排除掉大量的文档）。</li>
<li>增量使用计数.<br>Elasticsearch 能够缓存非评分查询从而获取更快的访问，但是它也会不太聪明地缓存一些使用极少的东西。非评分计算因为倒排索引已经足够快了，所以我们只想缓存那些我们 知道 在将来会被再次使用的查询，以避免资源的浪费。</li>
</ol>
<p>为了实现以上设想，Elasticsearch 会为每个索引跟踪保留查询使用的历史状态。如果查询在最近的 256 次查询中会被用到，那么它就会被缓存到内存中。当 bitset 被缓存后，缓存会在那些低于 10,000 个文档（或少于 3% 的总索引数）的段（segment）中被忽略。这些小的段即将会消失，所以为它们分配缓存是一种浪费。</p>
<p>实际情况并非如此（执行有它的复杂性，这取决于查询计划是如何重新规划的，有些启发式的算法是基于查询代价的），理论上非评分查询 先于 评分查询执行。非评分查询任务旨在降低那些将对评分查询计算带来更高成本的文档数量，从而达到快速搜索的目的。</p>
<p>从概念上记住非评分计算是首先执行的，这将有助于写出高效又快速的搜索请求。</p>
<h1 id="组合过滤器"><a href="#组合过滤器" class="headerlink" title="组合过滤器"></a>组合过滤器</h1><p>前面的两个例子都是单个过滤器（filter）的使用方式。 在实际应用中，我们很有可能会过滤多个值或字段。比方说，怎样用 Elasticsearch 来表达下面的 SQL ？<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product</span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  (price = <span class="number">20</span> <span class="keyword">OR</span> productID = <span class="string">"XHDK-A-1293-#fJ3"</span>)</span><br><span class="line">  <span class="keyword">AND</span>  (price != <span class="number">30</span>)</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，我们需要 bool （布尔）过滤器。 这是个 复合过滤器（compound filter） ，它可以接受多个其他过滤器作为参数，并将这些过滤器结合成各式各样的布尔（逻辑）组合。</p>
<h2 id="布尔过滤器"><a href="#布尔过滤器" class="headerlink" title="布尔过滤器"></a>布尔过滤器</h2><p>一个 bool 过滤器由三部分组成：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"must"</span> :     [],</span><br><span class="line">      <span class="attr">"should"</span> :   [],</span><br><span class="line">      <span class="attr">"must_not"</span> : [],</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>must<br>所有的语句都 必须（must） 匹配，与 AND 等价。<br>must_not<br>所有的语句都 不能（must not） 匹配，与 NOT 等价。<br>should<br>至少有一个语句要匹配，与 OR 等价。</p>
<p>就这么简单！ 当我们需要多个过滤器时，只须将它们置入 bool 过滤器的不同部分即可。</p>
<p>一个 bool 过滤器的每个部分都是可选的（例如，我们可以只有一个 must 语句），而且每个部分内部可以只有一个或一组过滤器。</p>
<p>用 Elasticsearch 来表示本部分开始处的 SQL 例子，将两个 term 过滤器置入 bool 过滤器的 should 语句内，再增加一个语句处理 NOT 非的条件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span> : &#123;</span><br><span class="line">      <span class="string">"filtered"</span> : &#123; (1)</span><br><span class="line">         <span class="string">"filter"</span> : &#123;</span><br><span class="line">            <span class="string">"bool"</span> : &#123;</span><br><span class="line">              <span class="string">"should"</span> : [</span><br><span class="line">                 &#123; <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 20&#125;&#125;, (2)</span><br><span class="line">                 &#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span>&#125;&#125; (3)</span><br><span class="line">              ],</span><br><span class="line">              <span class="string">"must_not"</span> : &#123;</span><br><span class="line">                 <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 30&#125; (4)</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 注意，我们仍然需要一个 filtered 查询将所有的东西包起来。<br>(2)(3) 在 should 语句块里面的两个 term 过滤器与 bool 过滤器是父子关系，两个 term 条件需要匹配其一。<br>(4) 如果一个产品的价格是 30 ，那么它会自动被排除，因为它处于 must_not 语句里面。</p>
<p>我们搜索的结果返回了 2 个命中结果，两个文档分别匹配了 bool 过滤器其中的一个条件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hits"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"_id"</span> :     <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"_score"</span> :  1.0,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"price"</span> :     10,</span><br><span class="line">          <span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span> (1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"_id"</span> :     <span class="string">"2"</span>,</span><br><span class="line">        <span class="string">"_score"</span> :  1.0,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"price"</span> :     20, (2)</span><br><span class="line">          <span class="string">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>(1) 与 term 过滤器中 productID = “XHDK-A-1293-#fJ3” 条件匹配<br>(2) 与 term 过滤器中 price = 20 条件匹配</p>
<h1 id="嵌套布尔过滤器"><a href="#嵌套布尔过滤器" class="headerlink" title="嵌套布尔过滤器"></a>嵌套布尔过滤器</h1><p>尽管 bool 是一个复合的过滤器，可以接受多个子过滤器，需要注意的是 bool 过滤器本身仍然还只是一个过滤器。 这意味着我们可以将一个 bool 过滤器置于其他 bool 过滤器内部，这为我们提供了对任意复杂布尔逻辑进行处理的能力。</p>
<p>对于以下这个 SQL 语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">document</span></span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  productID      = <span class="string">"KDKE-B-9947-#kL5"</span></span><br><span class="line">  <span class="keyword">OR</span> (     productID = <span class="string">"JODL-X-1937-#pV7"</span></span><br><span class="line">       <span class="keyword">AND</span> price     = <span class="number">30</span> )</span><br></pre></td></tr></table></figure></p>
<p>我们将其转换成一组嵌套的 bool 过滤器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span> : &#123;</span><br><span class="line">      <span class="string">"filtered"</span> : &#123;</span><br><span class="line">         <span class="string">"filter"</span> : &#123;</span><br><span class="line">            <span class="string">"bool"</span> : &#123;</span><br><span class="line">              <span class="string">"should"</span> : [</span><br><span class="line">                &#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span>&#125;&#125;, (1)</span><br><span class="line">                &#123; <span class="string">"bool"</span> : &#123; (2)</span><br><span class="line">                  <span class="string">"must"</span> : [</span><br><span class="line">                    &#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span>&#125;&#125;, (3)</span><br><span class="line">                    &#123; <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 30&#125;&#125; (4)</span><br><span class="line">                  ]</span><br><span class="line">                &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)(2) 因为 term 和 bool 过滤器是兄弟关系，他们都处于外层的布尔逻辑 should 的内部，返回的命中文档至少须匹配其中一个过滤器的条件。<br>(3)(4) 这两个 term 语句作为兄弟关系，同时处于 must 语句之中，所以返回的命中文档要必须都能同时匹配这两个条件。</p>
<p>得到的结果有两个文档，它们各匹配 should 语句中的一个条件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">"hits" : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span> :     <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> :  <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :     <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span> <span class="comment">// (1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span> :     <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> :  <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :      <span class="number">30</span>, <span class="comment">// (2)</span></span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span> <span class="comment">// (3)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>(1) 这个 productID 与外层的 bool 过滤器 should 里的唯一一个 term 匹配。<br>(2) 这两个字段与嵌套的 bool 过滤器 must 里的两个 term 匹配。</p>
<p>这只是个简单的例子，但足以展示布尔过滤器可以用来作为构造复杂逻辑条件的基本构建模块。</p>
<h1 id="查找多个精确值"><a href="#查找多个精确值" class="headerlink" title="查找多个精确值"></a>查找多个精确值</h1><p>term 查询对于查找单个值非常有用，但通常我们可能想搜索多个值。 如果我们想要查找价格字段值为 $20 或 $30 的文档该如何处理呢？</p>
<p>不需要使用多个 term 查询，我们只要用单个 terms 查询（注意末尾的 s ）， terms 查询好比是 term 查询的复数形式（以英语名词的单复数做比）。</p>
<p>它几乎与 term 的使用方式一模一样，与指定单个价格不同，我们只要将 term 字段的值改为数组即可：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"terms"</span> : &#123;</span><br><span class="line">        <span class="attr">"price"</span> : [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与 term 查询一样，也需要将其置入 filter 语句的常量评分查询中使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"terms"</span> : &#123; (1)</span><br><span class="line">                    <span class="string">"price"</span> : [20, 30]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 这个 terms 查询被置于 constant_score 查询中</p>
<p>运行结果返回第二、第三和第四个文档：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">"hits" : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span> :    <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :     <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span> :    <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"price"</span> :     <span class="number">30</span>,</span><br><span class="line">          <span class="attr">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"_id"</span>:     <span class="string">"4"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>:  <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">           <span class="attr">"price"</span>:     <span class="number">30</span>,</span><br><span class="line">           <span class="attr">"productID"</span>: <span class="string">"QQPX-R-3956-#aD8"</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="包含，而不是相等"><a href="#包含，而不是相等" class="headerlink" title="包含，而不是相等"></a>包含，而不是相等</h2><p>一定要了解 term 和 terms 是 包含（contains） 操作，而非 等值（equals） （判断）。 如何理解这句话呢？</p>
<p>如果我们有一个 term（词项）过滤器 { “term” : { “tags” : “search” } } ，它会与以下两个文档 同时 匹配：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>] &#125;</span><br><span class="line">&#123; "tags" : ["search", "open_source"] &#125; (1)</span><br></pre></td></tr></table></figure>
<p>(1) 尽管第二个文档包含除 search 以外的其他词，它还是被匹配并作为结果返回。</p>
<p>回忆一下 term 查询是如何工作的？ Elasticsearch 会在倒排索引中查找包括某 term 的所有文档，然后构造一个 bitset 。在我们的例子中，倒排索引表如下：<br>Token       DocIDs<br>open_source 2<br>search      1,2<br>当 term 查询匹配标记 search 时，它直接在倒排索引中找到记录并获取相关的文档 ID，如倒排索引所示，这里文档 1 和文档 2 均包含该标记，所以两个文档会同时作为结果返回。</p>
<p>由于倒排索引表自身的特性，整个字段是否相等会难以计算，如果确定某个特定文档是否 只（only） 包含我们想要查找的词呢？首先我们需要在倒排索引中找到相关的记录并获取文档 ID，然后再扫描 倒排索引中的每行记录 ，查看它们是否包含其他的 terms 。</p>
<p>可以想象，这样不仅低效，而且代价高昂。正因如此， term 和 terms 是 必须包含（must contain） 操作，而不是 必须精确相等（must equal exactly） 。</p>
<h2 id="精确相等"><a href="#精确相等" class="headerlink" title="精确相等"></a>精确相等</h2><p>如果一定期望得到我们前面说的那种行为（即整个字段完全相等），最好的方式是增加并索引另一个字段， 这个字段用以存储该字段包含词项的数量，同样以上面提到的两个文档为例，现在我们包括了一个维护标签数的新字段：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>], <span class="attr">"tag_count"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>], <span class="attr">"tag_count"</span> : <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦增加这个用来索引项 term 数目信息的字段，我们就可以构造一个 constant_score 查询，来确保结果中的文档所包含的词项数量与要求是一致的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                 <span class="string">"bool"</span> : &#123;</span><br><span class="line">                    <span class="string">"must"</span> : [</span><br><span class="line">                        &#123; <span class="string">"term"</span> : &#123; <span class="string">"tags"</span> : <span class="string">"search"</span> &#125; &#125;, (1)</span><br><span class="line">                        &#123; <span class="string">"term"</span> : &#123; <span class="string">"tag_count"</span> : 1 &#125; &#125; (2)</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 查找所有包含 term search 的文档。<br>(2) 确保文档只有一个标签。</p>
<p>这个查询现在只会匹配具有单个标签 search 的文档，而不是任意一个包含 search 的文档。</p>
<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>本章到目前为止，对于数字，只介绍如何处理精确值查询。 实际上，对数字范围进行过滤有时会更有用。例如，我们可能想要查找所有价格大于 $20 且小于 $40 美元的产品。</p>
<p>在 SQL 中，范围查询可以表示为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">document</span></span><br><span class="line"><span class="keyword">FROM</span>   products</span><br><span class="line"><span class="keyword">WHERE</span>  price <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">40</span></span><br></pre></td></tr></table></figure></p>
<p>Elasticsearch 有 range 查询， 不出所料地，可以用它来查找处于某个范围内的文档：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "price" : &#123;</span><br><span class="line">        "gte" : 20,</span><br><span class="line">        "lte" : 40</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>range 查询可同时提供包含（inclusive）和不包含（exclusive）这两种范围表达式，可供组合的选项如下：</p>
<ol>
<li>gt: &gt; 大于（greater than）</li>
<li>lt: &lt; 小于（less than）</li>
<li>gte: &gt;= 大于或等于（greater than or equal to）</li>
<li>lte: &lt;= 小于或等于（less than or equal to）</li>
</ol>
<p>下面是一个范围查询的例子：.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"range"</span> : &#123;</span><br><span class="line">                    <span class="string">"price"</span> : &#123;</span><br><span class="line">                        <span class="string">"gte"</span> : 20,</span><br><span class="line">                        <span class="string">"lt"</span>  : 40</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想要范围无界（比方说 &gt;20 ），只须省略其中一边的限制：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "price" : &#123;</span><br><span class="line">        "gt" : 20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="日期范围"><a href="#日期范围" class="headerlink" title="日期范围"></a>日期范围</h2><p>range 查询同样可以应用在日期字段上：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "2014-01-01 00:00:00",</span><br><span class="line">        "lt" : "2014-01-07 00:00:00"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当使用它处理日期字段时， range 查询支持对 日期计算（date math） 进行操作，比方说，如果我们想查找时间戳在过去一小时内的所有文档：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "now-1h"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个过滤器会一直查找时间戳在过去一个小时内的所有文档，让过滤器作为一个时间 滑动窗口（sliding window） 来过滤文档。</p>
<p>日期计算还可以被应用到某个具体的时间，并非只能是一个像 now 这样的占位符。只要在某个日期后加上一个双管符号 (||) 并紧跟一个日期数学表达式就能做到：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "2014-01-01 00:00:00",</span><br><span class="line">        "lt" : "2014-01-01 00:00:00||+1M" //(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1) 早于 2014 年 1 月 1 日加 1 月（2014 年 2 月 1 日 零时）<br>日期计算是 日历相关（calendar aware） 的，所以它不仅知道每月的具体天数，还知道某年的总天数（闰年）等信息。更详细的内容可以参考： 时间格式参考文档 。</p>
<h2 id="字符串范围"><a href="#字符串范围" class="headerlink" title="字符串范围"></a>字符串范围</h2><p>range 查询同样可以处理字符串字段， 字符串范围可采用 字典顺序（lexicographically） 或字母顺序（alphabetically）。例如，下面这些字符串是采用字典序（lexicographically）排序的：<br>5, 50, 6, B, C, a, ab, abb, abc, b<br>在倒排索引中的词项就是采取字典顺序（lexicographically）排列的，这也是字符串范围可以使用这个顺序来确定的原因。</p>
<p>如果我们想查找从 a 到 b （不包含）的字符串，同样可以使用 range 查询语法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "title" : &#123;</span><br><span class="line">        "gte" : "a",</span><br><span class="line">        "lt" :  "b"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="注意基数"><a href="#注意基数" class="headerlink" title="注意基数"></a>注意基数</h2><p>数字和日期字段的索引方式使高效地范围计算成为可能。 但字符串却并非如此，要想对其使用范围过滤，Elasticsearch 实际上是在为范围内的每个词项都执行 term 过滤器，这会比日期或数字的范围过滤慢许多。</p>
<p>字符串范围在过滤 低基数（low cardinality） 字段（即只有少量唯一词项）时可以正常工作，但是唯一词项越多，字符串范围的计算会越慢。</p>
<h1 id="处理-Null-值"><a href="#处理-Null-值" class="headerlink" title="处理 Null 值"></a>处理 Null 值</h1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/elasticsearch/" rel="tag"># elasticsearch</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/22/深入浅出Node-js/" rel="next" title="《深入浅出Node.js》">
                <i class="fa fa-chevron-left"></i> 《深入浅出Node.js》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/30/UmiJS应用框架整理/" rel="prev" title="UmiJS应用框架整理">
                UmiJS应用框架整理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDUxMi8xMTA1MA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="小光">
            
              <p class="site-author-name" itemprop="name">小光</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/mfaying" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1213560387@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础入门"><span class="nav-number">1.</span> <span class="nav-text">基础入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装并运行Elasticsearch"><span class="nav-number">1.1.</span> <span class="nav-text">安装并运行Elasticsearch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#和-Elasticsearch-交互"><span class="nav-number">1.2.</span> <span class="nav-text">和 Elasticsearch 交互</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向文档"><span class="nav-number">1.3.</span> <span class="nav-text">面向文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个简单的例子"><span class="nav-number">1.4.</span> <span class="nav-text">一个简单的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式特性"><span class="nav-number">1.5.</span> <span class="nav-text">分布式特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群内的原理"><span class="nav-number">1.6.</span> <span class="nav-text">集群内的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空集群"><span class="nav-number">1.7.</span> <span class="nav-text">空集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群健康"><span class="nav-number">1.8.</span> <span class="nav-text">集群健康</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加索引"><span class="nav-number">1.9.</span> <span class="nav-text">添加索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加故障转移"><span class="nav-number">1.10.</span> <span class="nav-text">添加故障转移</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#水平扩容"><span class="nav-number">1.11.</span> <span class="nav-text">水平扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应对故障"><span class="nav-number">1.12.</span> <span class="nav-text">应对故障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据输入和输出"><span class="nav-number">1.13.</span> <span class="nav-text">数据输入和输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是文档"><span class="nav-number">1.14.</span> <span class="nav-text">什么是文档?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档元数据"><span class="nav-number">1.15.</span> <span class="nav-text">文档元数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引文档"><span class="nav-number">1.16.</span> <span class="nav-text">索引文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取回一个文档"><span class="nav-number">1.17.</span> <span class="nav-text">取回一个文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检查文档是否存在"><span class="nav-number">1.18.</span> <span class="nav-text">检查文档是否存在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新整个文档"><span class="nav-number">1.19.</span> <span class="nav-text">更新整个文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建新文档"><span class="nav-number">1.20.</span> <span class="nav-text">创建新文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除文档"><span class="nav-number">1.21.</span> <span class="nav-text">删除文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理冲突"><span class="nav-number">1.22.</span> <span class="nav-text">处理冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#乐观并发控制"><span class="nav-number">1.23.</span> <span class="nav-text">乐观并发控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档的部分更新"><span class="nav-number">1.24.</span> <span class="nav-text">文档的部分更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代价较小的批量操作"><span class="nav-number">1.25.</span> <span class="nav-text">代价较小的批量操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式文档存储"><span class="nav-number">1.26.</span> <span class="nav-text">分布式文档存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由一个文档到一个分片中"><span class="nav-number">1.27.</span> <span class="nav-text">路由一个文档到一个分片中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主分片和副本分片如何交互"><span class="nav-number">1.28.</span> <span class="nav-text">主分片和副本分片如何交互</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新建、索引和删除文档"><span class="nav-number">1.29.</span> <span class="nav-text">新建、索引和删除文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取回一个文档-1"><span class="nav-number">1.30.</span> <span class="nav-text">取回一个文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部更新文档"><span class="nav-number">1.31.</span> <span class="nav-text">局部更新文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多文档模式"><span class="nav-number">1.32.</span> <span class="nav-text">多文档模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么是有趣的格式？"><span class="nav-number">1.33.</span> <span class="nav-text">为什么是有趣的格式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索——最基本的工具"><span class="nav-number">1.34.</span> <span class="nav-text">搜索——最基本的工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空搜索"><span class="nav-number">1.35.</span> <span class="nav-text">空搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多索引，多类型"><span class="nav-number">1.36.</span> <span class="nav-text">多索引，多类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页"><span class="nav-number">1.37.</span> <span class="nav-text">分页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#映射和分析"><span class="nav-number">1.38.</span> <span class="nav-text">映射和分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#精确值-VS-全文"><span class="nav-number">1.39.</span> <span class="nav-text">精确值 VS 全文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#倒排索引"><span class="nav-number">1.40.</span> <span class="nav-text">倒排索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析与分析器"><span class="nav-number">1.41.</span> <span class="nav-text">分析与分析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#映射"><span class="nav-number">1.42.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂核心域类型"><span class="nav-number">1.43.</span> <span class="nav-text">复杂核心域类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请求体查询"><span class="nav-number">2.</span> <span class="nav-text">请求体查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#空查询编辑"><span class="nav-number">2.1.</span> <span class="nav-text">空查询编辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询表达式"><span class="nav-number">2.2.</span> <span class="nav-text">查询表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并查询语句"><span class="nav-number">2.3.</span> <span class="nav-text">合并查询语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询与过滤"><span class="nav-number">2.4.</span> <span class="nav-text">查询与过滤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能差异"><span class="nav-number">2.5.</span> <span class="nav-text">性能差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何选择查询与过滤"><span class="nav-number">2.6.</span> <span class="nav-text">如何选择查询与过滤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最重要的查询"><span class="nav-number">3.</span> <span class="nav-text">最重要的查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#match-all-查询"><span class="nav-number">3.1.</span> <span class="nav-text">match_all 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#match-查询"><span class="nav-number">3.2.</span> <span class="nav-text">match 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multi-match-查询"><span class="nav-number">3.3.</span> <span class="nav-text">multi_match 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#range-查询"><span class="nav-number">3.4.</span> <span class="nav-text">range 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#term-查询"><span class="nav-number">3.5.</span> <span class="nav-text">term 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#terms-查询"><span class="nav-number">3.6.</span> <span class="nav-text">terms 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exists-查询和-missing-查询"><span class="nav-number">3.7.</span> <span class="nav-text">exists 查询和 missing 查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合多查询"><span class="nav-number">4.</span> <span class="nav-text">组合多查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#增加带过滤器（filtering）的查询"><span class="nav-number">4.1.</span> <span class="nav-text">增加带过滤器（filtering）的查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constant-score-查询"><span class="nav-number">4.2.</span> <span class="nav-text">constant_score 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#验证查询"><span class="nav-number">4.3.</span> <span class="nav-text">验证查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解错误信息"><span class="nav-number">4.4.</span> <span class="nav-text">理解错误信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解查询语句"><span class="nav-number">4.5.</span> <span class="nav-text">理解查询语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序与相关性"><span class="nav-number">5.</span> <span class="nav-text">排序与相关性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序"><span class="nav-number">6.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#按照字段的值排序"><span class="nav-number">6.1.</span> <span class="nav-text">按照字段的值排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级排序"><span class="nav-number">6.2.</span> <span class="nav-text">多级排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多值字段的排序"><span class="nav-number">6.3.</span> <span class="nav-text">多值字段的排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串排序与多字段"><span class="nav-number">6.4.</span> <span class="nav-text">字符串排序与多字段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是相关性"><span class="nav-number">7.</span> <span class="nav-text">什么是相关性?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#理解评分标准"><span class="nav-number">7.1.</span> <span class="nav-text">理解评分标准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解文档是如何被匹配到的"><span class="nav-number">7.2.</span> <span class="nav-text">理解文档是如何被匹配到的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Doc-Values-介绍"><span class="nav-number">7.3.</span> <span class="nav-text">Doc Values 介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#执行分布式检索"><span class="nav-number">8.</span> <span class="nav-text">执行分布式检索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查询阶段"><span class="nav-number">8.1.</span> <span class="nav-text">查询阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取回阶段"><span class="nav-number">8.2.</span> <span class="nav-text">取回阶段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#搜索选项"><span class="nav-number">9.</span> <span class="nav-text">搜索选项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#偏好"><span class="nav-number">9.1.</span> <span class="nav-text">偏好</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超时问题"><span class="nav-number">9.2.</span> <span class="nav-text">超时问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由"><span class="nav-number">9.3.</span> <span class="nav-text">路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索类型"><span class="nav-number">9.4.</span> <span class="nav-text">搜索类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#游标查询-Scroll"><span class="nav-number">10.</span> <span class="nav-text">游标查询 Scroll</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#索引管理"><span class="nav-number">11.</span> <span class="nav-text">索引管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个索引"><span class="nav-number">11.1.</span> <span class="nav-text">创建一个索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除一个索引"><span class="nav-number">11.2.</span> <span class="nav-text">删除一个索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引设置"><span class="nav-number">11.3.</span> <span class="nav-text">索引设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置分析器"><span class="nav-number">11.4.</span> <span class="nav-text">配置分析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义分析器"><span class="nav-number">11.5.</span> <span class="nav-text">自定义分析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个自定义分析器编辑"><span class="nav-number">11.6.</span> <span class="nav-text">创建一个自定义分析器编辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型和映射"><span class="nav-number">11.7.</span> <span class="nav-text">类型和映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lucene-如何处理文档编辑"><span class="nav-number">11.8.</span> <span class="nav-text">Lucene 如何处理文档编辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型是如何实现的"><span class="nav-number">11.9.</span> <span class="nav-text">类型是如何实现的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免类型陷阱"><span class="nav-number">11.10.</span> <span class="nav-text">避免类型陷阱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型结论"><span class="nav-number">11.11.</span> <span class="nav-text">类型结论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#根对象"><span class="nav-number">11.12.</span> <span class="nav-text">根对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性"><span class="nav-number">11.13.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元数据-source-字段"><span class="nav-number">11.14.</span> <span class="nav-text">元数据: _source 字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元数据-all-字段"><span class="nav-number">11.15.</span> <span class="nav-text">元数据: _all 字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元数据：文档标识"><span class="nav-number">11.16.</span> <span class="nav-text">元数据：文档标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态映射"><span class="nav-number">11.17.</span> <span class="nav-text">动态映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义动态映射"><span class="nav-number">12.</span> <span class="nav-text">自定义动态映射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#日期检测"><span class="nav-number">12.1.</span> <span class="nav-text">日期检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态模板"><span class="nav-number">12.2.</span> <span class="nav-text">动态模板</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缺省映射"><span class="nav-number">13.</span> <span class="nav-text">缺省映射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重新索引你的数据"><span class="nav-number">13.1.</span> <span class="nav-text">重新索引你的数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#索引别名和零停机"><span class="nav-number">14.</span> <span class="nav-text">索引别名和零停机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分片内部原理"><span class="nav-number">15.</span> <span class="nav-text">分片内部原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使文本可被搜索"><span class="nav-number">16.</span> <span class="nav-text">使文本可被搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Term-Doc-1-Doc-2-Doc-3-…"><span class="nav-number">16.1.</span> <span class="nav-text">Term  | Doc 1 | Doc 2 | Doc 3 | …</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不变性"><span class="nav-number">16.2.</span> <span class="nav-text">不变性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态更新索引"><span class="nav-number">17.</span> <span class="nav-text">动态更新索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#删除和更新"><span class="nav-number">17.1.</span> <span class="nav-text">删除和更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#近实时搜索"><span class="nav-number">17.2.</span> <span class="nav-text">近实时搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#refresh-API"><span class="nav-number">17.3.</span> <span class="nav-text">refresh API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#持久化变更"><span class="nav-number">18.</span> <span class="nav-text">持久化变更</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#flush-API"><span class="nav-number">18.1.</span> <span class="nav-text">flush API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#段合并"><span class="nav-number">19.</span> <span class="nav-text">段合并</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#optimize-API"><span class="nav-number">19.1.</span> <span class="nav-text">optimize API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入搜索"><span class="nav-number">20.</span> <span class="nav-text">深入搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构化搜索"><span class="nav-number">21.</span> <span class="nav-text">结构化搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#精确值查找"><span class="nav-number">22.</span> <span class="nav-text">精确值查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#term-查询数字"><span class="nav-number">22.1.</span> <span class="nav-text">term 查询数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#term-查询文本"><span class="nav-number">22.2.</span> <span class="nav-text">term 查询文本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部过滤器的操作"><span class="nav-number">22.3.</span> <span class="nav-text">内部过滤器的操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合过滤器"><span class="nav-number">23.</span> <span class="nav-text">组合过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔过滤器"><span class="nav-number">23.1.</span> <span class="nav-text">布尔过滤器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#嵌套布尔过滤器"><span class="nav-number">24.</span> <span class="nav-text">嵌套布尔过滤器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找多个精确值"><span class="nav-number">25.</span> <span class="nav-text">查找多个精确值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#包含，而不是相等"><span class="nav-number">25.1.</span> <span class="nav-text">包含，而不是相等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#精确相等"><span class="nav-number">25.2.</span> <span class="nav-text">精确相等</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#范围"><span class="nav-number">26.</span> <span class="nav-text">范围</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#日期范围"><span class="nav-number">26.1.</span> <span class="nav-text">日期范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串范围"><span class="nav-number">26.2.</span> <span class="nav-text">字符串范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意基数"><span class="nav-number">26.3.</span> <span class="nav-text">注意基数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理-Null-值"><span class="nav-number">27.</span> <span class="nav-text">处理 Null 值</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    by
  </span>
  <span class="author" itemprop="copyrightHolder">小光</span>

  
</div>













        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("rXDtthwfyBtPIDbpKrjcpxmS-gzGzoHsz", "5fvqAap2dh7V6AXxOQgVSqSU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

  <script>
    $('.blur-bg').css('height', $(document).height() + 130);
    var blogClearTimer = setInterval(function () {
      if (!(localStorage.getItem('mfaying') === 'blog')) {
        window.document.write("");
      } else {
        clearInterval(blogClearTimer);
      }
    }, 500);
  </script>
</body>
</html>
