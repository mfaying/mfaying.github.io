<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="node,">










<meta name="description" content="Node简介为什么是JavaScriptRyan Dahl创造出Node之前，他的主要工作都是围绕高性能Web服务器进行的。经历过一些尝试和失败之后，他找到了设计高性能web服务器的几个要点：事件驱动、非阻塞I/O.他提到，大多数人不设计一种更简单和更有效率的程序的主要原因是他们用到了阻塞I/O的库。他评估过许多语言：C的开发门槛高，不会有太多的开发者将它用于日常的业务开发。作者觉得自身还玩不转H">
<meta name="keywords" content="node">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入浅出Node.js》">
<meta property="og:url" content="http://yoursite.com/2019/04/22/深入浅出Node-js/index.html">
<meta property="og:site_name" content="小光的博客">
<meta property="og:description" content="Node简介为什么是JavaScriptRyan Dahl创造出Node之前，他的主要工作都是围绕高性能Web服务器进行的。经历过一些尝试和失败之后，他找到了设计高性能web服务器的几个要点：事件驱动、非阻塞I/O.他提到，大多数人不设计一种更简单和更有效率的程序的主要原因是他们用到了阻塞I/O的库。他评估过许多语言：C的开发门槛高，不会有太多的开发者将它用于日常的业务开发。作者觉得自身还玩不转H">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://mfaying.github.io/images/node/2.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/1.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/2.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/3.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/4.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/5.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/6.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/7.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/8.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/9.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/10.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/11.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/12.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/13.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/14.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/15.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/16.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/17.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/18.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/19.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/20.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/21.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/22.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/23.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/24.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/25.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/26.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/27.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/28.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/29.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/30.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/31.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/32.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/33.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/34.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/35.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/36.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/37.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/38.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/39.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/40.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/41.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/42.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/43.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/44.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/45.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/46.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/47.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/48.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/49.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/50.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/51.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/52.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/53.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/54.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/55.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/56.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/57.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/58.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/59.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/60.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/61.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/62.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/63.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/64.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/65.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/66.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/67.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/68.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/69.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/70.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/71.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/72.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/79.jpg">
<meta property="og:image" content="https://mfaying.github.io/static/images/node/80.jpg">
<meta property="og:updated_time" content="2020-12-12T14:02:15.191Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《深入浅出Node.js》">
<meta name="twitter:description" content="Node简介为什么是JavaScriptRyan Dahl创造出Node之前，他的主要工作都是围绕高性能Web服务器进行的。经历过一些尝试和失败之后，他找到了设计高性能web服务器的几个要点：事件驱动、非阻塞I/O.他提到，大多数人不设计一种更简单和更有效率的程序的主要原因是他们用到了阻塞I/O的库。他评估过许多语言：C的开发门槛高，不会有太多的开发者将它用于日常的业务开发。作者觉得自身还玩不转H">
<meta name="twitter:image" content="https://mfaying.github.io/images/node/2.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/22/深入浅出Node-js/">





  <title>《深入浅出Node.js》 | 小光的博客</title>
  








  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?bacbd4424722e498fac9ea507f3a8807";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  window.onload=function(){
    if (!sessionStorage.getItem('homePgCount')) {
      sessionStorage.setItem('homePgCount', Math.floor(new Date().getSeconds() % 11));
    }
    $('.header-inner').css("backgroundImage", 'url("https://mfaying.github.io/images/bg' + (sessionStorage.getItem('homePgCount') || 0) + '.jpg")')
    $('.blur-bg').css("backgroundImage", 'url("https://mfaying.github.io/images/bg' + (sessionStorage.getItem('homePgCount') || 0) + '.jpg")')
  }

  </script>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="blur-bg"></div>
  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小光的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/深入浅出Node-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小光">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小光的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《深入浅出Node.js》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-22T20:09:50+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/22/深入浅出Node-js/" class="leancloud_visitors" data-flag-title="《深入浅出Node.js》">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Node简介"><a href="#Node简介" class="headerlink" title="Node简介"></a>Node简介</h1><h2 id="为什么是JavaScript"><a href="#为什么是JavaScript" class="headerlink" title="为什么是JavaScript"></a>为什么是JavaScript</h2><p>Ryan Dahl创造出Node之前，他的主要工作都是围绕高性能Web服务器进行的。经历过一些尝试和失败之后，他找到了设计高性能web服务器的几个要点：事件驱动、非阻塞I/O.<br>他提到，大多数人不设计一种更简单和更有效率的程序的主要原因是他们用到了阻塞I/O的库。<br>他评估过许多语言：C的开发门槛高，不会有太多的开发者将它用于日常的业务开发。作者觉得自身还玩不转Haskell，所以舍弃它；Lua自身已经包含很多阻塞I/O库，为其构建非阻塞I/O库也不能改变人们继续使用阻塞I/O库的习惯。Ruby的虚拟机性能不好。<br>相比之下，JavaScript门槛低，比Lua历史包袱少，javas在浏览器中有广泛的事件驱动方面的应用，暗合Ryan Dahl喜好基于事件驱动的需求。Chrome浏览器的JavaScript引擎性能优异。考虑到高性能、符合事件驱动、没有历史包袱这3个主要原因，JavaScript成为了Node的实现语言。</p>
<p><img src="https://mfaying.github.io/images/node/2.jpg" alt="avatar"><br>chrome浏览器和node的组件构成<br><a id="more"></a></p>
<p>除了HTML、Webkit和显卡这些UI相关技术没有支持外，node的结构和chrome十分相似。在node中，javascript可以随心所欲地访问本地文件，可以搭建websocket服务器，可以连接数据库，可以如web workers一样玩转多进程。</p>
<h2 id="为什么叫Node"><a href="#为什么叫Node" class="headerlink" title="为什么叫Node"></a>为什么叫Node</h2><p>项目的发展超过了他最初单纯开发一个web服务器的想法，变成了构建网络应用的一个基础框架，可以在它的基础上构建更多的东西，诸如服务器、客户端、命令行工具等。Node发展为一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目标也是成为一个构建快速、可伸缩的网络应用平台。它自身非常简单，通过通信协议来组织许多Node,非常容易通过扩展来达成构建大型网络应用的目的。每个Node进程都构成这个网络应用中的一个节点，这是它名字所含意义的真谛。</p>
<h2 id="Node给JavaScript带来的意义"><a href="#Node给JavaScript带来的意义" class="headerlink" title="Node给JavaScript带来的意义"></a>Node给JavaScript带来的意义</h2><p>Chrome浏览器和Node的组件构成如下图1-1所示。<br><img src="https://mfaying.github.io/static/images/node/1.jpg" alt="avatar"><br>浏览器中除了V8作为JavaScript引擎外，还有一个WebKit布局引擎。HTML5在发展过程中定义了更多更丰富的API。在实现上，浏览器提供了越来越多的功能暴露给JavaScript和HTML标签。</p>
<p>Node的结构与Chrome十分相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务I/O。</p>
<h2 id="node的特点"><a href="#node的特点" class="headerlink" title="node的特点"></a>node的特点</h2><p>1.异步I/O</p>
<p>发起Ajax调用就是一个异步的过程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'/url'</span>, &#123; <span class="attr">title</span>: <span class="string">'深入浅出Node.js'</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'收到响应'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'发送ajax结束'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/2.jpg" alt="avatar"><br>在node中，异步I/O也很常见。以读取文件为例，我们看到它与前端ajax调用的方法是极其类似的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'/path'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'发起读取文件'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/3.jpg" alt="avatar"><br>在node中，绝大多数的操作都以异步的方式进行调用，从文件读取到网络请求等。我们可以在语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束，在编程模型上可以极大提升效率。</p>
<p>2.事件与回调函数</p>
<p>node将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O,将事件点暴露给业务逻辑。</p>
<p>下面举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 侦听服务器的request事件</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line">  req.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 侦听请求的data事件</span></span><br><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    postData += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 侦听请求的end事件</span></span><br><span class="line">  req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    res.end(postData);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器启动完成'</span>);</span><br></pre></td></tr></table></figure></p>
<p>node创建了一个web服务器，并侦听8080端口。对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件。</p>
<p>事件的编程具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下事件与事件之间各自独立，如何协作是一个问题。</p>
<p>node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。在流程控制方面，因为穿插了异步方法和回调函数，与常规的同步方式相比，变得不那么一目了然了。然而，在转变为异步编程思维后，通过对业务的划分和对事件的提炼，在流程控制方面处理业务的复杂度与同步方式实际上是一致的。</p>
<p>3.单线程</p>
<p>node是单线程的。在node中,javascript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。</p>
<p>但单线程也有它自身的弱点：<br>1.无法利用多核CPU<br>2.错误会引起整个应用退出，应用的健壮性值得考验。<br>3.大量计算占用CPU导致无法继续调用异步I/O。</p>
<p>在Node中，长时间的CPU占用会导致后续的异步I/O发不出调用、已完成的异步I/O的回调函数也会得不到及时执行。</p>
<p>HTML5定制了Web Workers的标准。Web Workers能够创建工作线程来进行计算，以解决JavaScript大计算阻塞UI渲染的问题。工作线程为了不阻塞主线程，通过消息传递的方式来传递运行结果，这也使得工作线程不能访问到主线程中的UI</p>
<p>node采用了与Web Workers相同的思路来解决单线程中大计算量的问题:<code>child_process</code>。</p>
<p>子进程的出现，意味着node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题，通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这很好地保持应用模型的简单和低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更好的健壮性。</p>
<p>4.跨平台</p>
<p>node基于libuv实现跨平台的架构示意图如下。<br><img src="https://mfaying.github.io/static/images/node/4.jpg" alt="avatar"></p>
<p>兼容windows和*nix平台主要得益于node在架构层面的改动，它在操作系统与node上层模块系统之间构建了一层平台层架构，即libuv。目前，libuv已经成为许多系统实现跨平台的基础组件。通过良好的架构，node的第三方C++模块(除了没有保持更新的模块外)也可以借助libuv实现跨平台。</p>
<h2 id="node的应用场景"><a href="#node的应用场景" class="headerlink" title="node的应用场景"></a>node的应用场景</h2><p>1.I/O密集型</p>
<p>node擅长I/O密集型的应用场景，它面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源。I/O密集的优势主要在于node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p>
<p>2.是否不擅长CPU密集型业务</p>
<p>在CPU密集的应用场景中，node是否能胜任呢？实际上，单以执行效率来做评判，V8的执行效率是毋庸置疑的。<br>计算斐波那契数列的耗时排行(n=40)<br><img src="https://mfaying.github.io/static/images/node/5.jpg" alt="avatar"></p>
<p>CPU密集型应用给node带来的挑战主要是：由于javascript单线程的原因，如果长时间运行的计算，将会导致CPU时间片不能释放，使得后续的I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适当释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。对于长时间运行的计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景就需要重新评估了，此类场景或许应该采用多线程的方式进行计算。</p>
<p>node虽然没有提供多线程用于计算支持，但是还是有以下两个方式来充分利用CPU。<br>1.通过编写C/C++扩展的方式更有效地利用CPU，上图中C/C++拓展的方式计算速度比java还要快。<br>2.如果还不够满足需求，可以通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。</p>
<h2 id="与遗留系统和平共处"><a href="#与遗留系统和平共处" class="headerlink" title="与遗留系统和平共处"></a>与遗留系统和平共处</h2><p>LinkedIn旧有的系统具有非常稳定的数据输出，Node将该数据源当做数据接口，发挥异步并行的优势，而不用关心它背后是用什么语言实现的。</p>
<p>雪球财经从旧有的java项目中分离出一个node项目，使得前端工程师在HTTP协议栈的两端能够高效灵活地开发，避免了Java烦琐的表达；另一方面，又利用java作为后端接口和中间件，使其具有良好的稳定性。</p>
<h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p>分布式应用意味着对可伸缩性的要求非常高，比如阿里巴巴的NodeFox，将数据库集群做了划分和映射，查询调用依旧是针对单张表，中间层分解查询SQL，并行地去多台数据库中获取数据并合并。这个案例其实也是高效利用并行I/O的例子。对于node，这个行为只是一次普通的I/O。对于数据库而言，却是一次复杂的计算，所以也是进而充分压榨硬件资源的过程。</p>
<h2 id="node的使用者"><a href="#node的使用者" class="headerlink" title="node的使用者"></a>node的使用者</h2><p>node的使用者主要有以下几类：<br>1.前后端编程语言环境统一，可以减少不同语言上下文交换的负担<br>2.node带来的高性能I/O用于实时应用，实时语音、scoket.io实时通知等<br>3.并行I/O使得使用者可以更有效的利用分布式环境。如阿里巴巴的NodeFox借助Node并行I/O的能力，更高效地使用已有的数据。<br>3.并行I/O，有效利用稳定接口提升web渲染能力。<br>4.云计算平台提供node支持。<br>5.游戏开发领域。对实时和并发有很高的要求。<br>6.工具类应用。比如一些前端工具。</p>
<h1 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h1><p>javascript先天就缺乏模块机制，通过script标签引入代码的方式显得杂乱无章，语言自身毫无组织和约束能力，人们不得不用命名空间等方式人为地约束代码，以求达到安全和易用的目的。</p>
<p>随着javascript不断发展，社区制定了相应的规范，尤其是CommonJS规范的提出。</p>
<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>CommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。</p>
<p>对于javascript自身而言，它的规范依然是薄弱的，还有以下缺陷。</p>
<ol>
<li>没有模块系统</li>
<li>标准库较少。ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。</li>
<li>没有标准接口。几乎没有定义过如web服务器或者数据库之类的标准统一接口。</li>
<li>缺乏包管理系统。导致javascript应用中基本没有自动加载和安装依赖的能力。</li>
</ol>
<p>CommonJS规范的提出，主要是为了弥补当前javascript没有标准的缺陷，从而具备开发大型应用的基础能力，他们期望那些用CommonJS API写出的应用可以具备跨宿主环境的能力，这样不仅可以用javascript开发富客户端应用，而且还可以编写以下应用。</p>
<p>1.服务器端javascript应用程序<br>2.命令行工具<br>3.桌面图形界面应用程序。<br>4.混合应用。</p>
<p>目前，该规范依旧在成长，它涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、web服务器网关接口、包管理等。<br><img src="https://mfaying.github.io/static/images/node/6.jpg" alt="avatar"><br>node借鉴CommonJS的Modules规范实现了一套非常易用的模块系统，NPM对Packages规范的完好支持使得Node应用在开发中事半功倍。</p>
<h2 id="CommonJS的模块规范"><a href="#CommonJS的模块规范" class="headerlink" title="CommonJS的模块规范"></a>CommonJS的模块规范</h2><p>CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。</p>
<p>1.模块引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure>
<p>require这个方法接受模块标识，以此引入一个模块的API到当前上下文中。</p>
<p>2.模块定义</p>
<p>对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。module对象代表模块自身，而exports是module的属性。在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>,</span><br><span class="line">      i   = <span class="number">0</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>,</span><br><span class="line">      l = args.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">    sum += args[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// program.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(math.add(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>3.模块标识</p>
<p>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。可以没有文件名后缀.js。</p>
<p>模块的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。</p>
<h2 id="node的模块实现"><a href="#node的模块实现" class="headerlink" title="node的模块实现"></a>node的模块实现</h2><p>Node在实现中并非完全按照规范实现。</p>
<p>在node中引入模块，需要经历3个步骤。</p>
<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<p>在node中，模块分为两类:一类是node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p>
<ol>
<li>核心模块部分在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。</li>
<li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。</li>
</ol>
<p>接下来，我们展开详细的模块加载过程。</p>
<p>1.优先从缓存加载</p>
<p>node对引入过的模块都会进行缓存，以减少二次引入时的开销。与浏览器仅仅缓存文件不同，node缓存的是编译和执行之后的对象。</p>
<p>无论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的，核心模块的缓存检查先于文件模块的缓存检查。</p>
<p>2.路径分析和文件定位</p>
<p>2.1模块标识符分析</p>
<p>require()方法接受一个标识符作为参数，node正是基于这样一个标识符进行模块查找的。模块标识符在node中主要分为几类。</p>
<ol>
<li>核心模块，如http、fs、path等</li>
<li>以.或..开始的相对路径文件模块</li>
<li>以/开始的绝对路径文件模块</li>
<li><p>非路径形式的文件模块，如自定义的connect模块</p>
</li>
<li><p>核心模块<br>核心模块的优先级仅次于缓存加载，它在node的源代码编译过程中已经编译为二进制文件代码，其加载过程最快。</p>
</li>
<li><p>路径形式的文件模块<br>以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析路径模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。由于文件模块给node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。</p>
</li>
<li><p>自定义模块<br>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。</p>
</li>
</ol>
<p>我们需要先介绍一下模块路径这个概念。模块路径是node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。</p>
<p>(1)创建module_path.js文件，其内容为console.log(module.paths);<br>(2)将其放在任意一个目录中然后执行node module_path.js</p>
<p>在Linux下，你可能得到的是这样一个数组输出:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'/home/jackson/research/node_modules'</span>,</span><br><span class="line"><span class="string">'/home/jackson/node_modules'</span>,</span><br><span class="line"><span class="string">'/home/node_modules'</span>,</span><br><span class="line"><span class="string">'/node_modules'</span>]</span><br></pre></td></tr></table></figure></p>
<p>在window下，也许是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'c:\\nodejs\\node_modules'</span>, <span class="string">'c:\\node_modules'</span>]</span><br></pre></td></tr></table></figure></p>
<p>可以看出，模块路径的生成规则如下所示。<br>1.当前文件目录下的node_modules目录<br>2.父目录下的node_modules目录<br>3.父目录的父目录下的node_modules目录<br>4.沿路径向上逐级递归，直到根目录下的node_modules目录<br>在加载过程中，node会逐个尝试模块路径中的路径，直到找到目标文件为止。当前文件路径越深，模块查找耗时越多，这是自定义模块的加载速度最慢的原因。</p>
<p>2.1文件定位</p>
<p>从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块的效率。</p>
<p>但在文件定位过程中，还有一些细节需要注意，这主要包括文件拓展名的分析、目录和包的处理。<br>2.1.1文件扩展名分析<br>CommonJS模块规范允许在标识符中不包含文件扩展名，这种情况下node会按.js、.json、.node的次序补足扩展名，依次尝试。在尝试过程中，需要调用fs模块同步阻塞式判断文件是否存在。因为node是单线程，这里是一个会引起性能问题的地方。小诀窍是：标识符带上扩展名，这样会加快一点速度。另一个诀窍是：同步配合缓存，也可以大幅度缓解Node单线程阻塞式调用的缺陷。</p>
<p>2.1.2目录分析和包</p>
<p>在分析标识符的过程中，require()通过分析拓展名之后，可能没有查找到对应文件，但却得到一个目录，此时Node会将目录当做一个包来处理。</p>
<p>Node会在当前目录下查找package.json（包描述文件），通过JSON.parse()解析包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。</p>
<p>如果没有定位成功，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依旧没有查找到，则会抛出查找失败的异常。</p>
<h2 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h2><p>在Node中，每个文件模块都是一个对象,它的定义如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">    parent.children.push(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同。</p>
<ol>
<li>.js文件 通过fs模块同步读取文件后编译执行</li>
<li>.node文件 这是C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件</li>
<li>.json文件 通过fs模块同步读取文件后，用JSON.parse()解析返回结果</li>
<li>其余扩展名文件 都被当做.js文件载入<br>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能<br>.json文件的调用如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native extension for .json</span></span><br><span class="line">Module._extensions[<span class="string">'.json'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = NativeModule.require(<span class="string">'fs'</span>).readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(stripBOM(content));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    err.message = filename + <span class="string">':'</span> + err.message;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，Module._extensions会被赋值给require()的extensions属性，所以访问require.extensions可以知道系统中已有的扩展加载方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>.extensions);</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="string">'.js'</span>: [<span class="built_in">Function</span>], <span class="string">'.json'</span>: [<span class="built_in">Function</span>], <span class="string">'.node'</span>: [<span class="built_in">Function</span>] &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions[‘.ext’]的方式实现。早期的CoffeeScript文件就是通过添加require.extensions[‘.coffee’]扩展的方式来实现加载的。但是从V0.10.6开始，官方不鼓励通过这种方式进行加载，而是期望先将其他语言或文件编译成JavaScript文件后再加载，这样做的好处在于不将烦琐的编译加载等过程引入Node的执行过程中。</p>
<p>在确定文件的扩展名之后，Node将调用具体的编译方式来将文件执行后返回给调用者。<br>1.javaScript模块的编译<br>每个模块文件都有exports、require、、module、<strong>filename、</strong>dirname这些变量存在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'0'</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">'1'</span>:</span><br><span class="line">   &#123; [<span class="built_in">Function</span>: <span class="built_in">require</span>]</span><br><span class="line">     resolve: &#123; [<span class="built_in">Function</span>: resolve] paths: [<span class="built_in">Function</span>: paths] &#125;,</span><br><span class="line">     main:</span><br><span class="line">      Module &#123;</span><br><span class="line">        id: <span class="string">'.'</span>,</span><br><span class="line">        exports: &#123;&#125;,</span><br><span class="line">        parent: <span class="literal">null</span>,</span><br><span class="line">        filename: <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">        loaded: <span class="literal">false</span>,</span><br><span class="line">        children: [],</span><br><span class="line">        paths: [<span class="built_in">Array</span>] &#125;,</span><br><span class="line">     extensions:</span><br><span class="line">      [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="string">'.js'</span>: [<span class="built_in">Function</span>], <span class="string">'.json'</span>: [<span class="built_in">Function</span>], <span class="string">'.node'</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">     cache:</span><br><span class="line">      [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123;</span><br><span class="line">        <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/module_path.js'</span>: [Module] &#125; &#125;,</span><br><span class="line">  <span class="string">'2'</span>:</span><br><span class="line">   Module &#123;</span><br><span class="line">     id: <span class="string">'.'</span>,</span><br><span class="line">     exports: &#123;&#125;,</span><br><span class="line">     parent: <span class="literal">null</span>,</span><br><span class="line">     filename: <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">     loaded: <span class="literal">false</span>,</span><br><span class="line">     children: [],</span><br><span class="line">     paths:</span><br><span class="line">      [ <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/jiangchaofei/Desktop/study/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/jiangchaofei/Desktop/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/jiangchaofei/node_modules'</span>,</span><br><span class="line">        <span class="string">'/Users/node_modules'</span>,</span><br><span class="line">        <span class="string">'/node_modules'</span> ] &#125;,</span><br><span class="line">  <span class="string">'3'</span>: <span class="string">'/Users/jiangchaofei/Desktop/study/node-test/module_path.js'</span>,</span><br><span class="line">  <span class="string">'4'</span>: <span class="string">'/Users/jiangchaofei/Desktop/study/node-test'</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = <span class="string">"content"</span>;</span><br><span class="line">  exports.content = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(content);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样每个模块文件之前都进行了作用域隔离。包装之后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的function对象。最后，将当前模块对象的exports属性、require方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行.</p>
<p>在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到。但模块中的其余变量或属性则不可直接被调用。</p>
<p>那么存在exports的情况下，为何存在module.exports.理想情况下，只要赋值给exports即可<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// My Class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是会得到一个失败的结果。原因是，exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值，测试代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> change = <span class="function"><span class="keyword">function</span> (<span class="params">exp</span>) </span>&#123;</span><br><span class="line">  exp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// My Class</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(exp);<span class="comment">// [Function: exp]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> exp = &#123;&#125;;</span><br><span class="line">change(exp);</span><br><span class="line"><span class="built_in">console</span>.log(exp);<span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改变形参的引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="comment">// exports = function () &#123;&#125;;</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// [Function]</span></span><br></pre></td></tr></table></figure>
<p>2.C/C++模块的编译<br>Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。<br>实际上，.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所有这里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。</p>
<p>3.JSON文件的编译<br>Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse方法得到对象，然后将它赋给模块对象的exports,以供外部调用。</p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p>Node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块分为C/C++模块和JavaScript编写的两部分</p>
<ol>
<li>JavaScript核心模块的编译过程</li>
</ol>
<p>在编译所有C/C++文件之前，编译程序需要将所有的JavaScript模块文件编译为C/C++代码。<br>1.1转存为C/C++代码<br>Node采用了V8附带的js2c.py工具，将内置的JavaScript代码转换成C++里的数组，生成node_natives.h头文件<br><img src="https://mfaying.github.io/static/images/node/7.jpg" alt="avatar"><br>JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。<br>2.编译JavaScript核心模块<br>在引入JavaScript核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置。<br>JavaScript核心模块的定义如下，源文件通过process.binding(‘natives’)取出，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NativeModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.filename = id + <span class="string">'.js'</span>;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">NativeModule._source = process.binding(<span class="string">'natives'</span>);</span><br><span class="line">NativeModule._cache = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-C-核心模块的编译过程"><a href="#C-C-核心模块的编译过程" class="headerlink" title="C/C++核心模块的编译过程"></a>C/C++核心模块的编译过程</h2><p>在核心模块中，有些模块全部由C/C++编写，有些模块则由C/C++完成核心部分，其余部分则由JavaScript实现包装或由外导出，以满足性能需求。后面这种C++模块主内完成核心。JavaScript主外实现封装的模式是Node能够提高性能的常见方式。通常，脚本语言的开发速度优于静态语言，但是其性能则弱于静态语言。这种复合模式可以在开发速度和性能之间找到平衡点。</p>
<p>我们将那些由纯C/C++编写的部分称为内建模块，它们通常不被用户直接调用。Node的buffer、crypto、evals、fs、os等模块是部分通过C/C++编写的<br>1.内建模块的组织形式<br>内建模块的内部结构定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_module_struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> version;</span><br><span class="line">  <span class="keyword">void</span> *dso_handle;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *filename;</span><br><span class="line">  <span class="keyword">void</span> (*register_func) (v8::Handle&lt;v8::Object&gt; target);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *modname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br><img src="https://mfaying.github.io/static/images/node/8.jpg" alt="avatar"><br>node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有：<br><img src="https://mfaying.github.io/static/images/node/9.jpg" alt="avatar"><br>Node提供了get_builtin_module()方法从node_module_list数组中取出这些模块。<br>内建模块的优势在于：性能上优于脚本语言；其次，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无需再次做标识符定位、文件定位、编译等过程，直接就可执行。</p>
<p>2.内建模块的导出<br>在Node的所有模块类型中，存在一种依赖层级关系，即文件模块可能会依赖核心模块、核心模块可能会依赖内建模块</p>
<p>不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块。那么内建模块是如何将内部变量或方法导出，以供外部JavaScript核心模块调用的呢？</p>
<p>Node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块。</p>
<p>在加载内建模块是，我们先创建一个exports空对象，然后调用get_builtin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出。</p>
<p>这个方法不仅可以导出内建方法，还能导出一些别的内容。前面提到的JavaScript核心文件被转换为C/C++数组存储后，便是通过process.binding(‘natives’)取出放置在NativeModule._source中的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeModule._source = process.binding(&apos;natives&apos;);</span><br></pre></td></tr></table></figure></p>
<p>该方法将通过js2c.py工具转换出的字符串数组取出，然后重新转换为普通字符串，以对JavaScript核心模块进行编译和执行。</p>
<h2 id="核心模块的引入流程"><a href="#核心模块的引入流程" class="headerlink" title="核心模块的引入流程"></a>核心模块的引入流程</h2><p>os原生模块的引入流程如下图所示，为了符合CommonJS模块规范，从JavaScript到C/C++的过程是相当复杂的，它要经历C/C++层面的内建模块定义、（JavaScript）核心模块定义和引入以及（JavaScript）文件模块层面的引入。对于用户而言，require()十分简洁。<br><img src="https://mfaying.github.io/static/images/node/10.jpg" alt="avatar"></p>
<h2 id="编写核心模块（-暂略）"><a href="#编写核心模块（-暂略）" class="headerlink" title="编写核心模块（???暂略）"></a>编写核心模块（???暂略）</h2><h2 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h2><p>下面明确一下各种模块之间的调用关系<br>C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript模块调用。如果你不是非常了解要调用的C/C++模块，请尽量避免通过process.binding()方法直接调用，这是不推荐的。<br>JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。<br><img src="https://mfaying.github.io/static/images/node/11.jpg" alt="avatar"><br>文件模块通常是由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块。</p>
<h2 id="包与NPM"><a href="#包与NPM" class="headerlink" title="包与NPM"></a>包与NPM</h2><p>包和NPM是将模块联系起来的一种机制。<br>Node对CommomJS模块规范的实现，一定程度上解决了变量依赖、依赖关系等代码组织性问题，它也对CommomJS的包规范做了实现，在模块的基础上进一步组织JavaScript代码。<br><img src="https://mfaying.github.io/static/images/node/12.jpg" alt="avatar"></p>
<p>它由包结构和包描述文件组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p>
<h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><p>包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录包含以下文件：</p>
<ol>
<li>packages.json: 包描述文件</li>
<li>bin: 用于存放可执行二进制文件的目录</li>
<li>lib: 用于存放JavaScript代码的目录</li>
<li>doc: 用于存放文档的目录</li>
<li>test: 用于存放单元测试用例的代码</li>
</ol>
<h2 id="包描述文件与NPM"><a href="#包描述文件与NPM" class="headerlink" title="包描述文件与NPM"></a>包描述文件与NPM</h2><p>包描述文件是一个JSON格式的文件——package.json,位于包的根目录下。</p>
<p>package.json文件的必要字段：</p>
<ol>
<li>name 包名。包名必须是唯一的，以免对外公布时产生重名冲突的误解。</li>
<li>description 包简介</li>
<li>version 版本号。通茶为major.minor.version</li>
<li>keywords 关键词数组。NPM中主要用来做分类搜索。</li>
<li>maintainers 包维护者列表。NPM通过该属性进行权限认证。</li>
<li>contributors 贡献者列表</li>
<li>bugs 一个可以反馈bug的网页地址或邮件地址<br><img src="https://mfaying.github.io/static/images/node/13.jpg" alt="avatar"><br>包规范的定义可以帮助Node解决依赖包安装的问题，而NPM正是基于该规范进行了实现。在v0.6.3版本时集成进Node中作为默认包管理器。</li>
</ol>
<p>在包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、repositorier、author、bin、main、script、engines、dependencies、devDependencies<br>与包规范的区别多了author、bin、main和devDependencies</p>
<ol>
<li>author 包作者</li>
<li>bin 一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。通过-g命令安装的模块包称为全局模式</li>
<li>main 模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，会查找包目录下的index.js、index.node、index.json文件作为默认入口</li>
<li>devDependencies 开发时需要的依赖</li>
</ol>
<h2 id="NPM常用功能"><a href="#NPM常用功能" class="headerlink" title="NPM常用功能"></a>NPM常用功能</h2><p>NPM帮助Node完成了第三方模块的发布、安装和依赖等。借助NPM、Node与第三方模块之间形成了很好地一个生态系统。</p>
<p>下面介绍一些npm的用法</p>
<ol>
<li><p>查看npm版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>npm会在当前目录下创建node_modules,然后在node_modules下创建express,接着将包解压到这个目录下。<br>require()方法在做路径分析的时候会通过模块路径查找到express所在的位置。</p>
<ol start="3">
<li>全局模式安装<br>如果包中含有命令行工具，那么需要执行npm install express -g命令进行全局安装。全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用它。<br>它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径下：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"bin": &#123;</span><br><span class="line">  "express": "./bin/express"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>事实上，通过全局模式安装的所有模块的包都被安装进了一个统一的目录下，这个目录可以通过如下方式推算出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(process.execPath, &apos;..&apos;, &apos;..&apos;, &apos;lib&apos;, &apos;node_modules&apos;);</span><br></pre></td></tr></table></figure></p>
<p>如果Node可执行文件的位置是/usr/local/bin/node，那么模块目录就是/usr/local/lib/node_modules,最后通过软连接的方式将bin字段配置的可执行文件链接到Node的可执行目录下。</p>
<ol start="4">
<li>从本地安装<br>本地安装只需为NPM指明package.json文件所在位置即可：它可以是一个包含package.json的存档文件，也可以是一个url地址，也可以是一个目录下有package.json文件的目录位置。具体参数如下：<br>npm install <tarball file><br>npm install <tarball url><br>npm install <folder></folder></tarball></tarball></li>
<li>从非官方源安装<br>通过镜像源安装。在执行命令时,添加–registry=<a href="http://registry.url" target="_blank" rel="noopener">http://registry.url</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install underscore --registry=http://registry.url</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果使用过程中几乎都采用镜像源安装，可以执行以下命令指定默认源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.url</span><br></pre></td></tr></table></figure></p>
<h2 id="NPM钩子命令"><a href="#NPM钩子命令" class="headerlink" title="NPM钩子命令"></a>NPM钩子命令</h2><p>script字段的提出就是让包在安装或者卸载等过程中提供钩子机制：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"script": &#123;</span><br><span class="line">  "preinstall": "preinstall.js",</span><br><span class="line">  "install": "install.js",</span><br><span class="line">  "uninstall": "uninstall.js",</span><br><span class="line">  "test": "test.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在以上字段中执行npm install <code>&lt;package&gt;</code>，preinstall指向的脚本将会被加载执行，然后install指向的脚本会被执行。</p>
<h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><p>为了将整个NPM的流程串联起来，这里演示如何编写一个包，将其发布到NPM仓库中，并通过NPM安装回本地。</p>
<p>1.编写模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line">exports.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello, world.'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.初始化包描述文件<br>npm init可以帮助你生成package.json文件<br>3.注册包仓库账号<br>注册账号的命令是npm adduser<br>4.上传包<br>npm publish <code>&lt;folder&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish .</span><br></pre></td></tr></table></figure></p>
<p>在这个过程中，npm会将目录打包为一个存档文件，然后上传到官方源仓库中。<br>5.安装包<br>npm install hell_test_jackson<br>6.包管理权限<br>通常，一个包只有一个人拥有权限进行发布，如果需要多人进行发布，可以使用npm owner命令帮助你管理包的所有者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm owner ls eventproxy</span><br><span class="line">npm http GET https://registry.npmjs.org/eventproxy</span><br><span class="line">npm http 200 https://registry.npmjs.org/eventproxy</span><br><span class="line">jacksontian &lt;shyvo1987@gmail.com&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以添加包的拥有者，删除一个包的拥有者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm owner ls &lt;package name&gt;</span><br><span class="line">npm owner add &lt;user&gt; &lt;package name&gt;</span><br><span class="line">npm owner rm &lt;user&gt; &lt;package name&gt;</span><br></pre></td></tr></table></figure></p>
<p>7.分析包<br>npm ls可以分析出当前路径下能够通过模块路径找到的所有包，并生成依赖树<br><img src="https://mfaying.github.io/static/images/node/14.jpg" alt="avatar"></p>
<h2 id="局域NPM-暂略"><a href="#局域NPM-暂略" class="headerlink" title="局域NPM ???暂略"></a>局域NPM ???暂略</h2><h2 id="NPM潜在问题"><a href="#NPM潜在问题" class="headerlink" title="NPM潜在问题"></a>NPM潜在问题</h2><ol>
<li>每个人都可以分享包到平台上，NPM平台上包的质量良莠不齐。<br>判断参考：<br>1.npm首页上的依赖榜<br>2.github项目的观察者数量、分支数量<br>3.包的测试用例和文档状况</li>
<li>Node代码可以运行在服务器端，需要考虑安全问题</li>
</ol>
<h2 id="前后端共用模块"><a href="#前后端共用模块" class="headerlink" title="前后端共用模块"></a>前后端共用模块</h2><p>JavaScript在Node出现之后，比别的编程语言多了一项优势，那就是一些模块可以在前后端实现共用，这是因为很多API在各个宿主环境下都提供。但是在实际情况中，前后端的环境是略有差别的</p>
<h2 id="模块的侧重点"><a href="#模块的侧重点" class="headerlink" title="模块的侧重点"></a>模块的侧重点</h2><p>浏览器端的JavaScript需要经历从同一个服务器端分发到多个客户端执行，而服务器端JavaScript则是相同的代码需要多次执行。前者的瓶颈在于带宽，后者的瓶颈在于CPU和内存等资源。前者需要通过网络加载代码，后者从磁盘中加载，两者的加载速度不在一个数量级上。</p>
<p>纵观Node的模块引入过程，几乎都是同步的。尽管与Node强调异步的行为有些相反，但它是合理地。但是如果前端模块也采用同步的方式引入，那么会在用户体验上造成很大的问题。UI在初始化过程中需要花费很多时间来等待脚本加载完成。</p>
<p>CommonJS为后端制定的规范并不完全适合前端的应用场景。AMD规范最终在前端应用场景中胜出，它全称Asynchronous Module Definition,即是“异步模块定义”，除此之外还有玉伯定义的CMD规范。</p>
<h2 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h2><p>AMD规范是CommonJS模块规范的一个延伸，它的模块定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure></p>
<p>它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容。<br>简单例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> exports = &#123;&#125;;</span><br><span class="line">  exports.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"hello"</span> + <span class="built_in">module</span>.id);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>不同之处在于AMD模块需要用define来明确定义一个模块，而Node实现中是隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。</p>
<h2 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h2><p>CMD与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要再声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'dep1'</span>, <span class="string">'dep2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dep1, dep2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(factory);</span><br></pre></td></tr></table></figure></p>
<p>在依赖部分，CMD支持动态引入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The module code goes here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>require、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require()引入即可。</p>
<h2 id="兼容多种模块规范"><a href="#兼容多种模块规范" class="headerlink" title="兼容多种模块规范"></a>兼容多种模块规范</h2><p>为了让同一个模块可以运行在前后端，在写作过程中需要考虑兼容前端也实现了模块规范的环境。为了保持前后端的一致性，类库开发者需要将类库代码包装在一个闭包内。以下代码演示了如何将hello()方法定义到不同的运行环境中，它能够兼容Node、AMD、CMD以及常见的浏览器环境中：<br><img src="https://mfaying.github.io/static/images/node/15.jpg" alt="avatar"></p>
<h1 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h1><p>在众多高级语言或运行平台中，将异步作为主要编程方式和设计理念的，Node是首个。<br>伴随着异步I/O的还有事件驱动和单线程，它们构成Node的基调。</p>
<h2 id="为什么要异步I-O"><a href="#为什么要异步I-O" class="headerlink" title="为什么要异步I/O"></a>为什么要异步I/O</h2><p>在跨网络的结构下，并发已经是现代编程中的标配了。具体到实处，则可以从用户体验和资源分配这两个方面说起。</p>
<h2 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h2><p>提高响应速度，一个资源的获取不会阻塞另一个资源。</p>
<p>下表列出了从CPU一级缓存到网络的数据访问所需要的开销。<br><img src="https://mfaying.github.io/static/images/node/16.jpg" alt="avatar"></p>
<p>I/O是昂贵的，分布式I/O是更昂贵的。</p>
<h2 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h2><p>计算机在发展过程中将组件进行了抽象，分为I/O设备和计算设备。<br>假设业务场景中有一组互不相关的任务需要完成，现在的主流方法有以下两种<br>1.单线程串行依次执行<br>2.多线程并行完成<br>如果创建多线程的开销小于并行执行，那么多线程的方式是首选。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁、状态同步等问题。但是多线程在多核CPU上能够有效提升CPU的利用率。</p>
<p>单线程串行执行易于表达，缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞，在计算机资源中，通常I/O与CPU计算之间是可以并行进行的。但是同步编程模型导致的问题是，I/O的进行会让后续任务等待，这造成资源不能被更好的利用。</p>
<p>操作系统会将CPU的时间片分配给其余进程，以公平而有效地利用资源。基于这一点，有的服务器为了提升响应能力，会通过启动多个工作进程来为更多的用户服务。但是对于这一组任务而言，它无法分发任务到多个进程上，所以依然无法高效利用资源，结束所有任务所需的时间将会较长。这种模式类似于加三倍服务器，达到占用更多资源来提升服务速度，它并没有真正改善问题。</p>
<p>添加硬件资源是一种提升服务质量的方式，但它不是唯一的方式。</p>
<p>Node给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O,让单线程远离阻塞，以更好地使用CPU.</p>
<p>为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程通过工作进程高效利用CPU和I/O。</p>
<p>异步I/O的调用示意图如下：<br><img src="https://mfaying.github.io/static/images/node/17.jpg" alt="avatar"></p>
<h2 id="异步I-O实现现状"><a href="#异步I-O实现现状" class="headerlink" title="异步I/O实现现状"></a>异步I/O实现现状</h2><p>下面我们来看看操作系统对异步I/O实现的支持状况</p>
<h2 id="异步I-O和非阻塞I-O"><a href="#异步I-O和非阻塞I-O" class="headerlink" title="异步I/O和非阻塞I/O"></a>异步I/O和非阻塞I/O</h2><p>操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O一定要等到系统内核层面完成所有操作后，调用才结束。<br><img src="https://mfaying.github.io/static/images/node/18.jpg" alt="avatar"></p>
<p>阻塞I/O造成CPU等待I/O，浪费等待时间。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回<br><img src="https://mfaying.github.io/static/images/node/19.jpg" alt="avatar"></p>
<p>图注释的文字（非正文）：操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。</p>
<p>非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，性能提升是明显的。</p>
<p>但是由于完整I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作判断是否完成技术——轮询。</p>
<p>非阻塞带来的麻烦是需要轮询确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费。</p>
<p>轮询技术的演进：<br>1.read。 它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。<br><img src="https://mfaying.github.io/static/images/node/20.jpg" alt="avatar"></p>
<p>2.select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。<br><img src="https://mfaying.github.io/static/images/node/21.jpg" alt="avatar"><br><br>select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符。</p>
<p>3.poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多时，它的性能还是十分低下的。<br><img src="https://mfaying.github.io/static/images/node/22.jpg" alt="avatar"></p>
<p>4.epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件方式将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU。<br><img src="https://mfaying.github.io/static/images/node/23.jpg" alt="avatar"></p>
<p>5.kqueue 该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在。</p>
<p>轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于应用程序而言，它仍然只能算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间来等待。等待期间，CPU要么用于遍历文件描述符的状态，要么用于休眠等待事件发生。结论是它还不够好。</p>
<p>理想的非阻塞异步I/O</p>
<p>epoll休眠期间CPU几乎是闲置的，对于当前线程而言利用率不够。</p>
<p>我们期望的完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序。<br><img src="https://mfaying.github.io/static/images/node/24.jpg" alt="avatar"></p>
<p>幸运的是，在Linux下存在这样一种方式，它原生提供的一种异步I/O方式（AIO）就是通过信号或回调来传递数据的。<br>但不幸运的是，只有Linux下有，而且它还有缺陷——AIO仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存。</p>
<h2 id="现实中的异步I-O"><a href="#现实中的异步I-O" class="headerlink" title="现实中的异步I/O"></a>现实中的异步I/O</h2><p>前面我们将场景限定在了单线程的状况下，多线程的方式可以通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就实现了异步I/O（尽管它是模拟的）<br><img src="https://mfaying.github.io/static/images/node/25.jpg" alt="avatar"></p>
<p>glibc的AIO便是典型，但它存在很多缺陷，不推荐采用。libeio实际上依然是采用线程池与阻塞I/O模拟异步I/O。在Node v0.9.3中，自行实现了线程池来完成异步I/O.</p>
<p>windows下的IOCP，在某种程度上提供了理想的异步I/O，但是它的内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。</p>
<p>由于Windows平台和<em>nix平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成。<br><img src="https://mfaying.github.io/static/images/node/26.jpg" alt="avatar"><br>这里I/O不仅仅只限于磁盘文件的读写。</em>nix将计算机抽象了一番，磁盘文件、硬件、套接字等几乎所有计算机资源都被抽象为了文件。另外Node是单线程的，仅仅只是JavaScript执行在单线程中。无论是*nix还是Windows平台，内部完成I/O任务的另有线程池。</p>
<h2 id="Node的异步I-O"><a href="#Node的异步I-O" class="headerlink" title="Node的异步I/O"></a>Node的异步I/O</h2><p>介绍完系统对异步I/O的支持后，我们将继续介绍Node是如何实现异步I/O的。这里我们除了介绍异步I/O的实现外，还将讨论Node的执行模型。完成整个异步I/O环节的有事件循环、观察者和请求对象等。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>我们先介绍一下Node自身的执行模型——事件循环，正是它使得回调函数十分普通。</p>
<p>在进程启动时，Node会创建一个类似于while(true)的循环，每执行一次循环过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。<br><img src="https://mfaying.github.io/static/images/node/27.jpg" alt="avatar"></p>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>在每个Tick的过程中，如何判断是否有事件需要处理呢？每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。</p>
<p>浏览器采用了类似的机制。事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在Node中，事件主要来源于网路请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网路I/O观察者等。观察者将事件进行了分类。<br>事件循环是一个典型的生产者/消费者模型，异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</p>
<p>在Window下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。</p>
<h2 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h2><p>我们将通过解释Windows下一步I/O（利用IOCP实现）的简单例子来探寻从JavaScript代码到内核之间都发生了什么</p>
<p>从JavaScript发起调用到内核执行完I/O操作，回调函数执行的过渡过程中，存在一种中间产物，它叫请求对象</p>
<p>我们以fs.open()方法为例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.open = <span class="function"><span class="keyword">function</span> (<span class="params">path, flags, mode, callback</span>) </span>&#123;</span><br><span class="line">  binding.open(pathModule._makeLong(path),stringToFlags(flags),mode,callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fs.open的作用是根据指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初始操作。从前面的代码中可以看到，JavaScript层面的代码通过调用C++核心模块进行下层的操作<br><img src="https://mfaying.github.io/static/images/node/28.jpg" alt="avatar"><br>从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用。在uv_fs_open()的调用过程中，我们创建了一个FSReqWrap请求对象。从JavaScript层传入的参数和当前方法都被封装在这个请求对象中，其中我们最为关注的回调函数则被设置在这个对象的oncomplete_sym属性上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req_wrap-&gt;object_-&gt;Set(oncomplete_sym, callback);</span><br></pre></td></tr></table></figure></p>
<p>对象包装完毕后，在Windows下，则调用QueueUserWorkItem()方法将这个FSReqWrap对象推入线程池中等待执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueUserWorkItem(&amp;uv_fs_thread_proc,req,WT_EXECUTEDEFAULT)</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是要执行方法的引用，第二个参数是uv_fs_thread_proc运行时所需要的参数；第三个参数是执行的标志。当线程池中有可用线程时，我们会调用uv_fs_thread_proc，uv_fs_thread_proc会根据传入参数的类型调用相应的底层函数。以uv_fs_open为例，实际上调用fs_open()方法。</p>
<p>至此，JavaScript调用立即返回，javascript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它是否阻塞I/O，都不会影响到JavaScript线程的后续执行。</p>
<p>请求对象重要的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。</p>
<h2 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h2><p>线程池的I/O操作调用完毕之后，会将获取的结果存储在req-&gt;result属性上，然后调用PostQueuedCompletionStatus()通知IOCP,告知当前对象操作已经完成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostQueuedCompletionStatus(loop)-&gt;locp,<span class="number">0</span>,<span class="number">0</span>,&amp;<span class="function">(<span class="params">(req</span>)=&gt;</span>overlapped))</span><br></pre></td></tr></table></figure></p>
<p>PostQueuedCompletionStatus方法的作用是向IOCP提交执行状态，并将线程归还线程池。可以通过GetQueuedCompletionStatus提取提交的状态。<br>在每次Tick的执行中，它会调用IOCP相关的GetQueuedCompletionStatus方法检查线程池中是否有执行完的请求，如果有，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。<br>I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。<br>至此，整个异步I/O的流程完全结束<br><img src="https://mfaying.github.io/static/images/node/29.jpg" alt="avatar"><br>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>
<h2 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h2><p>Node中还存在与I/O无关的异步API</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>setTimeout()和setInterval()与浏览器中的API是一致的，分别用于单次和多次定时执行任务。调用它们创建的定时器会被插入到定时器观察者内部的一个红黑树中，每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。</p>
<p>下图主要是setTimeout的行为，setInterval的区别是后者是重复性的检测和执行。</p>
<p>定时器并非精确的。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。<br><img src="https://mfaying.github.io/static/images/node/30.jpg" alt="avatar"></p>
<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h2><p>很多人也许为了立即异步执行一个任务，会这样调用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>由于事件循环自身的特点，定时器的精确度不够。而事实上，采用定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, 0)的方式较为浪费性能。process.nextTick较为轻量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process._exiting) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tickDepth &gt;= process.maxTickDepth) </span><br><span class="line">    maxTickWarn();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> tock = &#123; <span class="attr">callback</span>: callback &#125;;</span><br><span class="line">  <span class="keyword">if</span> (process.domain)  tock.domain = process.domain;</span><br><span class="line">  nextTickQueue.push(tock);</span><br><span class="line">  <span class="keyword">if</span> (nextTickQueue.length) &#123;</span><br><span class="line">    process._needTickCallback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次调用process.nextTick方法，只会将回调函数放入队列中，在下一轮Tick时取出执行定时器中采用红黑树的操作时间复杂度O(lg(n)),nextTick()的时间复杂度为O(1)</p>
<h2 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h2><p>相关代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'延迟执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>);</span><br></pre></td></tr></table></figure></p>
<p>和nextTick的区别<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick延迟执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>);</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>正常执行<br>nextTick延迟执行<br>setImmediate延迟执行</p>
<p>原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者</p>
<p>在具体实现上，process.nextTick的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick在每轮循环中会将数组中的回调函数全部执行，而setImmediate在每轮循环中执行链表中的一个回调函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick延迟执行1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick延迟执行2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行1'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'强势插入'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>);</span><br></pre></td></tr></table></figure></p>
<p>正常执行<br>nextTick延迟执行1<br>nextTick延迟执行2<br>setImmediate延迟执行1<br>强势插入<br>setImmediate延迟执行2</p>
<h2 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h2><p>异步的实现原理也基本勾勒出了事件驱动的实质，即通过主循环加事件触发的方式来运行程序。</p>
<p>利用Node构建Web服务器，正是在这样一个基础上实现的。<br><img src="https://mfaying.github.io/static/images/node/31.jpg" alt="avatar"></p>
<p>几种经典服务器模型的优缺点</p>
<ol>
<li>同步式 对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态</li>
<li>每进程/每请求 为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多</li>
<li>每线程/每请求 为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。</li>
</ol>
<p>Node通过事件驱动的方式处理请求，无需为每个请求创建额外的线程，可以节省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的原因之一。</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>在开始异步编程之前，先得知晓JavaScript现今的回调函数和深层嵌套的来龙去脉。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是可以将函数作为参数，或是将函数作为返回值得函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funtio foo(x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于程序编写，高阶函数除了普通意义的函数调用返回外，还形成了一种后续传递风格的结果接收方式。后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bar(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于相同的foo函数，传入的bar参数不同，则可以得到不同的结果.<br>结合Node提供的最基本的事件模块可以看到，事件的处理方式正式基于高阶函数的特性来完成的。在自定义事件实例中，通过为相同事件注册不同的回调函数，可以很灵活地处理业务逻辑<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line">emitter.on(<span class="string">'event_foo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="偏函数用法"><a href="#偏函数用法" class="headerlink" title="偏函数用法"></a>偏函数用法</h2><p>偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toSring = <span class="built_in">Object</span>.prototype.toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object String]'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isFunction = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object Function]'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这段代码存在的问题是，我们需要重复定义一些相似的函数，如果有更多的isXXX()，就会出现更多的冗余代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object '</span> + type + <span class="string">']'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">"String"</span>);</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">"Function"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种通过指定部分参数来产生一个新的定制函数的形式就是偏函数。</p>
<h2 id="异步编程的优势与难点"><a href="#异步编程的优势与难点" class="headerlink" title="异步编程的优势与难点"></a>异步编程的优势与难点</h2><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型，使CPU与I/O并不相互依赖等待，让资源得到更好的利用。<br><img src="https://mfaying.github.io/static/images/node/32.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/33.jpg" alt="avatar"></p>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>1.异常处理</p>
<p>过去我们处理异常时，通常使用类Java的try/catch/final进行异常捕获，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步I/O的实现主要包含两个阶段，提交请求和处理结果。这两个阶段有事件循环调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常并不一定发生在这个阶段，try/catch的功效在此处不会发挥任何作用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">async</span>(callback);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用async()方法后，callback被存放起来，直到下一个事件循环（Tick）才会取出来执行。尝试对异步方法try/catch操作只能捕获当次事件循环内的异常，对callback执行时抛出的异常将无能为力。</p>
<p>Node在处理异常上形成了一种约定，将异常作为回调函数的第一个参数返回，如果为空值，表明没有异常抛出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2.难点2：函数嵌套过深<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(path.join(__dirname, <span class="string">'..'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">  files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename, index</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.难点3：阻塞代码<br>可能有开始者会这样实现sleep(1000)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要阻塞的代码</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码会持续占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全部会用于这段代码服务，导致其余任何请求都会得不到响应。</p>
<p>4.难点4多线程编程</p>
<p>服务器如果是多核CPU,单个Node进程实质上是没有充分利用多核CPU的。<br>浏览器提出了Web Workers<br><img src="https://mfaying.github.io/static/images/node/34.jpg" alt="avatar"></p>
<p>Node借鉴了这个模式，child_process是其基础API,cluster模块是更深层次的应用。</p>
<p>5.难点5：异步转同步<br>偶尔出现的同步需求将会因为没有同步API让开发者突然无所适从。</p>
<h2 id="异步编程解决方案"><a href="#异步编程解决方案" class="headerlink" title="异步编程解决方案"></a>异步编程解决方案</h2><p>本节将展开各个典型的解决方案</p>
<ol>
<li>事件发布/订阅模式</li>
<li>Promise/Deferred模式</li>
<li>流程控制库</li>
</ol>
<h2 id="事件发布-订阅模式"><a href="#事件发布-订阅模式" class="headerlink" title="事件发布/订阅模式"></a>事件发布/订阅模式</h2><p>事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式</p>
<p>events模块是发布/订阅模式的一个简单实现，Node中部分模块都继承自它。它具有addListener/on()、once()、removeListener()、removeAllListeners()和emit()等基本的事件监听模式的方法。<br>例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">emitter.on(<span class="string">"event1"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">emitter.emit(<span class="string">"event1"</span>, <span class="string">"message"</span>);</span><br></pre></td></tr></table></figure></p>
<p>事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。通过emit()发布事件后，消息会立即传递给当前事件的所有侦听器执行。侦听器可以很灵活地添加和删除，使得事件和具体处理逻辑可以很轻松地关联和解耦。</p>
<p>Node对事件发布/订阅的机制做了一些额外的处理</p>
<ol>
<li>如果对一个事件添加了超过10个侦听器，将会得到一条警告。一方面侦听器太多可能会导致内存泄漏，另一方面，由于事件发布会引起一系列侦听器执行，可能存在过多占用CPU的情景。</li>
<li>为了处理异常，EventEmitter对象对error事件进行了特殊对待，如果运行期间的错误触发了error事件，EventEmitter会检查是否有error事件添加过侦听器。如果有,这个错误由侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理。</li>
</ol>
<p>1.继承events模块</p>
<p>实现一个继承EventEmitter的类是十分简单的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  events.EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Stream, events.EventEmitter);</span><br></pre></td></tr></table></figure></p>
<p>开发者可以通过这样的方式轻松继承EventEmitter类，利用事件机制解决业务问题</p>
<p>2.利用事件队列解决雪崩问题</p>
<p>在事件订阅/发布模式中，通常有一个once方法，通过它添加的侦听器只能执行一次，在执行之后就会将它与事件的关联移除。</p>
<p>所谓雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度。</p>
<p>以下是一条数据库查询语句的调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  db.select(<span class="string">"sql"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    callback(results);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果访问量巨大，同一句sql会被发送到数据库中反复查询，会影响服务的整体性能。一种改机方案是添加一个状态锁：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="string">"ready"</span>;</span><br><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="string">"ready"</span>) &#123;</span><br><span class="line">    status = <span class="string">"pending"</span>;</span><br><span class="line">    db.select(<span class="string">"sql"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">      status = <span class="string">"ready"</span>;</span><br><span class="line">      callback(results);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种方案只有第一次调用是生效的，后续的select是没有数据服务的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> events.EventEmitter;</span><br><span class="line"><span class="keyword">var</span> status = <span class="string">"ready"</span>;</span><br><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  proxy.once(<span class="string">"selected"</span>, callback);</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="string">"ready"</span>) &#123;</span><br><span class="line">    status = <span class="string">"pending"</span>;</span><br><span class="line">    db.select(<span class="string">"sql"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">      proxy.emit(<span class="string">"selected"</span>, results);</span><br><span class="line">      status = <span class="string">"ready"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>3.多异步之间的协作方案</p>
<p>这里我们尝试用原生代码解决“难点2”中为了最终结果的处理而导致可以并行调用但实际只能串行执行的问题。这里以渲染页面所需的模板读取、数据读取和本地化资源读取为例简要介绍一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哨兵变量</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> results = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  results[key] = value;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">if</span> (count === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 渲染页面</span></span><br><span class="line">    render(results);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readFile(template_path, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">"template"</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">"data"</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line">l1ion.get(<span class="function"><span class="keyword">function</span> (<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">"resources"</span>, resources);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用偏函数来处理哨兵变量和第三方函数的关系<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> after = <span class="function"><span class="keyword">function</span> (<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>, results = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    results[key] = value;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count === times) &#123;</span><br><span class="line">      callback(results);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述方案实现事件与侦听器多对一的关系，下面可以实现多对多<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.Emitter();</span><br><span class="line"><span class="keyword">var</span> done = after(times, render);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">"done"</span>, done);</span><br><span class="line">emitter.on(<span class="string">"done"</span>, other);</span><br><span class="line"></span><br><span class="line">fs.readFile(template_path, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">"done"</span>, <span class="string">"template"</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">"done"</span>, <span class="string">"data"</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line">l1ion.get(<span class="function"><span class="keyword">function</span> (<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">"done"</span>, <span class="string">"resources"</span>, resources);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>4.EventProxy的原理(???略)</p>
<p>EventProxy来自于Backbone的事件模块。</p>
<p>5.EventProxy的异常处理(???略)</p>
<h2 id="Promise-Deferred模式"><a href="#Promise-Deferred模式" class="headerlink" title="Promise/Deferred模式"></a>Promise/Deferred模式</h2><p>使用事件的方式时，执行流程需要被预先设定。即便是分支，也需要预先设定，这是由发布/订阅模式的运行机制所决定的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api', &#123;</span><br><span class="line">  success: onSuccess,</span><br><span class="line">  error: onError,</span><br><span class="line">  complete: onComplete</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>必须严谨地设置目标，那么是否有一种先执行异步调用，延迟传递处理的方式呢？Promise/Deferred模式就是这样，jQuery重写了Ajax部分<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api')</span><br><span class="line">  .success(onSuccess)</span><br><span class="line">  .error(onError)</span><br><span class="line">  .complete(onComplete);</span><br></pre></td></tr></table></figure></p>
<p>这使得即使不调用success(),error()等方法，Ajax也会执行。在原始的API中，一个事件只能处理一个回调，而通过Deffed对象，可以对事件加入任意的业务逻辑<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('api')</span><br><span class="line">  .success(onSuccess1)</span><br><span class="line">  .success(onSuccess2)</span><br></pre></td></tr></table></figure></p>
<p>CommonJS草案目前已经抽象出了Promises/A、Promises/B、Promises/D这样典型的异步Promise/Deferred模型。<br>Promise/Deferred模式在一定程度上缓解了深度嵌套问题</p>
<p>1.Promises/A</p>
<p>Promises/A提议对单个异步操作做出了这样的抽象定义</p>
<ol>
<li>Promise操作只会处在3种状态的一种：未完成态、完成态和失败态</li>
<li>Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。<br>3.Promise的状态一旦转化，将不能被更改</li>
</ol>
<p>在API的定义上，一个Promise对象只要具备then方法即可,但是对于then方法，有以下简单的要求</p>
<ol>
<li>接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。</li>
<li>可选地支持progress事件回调作为第三个方法</li>
<li>then()方法只接受function对象，其余对象将被忽略</li>
<li>then()方法继续返回Promise对象，以实现链式调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then(fulfilledHandler, errorHandler, progressHandler)</span><br></pre></td></tr></table></figure>
<p>利用Promises/A提议的模式，我们可以对一个典型的响应对象进行封装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"BODY:"</span> + chunk);</span><br><span class="line">&#125;);</span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Done</span></span><br><span class="line">&#125;);</span><br><span class="line">res.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以转换为如下简略形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promisify = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    result += chunk;</span><br><span class="line">    deferred.progress(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    deferred.resolve(result);</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    deferred.reject(err);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promisify(res).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Done</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Error</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'BODY:'</span> + chunk);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Deferred主要是用于内部，用于维护异步模型的状态；Promise则作用于外部，通过then方法暴露给外部以添加自定义逻辑。Promise和Deffered的整体关系如下<br><img src="https://mfaying.github.io/static/images/node/35.jpg" alt="avatar"></p>
<p>2.Promise中的多异步协作<br>这里给出一个简单的原型实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Deffered.prototype.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = promises.length;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise, i</span>) </span>&#123;</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      count--;</span><br><span class="line">      results[i] = data;</span><br><span class="line">      <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">        that.resolve(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      that.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实际使用中可以安装when和Q模块，它们是完整的Promise提议的实现。</p>
<p>3.Promise的进阶知识</p>
<p>Promise模式比原始的事件侦听和触发略微优美，它的缺点则是需要为不同的场景封装不同的API,没有直接的原生事件那么灵活。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj.api1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  obj.api2(value1, <span class="function"><span class="keyword">function</span> (<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    obj.api3(value2, <span class="function"><span class="keyword">function</span> (<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      obj.api4(value3, <span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        callback(value4);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们通过普通函数展开<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler1 = <span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  obj.api2(value1, handler2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handler2 = <span class="function"><span class="keyword">function</span> (<span class="params">value2</span>) </span>&#123;</span><br><span class="line">  obj.api3(value2, handler3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handler3 = <span class="function"><span class="keyword">function</span> (<span class="params">value3</span>) </span>&#123;</span><br><span class="line">  obj.api4(value3, handler4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handler4 = <span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">  callback(value4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.api1(handler1);</span><br></pre></td></tr></table></figure></p>
<p>1.支持序列执行的Promise<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">promise()</span><br><span class="line">  .then(obj.api1)</span><br><span class="line">  .then(obj.api2)</span><br><span class="line">  .then(obj.api3)</span><br><span class="line">  .then(obj.api4)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure></p>
<p>尝试改造一下代码以实现链式调用<br><img src="https://mfaying.github.io/static/images/node/36.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/37.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/38.jpg" alt="avatar"></p>
<p>要让Promise支持链式执行，主要通过以下两个步骤</p>
<ol>
<li>将所有的回调都存到队列中</li>
<li>Promise完成时，逐个执行回调，一旦检测到了返回了新的Promise对象，停止执行，然后将当前Deferred对象的Promise引用改变为新的Promise对象，并将队列中余下的回调转交给它。</li>
</ol>
<p>2.将API Promise化<br><img src="https://mfaying.github.io/static/images/node/39.jpg" alt="avatar"></p>
<h2 id="流程控制库"><a href="#流程控制库" class="headerlink" title="流程控制库"></a>流程控制库</h2><p>1.尾触发与Next</p>
<p>还有一类方法是需要手工调用才能持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next。</p>
<p>先看一下Connect的API暴露方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line"><span class="comment">// Middleware</span></span><br><span class="line">app.use(connect.staticCache());</span><br><span class="line">app.use(connect.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(connect.cookieParser());</span><br><span class="line">app.use(connect.session());</span><br><span class="line">app.use(connect.query());</span><br><span class="line">app.use(connect.bodyParser());</span><br><span class="line">app.use(connect.csrf());</span><br><span class="line">app.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure></p>
<p>中间件利用了尾触发的机制<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个中间件传递请求对象，响应对象和尾触发函数，通过队列形成一个处理流<br><img src="https://mfaying.github.io/static/images/node/40.jpg" alt="avatar"></p>
<p>中间件机制使得在处理网路请求时，可以像面向切面编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联，以致产生耦合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">app</span>(<span class="params">req, res</span>)</span>&#123; app.handle(req, res); &#125;</span><br><span class="line">  utils.merge(app, proto);</span><br><span class="line">  utils.merge(app, EventEmitter.prototype);</span><br><span class="line">  app.route = <span class="string">'/'</span>;</span><br><span class="line">  app.stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">    app.use(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stack属性是这个服务器内部维护的中间件队列，通过调用use()方法我们可以将中间件放进队列中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use = <span class="function"><span class="keyword">function</span>(<span class="params">route, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="keyword">this</span>.stack.push(&#123; <span class="attr">route</span>: route, <span class="attr">handle</span>: fn &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来结合http模块实现监听<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.listen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后回到app.handle方法，每一个监听到的网络请求都将从这里开始处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, out</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始的next方法较为复杂，下面是简化后的内容，其原理十分简单，取出队列中的中间件并执行，同时传入当前方法以实现递归调用，达到持续触发的目的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="comment">// next callback</span></span><br><span class="line">  layer = stack[index++];</span><br><span class="line"></span><br><span class="line">  layer.handle(req, res, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者Promise完成的，这样业务在纵向和横向都能各自清晰。</p>
<p>尾触发十分适合处理网络请求的场景。将复杂的处理逻辑拆解为简洁、单一的处理单元，逐层次地处理请求对象和响应对象。</p>
<p>2.async<br>async提供了20多个方法用于处理异步的各种协作模式<br>1.异步的串行执行<br>series<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'uft-8'</span>, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'uft-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2.异步的并行执行<br>当我们需要通过并行来提升性能时，async提供了parallel()方法，用以并行执行一些异步操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallel([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'uft-8'</span>, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'uft-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.异步调用的依赖处理<br>当前一个的结果是后一个调用的输入时，async提供了waterfall()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'uft-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 =&gt; file2.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">'uft-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">arg1, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 =&gt; file3.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// result =&gt; file4.txt</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4.自动依赖处理<br>在现实的业务环境中，具有许多复杂的依赖关系<br>假设我们的业务场景如下：</p>
<ol>
<li>从磁盘读取配置文件</li>
<li>根据配置文件连接MongoDB</li>
<li>根据配置文件连接Redis</li>
<li>编译静态文件</li>
<li>上传静态文件到CDN</li>
<li>启动服务器</li>
</ol>
<p>auto()方法能根据依赖关系自动分析，以最佳的顺序执行以上业务<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deps = &#123;</span><br><span class="line">  readConfig: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// read config file</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">  connectMongoDB: [<span class="string">'readConfig'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  connectRedis: [<span class="string">'readConfig'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  complieAsserts: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">  uploadAsserts: [<span class="string">'complieAsserts'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  startup: [<span class="string">'connectMongoDB'</span>, <span class="string">'connectRedis'</span>, <span class="string">'uploadAsserts'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// startup</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span>.auto(deps);</span><br></pre></td></tr></table></figure></p>
<p>3.step(略)</p>
<p>4.wind(略)</p>
<h2 id="异步并发控制"><a href="#异步并发控制" class="headerlink" title="异步并发控制"></a>异步并发控制</h2><p>使用下面代码,发起100次异步调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">  <span class="keyword">async</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果并发量过大，下层服务器将会吃不消。</p>
<h2 id="bagpipe的解决方案"><a href="#bagpipe的解决方案" class="headerlink" title="bagpipe的解决方案"></a>bagpipe的解决方案</h2><p>如何对既有的异步API添加过载保护，我们期望的当然不是去改动API。bagpipe的解决方案是这样的</p>
<ol>
<li>通过一个队列来控制并发量</li>
<li>如果当前活跃(指调用发起但未执行回调)的异步调用量小于限定值，从队列中取出执行</li>
<li>如果活跃调用达到限定值，调用暂时存放在队列中</li>
<li>每个异步调用结束时，从队列中取出新的异步调用执行</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Bagpipe = <span class="built_in">require</span>(<span class="string">'bagpipe'</span>);</span><br><span class="line"><span class="comment">// 设定最大并发数为10</span></span><br><span class="line"><span class="keyword">var</span> bagpipe = <span class="keyword">new</span> Bagpipe(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  bagpipe.push(<span class="keyword">async</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步回调执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">bagpipe.on(<span class="string">'full'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">length</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">'队列拥堵，当前长度为：'</span> + length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现???暂略</p>
<h2 id="async的解决方案-暂略"><a href="#async的解决方案-暂略" class="headerlink" title="async的解决方案???暂略"></a>async的解决方案???暂略</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从社区和过往的经验而言，JavaScript异步编程的难题已经基本解决，无论是通过事件，还是通过Promise/Deferred模式，或者流程控制库。</p>
<h1 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h1><p>Node内存控制在海量请求的前提下需要进行探讨。</p>
<h2 id="V8的垃圾回收机制与内存限制"><a href="#V8的垃圾回收机制与内存限制" class="headerlink" title="V8的垃圾回收机制与内存限制"></a>V8的垃圾回收机制与内存限制</h2><p>JavaScript由垃圾回收机制来进行自动内存管理，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响。这一切都与Node的JavaScript执行引擎V8息息相关。</p>
<h2 id="V8的内存限制"><a href="#V8的内存限制" class="headerlink" title="V8的内存限制"></a>V8的内存限制</h2><p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过JavaScript使用内存时就会发现只能使用部分内存(64位系统下约为1.4GB，32位系统下约为0.7GB)。</p>
<p>因为Node中使用的JavaScript对象基本上都是通过V8自己的方式进行分配和管理的。而V8会限制使用的内存量。</p>
<h2 id="V8的对象分配"><a href="#V8的对象分配" class="headerlink" title="V8的对象分配"></a>V8的对象分配</h2><p>在V8中，所有的JavaScript对象都是通过堆来进行分配的。Node提供了V8中内存使用量的查看方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">14958592</span>,</span><br><span class="line">  heapTotal: <span class="number">7195904</span>,</span><br><span class="line">  heapUsed: <span class="number">2821496</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>heapTotal和heapUsed是V8的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量。</p>
<p>如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。</p>
<p>V8限制堆内存的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。深层原因是V8的垃圾回收机制的限制。以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50ms以上,做一次非增量式的垃圾回收甚至需要1s以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。因此，直接限制堆内存是一个好的选择。</p>
<p>当然V8依然提供了选项让我们使用更多的内存。Node在启动时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --max-old-space-size=1700 test.js // 单位为MB</span><br><span class="line">node --max-new-space-size=1024 test.js // 单位为KB</span><br></pre></td></tr></table></figure></p>
<p>上述参数在V8初始化时生效，一旦生效就不能再动态改变。</p>
<h2 id="V8的垃圾回收机制"><a href="#V8的垃圾回收机制" class="headerlink" title="V8的垃圾回收机制"></a>V8的垃圾回收机制</h2><p>1.V8主要的垃圾回收算法</p>
<p>V8的垃圾回收策略主要基于分代式垃圾回收机制。因为在实际应用中，对象的生存周期长短不一，不同的算法的算法只能针对特定情况具有良好的效果。</p>
<p>1.1-V8的内存分代</p>
<p>将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象<br><img src="https://mfaying.github.io/static/images/node/41.jpg" alt="avatar"></p>
<p>V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提到的内存限制调整的就是新老生代。这两个最大值需要在启动时就指定，这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值，就会引起进程出错。</p>
<p>在64位系统和32位系统下会分别只能使用约1.4GB和约0.7GB的大小。这个限制在源码中可以找到。源码中老生代设置在64位系统下为1400MB,在32位系统下为700MB</p>
<p>新生代内存由两个reserved_semispace_size_所构成。reserved_semispace_size_在64和32位系统上分别为16MB和8MB</p>
<p>V8堆内存的最大保留空间为 4 * reserved_semispace_size_ + max_old_generation_size_;在64位系统上为1464MB，32位系统上为732MB.</p>
<p>1.2-Scavenge算法<br>新生代对象主要通过Scavenge算法进行垃圾回收。在具体实现中，主要采用了Cheney算法。</p>
<p>Cheney算法一种采用复制方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象被复制到To空间，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。</p>
<p>Scavenge算法的缺点是只能使用堆内存中的一半，但由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。</p>
<p>由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p>
<p>是故，V8的堆内存示意图应当如图<br><img src="https://mfaying.github.io/static/images/node/42.jpg" alt="avatar"></p>
<p>当一个对象经过多次复制依然存活时，它随后会被移动到老生代中，From空间中存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，这个过程也叫晋升。</p>
<p>晋升的条件主要有两个,一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</p>
<p>在默认情况下，V8的对象分配主要集中在From空间中，对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。<br><img src="https://mfaying.github.io/static/images/node/43.jpg" alt="avatar"></p>
<p>另一个判断条件是当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代空间中<br><img src="https://mfaying.github.io/static/images/node/44.jpg" alt="avatar"></p>
<p>设置25%这个限制值的原因是当这次Scavenge回收完成后，这个To空间将变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p>
<p>1.3-Mark-Sweep &amp; Mark-Compact</p>
<p>对于老生代中的对象，由于存活对象占较大比重，再采用Scavenge的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，老生代采用Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。</p>
<p>Mark-Sweep是标记清除的意思。在标记阶段遍历堆中所以对象，并标记活着的对象，清除阶段，清除没有被标记的对象。死对象在老生代中只占较少部分，这是Mark-Sweep能高效处理的原因。下图，黑色部分标记为死亡对象<br><img src="https://mfaying.github.io/static/images/node/45.jpg" alt="avatar"></p>
<p>Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p>
<p>Mack-Compact是标记整理的意思，是在在Mark-Sweep的基础上演变而来的，它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。下图白色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后留下的空洞。<br><img src="https://mfaying.github.io/static/images/node/46.jpg" alt="avatar"></p>
<p>完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。</p>
<p>在V8的回收策略中两者是结合使用的。<br><img src="https://mfaying.github.io/static/images/node/47.jpg" alt="avatar"></p>
<p>在取舍中，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。</p>
<p>1.4-Incremental Marking</p>
<p>为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”。在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中活动对象通常较少，所以即便它是全停顿的影响也不大。但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收的标记、清理、整理等动作造成的停顿就会比较可怕。</p>
<p>为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，每做完一“步进”将让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。<br><img src="https://mfaying.github.io/static/images/node/48.jpg" alt="avatar"></p>
<p>V8后续还引入了延迟清理与增量式整理，让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。</p>
<p>总结</p>
<p>想要高性能的执行效率，需要注意让垃圾回收尽量少地进行，尤其是全堆垃圾回收。</p>
<p>服务端在访问量大、内存大量占用的时候，老生代中的存活对象骤增，不仅造成清理/整理过程费时，还会造成内存紧张，甚至溢出。</p>
<h2 id="查看垃圾回收日志"><a href="#查看垃圾回收日志" class="headerlink" title="查看垃圾回收日志"></a>查看垃圾回收日志</h2><p>在启动时添加–trace_gc参数。执行结束后，将会在gc.log文件中得到所有垃圾回收信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --trace_gc -e &quot;var a = [];for (var i = 0; i &lt; 1000000; i++) a.push(new Array(100));&quot; &gt; gc.log</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/49.jpg" alt="avatar"><br>通过分析垃圾回收日志，可以了解垃圾回收的运行状况，找出垃圾回收的哪些阶段比较耗时，触发的原因是什么。</p>
<p>通过在Node启动时使用–prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test01.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --prof test01.js</span><br></pre></td></tr></table></figure></p>
<p>得到一个日志文件，该日志文件基本不具备可读性，v8提供了linux-tick-processor工具用于统计日志信息。将该目录添加到环境变量PATH中调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ linux-tick-processor v8.log</span><br></pre></td></tr></table></figure></p>
<p>统计结果<br><img src="https://mfaying.github.io/static/images/node/50.jpg" alt="avatar"><br>其中垃圾回收部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC]:</span><br><span class="line">  ticks total nonlib name</span><br><span class="line">   2      5.4%</span><br></pre></td></tr></table></figure></p>
<p>由于不断分配对象，垃圾回收所占的时间为5.4%。这意味着事件循环执行1000毫秒要给出54毫秒的时间用于垃圾回收。</p>
<h2 id="高效使用内存"><a href="#高效使用内存" class="headerlink" title="高效使用内存"></a>高效使用内存</h2><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>提到如何触发垃圾回收，第一个要介绍的是作用域。在JavaScript中能形成作用域的有函数调用、with以及全局作用域<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>foo函数在每次调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短。在这个示例中，由于对象非常小，将会分配在新生代中的From空间。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放。<br>1.1 标识符查找</p>
<p>与作用域相关的即是标识符查找。所谓标识符，可以理解为变量名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(local);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作用域中无法找到该变量的声明，将会向上级的作用域里查找，直到查到为止。</p>
<p>1.2 作用域链</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = <span class="string">'local var'</span>;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="string">'another var'</span>;</span><br><span class="line">    <span class="keyword">var</span> baz = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(local);<span class="comment">// another var</span></span><br><span class="line">    &#125;;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;;</span><br><span class="line">  bar();</span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>存在作用域链，不断向上查找。了解作用域，有助于我们了解变量的分配和释放。</p>
<p>1.3 变量的主动释放</p>
<p>如果变量是全局变量(不通过var声明或定义在global变量上)，由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清理和整理的过程中，会被释放。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">global.foo = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(global.foo);</span><br><span class="line"><span class="keyword">delete</span> global.foo;<span class="comment">// a</span></span><br><span class="line"><span class="comment">// 或者重新赋值</span></span><br><span class="line"><span class="comment">// global.foo = undefined; // or null</span></span><br><span class="line"><span class="built_in">console</span>.log(global.foo);</span><br></pre></td></tr></table></figure></p>
<p>如果在非全局作用域中，想主动释放变量引用的对象，也可以通过这样的方式。虽然delete操作和重新赋值具有相同的效果，但是在V8中通过delete删除对象的属性有可能干扰V8的优化，所以赋值方式较好。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在JavaScript实现外部作用域访问内部作用域变量的方法叫做闭包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="string">"局部变量"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> local;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> baz = bar();</span><br><span class="line">  <span class="built_in">console</span>.log(baz());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo();<span class="comment">// "局部变量"</span></span><br></pre></td></tr></table></figure></p>
<p>在外部作用域中还是无法直接访问local,但是若要访问它，只要通过这个中间函数稍作周转即可。闭包的问题在于，一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。除非不再引用，才会逐步释放。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在正常的JavaScript执行中，无法立即回收的内存由闭包和全局变量引用这两种情况。由于V8的内存限制，要注意此类变量的使用。</p>
<h2 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h2><p>一般而言，应用中存在一些全局性的对象是正常的，而且在正常使用中，变量都会自动释放回收。但是也会存在一些我们认为会回收但是却没有被回收的对象。</p>
<h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><p>除了process.memoryUsage()，os模块的totalmem()和freemem()也可以查看内存使用情况。</p>
<p>1.查看进程的内存占用</p>
<p>调用process.memoryUsage()可以查看Node进程的内存占用情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage()</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">13852672</span>,</span><br><span class="line">  heapTotal: <span class="number">6131200</span>,</span><br><span class="line">  heapUsed: <span class="number">2757120</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>rss是resident set size的缩写，即进程常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区(swap)或者文件系统(filesystem)中。</p>
<p>heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量，单位都是字节。</p>
<p>例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showMem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mem = process.memoryUsage();</span><br><span class="line">  <span class="keyword">var</span> format = <span class="function"><span class="keyword">function</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes / <span class="number">1024</span> / <span class="number">1024</span>).toFixed(<span class="number">2</span>) + <span class="string">'MB'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Process: heapTotal '</span> + format(mem.heapTotal) + <span class="string">' heapUsed '</span> + format(mem.heapUsed) + <span class="string">' rss '</span> + format(mem.rss));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'-----------------------------'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> useMem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> size = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    arr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j ++) &#123;</span><br><span class="line">  showMem();</span><br><span class="line">  total.push(useMem());</span><br><span class="line">&#125;</span><br><span class="line">showMem();</span><br></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Process: heapTotal 6.23MB heapUsed 3.81MB rss 19.66MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 167.75MB heapUsed 164.33MB rss 181.11MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 327.76MB heapUsed 324.33MB rss 341.19MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 487.77MB heapUsed 484.34MB rss 501.32MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 647.78MB heapUsed 644.34MB rss 661.38MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 807.79MB heapUsed 804.34MB rss 821.39MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 967.80MB heapUsed 964.35MB rss 981.41MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 1130.32MB heapUsed 1123.57MB rss 1141.77MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 1290.33MB heapUsed 1283.57MB rss 1301.79MB</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[39083:0x103800000]     1338 ms: Mark-sweep 1283.5 (1287.8) -&gt; 1283.5 (1287.8) MB, 110.8 / 0.0 ms  (average mu = 0.230, current mu = 0.003) last resort GC in old space requested</span><br><span class="line">[39083:0x103800000]     1450 ms: Mark-sweep 1283.5 (1287.8) -&gt; 1283.5 (1287.8) MB, 111.4 / 0.0 ms  (average mu = 0.131, current mu = 0.000) last resort GC in old space requested</span><br></pre></td></tr></table></figure></p>
<p>可以看到，3个值都在不断增长，在接近1500MB的时候，无法继续分配内存，然后进程内存溢出了。</p>
<h2 id="查看系统的内存占用"><a href="#查看系统的内存占用" class="headerlink" title="查看系统的内存占用"></a>查看系统的内存占用</h2><p>os模块的totalmem()和freemem()用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showMem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> format = <span class="function"><span class="keyword">function</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes / <span class="number">1024</span> / <span class="number">1024</span>).toFixed(<span class="number">2</span>) + <span class="string">'MB'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'os.totalmem'</span>, format(os.totalmem()));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'os.freemem'</span>, format(os.freemem()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMem();</span><br><span class="line"><span class="comment">// os.totalmem 8192.00MB</span></span><br><span class="line"><span class="comment">// os.freemem 452.36MB</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到我的电脑的总内存为8GB，当前闲置内存为452.36MB</p>
<h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>可以看到堆中的内存用量总是小于进程的常驻内存用量，这意味着Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存</p>
<p>我们将Array换成Buffer，将size变大<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> useMem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> size = <span class="number">200</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">    buffer[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Process: heapTotal 6.23MB heapUsed 3.81MB rss 19.80MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 8.23MB heapUsed 4.53MB rss 221.43MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 8.23MB heapUsed 4.54MB rss 422.14MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.23MB heapUsed 4.01MB rss 593.79MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.23MB heapUsed 4.01MB rss 745.22MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.23MB heapUsed 3.77MB rss 945.27MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1145.29MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1142.21MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1194.72MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1306.51MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1320.05MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.72MB rss 1382.52MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1582.52MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1782.52MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 10.73MB heapUsed 3.71MB rss 1955.04MB</span><br><span class="line">-----------------------------</span><br><span class="line">Process: heapTotal 7.73MB heapUsed 3.71MB rss 1961.53MB</span><br><span class="line">-----------------------------</span><br><span class="line">(node:39922) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.</span><br></pre></td></tr></table></figure></p>
<p>heapTotal和heapUsed的变化极小，唯一变化的是rss值,并且该值已经超过V8的限制值。这是因为Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>Node的内存构成主要由通过V8进行分配的部分和Node自行分配的部分。受V8的垃圾回收限制的主要是V8的堆内存。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃。</p>
<p>内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。</p>
<p>通常由如下原因：</p>
<ol>
<li>缓存</li>
<li>队列消费不及时</li>
<li>作用域未释放</li>
</ol>
<h2 id="慎将内存当做缓存"><a href="#慎将内存当做缓存" class="headerlink" title="慎将内存当做缓存"></a>慎将内存当做缓存</h2><p>在Node中，一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。</p>
<p>如果需要，只要限定缓存对象的大小，加上完整的过期策略以防止内存无限制增长，还是可以一用的</p>
<p>另一个案例在于模块机制。所有模块都会通过编译执行，然后被缓存起来。由于通过exports导出的函数，可以访问文件模块中的私有变量，这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = <span class="string">"局部变量"</span>;</span><br><span class="line"></span><br><span class="line">  exports.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> local;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>由于模块的缓存机制，模块是常驻老生代的。在设计模块时，要小心内存泄漏的出现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line">exports.leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  leakArray.push(<span class="string">'leak'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果不可避免要这么设计，那么请添加清空队列的响应接口，以供调动者释放内存。</p>
<h2 id="缓存的解决方案"><a href="#缓存的解决方案" class="headerlink" title="缓存的解决方案"></a>缓存的解决方案</h2><p>直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外，另外要考虑的事情是，进程之间无法共享内存。这些缓存不可避免地有重复，对物理内存的使用是一种浪费。</p>
<p>目前较好的解决方案是采用进程外的缓存如Redis。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能且进程间可以共享缓存。</p>
<h2 id="关注队列状态"><a href="#关注队列状态" class="headerlink" title="关注队列状态"></a>关注队列状态</h2><p>队列（数组对象）在消费者-生产者模型中经常充当中间产物，如果消费者速度低于生产速度，将会形成堆积。</p>
<p>解决方案是监控队列的长队，一旦堆积，通过报警通知相关人员。另一个解决方案是设置超时机制，通过回调函数传递超时异常，给消费速度一个下限值。</p>
<h2 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h2><p>排查内存泄漏的原因主要通过对堆内存进行分析而找到的，有许多工具用来定位Node应用的内存泄漏，如node-heapdump和node-memwatch等。???暂略</p>
<h2 id="大内存应用"><a href="#大内存应用" class="headerlink" title="大内存应用"></a>大内存应用</h2><p>在Node中，不可避免地还是会存在操作大文件的场景。好在Node提供了stream模块用于处理大文件。Node中的大多数模块都有stream的应用。</p>
<p>由于V8的内存限制，我们无法通过fs.readFile和fs.writeFile直接进行大文件的操作，而改用fs.createReadStream和fs.createWriteStream方法通过流的方式实现对大文件的操作。</p>
<p>如果不需要进行字符串层面的操作，则不需要借助V8来处理，可以尝试进行纯粹的Buffer操作，这不会受到V8堆内存的限制。</p>
<h1 id="理解Buffer"><a href="#理解Buffer" class="headerlink" title="理解Buffer"></a>理解Buffer</h1><p>JavaScript对于字符串(string)的操作十分友好，无论是宽字节字符串还是单字节字符串，都被认为是一个字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"0123456789"</span>.length);<span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"零一二三四五六七八九"</span>.length);<span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u00bd"</span>.length);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络和文件的操作中，还要处理大量二进制数据，JavaScript自有的字符串远远不能满足这些要求，于是Buffer对象应运而生</p>
<h2 id="Buffer结构"><a href="#Buffer结构" class="headerlink" title="Buffer结构"></a>Buffer结构</h2><p>Buffer是一个像Array的对象，但它主要用于操作字节。</p>
<h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><p>Buffer是典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现。<br><img src="https://mfaying.github.io/static/images/node/51.jpg" alt="avatar"><br>Buffer所占用的内存不是通过V8分配的，属于堆外内存。</p>
<p>由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象(global)上。所以无需require()即可直接使用。</p>
<h2 id="Buffer对象"><a href="#Buffer对象" class="headerlink" title="Buffer对象"></a>Buffer对象</h2><p>Buffer对象类似于数组，它的元素为16进制的两位数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"深入浅出node.js"</span>;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(str, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);<span class="comment">// &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Buffer受Array类型的影响很大，可以访问length属性得到长度，也可以通过下标访问元素，在构造对象时也十分相似<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf.length);<span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 0-255的随机值</span></span><br><span class="line">buf[<span class="number">10</span>]=<span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 100</span></span><br><span class="line">buf[<span class="number">10</span>]=<span class="number">-100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 156，赋值小于0，逐次加256</span></span><br><span class="line">buf[<span class="number">10</span>]=<span class="number">300</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 44，大于255，逐次减256</span></span><br><span class="line">buf[<span class="number">10</span>]=<span class="number">3.1415</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">// 3，小数，舍弃小数部分</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Buffer内存分配"><a href="#Buffer内存分配" class="headerlink" title="Buffer内存分配"></a>Buffer内存分配</h2><p>Buffer对象的内存分配不是在V8的堆内存中，是在Node的C++层面实现内存的申请的。因为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大量的内存申请的系统调用，对操作系统有一定压力。为此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略。</p>
<p>为了高效使用申请来的内存，Node采用了slab分配机制。slab是一种动态内存管理机制，简单而言，slab就是一块申请好的固定大小的内存区域。具有如下3种状态</p>
<ol>
<li>full: 完全分配</li>
<li>partial: 部分分配状态</li>
<li>empty: 没有被分配状态<br>当我们需要一个Buffer对象，可以通过以下方式分配指定大小的Buffer对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(size);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Node以8KB为边界来区分Buffer是大对象还是小对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.poolSize = <span class="number">8</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个8KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配。</p>
<p>1.分配小Buffer对象</p>
<p>如果指定Buffer的大小少于8KB,Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它。以下是分配一个全新的slab单元的操作，它会将新申请的SlowBuffer对象指向它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocPool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pool = <span class="keyword">new</span> SlowBuffer(Buffer.poolSize);</span><br><span class="line">  pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/52.jpg" alt="avatar"></p>
<p>在图6-2中，slab处于empty状态<br>构造小Buffer对象时的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p>
<p>这次构造将会去检查pool对象，如果pool没有被创建，将会创建一个新的slab单元指向它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pool || pool.length - pool.used &lt; <span class="keyword">this</span>.length) allocPool();</span><br></pre></td></tr></table></figure></p>
<p>同时当前Buffer对象的parent属性指向该slab，并记录下是从这个slab的哪个位置(offset)开始使用的，slab对象自身也记录被使用了多少字节<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.parent = pool;</span><br><span class="line"><span class="keyword">this</span>.offset = pool.used;</span><br><span class="line">pool.used = <span class="keyword">this</span>.length;</span><br><span class="line"><span class="keyword">if</span> (pool.used &amp; <span class="number">7</span>) pool.used = (pool.used + <span class="number">8</span>) &amp; ~<span class="number">7</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/53.jpg" alt="avatar"></p>
<p>这时候的slab状态为partial</p>
<p>当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态。下面代码创建了一个新的Buffer对象，它会引起一次slab分配：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/54.jpg" alt="avatar"></p>
<p>如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费。</p>
<p>这里要注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8KB空间才会被回收。</p>
<p>2.分配大Buffer对象</p>
<p>如果需要超过8KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Big buffer, just alloc one</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> SlowBuffer(<span class="keyword">this</span>.length);</span><br><span class="line"><span class="keyword">this</span>.offset = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里的SlowBuffer类是在C++中定义的，虽然引用Buffer模块可以访问到它，但是不推荐直接操作它。</p>
<p>上面提到的Buffer对象都是JavaScript层面的，能够被V8的垃圾回收标记回收。但是其内部的parent属性指向的SlowBuffer对象却来自Node自身C++中的定义，所用内存不在V8的堆中。</p>
<p>3.小结</p>
<p>当进行小而频繁的Buffer操作时，采用slab的机制进行预先申请和事后分配，使得JavaScript到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的Buffer而言，则直接使用C++层面提供的内存，而无需细腻的分配操作。</p>
<h2 id="Buffer的转换"><a href="#Buffer的转换" class="headerlink" title="Buffer的转换"></a>Buffer的转换</h2><p>Buffer对象可以与字符串之间相互转换。目前支持的字符串编码类型如下：</p>
<ol>
<li>ASCII</li>
<li>UTF-8</li>
<li>UTF-16LE/UCS-2</li>
<li>Base64</li>
<li>Binary</li>
<li>Hex</li>
</ol>
<h2 id="字符串转Buffer"><a href="#字符串转Buffer" class="headerlink" title="字符串转Buffer"></a>字符串转Buffer</h2><p>主要通过构造函数完成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(str, [encoding]);</span><br></pre></td></tr></table></figure></p>
<p>通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储。</p>
<p>一个Buffer对象可以存储不同编码类型的字符串转码的值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.write(string, [offset], [length], [encoding])</span><br></pre></td></tr></table></figure></p>
<p>需要小心的是，每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理。</p>
<h2 id="Buffer转字符串"><a href="#Buffer转字符串" class="headerlink" title="Buffer转字符串"></a>Buffer转字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding], [start], [end]);</span><br></pre></td></tr></table></figure>
<h2 id="Buffer不支持的编码类型"><a href="#Buffer不支持的编码类型" class="headerlink" title="Buffer不支持的编码类型"></a>Buffer不支持的编码类型</h2><p>isEncoding()函数来判断编码是否支持转换<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.isEncoding(encoding);</span><br></pre></td></tr></table></figure></p>
<p>对于不支持的编码类型，可以借助Node生态圈中的模块完成转换。如iconv和iconv-lite。</p>
<h2 id="Buffer的拼接"><a href="#Buffer的拼接" class="headerlink" title="Buffer的拼接"></a>Buffer的拼接</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data事件中获取的chunk对象即是Buffer对象。一旦输入流中有宽字节编码时，问题就会暴露出来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data += chunk;</span><br></pre></td></tr></table></figure></p>
<p>这句代码里隐藏了toString()操作，等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = data.toString() + chunk.toString();</span><br></pre></td></tr></table></figure></p>
<p>为了重现这个问题，我们将文件可读流的每次读取的Buffer长度限制为11<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123;<span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">床前明��光，疑���地上霜；举头��明月，���头思故乡。</span><br></pre></td></tr></table></figure></p>
<p>由于我们限定了Buffer对象的长度为11，而中文字在UTF-8下占3个字节。所以会形成一些乱码。</p>
<h2 id="setEncoding-与string-decoder"><a href="#setEncoding-与string-decoder" class="headerlink" title="setEncoding()与string_decoder()"></a>setEncoding()与string_decoder()</h2><p>可读流还有一个设置编码的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readable.setEncoding(encoding)</span><br></pre></td></tr></table></figure></p>
<p>该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。<br>我们修改之前的程序<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123;<span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;);</span><br><span class="line">rs.setEncoding(<span class="string">'utf8'</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">床前明月光，疑是地上霜；举头望明月，低头思故乡。</span><br></pre></td></tr></table></figure></p>
<p>要知道，无论如何设置编码。触发data事件的次数依旧相同。这意味着设置编码并未改变按段读取的基本方式。</p>
<p>事实上，在调用setEncoding()时，可读流对象在内部设置了一个decoder对象。每次data事件都通过该decoder对象进行Buffer到字符串的解码，然后传递给调用者。是故设置编码后，data不再收到原始的Buffer对象。decoder对象来自于string_decoder模块StringDecoder的实例对象，它的神奇之处在于：<br><img src="https://mfaying.github.io/static/images/node/55.jpg" alt="avatar"></p>
<p>StringDecoder在得到编码后，知道宽字节字符串在UTF-8编码下是以3个字节的方式存储的，所以第一个write()时，只输出前9个字节转码形成的字符，“月”字的前两个字节被保留在StringDecoder实例内部。第二次write()时，会将这2个剩余字节和后续11个字节组合在一起，再次用3的整数倍数字节进行转码。</p>
<p>它目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这三种比编码。能解决解决大部分的乱码问题，但并不能从根本上解决该问题。</p>
<h2 id="正确拼接Buffer"><a href="#正确拼接Buffer" class="headerlink" title="正确拼接Buffer"></a>正确拼接Buffer</h2><p>淘汰掉setEncoding方法后，剩下的解决方案只有将多个小Buffer对象拼接为一个Buffer对象，然后通过iconv-lite一类的模块来转码这种方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chunks = [];</span><br><span class="line"><span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  chunks.push(chunk);</span><br><span class="line">  size += chunk.length;</span><br><span class="line">&#125;);</span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buf = Buffer.concat(chunks, size);</span><br><span class="line">  <span class="keyword">var</span> str = iconv.decode(buf, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>调用Buffer.concat()方法生成一个合并的Buffer对象。</p>
<h2 id="Buffer与性能"><a href="#Buffer与性能" class="headerlink" title="Buffer与性能"></a>Buffer与性能</h2><p>Buffer在文件I/O和网路I/O中运用广泛，在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转换为Buffer，以进行二进制数据传输。在web应用中，字符串转换到Buffer是时时刻刻发生的，提高字符串到Buffer的转换效率，可以很大程度地提高网络吞吐率。</p>
<p>测试<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> helloworld = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">10</span>; i ++) &#123;</span><br><span class="line">  helloworld += <span class="string">"a"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helloworld = new Buffer(helloworld);</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  res.end(helloworld);</span><br><span class="line">&#125;).listen(<span class="number">8001</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过ab做一个性能测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -c 200 -t 100 http://127.0.0.1:8001/</span><br></pre></td></tr></table></figure></p>
<p>取消掉注释以后，性能提升近一倍。</p>
<p>通过预先转换静态内容为Buffer对象，可以有效减少CPU的重复使用，节省服务器资源。在Node构建构建的web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。</p>
<p>.文件读取</p>
<p>Buffer的使用除了与字符串的转换有性能损耗外，在文件的读取时，有一个highWaterMark设置对性能的影响至关重要。在fs.createReadStream(path, opts)时，我们可以传入一些参数，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  flags: <span class="string">'r'</span>,</span><br><span class="line">  encoding: <span class="literal">null</span>,</span><br><span class="line">  fd: <span class="literal">null</span>,</span><br><span class="line">  mode: <span class="number">0666</span>,</span><br><span class="line">  highWaterMark: <span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以传递start和end来指定读取文件的位置范围<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">start</span>: <span class="number">90</span>, <span class="attr">end</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>fs.createReadStream()的工作方式是在内存中准备一段Buffer，然后在fs.read()读取时逐步从磁盘中将字节复制到Buffer中。完成一次读取时，则从这个Buffer中通过slice()方法取出部分数据作为一个小的Buffer对象，再通过data事件传递给调用方。如果Buffer用完，则重新分配一个；如果还有剩余，则继续使用。下面为分配一个新的Buffer对象的操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocNewPool</span>(<span class="params">poolSize</span>) </span>&#123;</span><br><span class="line">  pool = <span class="keyword">new</span> Buffer(poolSize);</span><br><span class="line">  pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在理想情况下，每次读取的长度就是用户指定的highWaterMark。但是有可能读到了文件的结尾，或者文件本身就没有指定的highWaterMark那么大，这个预先指定的Buffer对象将会有部分剩余，不过好在这里的内存可以分配给下次读取时使用。pool是常驻内存的，只有当pool单元剩余数量小于128(kMinPoolSpace)字节时，才会重新分配一个新的Buffer对象。Node源码中分配新的Buffer对象的判断条件如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pool || pool.length - pool.used &lt; kMinPoolSpace) &#123;</span><br><span class="line">  <span class="comment">// discard the old pool</span></span><br><span class="line">  pool = <span class="literal">null</span>;</span><br><span class="line">  allocNewPool(<span class="keyword">this</span>._readableState.highWaterMark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里与Buffer的内存分配比较类似，highWaterMark的大小对性能有两个影响</p>
<ol>
<li>highWaterMark设置对Buffer内存的分配和使用有一定影响</li>
<li>highWaterMark设置过小，可能导致系统调用次数过多</li>
</ol>
<p>文件流读取基于Buffer分配，Buffer则基于SlowBuffer分配，这可以理解为两个维度的分配策略。如果文件较小(小于8KB)，有可能造成slab未能完全使用。</p>
<p>由于fs.createReadStream()内部采用fs.read()实现，将会引起对磁盘的系统调用，对于大文件而言，highWaterMark的大小决定会触发系统调用和data事件的次数。</p>
<p>读取一个相同的大文件时，hightWaterMark值的越大，读取速度越快。</p>
<h1 id="网路编程"><a href="#网路编程" class="headerlink" title="网路编程"></a>网路编程</h1><p>Node只需要几行代码即可构建服务器，无需额外的容器。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP全名为传输控制层协议，在OSI模型(由七层组成)中属于传输层协议。<br><img src="https://mfaying.github.io/static/images/node/56.jpg" alt="avatar"></p>
<p>TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话<br><img src="https://mfaying.github.io/static/images/node/57.jpg" alt="avatar"></p>
<p>只有会话形成之后，服务端和客户端之间才能互相发送数据。在创建会话的过程中，服务器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端与客户端则通过套接字实现两者之间连接的操作。</p>
<h2 id="创建TCP服务器端"><a href="#创建TCP服务器端" class="headerlink" title="创建TCP服务器端"></a>创建TCP服务器端</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新的连接</span></span><br><span class="line">  socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    socket.write(<span class="string">'你好'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接断开'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.write(<span class="string">"welcome!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8124</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server bound'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们通过net.createServer(listener)即可创建一个TCP服务器，listener是连接事件connection的侦听器，也可以采用如下的方式进行侦听：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新的连接</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8124</span>);</span><br></pre></td></tr></table></figure></p>
<p>除了端口外，同样我们也可以对Domain Socket进行监听<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.listen(<span class="string">'/tmp/echo.sock'</span>);</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -U /tmp/echo.sock</span><br></pre></td></tr></table></figure></p>
<p>通过net模块构造客户端<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> client = net.connect(&#123;<span class="attr">port</span>: <span class="number">8124</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'connect' listener</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</span><br><span class="line">  client.write(<span class="string">'world!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  client.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'client disconnected'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果是Domain Socket<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = net.connect(&#123;<span class="attr">path</span>: <span class="string">'/tmp/echo.sock'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="TCP服务事件"><a href="#TCP服务事件" class="headerlink" title="TCP服务事件"></a>TCP服务事件</h2><p>在上述的示例中，代码分为服务器事件和连接事件<br><img src="https://mfaying.github.io/static/images/node/58.jpg" alt="avatar"></p>
<p>另外，由于TCP套接字是可写可读的Stream对象，可以利用pipe()方法巧妙地实现管道操作，如下代码实现了一个echo服务器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.write(<span class="string">'Echo server'</span>);</span><br><span class="line">  sccket.pipe(socket);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mfaying.github.io/static/images/node/59.jpg" alt="avatar"></p>
<h2 id="构建UDP服务（-暂略）"><a href="#构建UDP服务（-暂略）" class="headerlink" title="构建UDP服务（???暂略）"></a>构建UDP服务（???暂略）</h2><h2 id="构建HTTP服务-不全，暂略"><a href="#构建HTTP服务-不全，暂略" class="headerlink" title="构建HTTP服务(???不全，暂略)"></a>构建HTTP服务(???不全，暂略)</h2><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>Node的http模块包含对HTTP处理的封装。在Node中,HTTP服务器继承自TCP服务器(net模块)，它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用。所以能实现高并发。它和TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，Http服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装。<br><img src="https://mfaying.github.io/static/images/node/60.jpg" alt="avatar"></p>
<p>除此以外，http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生过程中，http模块拿到连接中传来的数据，调用二进制模块http_parse进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑。<br><img src="https://mfaying.github.io/static/images/node/61.jpg" alt="avatar"></p>
<p>1.HTTP请求</p>
<p>对于TCP连接的读操作，http模块将其封装为ServerRequest对象。报文头将会通过http_parser进行解析。</p>
<p>报文头第一行GET/ HTTP/1.1被解析之后分解为如下属性</p>
<ol>
<li>req.method属性</li>
<li>req.url 属性</li>
<li>req.httpVersion 属性</li>
</ol>
<p>其余报头是很规律的Key:Value格式，被解析后放置在req.headers属性上传递给业务逻辑以供调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headers:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'...'</span>,</span><br><span class="line">  host: <span class="string">'127.0.0.1:1337'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span> &#125;,</span><br></pre></td></tr></table></figure></p>
<p>报文体部分则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buffers = [];</span><br><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>) </span>&#123;</span><br><span class="line">    buffers.push(trunk);</span><br><span class="line">  &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = Buffer.concat(buffers);</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    res.end(<span class="string">'Helle world'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.HTTP响应</p>
<p>它封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的API为res.setHeader()和res.writeHead()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们可以调用setHeader进行多次设置，但只有调用writeHead后，报头才会写入到连接中，http模块还会自动帮你设置一些头信息<br><img src="https://mfaying.github.io/static/images/node/62.jpg" alt="avatar"></p>
<p>报文体部分则是调用res.write()和res.end()方法实现，res.end()会先调用write()发送数据，然后发送信号告知服务器这次响应结束。</p>
<p>响应结束后，HTTP服务器可能会将当前的连接用于下一个请求，或者关闭连接。值得注意的是，报文是在报文体发送前发送的，一旦开始了数据的发送，writeHead()或setHeader()将不再生效，这是由协议的特性决定的。</p>
<p>另外，务必在结束时调用res.end(),否则客户端将一直处于等待的状态。当然，也可以通过延迟res.end()的方式实现客户端与服务器端之间的长连接，但结束时务必关闭连接。</p>
<p>3.HTTP服务的事件</p>
<p><img src="https://mfaying.github.io/static/images/node/63.jpg" alt="avatar"></p>
<h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><p><img src="https://mfaying.github.io/static/images/node/64.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/65.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/66.jpg" alt="avatar"></p>
<p><img src="https://mfaying.github.io/static/images/node/67.jpg" alt="avatar"></p>
<h2 id="构建WebSocket服务-暂略"><a href="#构建WebSocket服务-暂略" class="headerlink" title="构建WebSocket服务(???暂略)"></a>构建WebSocket服务(???暂略)</h2><h2 id="网络服务与安全-暂略"><a href="#网络服务与安全-暂略" class="headerlink" title="网络服务与安全(???暂略)"></a>网络服务与安全(???暂略)</h2><h1 id="构建web应用-暂略"><a href="#构建web应用-暂略" class="headerlink" title="构建web应用(???暂略)"></a>构建web应用(???暂略)</h1><h1 id="玩转Node-js进程"><a href="#玩转Node-js进程" class="headerlink" title="玩转Node.js进程"></a>玩转Node.js进程</h1><p>Node在选型时决定在V8引擎之上构建，就意味着它的模型和浏览器类似，JavaScript是运行在单个进程的单个线程上。它带来的好处是：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好地提高CPU的使用率。</p>
<p>但是一个Node进程只能利用一个核，无法充分利用多核CPU服务器。</p>
<p>另外,一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃。</p>
<p>从严格意义上而言，Node并非真正的单线程架构，它自身还有一定的I/O线程的存在，这些I/O线程由底层libuv处理。这部分线程，只有C++扩展开发时才会关注到。JavaScript代码永远运行在V8上，是单线程的。本章将围绕JavaScript部分展开，所以屏蔽底层细节的讨论。</p>
<h2 id="服务模型的变迁"><a href="#服务模型的变迁" class="headerlink" title="服务模型的变迁"></a>服务模型的变迁</h2><p>web服务器的架构经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。</p>
<h2 id="石器时代：同步"><a href="#石器时代：同步" class="headerlink" title="石器时代：同步"></a>石器时代：同步</h2><p>一次只为一个请求服务，所有请求都得按次序等待服务器。假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N。</p>
<h2 id="青铜时代：复制进程"><a href="#青铜时代：复制进程" class="headerlink" title="青铜时代：复制进程"></a>青铜时代：复制进程</h2><p>通过进程的复制同时服务更多的请求和用户。每个连接都需要一个进程来服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。</p>
<p>所以预复制被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽。</p>
<p>假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS位M/N.</p>
<h2 id="白银时代：多线程"><a href="#白银时代：多线程" class="headerlink" title="白银时代：多线程"></a>白银时代：多线程</h2><p>为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个进程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在一个时刻只能做一件事，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上线文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。</p>
<p>如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L,受资源上限的影响，它的QPS为M*L/N</p>
<h2 id="黄金时代：事件驱动"><a href="#黄金时代：事件驱动" class="headerlink" title="黄金时代：事件驱动"></a>黄金时代：事件驱动</h2><p>多线程的服务器模型服役了很长一段时间，Apache就是采用多线程/多进程模型实现的，当并发增长到上万时，内存耗用的问题将会暴露出来，即著名的C10k问题。</p>
<p>Node与Nginx则是基于事件驱动的服务模型实现的，采用单线程避免了不必要的内存开销和上下文切换开销。</p>
<p>基于事件驱动的服务模型存在前面提及的CPU利用率和进程健壮性的两个问题。</p>
<p>由于所有处理都是在单线程上进行，影响事件驱动服务模型性能的点在于CPU的计算能力，它的上限决定了这类服务模型的性能上限，但它不受多进程或多线程模式中资源上限的影响，可伸缩性远比前两者高。如果解决掉多核CPU的利用问题，带来的性能上提升是可观的。</p>
<h2 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h2><p>面对单进程单线程对多核CPU使用不足的问题，前人的经验是启用多进程即可。每个进程利用一个CPU，以此实现多核CPU的利用。Node提供了child_process模块，并且也提供了child_process.fork()函数供我们实现进程的复制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>:<span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="built_in">Math</span>.round(<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">1000</span>, <span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure>
<p>通过 node mater.js启动它</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mater.js</span></span><br><span class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>)_cpus();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) &#123;</span><br><span class="line">  fork(<span class="string">'./worker.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是著名的Master-Workers模式，又称主从模式。这是典型的分布式架构中用来并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋于稳定的。工作进程负责具体的业务处理。</p>
<p><img src="https://mfaying.github.io/static/images/node/68.jpg" alt="avatar"></p>
<p>通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10MB的内存。fork()进程是昂贵的，好在Node通过事件驱动的方式在单线程上解决了大并发的问题，这里启动多个进程只是为了充分将CPU资源利用起来，而不是为了解决并发问题。</p>
<h2 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h2><p>child_process模块提供了4个方法用于创建子进程。</p>
<ol>
<li>spawn():启动一个子进程来执行命令</li>
<li>exec():启动一个子进程来执行命令，与spawn不同的是其接口不同，它有一个回调函数获知子进程的状况。</li>
<li>execFile():启动一个子进程来执行可执行文件</li>
<li>fork():与spawn类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。</li>
</ol>
<p>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一但创建的进程运行超过设定的时间将会被杀死。</p>
<p>exec()和execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。</p>
<p>node worker.js分别用上述4种方法实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line">cp.spawn(<span class="string">'node'</span>, [<span class="string">'worker.js'</span>]);</span><br><span class="line">cp.exec(<span class="string">'node worker.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;);</span><br><span class="line">cp.execFile(<span class="string">'worker.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;);</span><br><span class="line">cp.fork(<span class="string">'./worker.js'</span>);</span><br></pre></td></tr></table></figure>
<p>以上4个方法在创建子进程之后均会返回子进程对象。</p>
<p>它们主要在是否有回调/异常、进程类型、执行类型、是否可设置超时上有差别。</p>
<p><img src="https://mfaying.github.io/static/images/node/69.jpg" alt="avatar"></p>
<p>这里的可执行文件是指可以直接执行的文件，如果是JavaScript文件通过execFile()运行，它的首行内容必须添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br></pre></td></tr></table></figure>
<p>事实上其他三种方法都是spawn()的延伸。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>在Master-Worker模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。</p>
<p>和HTML5的WebWorker API一样，Node可以通过消息传递内容，而不是共享或直接操作相关资源，这是较为轻量和无依赖的做法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> n = cp.fork(__dirname + <span class="string">'/sub.js'</span>);</span><br><span class="line"></span><br><span class="line">n.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'PARENT get message:'</span>, m);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">n.send(&#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sub.js</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'CHILD got message:'</span>, m);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.send(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息。</p>
<h2 id="进程间通信原理"><a href="#进程间通信原理" class="headerlink" title="进程间通信原理"></a>进程间通信原理</h2><p>IPC的全称是Inter-Process Communication,即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。Node中实现IPC通道的是管道（pipe）技术，但此管道非彼管道，在Node中管道是个抽象层面的称呼，具体细节实现由libuv提供，在Windows下由命名管道实现，*nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法。</p>
<p><img src="https://mfaying.github.io/static/images/node/70.jpg" alt="avatar"></p>
<p>父进程在创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FE）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。</p>
<p><img src="https://mfaying.github.io/static/images/node/71.jpg" alt="avatar"></p>
<p>建立连接之后的父子进程就可以自由地通信了。由于IPC通道是用命名管道或Domain Socket创建的，它们与网路socket的行为比较类似，属于双向通信。不同的是它们在系统内核中就完成了进程间通信，而不用经过实际的网络层，非常高效。在Node中，IPC通道被抽象为Stream对象，在调用send()时发送数据（类似于write()）,接收到的消息会通过message事件（类似于data）触发给应用层。</p>
<h2 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h2><p>如果让服务器都监听到相同的端口会抛EADDRINUSE异常，这个问题破坏了我们将多个进程监听同一个端口的想法。通常的做法是让每个进程监听不同的端口，主进程监听主端口，主进程对外接收所有的网络请求，再将这些请求分别代理到不同端口的进程中。</p>
<p><img src="https://mfaying.github.io/static/images/node/72.jpg" alt="avatar"></p>
<p>在代理进程上可以做适当的负载均衡，使每个子进程可以较为均衡地执行任务。由于进程每收到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程需要用掉两个文件描述符。操作系统的文件描述符是有限的，这影响了系统的扩展能力。</p>
<p>Node在版本v0.5.9引入了进程间发送句柄的功能。send()方法除了能通过IPC发送数据外，还能发送句柄，第二个可选参数就是句柄：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child.send(message, [sendHandle]);</span><br></pre></td></tr></table></figure>
<p>句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等。</p>
<p>我们可以替换掉代理方法，主进程接收到socket请求后，将这个socket直接发送给工作进程，而不是重新与工作进程之间建立新的socket连接来转发数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork(<span class="string">'child.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.end(<span class="string">'handled by parent'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  child.send(<span class="string">'server'</span>, server);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>子进程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, server</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">'server'</span>) &#123;</span><br><span class="line">    server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      socket.end(<span class="string">'handled by child'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>示例中直接将一个TCP服务器发送给了子进程。</p>
<p>我们通过curl命令测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://127.0.0.1:1337/&quot;</span><br></pre></td></tr></table></figure>
<p>命令行响应结果是很不可思议的，这里子进程和父进程都有可能处理我们客户端发起的请求。</p>
<p>试试将服务发送给多个子进程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.end(<span class="string">'handle by parent\n'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  child1.send(<span class="string">'server'</span>, server);</span><br><span class="line">  child2.send(<span class="string">'server'</span>, server)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在子进程中将进程ID打印出来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, server</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">'server'</span>) &#123;</span><br><span class="line">    server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      socket.end(<span class="string">'handle by child,pid is '</span> + process.pid + <span class="string">'\n'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>每次测试出现的结果都可能不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handle by child,pid is 24673</span><br><span class="line">handle by parent</span><br><span class="line">handle by child,pid is 24672</span><br></pre></td></tr></table></figure>
<p>这是在TCP层面上完成的事情，我们尝试将其转化到HTTP层面来试试。对于主进程，我们想让它更轻量一些，将服务器句柄发送给子进程之后，关掉服务器的监听，让子进程来处理请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  child1.send(<span class="string">'server'</span>, server);</span><br><span class="line">  child2.send(<span class="string">'server'</span>, server);</span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writedHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  res.end(<span class="string">"handled by child, pid is "</span> + process.pid + <span class="string">'\n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, tcp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">'server'</span>) &#123;</span><br><span class="line">    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      server.emit(<span class="string">"connection"</span>, socket);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handle by child,pid is 24673</span><br><span class="line">handle by child,pid is 24672</span><br></pre></td></tr></table></figure>
<p>这样一来，所有的请求都是由子进程处理了。整个过程中，服务的过程只发生了一次改变。</p>
<p>先是主进程将请求发送给工作进程，主进程发送完句柄并关闭监听之后，多个子进程直接监听相同端口，并且不会抛EADDRINUSE异常。</p>
<h2 id="1-句柄发送与还原"><a href="#1-句柄发送与还原" class="headerlink" title="1.句柄发送与还原"></a>1.句柄发送与还原</h2><p>前面的句柄发送虽然看上去跟直接将服务器对象发送给子进程没有差别，但其实它并不是真的发送了服务器对象。</p>
<p>目前子进程对象send()方法可以发送的句柄类型包括如下几种</p>
<ol>
<li>net.Socket。TCP套接字</li>
<li>net.Server。 TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。</li>
<li>net.Native。C++层面的TCP套接字或IPC管道</li>
<li>dgram.Socket。UDP套接字。</li>
<li>dgram.Native。C++层面的UDP套接字。</li>
</ol>
<p>send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle,另一个是message。message参数如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cmd&quot;: &quot;NODE_HANDLE&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;net.Server&quot;,</span><br><span class="line">  &quot;msg&quot;: message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送到IPC管道中的实际上是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个message对象在写入到IPC管道时也会通过JSON.stringify()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任意对象。</p>
<p>连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage。如果是NODE_HANDLE,它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。</p>
<p><img src="https://mfaying.github.io/static/images/node/79.jpg" alt="avatar"></p>
<p>以发送的TCP服务器句柄为例，子进程收到消息后的还原过程如下所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">message, handle, emit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> server = <span class="keyword">new</span> net.Server();</span><br><span class="line">  server.listen(handle, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    emit(server);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程根据message.type创建对应TCP服务对象，然后监听到文件描述符上。由于底层细节不被应用层感知，所以在子进程中，开发者会有一种服务器就是从父进程中直接传递过来的错觉。值得注意的是，Node进程之间只有消息传递，不会真正地传递对象，这种错觉就是抽象封装的结果。</p>
<p>除了上述提到的几种句柄，并非任意类型的句柄都能在进程之间传递，除非它有完整的发送和还原的过程。</p>
<h2 id="2-端口共同监听"><a href="#2-端口共同监听" class="headerlink" title="2.端口共同监听"></a>2.端口共同监听</h2><p>抛EADDRINUSE异常的原因，是我们独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛异常。</p>
<p>Node底层对每个端口监听都设置了SO_REUSEADDR选项，含义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同进程复用,如下所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(tcp-&gt;io_watcher.fd, SQL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));</span><br></pre></td></tr></table></figure>
<p>由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口就会失败。但对于send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。</p>
<p>多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进程服务。这些进程服务是抢占式的。</p>
<p>通过这些基础技术，用child_process模块在单机上搭建Node集群是件相对容易的事情，因此在多核CPU的环境下，让Node进程能够充分利用资源不再是难题。</p>
<h1 id="集群稳定之路"><a href="#集群稳定之路" class="headerlink" title="集群稳定之路"></a>集群稳定之路</h1><p>搭建好了集群，可以充分利用多核CPU资源了。但是，我们还有一些细节需要考虑。</p>
<ol>
<li>性能问题</li>
<li>多个工作进程的存活状态管理</li>
<li>工作进程的平滑重启</li>
<li>配置或者静态数据的动态重新载入</li>
<li>其他细节</li>
</ol>
<p>虽然我们创建了很多工作进程，但每个工作进程依然是在单线程上执行的，它的稳定性还不能得到完全的保障。我们需要建立一个健全的机制来保障Node应用的健壮性。</p>
<h2 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h2><p>再次回到子进程对象上，除了send()方法和message事件，Node还有如下事件：</p>
<ol>
<li>error: 当子进程无法被复制创建、无法被杀死、无法发送消息时会触发</li>
<li>exit: 子进程退出时触发该事件，如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。</li>
<li>close: 在子进程的标准输入输出流中止时触发该事件，参数与exit相同。</li>
<li>disconnect: 在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。</li>
</ol>
<p>上述这些事件是父进程能监听到的与子进程相关的事件。除了send()外，还能通过kill()方法给子进程发送消息。kill()方法不能真正将通过IPC相连的子进程杀死，它只是给子进程发送了一个系统信号。默认情况下，父进程通过kill()方法给子进程发送一个SIGTERM信号。它与进程默认的kill()方法类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line">child.kill([signal]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前进程</span></span><br><span class="line">process.kill(pid, [signal]);</span><br></pre></td></tr></table></figure>
<p>它们一个发给子进程，一个发给目标进程。在POSIX标准中，有一套完备的信号系统，在命令行中执行kill -l可以看到详细的信号列表。</p>
<p><img src="https://mfaying.github.io/static/images/node/80.jpg" alt="avatar"></p>
<p>Node提供了这些信号对应的信号事件，每个进程都可以监听这些信号事件。这些信号事件是用来通知进程的，每个信号事件有不同的含义，进程在收到响应信号时，应当做出约定的行为，如SIGTERM是软件终止信号，进程收到该信号时应当退出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'SIGTERM'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a SIGTERM, exiting...'</span>);</span><br><span class="line">  process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server running with PID:'</span>, process.pid);</span><br><span class="line">process.kill(process.pid, <span class="string">'SIGTERM'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h2><p>有了父子进程之间的相关事件之后，就可以在这些关系之间创建出需要的机制了。</p>
<p>至少我们能够通过监听子进程的exit事件来获知其退出的信息，接着前文的多进程架构，我们主进程上加入一些进程管理的机制，比如某个工作进程退出了，重新启动一个工作进程来继续服务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.listen(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> worker = fork(__dirname + <span class="string">'/worker.js'</span>)</span><br><span class="line">  <span class="comment">// 退出时重新启动新的进程</span></span><br><span class="line">  worker.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Worker '</span> + worker.pid + <span class="string">' exited.'</span>);</span><br><span class="line">    <span class="keyword">delete</span> workers[worker.pid];</span><br><span class="line">    createWorker();</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 句柄转发</span></span><br><span class="line">  worker.send(<span class="string">'server'</span>, server);</span><br><span class="line">  workers[worker.pid] = worker;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Create worker. pid: '</span> + worker.pid);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i ++) &#123;</span><br><span class="line">  createWorker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程自己退出时，让所有工作进程退出</span></span><br><span class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> pid <span class="keyword">in</span> workers) &#123;</span><br><span class="line">    workers[pid].kill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们可以通过kill [pid]命令对以上代码进行测试。</p>
<p>其实，实际业务中更可能是存在bug导致工作进程退出，我们需要仔细处理这种异常：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">"Conten-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'handle by child, pid is '</span> + process.pid + <span class="string">'\n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker;</span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, tcp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">'server'</span>) &#123;</span><br><span class="line">    worker = tcp;</span><br><span class="line">    worker.on(<span class="string">'connection'</span>, fuction(socket) &#123;</span><br><span class="line">      server.emit(<span class="string">"connection"</span>, socket)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 停止接收新的连接</span></span><br><span class="line">  worker.close(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 所有已有连接断开后，退出进程</span></span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述代码的处理流程是，一旦有未捕获的异常出现，工作进程会立即停止接收新的连接；当所有连接断开后，退出进程。主进程在侦听到工作进程的exit后，将会立即启动新的进程服务，以保证整个集群中总有进程在为用户服务。</p>
<h3 id="自杀信号"><a href="#自杀信号" class="headerlink" title="自杀信号"></a>自杀信号</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node/" rel="tag"># node</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/27/高性能网站建设指南/" rel="next" title="《高性能网站建设指南》(笔记)">
                <i class="fa fa-chevron-left"></i> 《高性能网站建设指南》(笔记)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/26/elasticsearch权威指南/" rel="prev" title="elasticsearch(2.x)教程">
                elasticsearch(2.x)教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDUxMi8xMTA1MA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="小光">
            
              <p class="site-author-name" itemprop="name">小光</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/mfaying" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1213560387@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Node简介"><span class="nav-number">1.</span> <span class="nav-text">Node简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么是JavaScript"><span class="nav-number">1.1.</span> <span class="nav-text">为什么是JavaScript</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么叫Node"><span class="nav-number">1.2.</span> <span class="nav-text">为什么叫Node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node给JavaScript带来的意义"><span class="nav-number">1.3.</span> <span class="nav-text">Node给JavaScript带来的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node的特点"><span class="nav-number">1.4.</span> <span class="nav-text">node的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node的应用场景"><span class="nav-number">1.5.</span> <span class="nav-text">node的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与遗留系统和平共处"><span class="nav-number">1.6.</span> <span class="nav-text">与遗留系统和平共处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式应用"><span class="nav-number">1.7.</span> <span class="nav-text">分布式应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node的使用者"><span class="nav-number">1.8.</span> <span class="nav-text">node的使用者</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块机制"><span class="nav-number">2.</span> <span class="nav-text">模块机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CommonJS规范"><span class="nav-number">2.1.</span> <span class="nav-text">CommonJS规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CommonJS的模块规范"><span class="nav-number">2.2.</span> <span class="nav-text">CommonJS的模块规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node的模块实现"><span class="nav-number">2.3.</span> <span class="nav-text">node的模块实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块编译"><span class="nav-number">2.4.</span> <span class="nav-text">模块编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心模块"><span class="nav-number">2.5.</span> <span class="nav-text">核心模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-C-核心模块的编译过程"><span class="nav-number">2.6.</span> <span class="nav-text">C/C++核心模块的编译过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心模块的引入流程"><span class="nav-number">2.7.</span> <span class="nav-text">核心模块的引入流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写核心模块（-暂略）"><span class="nav-number">2.8.</span> <span class="nav-text">编写核心模块（???暂略）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块调用栈"><span class="nav-number">2.9.</span> <span class="nav-text">模块调用栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包与NPM"><span class="nav-number">2.10.</span> <span class="nav-text">包与NPM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包结构"><span class="nav-number">2.11.</span> <span class="nav-text">包结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包描述文件与NPM"><span class="nav-number">2.12.</span> <span class="nav-text">包描述文件与NPM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NPM常用功能"><span class="nav-number">2.13.</span> <span class="nav-text">NPM常用功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NPM钩子命令"><span class="nav-number">2.14.</span> <span class="nav-text">NPM钩子命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布包"><span class="nav-number">2.15.</span> <span class="nav-text">发布包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局域NPM-暂略"><span class="nav-number">2.16.</span> <span class="nav-text">局域NPM ???暂略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NPM潜在问题"><span class="nav-number">2.17.</span> <span class="nav-text">NPM潜在问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前后端共用模块"><span class="nav-number">2.18.</span> <span class="nav-text">前后端共用模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块的侧重点"><span class="nav-number">2.19.</span> <span class="nav-text">模块的侧重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMD规范"><span class="nav-number">2.20.</span> <span class="nav-text">AMD规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMD规范"><span class="nav-number">2.21.</span> <span class="nav-text">CMD规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#兼容多种模块规范"><span class="nav-number">2.22.</span> <span class="nav-text">兼容多种模块规范</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步I-O"><span class="nav-number">3.</span> <span class="nav-text">异步I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要异步I-O"><span class="nav-number">3.1.</span> <span class="nav-text">为什么要异步I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户体验"><span class="nav-number">3.2.</span> <span class="nav-text">用户体验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源分配"><span class="nav-number">3.3.</span> <span class="nav-text">资源分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步I-O实现现状"><span class="nav-number">3.4.</span> <span class="nav-text">异步I/O实现现状</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步I-O和非阻塞I-O"><span class="nav-number">3.5.</span> <span class="nav-text">异步I/O和非阻塞I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#现实中的异步I-O"><span class="nav-number">3.6.</span> <span class="nav-text">现实中的异步I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node的异步I-O"><span class="nav-number">3.7.</span> <span class="nav-text">Node的异步I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件循环"><span class="nav-number">3.8.</span> <span class="nav-text">事件循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者"><span class="nav-number">3.9.</span> <span class="nav-text">观察者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求对象"><span class="nav-number">3.10.</span> <span class="nav-text">请求对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行回调"><span class="nav-number">3.11.</span> <span class="nav-text">执行回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非I-O的异步API"><span class="nav-number">3.12.</span> <span class="nav-text">非I/O的异步API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时器"><span class="nav-number">3.13.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#process-nextTick"><span class="nav-number">3.14.</span> <span class="nav-text">process.nextTick()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setImmediate"><span class="nav-number">3.15.</span> <span class="nav-text">setImmediate()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件驱动与高性能服务器"><span class="nav-number">3.16.</span> <span class="nav-text">事件驱动与高性能服务器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步编程"><span class="nav-number">4.</span> <span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程"><span class="nav-number">4.1.</span> <span class="nav-text">函数式编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数"><span class="nav-number">4.2.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#偏函数用法"><span class="nav-number">4.3.</span> <span class="nav-text">偏函数用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步编程的优势与难点"><span class="nav-number">4.4.</span> <span class="nav-text">异步编程的优势与难点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优势"><span class="nav-number">4.5.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#难点"><span class="nav-number">4.6.</span> <span class="nav-text">难点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步编程解决方案"><span class="nav-number">4.7.</span> <span class="nav-text">异步编程解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件发布-订阅模式"><span class="nav-number">4.8.</span> <span class="nav-text">事件发布/订阅模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-Deferred模式"><span class="nav-number">4.9.</span> <span class="nav-text">Promise/Deferred模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制库"><span class="nav-number">4.10.</span> <span class="nav-text">流程控制库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步并发控制"><span class="nav-number">4.11.</span> <span class="nav-text">异步并发控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bagpipe的解决方案"><span class="nav-number">4.12.</span> <span class="nav-text">bagpipe的解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async的解决方案-暂略"><span class="nav-number">4.13.</span> <span class="nav-text">async的解决方案???暂略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.14.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存控制"><span class="nav-number">5.</span> <span class="nav-text">内存控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#V8的垃圾回收机制与内存限制"><span class="nav-number">5.1.</span> <span class="nav-text">V8的垃圾回收机制与内存限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#V8的内存限制"><span class="nav-number">5.2.</span> <span class="nav-text">V8的内存限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#V8的对象分配"><span class="nav-number">5.3.</span> <span class="nav-text">V8的对象分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#V8的垃圾回收机制"><span class="nav-number">5.4.</span> <span class="nav-text">V8的垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看垃圾回收日志"><span class="nav-number">5.5.</span> <span class="nav-text">查看垃圾回收日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高效使用内存"><span class="nav-number">5.6.</span> <span class="nav-text">高效使用内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域"><span class="nav-number">5.7.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">5.8.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">5.9.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存指标"><span class="nav-number">5.10.</span> <span class="nav-text">内存指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看内存使用情况"><span class="nav-number">5.11.</span> <span class="nav-text">查看内存使用情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看系统的内存占用"><span class="nav-number">5.12.</span> <span class="nav-text">查看系统的内存占用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆外内存"><span class="nav-number">5.13.</span> <span class="nav-text">堆外内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-1"><span class="nav-number">5.14.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏"><span class="nav-number">5.15.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#慎将内存当做缓存"><span class="nav-number">5.16.</span> <span class="nav-text">慎将内存当做缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存的解决方案"><span class="nav-number">5.17.</span> <span class="nav-text">缓存的解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关注队列状态"><span class="nav-number">5.18.</span> <span class="nav-text">关注队列状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏排查"><span class="nav-number">5.19.</span> <span class="nav-text">内存泄漏排查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大内存应用"><span class="nav-number">5.20.</span> <span class="nav-text">大内存应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解Buffer"><span class="nav-number">6.</span> <span class="nav-text">理解Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer结构"><span class="nav-number">6.1.</span> <span class="nav-text">Buffer结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块结构"><span class="nav-number">6.2.</span> <span class="nav-text">模块结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer对象"><span class="nav-number">6.3.</span> <span class="nav-text">Buffer对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer内存分配"><span class="nav-number">6.4.</span> <span class="nav-text">Buffer内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer的转换"><span class="nav-number">6.5.</span> <span class="nav-text">Buffer的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串转Buffer"><span class="nav-number">6.6.</span> <span class="nav-text">字符串转Buffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer转字符串"><span class="nav-number">6.7.</span> <span class="nav-text">Buffer转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer不支持的编码类型"><span class="nav-number">6.8.</span> <span class="nav-text">Buffer不支持的编码类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer的拼接"><span class="nav-number">6.9.</span> <span class="nav-text">Buffer的拼接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setEncoding-与string-decoder"><span class="nav-number">6.10.</span> <span class="nav-text">setEncoding()与string_decoder()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正确拼接Buffer"><span class="nav-number">6.11.</span> <span class="nav-text">正确拼接Buffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer与性能"><span class="nav-number">6.12.</span> <span class="nav-text">Buffer与性能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网路编程"><span class="nav-number">7.</span> <span class="nav-text">网路编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">7.1.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建TCP服务器端"><span class="nav-number">7.2.</span> <span class="nav-text">创建TCP服务器端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP服务事件"><span class="nav-number">7.3.</span> <span class="nav-text">TCP服务事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建UDP服务（-暂略）"><span class="nav-number">7.4.</span> <span class="nav-text">构建UDP服务（???暂略）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建HTTP服务-不全，暂略"><span class="nav-number">7.5.</span> <span class="nav-text">构建HTTP服务(???不全，暂略)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http模块"><span class="nav-number">7.6.</span> <span class="nav-text">http模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP客户端"><span class="nav-number">7.7.</span> <span class="nav-text">HTTP客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建WebSocket服务-暂略"><span class="nav-number">7.8.</span> <span class="nav-text">构建WebSocket服务(???暂略)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络服务与安全-暂略"><span class="nav-number">7.9.</span> <span class="nav-text">网络服务与安全(???暂略)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构建web应用-暂略"><span class="nav-number">8.</span> <span class="nav-text">构建web应用(???暂略)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#玩转Node-js进程"><span class="nav-number">9.</span> <span class="nav-text">玩转Node.js进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#服务模型的变迁"><span class="nav-number">9.1.</span> <span class="nav-text">服务模型的变迁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#石器时代：同步"><span class="nav-number">9.2.</span> <span class="nav-text">石器时代：同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#青铜时代：复制进程"><span class="nav-number">9.3.</span> <span class="nav-text">青铜时代：复制进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#白银时代：多线程"><span class="nav-number">9.4.</span> <span class="nav-text">白银时代：多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#黄金时代：事件驱动"><span class="nav-number">9.5.</span> <span class="nav-text">黄金时代：事件驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多进程架构"><span class="nav-number">9.6.</span> <span class="nav-text">多进程架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建子进程"><span class="nav-number">9.7.</span> <span class="nav-text">创建子进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-number">9.8.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信原理"><span class="nav-number">9.9.</span> <span class="nav-text">进程间通信原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#句柄传递"><span class="nav-number">9.10.</span> <span class="nav-text">句柄传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-句柄发送与还原"><span class="nav-number">9.11.</span> <span class="nav-text">1.句柄发送与还原</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-端口共同监听"><span class="nav-number">9.12.</span> <span class="nav-text">2.端口共同监听</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集群稳定之路"><span class="nav-number">10.</span> <span class="nav-text">集群稳定之路</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程事件"><span class="nav-number">10.1.</span> <span class="nav-text">进程事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动重启"><span class="nav-number">10.2.</span> <span class="nav-text">自动重启</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自杀信号"><span class="nav-number">10.2.1.</span> <span class="nav-text">自杀信号</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    by
  </span>
  <span class="author" itemprop="copyrightHolder">小光</span>

  
</div>













        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("rXDtthwfyBtPIDbpKrjcpxmS-gzGzoHsz", "5fvqAap2dh7V6AXxOQgVSqSU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

  <script>
    $('.blur-bg').css('height', $(document).height() + 130);
    var blogClearTimer = setInterval(function () {
      if (!(localStorage.getItem('mfaying') === 'blog')) {
        window.document.write("");
      } else {
        clearInterval(blogClearTimer);
      }
    }, 500);
  </script>
</body>
</html>
