<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="react,">










<meta name="description" content="react 全系列">
<meta name="keywords" content="react">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入React技术栈》">
<meta property="og:url" content="http://yoursite.com/2019/11/10/《深入React技术栈》/index.html">
<meta property="og:site_name" content="小光的博客">
<meta property="og:description" content="react 全系列">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-10-04T03:29:14.035Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《深入React技术栈》">
<meta name="twitter:description" content="react 全系列">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/10/《深入React技术栈》/">





  <title>《深入React技术栈》 | 小光的博客</title>
  








  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?bacbd4424722e498fac9ea507f3a8807";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  window.onload=function(){
    if (!sessionStorage.getItem('homePgCount')) {
      sessionStorage.setItem('homePgCount', Math.floor(new Date().getSeconds() % 11));
    }
    $('.header-inner').css("backgroundImage", 'url("https://mfaying.github.io/images/bg' + (sessionStorage.getItem('homePgCount') || 0) + '.jpg")')
    $('.blur-bg').css("backgroundImage", 'url("https://mfaying.github.io/images/bg' + (sessionStorage.getItem('homePgCount') || 0) + '.jpg")')
  }

  </script>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="blur-bg"></div>
  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小光的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/《深入React技术栈》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小光">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小光的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《深入React技术栈》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-10T13:40:44+08:00">
                2019-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/11/10/《深入React技术栈》/" class="leancloud_visitors" data-flag-title="《深入React技术栈》">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>react 全系列</p>
<a id="more"></a>
<h1 id="React-简介"><a href="#React-简介" class="headerlink" title="React 简介"></a>React 简介</h1><p>React 是 Facebook 在 2013 年开源 JavaScript 库。它把界面抽象成一个个组件，通过组合这些组件，开发者可以得到功能丰富的页面。同时引入了 JSX 语法，使得复用组件变得容易，且结构清晰。并且有了组件这层的抽象，代码和真实渲染目标分离，除了可以在浏览器端渲染到 DOM 开发网页外，还能用于原生移动应用的开发。</p>
<h2 id="专注视图层"><a href="#专注视图层" class="headerlink" title="专注视图层"></a>专注视图层</h2><p>React 并不是完整的 MVC/MVVM 框架，它专注于 View（视图）层解决方案。与模板引擎不同，React 又是一个包括 View 和 Controller 的库。</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM。每次数据更新，对比前后的 Virtual DOM，对发生变化的部分做批量更新，提升性能。并且 Virtual DOM 可以方便地与其他平台集成，比如 react-native 就是基于 Virtual DOM 渲染原生控件的。</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>命令式编程是给计算机下命名，而函数式编程，对应的是声明式编程。声明式编程的本质是 lambda 演算，比如我们要操作一个数组里的每个元素，返回一个新数组。我们的做法是构建一个 f 函数(规则)作用在数组上，然后返回新数组。这样，计算可以被重复利用。</p>
<h1 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h1><p>JSX 是 react 为了方便 View 层组件化，承载构建 HTML 结构化页面职责的而创立的语言（语法）。</p>
<h2 id="DOM-元素和组件元素"><a href="#DOM-元素和组件元素" class="headerlink" title="DOM 元素和组件元素"></a>DOM 元素和组件元素</h2><p>在 react 中创建的虚拟元素可以分为两类，DOM 元素(DOM element)与组件元素(component element)。分别对应着原生 DOM 元素和自定义元素。</p>
<h2 id="DOM-元素"><a href="#DOM-元素" class="headerlink" title="DOM 元素"></a>DOM 元素</h2><p>当使用 JavaScript 来描述 Web 页面的 HTML 元素时，可以表示为纯粹的 JSON 对象。例如，描述一个按钮</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-blue"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>-&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &apos;button&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &apos;btn btn-blue&apos;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: &apos;em&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        children: &apos;Confirm&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 react 中，到处可见的元素并不是真实的实例，它们只是页面的描述对象。</p>
<h2 id="组件元素"><a href="#组件元素" class="headerlink" title="组件元素"></a>组件元素</h2><p>React 还可以自定义组件元素。<br>类比如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; color, text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">"button"</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      className: <span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: <span class="string">"em"</span>,</span><br><span class="line">          props: &#123;</span><br><span class="line">            children: text</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Button 其实也可以作为元素而存在，方法名对应了元素类型，参数对应了元素属性。<br>这也是 React 的核心思想之一，我们可以让 DOM 元素、组件元素嵌套、组合，最后用递归渲染的方式构建出完全的 DOM 元素树。<br>但是这种写法不容易阅读和维护了，JSX 语法就应运而生了。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; color, text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  &lt;button className=&#123;<span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>&#125;&gt;</span><br><span class="line">    &lt;em&gt;&#123;text&#125;&lt;<span class="regexp">/em&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>button&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换成纯 JavaScript 后再由浏览器执行。</p>
<h2 id="JSX-基本语法"><a href="#JSX-基本语法" class="headerlink" title="JSX 基本语法"></a>JSX 基本语法</h2><p>JSX 的官方定义是类 XML 语法的 ECMAScript 扩展。</p>
<h2 id="XML-基本语法"><a href="#XML-基本语法" class="headerlink" title="XML 基本语法"></a>XML 基本语法</h2><p>使用类 XML 语法，我们可以清晰地看到 DOM 树状结果及其属性。只不过它被包裹在 JavaScript 的方法中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>需要注意几点</p>
<ol>
<li>定义标签时，只允许被一个标签包裹。<br>如</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="params">()</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<p>会报错，最外层没有包裹，显然无法转译成 React.createElement 方法调用</p>
<ol start="2">
<li>标签必须闭合，如<code>&lt;div&gt;&lt;/div&gt;</code>、<code>&lt;div /&gt;</code></li>
</ol>
<h2 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h2><p>小写字母对应 DOM 元素，大写字母对应组件元素<br>此外，还有一些特殊的标签值得讨论，比如注释和 DOCTYPE 头<br>JSX 还是 JavsScript，依然可以用简单的方法使用注释，在子元素位置使用注释要用{}包起来。<br>对于常用于判断浏览器版本的条件注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if IE]&gt;</span><br><span class="line">  &lt;p&gt;work in IE&lt;/p&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<p>需要用 JavaScript 判断来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  (!!window.ActiveXObject || &apos;ActiveXObject&apos; in window) ?</span><br><span class="line">  &lt;p&gt;work in IE&lt;/p&gt; : &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DOCTYPE 头是一个非常特殊的标志，一般会在 React 服务端渲染时用到。DOCTYPE 是没有闭合的，我们无法渲染它。常见的做法是构造一个保存 HTML 的变量，将 DOCTYPE 和整个 HTML 标签渲染后的结果串联起来。</p>
<h2 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h2><p>DOM 元素属性是标准规范属性，但 class 和 for 由于是关键字，由 className 和 htmlFor 替代。<br>组件元素属性是完全自定义的属性，也可以理解为实现组件所需要的参数。一般采用小驼峰写法。<br>此外还有一些特有的属性表达</p>
<ol>
<li>省略 Boolean 属性值会导致 JSX 认为 bool 值设为了 true</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Checkbox checked=&#123;<span class="literal">true</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>可以简写成</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Checkbox checked /&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Checkbox checked=&#123;<span class="literal">false</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>可以省略为</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Checkbox /&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>展开属性<br>使用 ES6 rest/spread 特性可以提高开发效率</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">"foo"</span>, <span class="attr">value</span>: <span class="string">"bar"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> component = <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...data</span>&#125; /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>自定义 HTML 属性<br>往 DOM 元素传入自定义属性，React 是不会渲染的</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">d</span>=<span class="string">"xxx"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要使用 data-前缀，这和 HTML 标准也是一致的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-attr</span>=<span class="string">"xxx"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而在自定义标签中，任意属性都是被支持的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomComponent d=&quot;xxx&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>JavaScript 属性表达式</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person name=&#123;<span class="literal">true</span> ? <span class="number">1</span> : <span class="number">2</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>HTML 转义<br>React 会将所有要显示到 DOM 的字符串转义，防止 XSS。如<code>&amp;copy;</code>不会正确显示。<br>可以通过以下方法解决 1.直接使用 UTF-8 字符 2.使用 Unicode 编码 3.使用功数组组装<code>&lt;div&gt;{[&#39;cc &#39;, &lt;span&gt;&amp;copy;&lt;/span&gt;, &#39; 2015&#39;]}&lt;/div&gt;</code> 4.直接插入原始的 HTML</li>
</ol>
<p>React 还提供了 dangerouslySetInnerHTML 属性。它避免了 React 转义字符，请在确定必要的情况下使用它</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: <span class="string">"cc &amp;copy; 2015"</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h1 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h1><h2 id="组件的演变"><a href="#组件的演变" class="headerlink" title="组件的演变"></a>组件的演变</h2><p>在 MVC架构出现之前，组件主要分为两种</p>
<ol>
<li>狭义上的组件，又称 UI 组件，主要围绕交互动作上的抽象，利用 JavaScript 操作 DOM 结构或 style 样式来控制</li>
<li>广义上的组件，带有业务含义和数据的 UI 组件组合。它更倾向于采用分层的思想去处理<br>对于 UI 组件，分为 3 部分：结构、样式和交互行为，对应于 HTML、CSS 和 JavaScript.</li>
</ol>
<p>封装的基本思路就是面向对象思想。交互基本上以操作 DOM 为主。逻辑上是结构上哪里需要变，我们就操作哪里。以下是几项规范标准组件的信息。</p>
<ol>
<li>基本的封装性。尽管说 JavaScript 没有真正面向对象的方法，但是我们还是可以通过实例化的方法来制造对象。</li>
<li>简单的生命周期呈现。如 contructor 和 destroy,代表了组件的挂载和卸载过程。</li>
<li>明确的数据流动。这里的数据指的是调用组件的参数。一旦确定参数的值，就会解析传进来的参数，根据参数的不同作出不同的响应。</li>
</ol>
<p>这个阶段，前端在应用级别没有过多复杂的交互。传统组件的主要问题在于结构、样式与行为没有很好地结合，不同参数下的逻辑可能会导致不同的渲染逻辑，这时就会存在大量的 HTML 结构与 style 样式的拼装。逻辑一旦复杂，开发及维护成本相当高。</p>
<p>于是分层思想引进了，出现了 MVC 架构。View 只关心怎么输出变量，所以就诞生了各种各样的模板语言。让模板本身承载逻辑，可以帮我们解决 View 上的逻辑问题。对于组件来说，可以将拼装 HTML 的逻辑部分解耦出去，解决了数据与界面耦合的问题。</p>
<p>模板作为一个 DSL，也有其局限性。在 Angular 中，我们看到了在 HTML 上定义指令的方式。</p>
<p>W3C 将类似的思想制定成了规范,称为 Web Components。它通过定义 Custom Elements(自定义元素)的方式来统一组件。每个自定义元素可以定义自己对外提供的属性、方法,还有事件，内部可以像写一个页面一样，专注于实现功能来完成对组件的封装。</p>
<p>Web Components 由 4 个组成部分：HTML Templates 定义了之前模板的概念，Custom Elements 定义了组件的展现形式，Shadow DOM 定义了组件的作用域范围、可以囊括样式，HTML Imports 提出了新的引入方式。</p>
<p>事实上，它还是需要时间的考验的。因为诸如如何包装在这套规范之上的框架，如何获得在浏览器端的全部支持，怎么与现代应用架构结合等等。但它却是开辟了一条罗马大道，告诉我们组件化可以这样去做。</p>
<h2 id="React-组件的构建"><a href="#React-组件的构建" class="headerlink" title="React 组件的构建"></a>React 组件的构建</h2><p>React 的本质就是关心元素的构成，React 组件即为组件元素。组件元素被描述成纯粹的 JSON 对象，意味着可以使用方法或是类来构建。React 组件基本上由 3 个部分组成-属性(props)、状态(state)以及生命周期方法。</p>
<p>React 组件可以接收参数，也可能有自身状态。一旦接收到的参数或自身状态有所改变，React 组件就会执行相应的生命周期方法，最后渲染。</p>
<p>1.React 与 Web Components<br>从 React 组件上看，它与 Web Components 传达的理念是一致的，但两者的实现方式不同：</p>
<ol>
<li>React 自定义元素是库自己构建的，与 Web Components 规范并不通用；</li>
<li>React 渲染过程包括了模板的概念，即 JSX</li>
<li>React 组件的实现均在方法与类中，因此可以做到相互隔离，但不包括样式。</li>
<li>React 引用方式遵循 ES6 module 标准</li>
</ol>
<p>React 在纯 JavaScript 上下了工夫，将 HTML 结构彻底引入到 JavaScript 中。这种做法褒贬不一，但有效地解决了组件所要解决的问题之一。</p>
<p>2.React 组件的构建方法<br>React 组件基本上由组件的构建方式、组件内的属性状态与生命周期方法组成。</p>
<p>React 组件构建上提供了 3 种不同的方法:React.createClass、ES6 classes 和无状态函数。</p>
<p>React.createClass<br>用 React.createClass 构建组件是 React 最传统、也是兼容性最好的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = React.createClass(&#123;</span><br><span class="line">  getDefaultProps() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      color: <span class="string">"blue"</span>,</span><br><span class="line">      text: <span class="string">"Confirm"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color, text &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=&#123;<span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>&#125;&gt;</span><br><span class="line">        &lt;em&gt;&#123;text&#125;&lt;<span class="regexp">/em&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ES6 classes<br>ES6 classes 的写法是通过 ES6 标准的类语法的方式来构建方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  contructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span>,</span><br><span class="line">    text: <span class="string">"Confirm"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color, text &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=&#123;<span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>&#125;&gt;</span><br><span class="line">        &lt;em&gt;&#123;text&#125;&lt;<span class="regexp">/em&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 createClass 的结果相同的是，调用类实现的组件会创建实例对象。</p>
<p>我们很容易联想到组件抽象过程中也可以使用继承的思路。在实际应用中，我们极少让子类去继承功能组件。继承牵一发而动全身。在 React 组件开发中，常用的方式是将组件拆分到合理的粒度，用组合的方式合成业务组件。</p>
<p>说明：React 的所有组件都继承自顶层类 React.Component。它的定义非常简洁，只是初始化了 React.Component 方法，声明了 props、context、refs 等，并在原型上定义了 setState 和 foreUpdate 方法。内部初始化的生命周期方法与 createClass 方式使用的是同一个方法创建的。</p>
<p>无状态函数<br>使用无状态函数构建的组件称为无状态组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">&#123; color = <span class="string">"blue"</span>, text = <span class="string">"Confirm"</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button className=&#123;<span class="string">`btn btn-<span class="subst">$&#123;color&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;em&gt;&#123;text&#125;&lt;<span class="regexp">/em&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无状态组件只传入 props 和 context 两个参数；也就是说，它不存在 state，也没有生命周期方法，组件本身即上面两种 React 组件构建方法中的 render。不过，像 propTypes 和 defaultProps 还是可以通过向方法设置静态属性来实现的。</p>
<p>无状态组件不像上述两种方法在调用时会创建新实例，它创建时始终保持了一个实例，避免了不必要的检查和内存分配。</p>
<h1 id="React-数据流"><a href="#React-数据流" class="headerlink" title="React 数据流"></a>React 数据流</h1><p>在 React 中，数据是自顶向下单向流动的，即从父组件到子组件。</p>
<p>state 与 props 是组件中最重要的概念。如果顶层组件初始化 props，那么 React 会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。state 只关心组件自己内部的状态，这些状态只能在组件内改变。把组件看成一个函数，props 就是它的参数，内部由 state 作为函数的内部参数，返回一个 Virtual DOM 的实现。</p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>在 React 中，state 为组件内部状态。当组件内部使用 setState 方法时，该组件会尝试重新渲染。</p>
<p>值得注意的，setState 是一个异步方法，一个生命周期内所有的 setState 方法会合并操作。</p>
<p>我们思考一个常规的 Tabs 组件，对于 activeIndex 作为 state，就有两种不同的视角。</p>
<ol>
<li>在内部更新。当我们切换 tab 标签时，可以看作是组件内部的交互行为，被选择后通过回调函数返回具体选择的索引。</li>
<li>在外部更新。当我们切换 tab 标签时，可以看作是组件外部在传入具体的索引，而组件就像“木偶”一样被操控着。<br>这两种情形在 React 组件的设计中非常常见，我们分别称为智能组件和木偶组件</li>
</ol>
<p>当然，实现组件时，可以同时考虑兼容这两种</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> currProps = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> activeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 来源于需要外部更新的</span></span><br><span class="line">  <span class="keyword">if</span> (activeIndex <span class="keyword">in</span> currProps) &#123;</span><br><span class="line">    activeIndex = currProps.activeIndex;</span><br><span class="line">    <span class="comment">// 来源于使用内部更新的</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'defaultActiveIndex'</span> <span class="keyword">in</span> currProps) &#123;</span><br><span class="line">    activeIndex = currProps.defaultActiveIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    activeIndex,</span><br><span class="line">    prevIndex: activeIndex,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>props 是 React 用来让组件之间互相联系的一种机制，通俗地说就像方法的参数一样。</p>
<p>props 的传递过程，对于 React 组件来说非常直观。React 的单向数据流，主要的流动管道就是 props。props 本身是不可变的。组件的 props 一定来自于默认属性或通过父组件传递而来。</p>
<p>React 为 props 提供了默认配置，通过 defaultProps 静态变量的方式来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">  classPrefix: <span class="string">'tabs'</span>,</span><br><span class="line">  onChange: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="子组件-prop"><a href="#子组件-prop" class="headerlink" title="子组件 prop"></a>子组件 prop</h2><p>在 React 中有一个重要且内置的 props——children，它代表组件的子组件集合。</p>
<p>实现的基本思路以 TabContent 组件渲染 TabPane 子组件集合为例来讲</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getTabPanes() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; classPrefix, activeIndex, panels, isActive &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> React.Children.map(panels, (child) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> order = <span class="built_in">parseInt</span>(child.props.order, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> React.cloneElement(child, &#123;</span><br><span class="line">      classPrefix,</span><br><span class="line">      isActive,</span><br><span class="line">      children: child.props.children,</span><br><span class="line">      key: <span class="string">`tabpane-<span class="subst">$&#123;order&#125;</span>`</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是通过 React.Children.map 方法遍历子组件，同时利用 React 的 cloneElement 方法克隆到 TabPane 组件，最后返回这个 TabPane 组件集合。</p>
<p>React.Children 是 React 官方提供的一系列操作 children 的方法。它提供诸如 map、forEach、count 等实用函数。<br>使用 getTabPanes</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.getTabPanes()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如我们把 render 方法中的 this.getTabPanes 方法中对子组件的遍历直接放进去</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&lt;div&gt;&#123;React.Children.map(<span class="keyword">this</span>.props.children, (child</span>) =&gt;</span> &#123;...&#125;)&#125;&lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种调用方式称为 Dynamic Children（动态子组件）。</p>
<h2 id="组件props"><a href="#组件props" class="headerlink" title="组件props"></a>组件props</h2><p>也可以将子组件以props的形式传递。一般我们会用这种方法让开发者定义组件的某一个prop，让其具备多种类型，来做到简单配置和自定义配置组合在一起的效果。</p>
<h2 id="用function-prop与父组件通信"><a href="#用function-prop与父组件通信" class="headerlink" title="用function prop与父组件通信"></a>用function prop与父组件通信</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.onChange(activeIndex, prevIndex)</span><br></pre></td></tr></table></figure>
<p>触发了onChange prop回调函数给父组件必要的值。</p>
<h2 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h2><p>propTypes用于规范props的类型与必需的状态。它会在开发环境下，对组件的prop值的类型作检查。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">  classPrefix: React.PropTypes.string,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>propTypes有很多类型支持，不仅有基本类型，还包括枚举和自定义类型。</p>
<h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><h2 id="挂载和卸载过程"><a href="#挂载和卸载过程" class="headerlink" title="挂载和卸载过程"></a>挂载和卸载过程</h2><p>1.组件的挂载<br>这个过程主要做组件状态的初始化，我们推荐以下面例子为模板写初始化组件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>This is a demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们在componentWillMount中执行setState方法，组件会更新state，但组件只渲染一次。因此，这是无意义的执行，完全可以放在constructor初始化state中。<br>如果我们在componentDidMount中执行setState方法，组件会再次更新，不过在初始化过程就渲染了两次组件，这并不是一次好事。但实际情况，有一些场景必须这么做，比如需要获取组件的位置。</p>
<ol start="2">
<li>组件的卸载<br>componentWillUnmount，我们常常会执行一些清理方法，比如事件回收、清除定时器。</li>
</ol>
<h2 id="数据更新过程"><a href="#数据更新过程" class="headerlink" title="数据更新过程"></a>数据更新过程</h2><p>更新过程指的是父组件向下传递props或组件自身执行setState方法时发生的一系列更新动作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="comment">// this.setState(&#123;&#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="comment">// return true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果组件自身的state更新了，会依次执行shouldComponentUpdate、componentWillUpdate、render和componentDidUpdate</p>
<p>shouldComponentUpdate接收需要更新的props和state，让开发者增加判断逻辑，不需要更新方法最终返回false即可，这是性能优化的手段之一。</p>
<p>无状态组件是没有生命周期方法的，这也意味着它没有shouldComponentUpdate。渲染该类组件，每次都会重新渲染。</p>
<p>componentWillUpdate方法提供的是需要更新的props和state，而componentDidUpdate提供更新前的props和state。</p>
<p>注意不能在componentWillUpdate执行setState方法，会导致循环执行render。</p>
<p>如果组件是由父组件更新props而更新的，那么在shouldComponentUpdate之前会先执行componentWillRecieveProps方法。此方法可以作为React在props传入后，渲染之前setState的机会，在此方法中调用setState是不会二次渲染的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'activeIndex'</span> <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      activeIndex: nextProps.activeIndex</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="React与DOM"><a href="#React与DOM" class="headerlink" title="React与DOM"></a>React与DOM</h1><h2 id="ReactDOM"><a href="#ReactDOM" class="headerlink" title="ReactDOM"></a>ReactDOM</h2><p>ReactDOM中的API非常少，只有findDOMNode、unmountComponentAtNode和render。<br>1.findDOMNode<br>Reactz提供的获取DOM元素的方法有两种，其中一种就是ReactDOM提供的findDOMNode：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMElement findDOMNode(ReactComponent component)</span><br></pre></td></tr></table></figure></p>
<p>当组件被渲染到DOM后，findDOMNode返回该React组件实例相应的DOM节点。它可以用于获取表单的value以及用于DOM的测量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> dom = ReactDOM.findDOMNode(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent render(</span><br><span class="line">  ReactElement element,</span><br><span class="line">  DOMElement container,</span><br><span class="line">  [<span class="function"><span class="keyword">function</span> <span class="title">callback</span>]</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure>
<p>该方法把元素挂载到container中，并且返回element的实例（即refs引用）。如果是无状态组件，render会返回null。当组件装载完毕时，callback被调用。</p>
<p>与render相反，React还提供了一个很少使用的unmountComponentAtNode方法来进行卸载操作。</p>
<h2 id="ReactDOM的不稳定方法"><a href="#ReactDOM的不稳定方法" class="headerlink" title="ReactDOM的不稳定方法"></a>ReactDOM的不稳定方法</h2><p>unstable_renderSubtreeIntoContainer。它可以更新组件到传入的DOM节点。它与render方法相比，区别在于是否传入父节点。</p>
<p>另一个ReactDOM中的不稳定方法unstable_batchedUpdates是关于setState更新策略的。</p>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>它是React组件中非常特殊的prop，可以附加到任何一个组件上。组件被调用时会新建一个该组件的实例，而refs就会指向这个实例。</p>
<p>findDOMNode和refs都无法用于无状态组件中，无状态组件挂载只是方法调用，没有新建实例。</p>
<h2 id="React之外的DOM操作"><a href="#React之外的DOM操作" class="headerlink" title="React之外的DOM操作"></a>React之外的DOM操作</h2><p>调用HTML5 Audio/Video的play方法和input的focus方法，React就无能为力了，需要使用相应的DOM方法来实现。</p>
<p>还有组件以外区域（一般指document、body）的事件绑定、DOM的尺寸计算。</p>
<h1 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h1><p>React基于Virtual DOM实现了一个SyntheticEvent(合成事件)层，我们定义的处理器会接收一个SyntheticEvent对象的实例，它完全符合W3C标准，不会存在任何IE的兼容性问题。并且与原生的浏览器事件一样拥有同样的接口，同样支持事件的冒泡机制，我门可以使用stopPropagation()和preventDefault()来中断它。如果需要访问原生事件对象，可以使用nativeEvent属性。</p>
<h2 id="合成事件的绑定方式"><a href="#合成事件的绑定方式" class="headerlink" title="合成事件的绑定方式"></a>合成事件的绑定方式</h2><p>React事件的绑定方式与原生的HTML事件监听器属性很相似。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Test&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="合成事件的实现机制"><a href="#合成事件的实现机制" class="headerlink" title="合成事件的实现机制"></a>合成事件的实现机制</h2><p>在React底层，主要对合成事件做了两件事：事件委派和自动绑定。</p>
<p>1.事件委派</p>
<p>React不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。（实现原理：对最外层的容器进行绑定，依赖事件的冒泡机制完成委派。）这样简化了事件处理和回收机制，效率也有很大提升。</p>
<p>2.自定绑定</p>
<p>在React组件中，每个方法的上下文都会指向该组件的实例，即自定绑定this为当前组件。而且React还会对这种引用进行缓存。在使用ES6 classes或者纯函数时，这种自定绑定就不复存在了，我们需要手动实现this的绑定。<br>我们来看几种绑定方法<br>bind方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  constuctor() &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数可以自动绑定此函数的作用域的this<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick= <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在React中使用原生事件"><a href="#在React中使用原生事件" class="headerlink" title="在React中使用原生事件"></a>在React中使用原生事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeEventDemo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.button.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleClick)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmout() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.button.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleClick)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对比React合成事件与JavaScript原生事件"><a href="#对比React合成事件与JavaScript原生事件" class="headerlink" title="对比React合成事件与JavaScript原生事件"></a>对比React合成事件与JavaScript原生事件</h2><p>1.事件传播与阻止事件传播</p>
<p>浏览器原生DOM事件的传播可以分为3个阶段：事件捕获阶段、目标对象本身的事件处理程序调用、事件冒泡。可以将e.addEventListener的第三个参数设置为true时，为元素e注册捕获事件处理程序。事件捕获在IE9以下无法使用。事件捕获在应用程序开发中意义不大，React在合成事件中并没有实现事件捕获，仅仅支持了事件冒泡机制。</p>
<p>阻止原生事件传播需要使用e.stopPropagation，不过对于不支持该方法的浏览器（IE9以下）只能使用e.cancelBubble = true来阻止。而在React合成事件中，只需要使用stopPropagation()即可。阻止React事件冒泡的行为只能用于React合成事件系统中，且没有办法阻止原生事件的冒泡。反之，原生事件阻止冒泡，可以阻止React合成事件的传播。</p>
<p>2.事件类型</p>
<p>React合成事件的事件类型是JavaScript原生事件类型的一个子集。它仅仅实现了DOM Level3的事件接口，并且统一了浏览器的兼容问题。有些事件React没有实现，或者受某些限制没办法去实现，如window的resize事件。</p>
<p>3.事件绑定方式</p>
<p>受到DOM标准影响，浏览器绑定原生事件的方式有很多种。React合成事件的绑定方式则简单很多<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Test&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>4.事件对象</p>
<p>在React合成事件系统中，不存在兼容性问题，可以得到一个合成事件对象。</p>
<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>在React中，一切数据都是状态，当然也包括表单数据。接下来我们讲讲React是如何处理表单的。</p>
<h2 id="应用表单组件"><a href="#应用表单组件" class="headerlink" title="应用表单组件"></a>应用表单组件</h2><p>html表单中的所有组件在React的JSX都有实现，只是它们在用法上有些区别，有些是JSX语法上的，有些则是由于React对状态处理上导致的一些区别。</p>
<p>1.文本框<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      inputValue: <span class="string">''</span>,</span><br><span class="line">      textareaValue: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      inputValue: e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleTextareaChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      textareaValue: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; inputValue, textareaValue &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          单行输入框：</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;inputValue&#125; onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;</span></span><br><span class="line"><span class="regexp">          多行输入框：</span></span><br><span class="line"><span class="regexp">          &lt;textarea type="text" value=&#123;textareaValue&#125; onChange=&#123;this.handleTextareaChange&#125;/</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在HTML中textarea的值是通过children来表示的，而在react中是用一个value prop来表示表单的值的。</p>
<p>2.单选按钮与复选框</p>
<p>在HTML中，用类型为radio的input标签表示单选按钮，用类型为checkbox的input标签表示复选框。这两种表单的value值一般是不会改变的，而是通过一个布尔类型的checked prop来表示是否为选中状态。在JSX中这些是相同的，不过用法上还是有些区别。</p>
<p>单选按钮的示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  construtor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      radioValue: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">      radioValue: e.target.value</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; radioValue &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;gender:&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label&gt;</span></span><br><span class="line"><span class="regexp">          male:</span></span><br><span class="line"><span class="regexp">          &lt;input </span></span><br><span class="line"><span class="regexp">            type="radio"</span></span><br><span class="line"><span class="regexp">            value="male"</span></span><br><span class="line"><span class="regexp">            checked=&#123;radioValue === 'male'&#125;</span></span><br><span class="line"><span class="regexp">            onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label&gt;</span></span><br><span class="line"><span class="regexp">          female:</span></span><br><span class="line"><span class="regexp">          &lt;input </span></span><br><span class="line"><span class="regexp">            type="radio"</span></span><br><span class="line"><span class="regexp">            value="female"</span></span><br><span class="line"><span class="regexp">            checked=&#123;radioValue === 'female'&#125;</span></span><br><span class="line"><span class="regexp">            onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复选按钮的示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      coffee: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; checked, value &#125; = e.target;</span><br><span class="line">    <span class="keyword">let</span> &#123; coffee &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checked &amp;&amp; coffee.indexOf(value) === <span class="number">-1</span>) &#123;</span><br><span class="line">      coffee.push(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      coffee = coffee.filter(<span class="function"><span class="params">i</span> =&gt;</span> i !== value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      coffee,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; coffee &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;请选择你最喜欢的咖啡&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input </span></span><br><span class="line"><span class="regexp">            type="checkbox"</span></span><br><span class="line"><span class="regexp">            value="Cappuccino"</span></span><br><span class="line"><span class="regexp">            checked=&#123;coffee.indexOf('Cappuccino') !== -1&#125;</span></span><br><span class="line"><span class="regexp">            onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          Cappuccino</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;br /</span>&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          &lt;input </span><br><span class="line">            type=<span class="string">"checkbox"</span></span><br><span class="line">            value=<span class="string">"CafeMocha"</span></span><br><span class="line">            checked=&#123;coffee.indexOf(<span class="string">'CafeMocha'</span>) !== <span class="number">-1</span>&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          CafeMocha</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.Select组件</p>
<p>在HTML的select元素中，存在单选和多选两种。在JSX语法中，同样可以通过设置select标签的multiple={true}来实现一个多选下拉列表。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      area: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      area: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; area &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;select value=&#123;area&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">        &lt;option value=<span class="string">'beijing'</span>&gt;北京&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">        &lt;option value='shangehai'&gt;上海&lt;/</span>option&gt;</span><br><span class="line">      &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>select元素设置multiple={true}的示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      area: [<span class="string">'beijing'</span>, <span class="string">'shanghai'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; options &#125; = e.target;</span><br><span class="line">    <span class="keyword">const</span> area = <span class="built_in">Object</span>.keys(options)</span><br><span class="line">      .filter(<span class="function"><span class="params">i</span> =&gt;</span> options[i].selected === <span class="literal">true</span>)</span><br><span class="line">      .map(<span class="function"><span class="params">i</span> =&gt;</span> options[i].value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      area,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; area &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;select multiple=&#123;<span class="literal">true</span>&#125; value=&#123;area&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">        &lt;option value=<span class="string">"北京"</span>&gt;北京&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">        &lt;option value="上海"&gt;上海&lt;/</span>option&gt;</span><br><span class="line">      &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在HTMl的option组件需要一个selected属性来表示默认选中的列表项，而React的处理方式是通过为select组件添加value prop来表示选中的option，在一定程度上统一了接口。</p>
<p>实际上，也可以写成这种形式，不过开发体验就会差很多，React也会抛警告。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select multiple=&#123;<span class="literal">true</span>&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">  &lt;option value=<span class="string">"beijing"</span> selected=&#123;area.indexOf(<span class="string">'beijing'</span>) !== <span class="number">-1</span>&#125;&gt;北京&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">  &lt;option value="shanghai" selected=&#123;area.indexOf('shanghai') !== -1&#125;&gt;上海&lt;/</span>option&gt;</span><br><span class="line">&lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>每当表单的状态发生变化，都会被写入到组件的state中，这种组件在React中被称为受控组件。在受控组件中，组件渲染出的状态与它的value或checked prop相对应。React通过这种方式消除了组件的局部状态，使得应用的整个状态更加可控。</p>
<h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>如果一个表单组件没有value prop(或checked prop),就可以称之为非受控组件。相应的你可以使用defaultValue和defaultChecked prop来表示组件的默认状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Compoent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.refs.name;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input ref=<span class="string">"name"</span> type=<span class="string">"text"</span> defaultValue=<span class="string">"Hangzhou"</span> /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在React中，非受控组件是一种反模式，它的值不受组件自身的state或props控制。通常，需要为其添加ref prop来访问渲染后的底层DOM元素。</p>
<h2 id="对比受控组件和非受控组件"><a href="#对比受控组件和非受控组件" class="headerlink" title="对比受控组件和非受控组件"></a>对比受控组件和非受控组件</h2><p>受控组件和非受控组件的最大区别是：非受控组件的状态并不会受应用状态的控制，应用中也多了局部组件状态，而受控组件的值来自于组件的state。</p>
<p>1.性能上的问题</p>
<p>受控组件onChange后，调用setState会重新渲染，确实会有一些性能损耗。</p>
<p>2.是否需要事件绑定</p>
<p>受控组件需要为每个组件绑定一个change事件，并且定义一个事件处理器来同步表单值和组件的状态。</p>
<p>尽管如此，在React仍然提倡使用受控组件，因为它可以使得应用的整个状态更加可控。</p>
<h2 id="表单组件的几个重要属性"><a href="#表单组件的几个重要属性" class="headerlink" title="表单组件的几个重要属性"></a>表单组件的几个重要属性</h2><p>1.状态属性</p>
<p>React的form组件提供了几个重要的属性，用于展示组件的状态。<br>value: 类型为text的input组件、textarea组件以及select组件都借助value prop来展示应用的状态。<br>checked: 类型为radio或checkbox的组件借助值为boolean类型的checked prop来展示应用的状态。<br>selected: 该属性可作用于select组件下面的option上，React并不建议使用功这种方式，推荐使用value.</p>
<p>2.事件属性</p>
<p>在状态属性发生变化时，会触发onChange事件属性。实际上，受控组件中的change事件与HTML DOM中提供的input事件更为类似。React支持DOM Level3中定义的所有表单事件。</p>
<h1 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h1><h2 id="基本样式设置"><a href="#基本样式设置" class="headerlink" title="基本样式设置"></a>基本样式设置</h2><p>React可以通过设置className prop给html设置class，也可以通过style prop给组件设置行内样式。</p>
<h2 id="使用classnames库"><a href="#使用classnames库" class="headerlink" title="使用classnames库"></a>使用classnames库</h2><p>我们可以通过classnames库来设置html的类名</p>
<h2 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h2><p>CSS模块化的解决方案有很多，但主要有两类。</p>
<ol>
<li>Inline Style。这种方案彻底抛弃CSS，使用JavaScript或JSON来写样式，能给CSS提供JavaScript同样强大的模块化能力。但缺点同样明显，它几乎不能利用CSS本身的特性，比如级联、媒体查询等，:hover和:active等伪类处理起来比较复杂。另外，这种方案需要依赖框架实现，其中与React相关的有Radium、jsxstyle和react-style</li>
<li>CSS Modules。依旧使用CSS，但使用JavaScript来管理样式依赖。CSS Modules能最大化地结合现有CSS生态和JavaScript模块化能力，其API非常简洁。发布时依旧编译出单独的JavaScript和CSS文件。现在，webpack css-loader内置CSS Modules功能。</li>
</ol>
<p>1.CSS模块化遇到了哪些问题</p>
<p>CSS模块化重要的是解决好以下两个问题：CSS样式的导入与导出。灵活按需导入以便复用代码，导出时要隐藏内部作用域，以免造成全局污染。Sass、Less、PostCSS等试图解决CSS编程能力弱的问题，但并没有解决模块化这个问题。React实际开发需要的CSS相关问题有：</p>
<ol>
<li>全局污染：CSS使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的样式全局生效，样式可能被错误覆盖。因此产生了非常丑陋的!important，甚至inline !important和复杂的选择器权重计数表，提高犯错概率和使用成本。Web Component标准中的Shadow DOM能彻底解决这个问题，但它把样式彻底局部化，造成外部无法重写样式，损失了灵活性。</li>
<li>命名混乱：由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复杂，容易形成不同的命名风格，样式变多后，命名将更加混乱。</li>
<li>依赖管理不彻底：组件应该相互独立，引入一个组件时，应该只引入它所需要的CSS样式。现在的做法是除了引入JavaScript，还要再引入它的CSS，而且Sass/Less很难实现对每个组件都编译出单独的CSS，引入所有模块的CSS又造成浪费。JavaScript的模块化已经非常成熟，如果能让JavaScript来管理CSS依赖是很好的解决办法，而webpack的css-loader提供了这种能力。</li>
<li>无法共享变量：复杂组件要使用JavaScript和CSS来共同处理样式，就会造成有些变量在JavaScript和CSS中冗余，而预编译语言不能提供跨JavaScript和CSS共享变量的这种能力。</li>
<li>代码压缩不彻底：对与非常长的类名压缩无能为力。</li>
</ol>
<p>2.CSS Modules模块化方案</p>
<p>CSS Modules内部通过ICSS来解决样式导入和导出这两个问题，分别对应:import和:export两个新增的伪类。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:import("path/to/dep.css") &#123;</span><br><span class="line">  <span class="selector-tag">localAlias</span>: <span class="selector-tag">keyFromDep</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:export</span> &#123;</span><br><span class="line">  <span class="attribute">exportedKey</span>: exportedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但直接使用这两个关键字编程太烦琐，项目中很少会直接使用它们，我们需要的是用JavaScript来管理CSS的能力。结合webpack的css-loader，就可以在CSS中定义样式，在JavaScript文件中导出。</p>
<h2 id="启用CSS-Modules"><a href="#启用CSS-Modules" class="headerlink" title="启用CSS Modules"></a>启用CSS Modules</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css?modules&amp;localIdentName=[name]__[local]-[hash:base64:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>加上modules即为启用，其中localIdentName是设置生成样式命名规则</p>
<p>下面我们看看js是怎么引入CSS的：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* button相关的所有样式 */</span></span><br><span class="line"><span class="selector-class">.normal</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Button.css'</span></span><br><span class="line"></span><br><span class="line">buttonElm.outerHTML = <span class="string">`&lt;button class=<span class="subst">$&#123;styles.normal&#125;</span>&gt;Submit&lt;/button&gt;`</span></span><br></pre></td></tr></table></figure>
<p>最终生成的HTML是这样的<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"button--normal-abc5436"</span>&gt;Processing...&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样class的名称基本就是唯一的。<br>CSS Modules对CSS中的class名都做了处理，使用对象来保存原class和混淆后class的对应关系。通过这些简单的处理，CSS Modules实现了以下几点：</p>
<ol>
<li>所有样式都是局部化的，解决了命名冲突和全局污染问题</li>
<li>class名生成规则配置灵活，可以以此来压缩class名</li>
<li>只需要引用组件的JavaScript，就能搞定组件所有的JavaScript和CSS</li>
<li>依然是CSS，学习成本几乎为零<h2 id="样式默认局部"><a href="#样式默认局部" class="headerlink" title="样式默认局部"></a>样式默认局部</h2>使用CSS Modules相当于给每个class名外加了:local，以此来实现样式的局部化。如果我们想切换到全局模式，可以使用:global包裹<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.normal &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 与上面等价 */</span></span><br><span class="line">:local(.normal) &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定义全局样式 */</span></span><br><span class="line">:global(.btn) &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定义多个全局样式 */</span></span><br><span class="line">:global &#123;</span><br><span class="line">  .link &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">  .box &#123;</span><br><span class="line">    color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="使用composes来组合样式"><a href="#使用composes来组合样式" class="headerlink" title="使用composes来组合样式"></a>使用composes来组合样式</h2><p>对于样式复用，CSS Modules只提供了唯一的方式来处理——composes组合。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* components/Button.css */</span></span><br><span class="line"><span class="selector-class">.base</span> &#123; <span class="comment">/* 所有通用的样式 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.normal</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: base;</span><br><span class="line">  <span class="comment">/* normal其他样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，使用composes还可以组合外部文件中的样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* settings.css */</span></span><br><span class="line"><span class="selector-class">.primary-color</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* component/Button.css */</span></span><br><span class="line"><span class="selector-class">.base</span> &#123; <span class="comment">/* 所有通用样式 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.primary</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: base;</span><br><span class="line">  <span class="attribute">composes</span>: $primary-color from <span class="string">'./settings.css'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于大多数项目，有了composes后，已经不再需要预编译处理器了。但是如果想用的话，由于composes不是标准的CSS语法，编译会报错，此时只能使用预处理自己的语法做样式复用了。</p>
<h2 id="class命名技巧"><a href="#class命名技巧" class="headerlink" title="class命名技巧"></a>class命名技巧</h2><p>CSS Modules的命名规范是从BEM扩展而来的。BEM把样式名分为3个级别</p>
<ol>
<li>Block: 对应模块名，如Dialog</li>
<li>Element: 对应模块中的节点名 Confirm Button</li>
<li>Modifier: 对应节点相关的状态，如disabled和highlight<br>如dialog__confirm-button–highlight。<h2 id="实现CSS与JavaScript变量共享"><a href="#实现CSS与JavaScript变量共享" class="headerlink" title="实现CSS与JavaScript变量共享"></a>实现CSS与JavaScript变量共享</h2>:export关键字可以把CSS中的变量输出到JavaScript中<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary-color</span>: <span class="number">#f40</span>;</span><br><span class="line"></span><br><span class="line">:export &#123;</span><br><span class="line">  primaryColor: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'config.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(style.primaryColor);</span><br></pre></td></tr></table></figure>
<h2 id="CSS-Modules使用技巧"><a href="#CSS-Modules使用技巧" class="headerlink" title="CSS Modules使用技巧"></a>CSS Modules使用技巧</h2><p>建议遵循如下原则</p>
<ol>
<li>不使用选择器，只使用class名来定义样式</li>
<li>不层叠多个class，只使用一个class把所有样式定义好</li>
<li>所有样式通过composes组合来实现复用</li>
<li>不嵌套<br>常见问题<br>1.如果在一个style文件使用同名class?<br>虽然编译后可能是随机码，但仍是同名的。<br>2.如果在style文件中使用了id选择器、伪类和标签选择器等呢？<br>这些选择器不被转换，原封不动地出现在编译后的CSS中。也就是CSS Moudles只会转换class名相关的样式<h2 id="CSS-Modules结合历史遗留项目实践"><a href="#CSS-Modules结合历史遗留项目实践" class="headerlink" title="CSS Modules结合历史遗留项目实践"></a>CSS Modules结合历史遗留项目实践</h2></li>
</ol>
<p>1.外部如何覆盖局部样式</p>
<p>因为无法预知最终的class名，不能通过一般选择器覆盖样式。我们可以给组件关键节点加上data-role属性，然后通过属性选择器来覆盖样式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dialog.js</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=&#123;styles.root&#125; data-role=<span class="string">"dialog-root"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// dialog.css</span><br><span class="line"><span class="selector-attr">[data-role=<span class="string">"dialog-root"</span>]</span> &#123;</span><br><span class="line">  // override style</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.如何与全局样式共存</p>
<p>修改webpack配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    exclude: path.resolve(__dirname, <span class="string">'src/views'</span>),</span><br><span class="line">    loader: <span class="string">'style!css?modules&amp;localIdentName=[name]__[local]!sass?sourceMap=true'</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    include: path.resolve(__dirname, <span class="string">'src/styles'</span>),</span><br><span class="line">    loader: <span class="string">'style!css!sass?sourceMap=true'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/app.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./styles/app.scss'</span>;</span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'./view/Component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* src/views/Component.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./Component.scss'</span></span><br></pre></td></tr></table></figure>
<h2 id="CSS-Modules结合React实践"><a href="#CSS-Modules结合React实践" class="headerlink" title="CSS Modules结合React实践"></a>CSS Modules结合React实践</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./dialog.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.root&#125;&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果不想频繁地输入styles.**，可以使用react-css-modules</p>
<h1 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h1><h2 id="父组件向子组件通信"><a href="#父组件向子组件通信" class="headerlink" title="父组件向子组件通信"></a>父组件向子组件通信</h2><p>父组件可以通过props向子组件传递需要的信息</p>
<h2 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h2><p>有两种方法：1.利用回调函数。2.利用自定义事件机制：这种方法更通用，设计组件时考虑加入事件机制往往可以达到简化组件API的目的。</p>
<p>在React中，可以使用任意一种方法，在简单场景下使用自定义事件过于复杂，一般利用回调函数。</p>
<h2 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h2><p>当需要让子组件跨级访问信息时，若像之前那样向更高级别的组件层层传递props，此时代码显得不那么优雅，甚至有些冗余。在React中，我们还可以使用context来实现跨级父子组件间的通信。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.context.color &#125;&#125;&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      color: <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React官方并不建议大量使用context，因为当组件结构复杂的时候，我们很难知道context是从哪传过来的。使用context比较好的场景是真正意义上的全局信息且不会更改，例如界面主题、用户信息等。总体的原则是如果我们真的需要它，那么建议写成高阶组件来实现。</p>
<h2 id="没有嵌套关系的组件通信"><a href="#没有嵌套关系的组件通信" class="headerlink" title="没有嵌套关系的组件通信"></a>没有嵌套关系的组件通信</h2><p>没有嵌套关系的，那只能通过可以影响全局的一些机制去考虑。之前讲的自定义事件机制不失为一种上佳的方法。</p>
<p>我们在处理事件过程中需要注意，在componentDidMount事件中，如果组件挂载完成，再订阅事件；当组件卸载的时候，在componentWillUnmount事件中取消事件的订阅。</p>
<p>对于React使用的场景，EventEmitter只需要单例就可以了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; EventEmitter &#125; <span class="keyword">from</span> <span class="string">'events'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> EventEmitter();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">'./events'</span>;</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'ItenChange'</span>, entry)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.itemChange = emitter.on(<span class="string">'ItemChange'</span>, (data) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    emitter.removeListener(<span class="keyword">this</span>.itemChange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，程序中出现多级传递或跨级传递，那么要个重新审视一下是否有更合理的方式。Pub/Sub的模式可能也会带来逻辑关系的混乱。</p>
<p>跨级通信往往是反模式的，应该尽量避免仅仅通过例如Pub/Sub实现的设计思路，加入强依赖与约定来进一步梳理流程是更好的方法。（如使用Redux）</p>
<h1 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h1><p>常常有这样的场景，有一类功能需要被不同的组件公用，此时就涉及抽象的话题。我们重点讨论两种：mixin和高阶组件</p>
<h2 id="封装mixin方法"><a href="#封装mixin方法" class="headerlink" title="封装mixin方法"></a>封装mixin方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = <span class="function"><span class="keyword">function</span>(<span class="params">obj, mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = obj;</span><br><span class="line">  newObj.prototype = <span class="built_in">Object</span>.create(obj.prototype);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> mixins) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mixins.hasOwnProperty(prop)) &#123;</span><br><span class="line">      newObj.prototype[prop] = mixins[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BigMixin = &#123;</span><br><span class="line">  fly: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fly'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Big = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new big'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consg FlyBig = mixin(Big, BigMixin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flyBig = <span class="keyword">new</span> FlyBig();</span><br><span class="line">flyBig.fly(); <span class="comment">// =&gt; 'fly'</span></span><br></pre></td></tr></table></figure>
<p>对于广义的mixin方法，就是用赋值的方式将mixin对象里的方法都挂载到原对象上，来实现对对象的混入。</p>
<p>看到上述实现，你可能会联想到underscore库中的extend或lodash库中的assign方法，或者说ES6中的Object.assign()方法。MDN上的解释是把任意多个源对象所拥有的自身可枚举属性复制给目标对象，然后返回目标对象。</p>
<h2 id="在React中使用mixin"><a href="#在React中使用mixin" class="headerlink" title="在React中使用mixin"></a>在React中使用mixin</h2><p>React在使用createClass构建组件时提供了mixin属性，比如官方封装的PureRenderMixin<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PureRenderMixin <span class="keyword">from</span> <span class="string">'react-addons-pure-render-mixin'</span>;</span><br><span class="line"></span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>mixins数组也可以增加多个mixin，其若mixin方法之间有重合，对于普通方法，在控制台里会报一个ReactClassInterface的错误。对于生命周期方法，会将各个模块的生命周期方法叠加在一起顺序执行。</p>
<p>mixin为组件做了两件事：</p>
<ol>
<li>工具方法。如果你想共享一些工具类方法，可以定义它们，直接在各个组件中使用。</li>
<li>生命周期继承，props与state合并，mixin也可以作用在getInitialState的结果上，作state的合并，而props也是这样合并的。<h2 id="ES6-Classes与decorator"><a href="#ES6-Classes与decorator" class="headerlink" title="ES6 Classes与decorator"></a>ES6 Classes与decorator</h2>ES6 classes形式构建组件，它并不支持mixin。decorator语法糖可以实现class上的mixin。</li>
</ol>
<p>core-decorators库为开发者提供了一些实用的decorator,其中实现了我们正想要的@mixin<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getOwnPropertyDescriptors &#125; <span class="keyword">from</span> <span class="string">'./private/utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; defineProperty &#125; = <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClass</span>(<span class="params">target, mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!mixins.length) &#123;</span><br><span class="line">    <span class="comment">// throw error;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = mixins.length; i &lt; l; i ++) &#123;</span><br><span class="line">    <span class="keyword">const</span> descs = getOwnPropertyDescriptors(mixins[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> descs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> target.prototype)) &#123;</span><br><span class="line">        defineProperty(target.prototype, key, descs[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> mixins[<span class="number">0</span>] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleClass(mixins[<span class="number">0</span>], [])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> handleClass(target, mixins)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原理也很简单，它将每一个mixin对象的方法都叠加到target对象的原型上以达到mixin的目的。这样就可以用@mixin来做多个重用模块的叠加了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PureRender = &#123;</span><br><span class="line">  shouldComponentUpdate() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Theme = &#123;</span><br><span class="line">  setTheme() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixin(PureRender, Theme)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mixin的逻辑和最早实现的简单逻辑很相似，之前直接给对象的prototype属性赋值，但这里用了getOwnPropertyDescriptor和defineProperty这两个方法，有什么区别呢？</p>
<p>这样实现的好在于definedProperty这个方法，也就是定义和赋值的区别，定义是对已有的定义，赋值是覆盖已有的定义。前者并不会覆盖已有方法，但后者会。本质上与官方的mixin方法都很不一样，除了定义方法级别不能覆盖外，还得加上对生命周期方法的继承，以及对state的合并。</p>
<p>decorator还有作用在方法上的，它可以控制方法的自有属性，也可以作decorator的工厂方法。</p>
<h2 id="mixin的问题"><a href="#mixin的问题" class="headerlink" title="mixin的问题"></a>mixin的问题</h2><p>mixin存在很多问题，已经被官方弃用了，由高阶组件替代。</p>
<p>1.破坏的原有组件的封装</p>
<p>我们知道mixin方法会混入方法，给原有组件带来新的特性，比如mixin中有一个renderList方法，给我们带来了渲染List的能力，但它也可能带来新的state和props,这意味着组件有一些”不可见”的状态需要我们去维护，但我们在使用的时候并不清楚。此外renderList中的方法会调用组件中方法，但很可能被其他mixin截获，带来很多不可知。</p>
<p>2.不同mixin的命名冲突</p>
<p>3.增加复杂性</p>
<p>我们设计一个组件，引入PopupMixin的mixin，这样就给组件引进了PopupMixin生命周期方法。当我们再引入HoverMixin，将有更多的方法被引进。当然我们可以进一步抽象出TooltipMixin,将两个整合在一起，但我们发现它们都有compomentDidUpdate方法。过一段时间，你会发现它的逻辑已经复杂到难以理解了。</p>
<p>我们写React组件时，首先考虑的往往是单一的功能、简洁的设计和逻辑。当加入功能的时候，可以继续控制组件的输入和输出。如果说因为复杂性，我们不断加入新的状态，那么组件会变得非常难维护。</p>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶函数是函数式编程中的一个基本概念，这种函数接受函数作为输入，或是输出一个函数。<br>高阶组件类似高阶函数，它接受React组件作为输入，输出一个新的React组件。</p>
<p>高阶组件让我们的代码更具有复用性、逻辑性与抽象特性，它可以对render方法作劫持，也可以控制props和state。</p>
<p>实现高阶组件的方法有两种：</p>
<ol>
<li>属性代理：通过被包裹的React组件来操作props</li>
<li>反向继承：继承于被包裹的React组件</li>
</ol>
<p>1.属性代理<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就可以通过高阶组件来传递props，这种方法即为属性代理。<br>这样组件就可以一层层地作为参数被调用，原始组件就具备了高阶组件对它的修饰。保持了单个组件封装性同时还保留了易用性。当然，也可以用decorator来转换<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@MyContainer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent</span><br></pre></td></tr></table></figure></p>
<p>上述执行生命周期的过程类似于堆栈调用：<br>didmount -&gt; HOC didmount -&gt; (HOCs didmount) -&gt; (HOCs will unmount) -&gt; HOC will unmount -&gt; unmount<br>从功能上，高阶组件一样可以做到像mixin对组件的控制，包括控制props、通过refs使用引用、抽象state和使用其他元素包裹WrappedComponent.</p>
<p>1.控制props</p>
<p>我们可以读取、增加、编辑或是移除从WrappedComponent传进来的props，但需要小心删除与编辑重要的props。我们应该尽可能对高阶组件的props作新的命名以防止混淆。</p>
<p>例如，我们需要增加一个新的prop:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        text: newText,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.通过refs使用引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    proc(wrappedComponentInstance) &#123;</span><br><span class="line">      wrappedComponentInstance.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.props, &#123;</span><br><span class="line">        ref: <span class="keyword">this</span>.proc.bind(<span class="keyword">this</span>),</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以方便地用于读取或增加实例的props,并调用实例的方法。<br>3.抽象state<br>高阶组件可以将原组件抽象为展示型组件，分离内部状态<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        name: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.onNameChange = <span class="keyword">this</span>.onNameChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onNameChange(event) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        name: event.target.value</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">          value: <span class="keyword">this</span>.state.name,</span><br><span class="line">          onChange: <span class="keyword">this</span>.onNameChange,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这样就有效地抽象了同样的state操作。<br>4.使用其他元素包裹WrappedComponent<br>这既可以是为了加样式，也可以是为了布局<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123; <span class="attr">display</span>: <span class="string">'block'</span> &#125;&#125;&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span></span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高阶组件返回的组件继承于WrappedComponent，因为被动地继承了WrappedComponent，所有调用都会反向，这也是这种方法的由来。<br>因为依赖于继承的机制，HOC的调用顺序和队列是一样的<br>didmount-&gt;HOC didmount-&gt;(HOCs didmount)-&gt;will unmount-&gt;HOC will unmount-&gt;(HOCs will unmount)</p>
<p>在反向继承方法中，高阶组件可以使用WrappedComponent引用，这意味着它可以使用WrappedComponent的state、props、生命周期、和render。但它不能保证完整的子组件树被解析。</p>
<p>它有两大特点</p>
<p>1.渲染劫持</p>
<p>高阶组件可以控制WrappedComponent的渲染过程。可以在这个过程中在任何React元素输出的结果中读取；增加、修改。删除props,或读取或修改React元素树，或条件显示元素树，又或是用样式控制包裹元素树。</p>
<p>如果元素树中包括了函数类型的React组件，就不能操作组件的子组件。</p>
<p>条件渲染示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对render的输出结果进行修改<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> elementsTree = <span class="keyword">super</span>.render();</span><br><span class="line">      <span class="keyword">let</span> newProps;</span><br><span class="line">      <span class="keyword">if</span> (elementsTree &amp;&amp; elementsTree.type === <span class="string">'input'</span>) &#123;</span><br><span class="line">        newProps = &#123; <span class="attr">value</span>: <span class="string">'may the force be with you'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, elementsTree.props, newProps);</span><br><span class="line">      <span class="keyword">const</span> newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children);</span><br><span class="line">      <span class="keyword">return</span> newElementsTree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.控制state</p>
<p>高阶组件可以读取、修改或删除WrappedComponent实例中的state，如果需要的话，也可以增加state。但这样做，可能会让WrappedComponent组件内部状态变得一团糟。大部分高阶组件都应该限制读取或增加state，尤其是后者，可以通过重命名state，以防止混淆<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;HOC Debugger Component&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;Props&lt;/</span>p&gt;<span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;JSON.stringify(this.props, null, 2)&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line">          &lt;p&gt;State&lt;<span class="regexp">/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/</span>pre&gt;</span><br><span class="line">          &#123;<span class="keyword">super</span>.render()&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，显示了WrappedComponent的props和state，方便我们调试。</p>
<h2 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h2><p>高阶组件失去了原始的diplayName，我们应该为高阶组件命名<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOC.displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName ||</span><br><span class="line">         WrappedComponent.name || </span><br><span class="line">         <span class="string">'Component'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件参数"><a href="#组件参数" class="headerlink" title="组件参数"></a>组件参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOCFactoryFactory</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">HOCFactory</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合式组件开发实践"><a href="#组合式组件开发实践" class="headerlink" title="组合式组件开发实践"></a>组合式组件开发实践</h2><p>我们多次提到，使用React开发组件时利用props传递参数。也就是说，用参数来配置组件时我们最常用的封装方式。随着场景发生变化，组件的形态也发生变化，我们必须不断增加props去应对变化，此时便会导致props的泛滥，而在拓展中又必须保证组件向下兼容，只增不减，使组件的可维护性降低。</p>
<p>我们就可以利用上述高阶组件的思想，提出组件组合式开发模式，有效地解决了配置式所存在的一些问题。</p>
<p>1.组件再分离</p>
<p>SelectInput、SearchInput与List三个颗粒度更细的组件可以组合成功能丰富的组件，而每个组件可以是纯粹的、木偶式的组件。</p>
<p>2.逻辑再抽象</p>
<p>组件中相同交互逻辑和业务逻辑也应该抽象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成SearchInput与List的交互</span></span><br><span class="line"><span class="keyword">const</span> searchDecorator = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SearchDecorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.handleSearch = <span class="keyword">this</span>.handleSearch.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleSearch(keyword) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        data: <span class="keyword">this</span>.props.data,</span><br><span class="line">        keyword,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.props.onSearch(keyword)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data, keyword &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          data=&#123;data&#125;</span><br><span class="line">          keyword=&#123;keyword&#125;</span><br><span class="line">          onSearch=&#123;<span class="keyword">this</span>.handleSearch&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SearchDecorator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成List数据请求</span></span><br><span class="line"><span class="keyword">const</span> asyncSelectDecorator = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AsyncSelectDecorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; url, params &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">      fetch(url, &#123; params &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          data=&#123;<span class="keyword">this</span>.state.data&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AsyncSelectDecorator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们用compose将高阶组件层层包裹，将页面和逻辑完美结合在一起<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FinalSelector = compose(asyncSelectDecorator, searchDecorator, selectedItemDecorator)(Selector)</span><br></pre></td></tr></table></figure></p>
<h1 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h1><p>从React的渲染过程中，如何防止不必要的渲染是最需要去解决的问题。<br>针对这个问题，React官方提供了一个便捷的方法来解决，那就是PureRender</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>纯函数由三大原则构成</p>
<p>1.给定相同的输入，它总是返回相同的输出</p>
<p>2.过程没有副作用（我们不能改变外部状态）</p>
<p>3.没有额外的状态依赖</p>
<p>纯函数也非常方便进行方法级别的测试以及重构，可以让程序具有良好的扩展性及适应性。</p>
<h2 id="PureRender"><a href="#PureRender" class="headerlink" title="PureRender"></a>PureRender</h2><p>PureRender中的Pure指的就是组件满足纯函数的条件，即组件的渲染是被相同的props和state渲染进而得到相同的结果。</p>
<p>1.PureRender本质</p>
<p>官方在早期为开发者提供了一个react-addons-pure-render-mixin的插件，其原理为重新实现了shouldComponentUpdate生命周期方法，让当前传入的props和state与之前的作浅比较，如果返回false,那么组件就不会执行render方法。（若做深度比较，也很耗性能）</p>
<p>PuerRender源码中，只对新旧props作了浅比较，以下是shallowEqual的示例代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">obj, newObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === newObj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> objKeys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">const</span> newObjKeys = <span class="built_in">Object</span>.keys(newObj);</span><br><span class="line">  <span class="keyword">if</span> (objKeys.length !== newObjKeysl.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> objKeys.every(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newObj[key] === obj[key];</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.优化PureRender</p>
<p>如果说props或state中有以下几种类型的情况，那么无论如何，它都会触发PureRender为true。</p>
<p>3.1直接为props设置对象或数组</p>
<p>引用的地址会改变<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Account style=&#123;&#123; <span class="attr">color</span>: <span class="string">'black'</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>避免这个问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultStyle = &#123;&#125;;</span><br><span class="line">&lt;Account style=&#123;&#123; <span class="keyword">this</span>.props.style || defaultStyle &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.2设置props方法并通过事件绑定在元素上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.update(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.3设置子组件</p>
<p>对于设置了子组件的React组件，在调用shouldComponentUpdate时，均返回true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Item&gt;</span><br><span class="line">        &lt;span&gt;Arcthur&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Item&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Item </span><br><span class="line">  children=&#123;React.createElement(<span class="string">'span'</span>, &#123;&#125;, <span class="string">'Arcthur'</span>)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>怎么避免重复渲染覆盖呢?我们在NameItem设置PureRender，也就是提到父级来判断。</p>
<h2 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h2><p> 在传递数据时可以直接使用Immutable Data来进一步提升组件的渲染性能。</p>
<p> JavaScript中的对象一般是可变的，因为使用了引用赋值，新的对象简单地引用了原始对象，改变新的对象将影响到原始对象。</p>
<p> 使用浅拷贝或深拷贝可以避免修改，但这样做又造成了内存和CPU的浪费。</p>
<p> 1.Immutable Data一旦被创建，就不能再更改数据，对Immutable对象进行修改，添加或删除操作，都会返回一个新的Immutable对象。Immutable实现的原理是持久化的数据结构，也就是使用旧数据创建新数据，要保存旧数据同时可用且不变，同时为了避免深拷贝把所有节点复制一遍带来的性能损耗，Immutable使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。</p>
<h2 id="Immutable的优点"><a href="#Immutable的优点" class="headerlink" title="Immutable的优点"></a>Immutable的优点</h2><p>1.降低了可变带来的复杂度。</p>
<p>可变数据耦合了time和value的概念，造成了数据很难被回溯<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touchAndLog</span> (<span class="params">touchFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = &#123; <span class="attr">key</span>: <span class="string">'1'</span> &#125;</span><br><span class="line">  touchFn(data);</span><br><span class="line">  <span class="built_in">console</span>.log(data.key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若data是不可变的，能打印的结果是什么。</p>
<p>2.节省内存</p>
<p>Immutable使用的结构共享尽量复用内存。没有引用的对象会被垃圾回收。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Map</span>(&#123;</span><br><span class="line">  select: <span class="string">'1'</span>,</span><br><span class="line">  filter: <span class="built_in">Map</span>(&#123; <span class="attr">name</span>: <span class="string">'2'</span> &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = a.set(<span class="string">'select'</span>, <span class="string">'people'</span>);</span><br><span class="line"></span><br><span class="line">a === b</span><br><span class="line">a.get(<span class="string">'filter'</span>) === b.get(<span class="string">'filter'</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>3.撤销/重做，复制/粘贴，甚至时间旅行这些功能都很容易实现。</p>
<p>因为每次数据都是不一样的，那么只要把这些数据放到一个数组里存储起来，就能自由回退。</p>
<p>4.并发安全</p>
<p>数据天生是不可变的，后端常用的并发锁就不需要了，然而现在并没有用，因为一般JavaScript是单线程运行的。</p>
<p>5.拥抱函数式编程</p>
<p>Immutable本身就是函数式编程中的概念，只要输入一致，输出必然一致。</p>
<h2 id="使用Immutable的缺点"><a href="#使用Immutable的缺点" class="headerlink" title="使用Immutable的缺点"></a>使用Immutable的缺点</h2><p>容易与原生对象混淆是使用Immutale的过程中遇到的最大问题。<br>下面给出了一些办法</p>
<p>1.使用FlowType或TypeScript静态类型检查工具</p>
<p>2.约定变量命名规则，如Immutable类型对象以$$开头</p>
<p>3.使用Immutable.fromJS而不是Immutable.Map或Immutable.List来创建对象，这样可以避免Immutable对象和原生对象间的混用</p>
<h2 id="Immutable-js"><a href="#Immutable-js" class="headerlink" title="Immutable.js"></a>Immutable.js</h2><p>两个Immutable对象可以使用===来比较，这样是直接比较内存地址，其性能最好。但是即使两个对象的值是一样的，也会返回false。</p>
<p>Immutable提供了Immutable.is来作”值比较”，Immutable比较的是两个对象的hasCode或valueOf，由于Immutable内部使用了trie数据结构来存储，只要两个对象的hasCode相等，值就是一样的。这样的算法避免了深度遍历比较，因此性能非常好。</p>
<h2 id="Immutable与cursor"><a href="#Immutable与cursor" class="headerlink" title="Immutable与cursor"></a>Immutable与cursor</h2><p>这里的cursor和数据库中的游标是完全不同的概念。由于Immutable数据一般嵌套非常深，所以为了便于访问深层数据，cursor提供了可以直接访问这个深层数据的引用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = Immutable.fromJS(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125; &#125;);</span><br><span class="line"><span class="keyword">let</span> cursor = Cursor.from(data, [<span class="string">'a'</span>, <span class="string">'b'</span>], newData =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当cursor或其子cursor执行更新时调用</span></span><br><span class="line">  <span class="built_in">console</span>.log(newData)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">cursor.get(<span class="string">'c'</span>);</span><br><span class="line">cursor = cursor.update(<span class="string">'c'</span>, x =&gt; x + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">cursor.get(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="Immutable与PureRender"><a href="#Immutable与PureRender" class="headerlink" title="Immutable与PureRender"></a>Immutable与PureRender</h2><p>React做性能优化时最常用的就是shouldComponentUpdate，使用深拷贝和深比较是非常昂贵的选择。而使使用Immutable.js，===和is是高效地判断数据是否变化的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; is &#125; <span class="keyword">from</span> <span class="string">'immutable'</span></span><br><span class="line"></span><br><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">const</span> thisProps = <span class="keyword">this</span>.props || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> thisState = <span class="keyword">this</span>.state || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(thisProps).length !== <span class="built_in">Object</span>.keys(nextProps).length || <span class="built_in">Object</span>.keys(thisState).length !== <span class="built_in">Object</span>.keys(nextState).length)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.hasOwnProperty(key) &amp;&amp; !is(thisProps[key], nextProps[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextState.hasOwnProperty(key) &amp;&amp; !is(thisState[key], nextState[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Immutable与setState"><a href="#Immutable与setState" class="headerlink" title="Immutable与setState"></a>Immutable与setState</h2><p>React建议把this.state当作不可变的，因此修改前需要做一个深拷贝<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    data: &#123; <span class="attr">time</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleAdd() &#123;</span><br><span class="line">    <span class="keyword">let</span> data = _.cloneDeep(<span class="keyword">this</span>.state.data);</span><br><span class="line">    data.time = data.time + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; data &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Immutable后，操作变得很简单<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="built_in">Map</span> &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    data: <span class="built_in">Map</span>(&#123; <span class="attr">time</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleAdd() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      data: data.update(<span class="string">'times'</span>, v =&gt; v + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Immutable可以给应用带来极大的性能提升。</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>如果每一个组件是一个数组或迭代器的话，那么必须有一个唯一的key prop。它是用来标识当前项的唯一性的。如果使用index，它相当于一个随机键，无论有没有相同的项，更新都会渲染。如果key相同，react会抛警告，且只会渲染第一个key。</p>
<p>若有两个子组件需要渲染，可以用插件createFragment包裹来解决。</p>
<h2 id="react-addons-perf"><a href="#react-addons-perf" class="headerlink" title="react-addons-perf"></a>react-addons-perf</h2><p>react-addons-perf通过Perf.start和Perf.stop两个API设置开始和结束的状态来作分析，它会把各组件渲染的各阶段的时间统计出来，然后打印出一张表格。</p>
<h1 id="解读-React-源码"><a href="#解读-React-源码" class="headerlink" title="解读 React 源码"></a>解读 React 源码</h1><p>注：源码以React15.0</p>
<p>reconciler（协调器），是最核心的部分。包含 React 中自定义组件的实现（ReactCompositeComponent）、组件生命周期机制、setState 机制（ReactUpdates、ReactUpdateQueue）、DOM diff 算法（ReactMultiChild）等重要的特性方法。</p>
<h2 id="Virtual-DOM-1"><a href="#Virtual-DOM-1" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>构建一套简易的 Virtual DOM 并不复杂，它只需要具备一个 DOM 标签所需要的基本元素即可：</p>
<ol>
<li>标签名</li>
<li>节点属性，包含样式、属性、事件等</li>
<li>子节点</li>
<li>标识 id</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tagName: <span class="string">'div'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    style: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [],</span><br><span class="line">  key: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Virtual DOM 当然远不止于此，却也离不开这些基础元素。下面让我们一探究竟</p>
<p>Virtual DOM 中的节点称为 ReactNode,它分为 3 种类型 ReactElement、ReactFragment 和 ReactText。其中 ReactElement 又分为 ReactComponentElement 和 ReactDOMElement。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type ReactNode = ReactElement | ReactFragment | ReactText;</span><br><span class="line"></span><br><span class="line">type ReactElement = ReactComponentElement | ReactDOMElement;</span><br><span class="line"></span><br><span class="line">type ReactDOMElement = &#123;</span><br><span class="line">  type: string,</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: ReactNodeList,</span><br><span class="line">    className: string,</span><br><span class="line">    etc.</span><br><span class="line">  &#125;,</span><br><span class="line">  key: string | boolean | number | <span class="literal">null</span>,</span><br><span class="line">  ref: string | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type ReactComponentElement&lt;TProps&gt; = &#123;</span><br><span class="line">  type: ReactClass&lt;TProps&gt;,</span><br><span class="line">  props: TProps,</span><br><span class="line">  key: string | boolean | number | <span class="literal">null</span>,</span><br><span class="line">  ref: string | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type ReactFragment = <span class="built_in">Array</span>&lt;ReactNode | ReactEmpty&gt;;</span><br><span class="line"></span><br><span class="line">type ReactNodeList = ReactNode | ReactEmpty;</span><br><span class="line"></span><br><span class="line">type ReactText = string | number;</span><br><span class="line"></span><br><span class="line">type ReactEmpty = <span class="literal">null</span> | <span class="literal">undefined</span> | boolean;</span><br></pre></td></tr></table></figure>
<p>Virtual DOM 是如何根据这些节点类型来创建元素的呢？</p>
<h2 id="创建-React-元素"><a href="#创建-React-元素" class="headerlink" title="创建 React 元素"></a>创建 React 元素</h2><p>我们知道通过 JSX 创建的虚拟元素最终会被编译成调用 React 的 createElement 方法。那么 createElement 方法到底做了什么呢,其实 createElement 只是做了简单的参数修正，返回一个 ReactElement 实例对象，也就是虚拟元素实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ReactElement.createElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化参数</span></span><br><span class="line">  <span class="keyword">var</span> propName;</span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在config，则提取里面的内容</span></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    ref = config.ref === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.ref;</span><br><span class="line">    key = config.key === <span class="literal">undefined</span> ? <span class="literal">null</span> : <span class="string">''</span> + config.key;</span><br><span class="line">    self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">    source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line">    <span class="comment">// 复制config里的内容到props（如id和className等）</span></span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.hasOwnProperty(propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理children，全部挂载到props的children属性上。如果只有一个参数，直接赋值给children，否则做合并处理。</span></span><br><span class="line">  <span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenLength; i ++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果某个prop为空且存在默认的prop，则将默认prop赋给当前的prop</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    <span class="keyword">var</span> defaultProps = type.defaultProps;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> props[propName] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个ReactElement实例对象</span></span><br><span class="line">  <span class="keyword">return</span> ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Virtual DOM 通过 createElement 创建虚拟元素，那又是如何创建组件的呢？</p>
<h2 id="初始化组件入口"><a href="#初始化组件入口" class="headerlink" title="初始化组件入口"></a>初始化组件入口</h2><p>当使用 React 创建组件时，首先会调用 instantiateReactComponent,这是初始化组件的入口函数，它通过判断 node 类型来区分不同组件的入口。</p>
<ol>
<li><p>当 node 为空时，说明 node 不存在，则初始化空组件 ReactEmptyComponent.create(instantiateReactComponent).</p>
</li>
<li><p>当 node 类型为对象，需进一步判断，如果 element 类型为字符串时，则初始化 DOM 标签组件 ReactNativeComponent.createInternalComponent(element),否则初始化自定义组件<br>ReactCompositeComponentWrapper()</p>
</li>
<li><p>当 node 类型为字符串或数字时，则初始化文本组件 ReactNativeComponent.createInstanceForText(node)</p>
</li>
<li><p>其他情况不处理</p>
</li>
</ol>
<p>instantiateReactComponent方法的源码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化组件入口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node, parentCompositeType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 空组件（ReactEmptyComponent）</span></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span> || node === <span class="literal">false</span>) &#123;</span><br><span class="line">    instance = ReactEmptyComponent.create(instantiateReactComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = node;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="comment">// DOM标签（ReactDOMComponent）</span></span><br><span class="line">      instance = RectNativeComponent.createInternalComponent(element)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">      <span class="comment">// 不是字符串表示的自定义组件暂无法使用，此处将不做组件的初始化操作</span></span><br><span class="line">      instance = <span class="keyword">new</span> element.type(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 自定义组件（ReactCompositeComponent）</span></span><br><span class="line">      instance = <span class="keyword">new</span> ReactCompositeComponentWrapper();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 字符串或数字（ReactTextComponent）</span></span><br><span class="line">    instance = ReactNativeComponent.createInstanceForText(node)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不做处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置实例</span></span><br><span class="line">  instance.construct(node);</span><br><span class="line">  <span class="comment">// 初始化参数</span></span><br><span class="line">  instance._mountIndex = <span class="number">0</span>;</span><br><span class="line">  instance._mountImage = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文本组件"><a href="#文本组件" class="headerlink" title="文本组件"></a>文本组件</h2><p>node 类型为文本节点是不算 Virtual DOM 元素的，但 React 为了保持渲染的一致性，将其封装为文本组件ReactDOMTextComponent。</p>
<p>在执行 mountComponent 方法时，ReactDOMTextComponent 通过 transaction.useCreateElement 判断该文本是否是通过 createElement 方法创建的节点，如果是，则为该节点创建相应的标签和标识 domID，这样每个文本节点也能与其他 React 节点一样拥有自己的唯一标识，同时也拥有了VirtualDOM diff的权利。如果不是，则不再为其创建<code>&lt;span&gt;</code>和 domID 标识，直接返回文本。</p>
<p>不再为裸露的文本内容包裹<code>&lt;span&gt;</code>标签,是React15.0版本的更新点之一。此前，React为裸露的文本内容包裹上<code>&lt;span&gt;</code>标签，其实并没有任何作用，反而增加了不必要的标签。</p>
<p>在执行 receiveComponent 方法时，可以通过 DOMChildrenOperations.replaceDelimitedText(componentNodes[0], componentNodes[1], nextStringText)来更新文本内容。</p>
<p>ReactDOMTextComponent的源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文本组件，这是ReactText，并不是ReactElementd</span></span><br><span class="line"><span class="keyword">var</span> ReactDOMTextComponent = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存当前的字符串</span></span><br><span class="line">  <span class="keyword">this</span>._currentElement = text;</span><br><span class="line">  <span class="keyword">this</span>._stringText = <span class="string">''</span> + text;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ReactDOMComponentTree 需要使用的参数</span></span><br><span class="line">  <span class="keyword">this</span>._nativeNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._nativeParent = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>._domID = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._mountIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>._closingComment = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._commentNodes = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(ReactDOMTextComponent.prototype, &#123;</span><br><span class="line">  mountComponent: <span class="function"><span class="keyword">function</span>(<span class="params">transaction nativeParent, nativeContainerInfo, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> domID = nativeContainerInfo._idCounter++;</span><br><span class="line">    <span class="keyword">var</span> openingValue = <span class="string">' react-text: '</span> + domID + <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> closingValue = <span class="string">' /react-text '</span>;</span><br><span class="line">    <span class="keyword">this</span>._domID = domID;</span><br><span class="line">    <span class="keyword">this</span>._nativeParent = nativeParent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果使用createElement创建文本标签，则该文本会带上标签和domID</span></span><br><span class="line">    <span class="keyword">if</span> (transaction.useCreateElement) &#123;</span><br><span class="line">      <span class="keyword">var</span> ownerDocument = nativeContainerInfo._ownerDocument;</span><br><span class="line">      <span class="keyword">var</span> openingComment = ownerDocument.createCommet(openingValue);</span><br><span class="line">      <span class="keyword">var</span> closingComment = ownerDocument.createComment(closingValue);</span><br><span class="line">      <span class="keyword">var</span> lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());</span><br><span class="line">      <span class="comment">// 开始标签</span></span><br><span class="line">      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));</span><br><span class="line">      <span class="comment">// 如果是文本类型，则创建文本节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._stringText) &#123;</span><br><span class="line">        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(<span class="keyword">this</span>._stringText)));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 结束标签</span></span><br><span class="line">      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));</span><br><span class="line">      ReactDOMComponentTree.precacheNode(<span class="keyword">this</span>, openingComment);</span><br><span class="line">      <span class="keyword">this</span>._closingComment = closingComment;</span><br><span class="line">      <span class="keyword">return</span> lazyTree;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> escapedText = escapeTextContentForBrowser(<span class="keyword">this</span>._stringText);</span><br><span class="line">      <span class="comment">// 静态页面下直接返回文本</span></span><br><span class="line">      <span class="keyword">if</span> (transaction.renderToStaticMarkup) &#123;</span><br><span class="line">        <span class="keyword">return</span> escapedText;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果不是通过createElement创建的文本，则将标签和属性注释掉，直接返回文本内容。</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">'!&lt;--'</span> + openingValue + <span class="string">'--&gt;'</span> + escapedText + <span class="string">'&lt;!--'</span> + closingValue + <span class="string">'--&gt;'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新文本内容</span></span><br><span class="line">  receiveComponent: <span class="function"><span class="keyword">function</span>(<span class="params">nextComponent, transaction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextText !== <span class="keyword">this</span>._currentElement) &#123;</span><br><span class="line">      <span class="keyword">this</span>._currentElement = nextText;</span><br><span class="line">      <span class="keyword">var</span> nextStringText = <span class="string">''</span> + nextText;</span><br><span class="line">      <span class="keyword">if</span> (nextStringText !== <span class="keyword">this</span>._stringText) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stringText = nextStringText;</span><br><span class="line">        <span class="keyword">var</span> componentNodes = <span class="keyword">this</span>.getNativeNode();</span><br><span class="line"></span><br><span class="line">        DOMChildrenOerations.replaceDelimitedText(commentNodes[<span class="number">0</span>], commentNodes[<span class="number">1</span>], nextStringText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="DOM-标签组件"><a href="#DOM-标签组件" class="headerlink" title="DOM 标签组件"></a>DOM 标签组件</h2><p>ReactDOMComponent 针对 Vitual DOM 标签的处理主要分为以下两个部分：</p>
<ol>
<li>属性的更新，包括更新样式、更新属性、处理事件等；</li>
<li>子节点的更新，包括更新内容、更新子节点，此部分涉及 diff 算法</li>
</ol>
<h2 id="更新属性"><a href="#更新属性" class="headerlink" title="更新属性"></a>更新属性</h2><p>当执行 mountComponent 方法时，ReactDOMComponent 首先会生成标记和标签，通过 this.createOpenTagMarkupAndPutListeners(transaction)来处理 DOM 节点的属性和事件。</p>
<ol>
<li>如果存在事件，则对当前的节点添加事件代理，即调用 enqueuePutListener(this, propKey, propValue, transaction)</li>
<li>如果存在样式，首先会对样式进行合并操作 Object.assign({}, props.style),然后通过 CSSPropertyOperations.createMarkupForStyles(propValue, this)创建样式。</li>
<li>通过DOMPropertyOperations.createMarkupForProperty(propKey, propValue)创建属性。</li>
<li>通过 DOMPropertyOperations.createMarkupForID(this._domID)创建唯一标识</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">_createOpenTagMarkupAndPutListeners: <span class="function"><span class="keyword">function</span>(<span class="params">transaction, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="string">'&lt;'</span> + <span class="keyword">this</span>._currentElement.type;</span><br><span class="line">  <span class="comment">// 拼凑出属性</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> propKey <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">var</span> propValue = props[propKey]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="comment">// 针对当前的节点添加事件代理</span></span><br><span class="line">      <span class="keyword">if</span> (propValue) &#123;</span><br><span class="line">        enqueuePutListener(<span class="keyword">this</span>, propKey, propValue, transaction)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propValue) &#123;</span><br><span class="line">          <span class="comment">// 合并样式</span></span><br><span class="line">          propValue = <span class="keyword">this</span>._previousStyleCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, props.style)</span><br><span class="line">        &#125;</span><br><span class="line">        propValue = CSSPropertyOperations.createMarkupForStyles(propValue, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建属性标识</span></span><br><span class="line">      <span class="keyword">var</span> markup = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._tag != <span class="literal">null</span> &amp;&amp; isCustomComponent(<span class="keyword">this</span>._tag, props)) &#123;</span><br><span class="line">        markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (markup) &#123;</span><br><span class="line">        ret += <span class="string">' '</span> + markup</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于静态页面，不需要设置react-id，这样可以节省大量字符</span></span><br><span class="line">  <span class="keyword">if</span> (transaction.renderToStaticMarkup) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置react-id</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._nativeParent) &#123;</span><br><span class="line">    ret += <span class="string">' '</span> + DOMPropertyOperations.createMarkupForRoot();</span><br><span class="line">  &#125;</span><br><span class="line">  ret += <span class="string">' '</span> + DOMPropertyOperations.createMarkupForID(<span class="keyword">this</span>._domID)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行 receiveComponent 方法时，ReactDOMComponent 会通过 this.updateComponent(transaction, prevElement, nextElement, context)来更新 DOM 节点属性。</p>
<p>先是删除不需要的旧属性。如果不需要旧样式，则遍历旧样式集合，并对每个样式进行置空删除；如果不需要事件，则将其事件监听的属性去掉，即针对当前的节点取消事件代理 deleteListener(this, propKey);如果旧属性不在新属性集合里时，则需要删除旧属性 DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey)。</p>
<p>再是更新新属性。如果存在新样式，则将新样式进行合并 Object.assign({}, nextProp);如果在旧样式中但不在新样式中，则清除该样式；如果既在旧样式中也在新样式中，且不相同，则更新样式 styleUpdates[styleName] = nextProp[styleName];如果在新样式中，但不在旧样式中，则直接更新为新样式 styleUpdates = nextProp;如果存在事件更新，则添加事件监听的属性 enqueuePutListener(this, propKey, nextProp, transaction);如果存在新属性，则添加新属性，或者更新旧的同名属性 DOMPropertyOperations.setValueForAttribute(node, propkey, nextProp).</p>
<p>至此，ReactDOMComponent完成了DOM节点属性更新的操作，相关代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">_updateDOMProperties: <span class="function"><span class="keyword">function</span>(<span class="params">lastProps, nextProps, transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> propKey;</span><br><span class="line">  <span class="keyword">var</span> styleName;</span><br><span class="line">  <span class="keyword">var</span> styleUpdates;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当一个旧属性不在新的属性集合里时，需要删除</span></span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</span><br><span class="line">    <span class="comment">// 如果新属性里有，或者propKey是在原型上的则直接跳过，这样剩下的都是不在新属性集合里的。</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从DOM上删除不需要的样式</span></span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastStyle = <span class="keyword">this</span>._previousStyleCopy;</span><br><span class="line">      <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastStyle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastStyle.hasOwnProperty(styleName)) &#123;</span><br><span class="line">          styleUpdates = styleUpdates || &#123;&#125;;</span><br><span class="line">          styleUpdates[styleName] = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>._previousStyleCopy = <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastProps[propKey]) &#123;</span><br><span class="line">        <span class="comment">// 这里的事件监听的属性需要去掉监听，针对当前的节点取消事件代理</span></span><br><span class="line">        deleteListener(<span class="keyword">this</span>, propKey)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) &#123;</span><br><span class="line">      <span class="comment">// 从DOM上删除不需要的属性</span></span><br><span class="line">      DOMPropertyOperations.deleteValueForProperty(getNode(<span class="keyword">this</span>), propKey)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于新的属性，需要写到DOM节点上</span></span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">var</span> nextProp = nextProps[propKey];</span><br><span class="line">    <span class="keyword">var</span> lastProp = propKey === STYLE ? <span class="keyword">this</span>._previousStyleCopy : lastProps != <span class="literal">null</span> ? lastProps[propKey] : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 不在新属性中，或与旧属性相同，则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp === <span class="literal">null</span> &amp;&amp; lastProp == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在DOM上写入新样式（更新样式）</span></span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">        nextProp = <span class="keyword">this</span>._previousStyleCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, nextProp)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lastProp) &#123;</span><br><span class="line">        <span class="comment">// 在旧样式中且不在新样式中，清除该样式</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) &#123;</span><br><span class="line">            styleUpdates = styleUpdates || &#123;&#125;</span><br><span class="line">            styleUpdates[styleName] = <span class="string">''</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 即在旧样式中也在新样式中，且不相同，更新该样式</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> nextProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) &#123;</span><br><span class="line">            styleUpdates = styleUpdates || &#123;&#125;</span><br><span class="line">            styleUpdates[styleName] = nextProp[styleName]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在旧样式，直接写入新样式</span></span><br><span class="line">        styleUpdates = nextProp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">        <span class="comment">// 添加事件监听的属性</span></span><br><span class="line">        enqueuePutListener(<span class="keyword">this</span>, propKey, nextProp, transaction)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteListener(<span class="keyword">this</span>, propKey)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 添加新的属性，或者是更新旧的同名属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCustomComponent(<span class="keyword">this</span>._tag, nextProps)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!RESERVED_PROPS.hasOwnProperty(propKey)) &#123;</span><br><span class="line">        <span class="comment">// setValueForAttribute 更新属性</span></span><br><span class="line">        DOMPropertyOperations.setValueForAttribute(getNode(<span class="keyword">this</span>), propKey, nextProp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) &#123;</span><br><span class="line">      <span class="keyword">var</span> node = getNode(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">        DOMPropertyOperations.setValueForProperty(node, propKey, nextProp)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果更新为null或undefined，则执行删除属性操作</span></span><br><span class="line">        DOMPropertyOperations.deleteValueForProperty(node, propKey)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果styleUpdates不为空，则设置新样式</span></span><br><span class="line">    <span class="keyword">if</span> (styleUpdates) &#123;</span><br><span class="line">      CSSPropertyOperations.setValueForStyles(getNode(<span class="keyword">this</span>), styleUpdates, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h2><p>当执行mountComponent方法时，ReactDOMComponent会通过this._createContentMarkup(transaction, props, context)来处理DOM节点的内容。</p>
<p>首先，获取节点内容props.dangerouslySetInnerHTML。如果存在子节点，则通过this.mountChildren(childrenToUse, transaction, context)对子节点进行初始化渲染：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_createContentMarkup: <span class="function"><span class="keyword">function</span>(<span class="params">transaction, props, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取子节点渲染出的内容</span></span><br><span class="line">  <span class="keyword">var</span> innerHTML = props.dangerouslySetInnerHTML;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (innerHTML != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (innerHTML.__html != <span class="literal">null</span>) &#123;</span><br><span class="line">      ret = innerHTML.__html;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> contentToUse = CONTENT_TYPES[<span class="keyword">typeof</span> props.children] ? props.children : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> childrenToUse = contentToUse != <span class="literal">null</span> ? <span class="literal">null</span> : props.children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childrenToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">      ret = escapeTextContentForBrowser(contentToUse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 对子节点进行初始化渲染</span></span><br><span class="line">      <span class="keyword">var</span> mountImages = <span class="keyword">this</span>.mountChildren(childrenToUse, transaction, context)</span><br><span class="line"></span><br><span class="line">      ret = mountImages.join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否需要换行</span></span><br><span class="line">  <span class="keyword">if</span> (newlineEatingTags[<span class="keyword">this</span>._tag] &amp;&amp; ret.charAt(<span class="number">0</span>) === <span class="string">'\n'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\n'</span> + ret;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行 receiveComponent 方法时，ReactDOMComponent 会通过 this._updateDOMChildren(lastProps, nextProps, transaction, context)来更新 DOM 内容和子节点。</p>
<p>先是删除不需要的子节点和内容。如果旧节点存在，而新节点不存在，说明当前节点在更新后被删除，此时执行 this.updateChildren(null, transaction, context);如果旧的内容存在，而新的内容不存在，说明当前内容在更新后被删除，此时执行方法 this.updateTextContent(‘’)。</p>
<p>再是更新子节点和内容。如果新子节点存在，则更新其子节点，此时执行方法 this.updateChildren(nextChildren, transaction, context);如果新内容存在，更新内容，执行 this.updateTextContent(‘’ + nextContent)</p>
<p>至此，ReactDOMComponent完成了DOM子节点和内容的更新操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_updateDOMChildren: <span class="function"><span class="keyword">function</span>(<span class="params">lastProps, nextProps, transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastContent = CONTENT_TYPES[<span class="keyword">typeof</span> lastProps.children] ? lastProps.children : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> nextContent = CONTENT_TYPES[<span class="keyword">typeof</span> nextProps.children] ? nextProps.children : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> lastHtml = lastProps.dangerouslySetInnerHTML &amp;&amp; lastProps.dangerouslySetInnerHTML._html;</span><br><span class="line">  <span class="keyword">var</span> nextHtml = nextProps.dangerouslySetInnerHTML &amp;&amp; nextProps.dangerouslySetInnerHTML._html;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> lastChildren = lastContent != <span class="literal">null</span> ? nu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当卸载组件时，ReactDOMComponent 会卸载子节点、清除事件监听、情空标识等。</p>
<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>ReactCompositeComponent 自定义组件实现了一整套 React 生命周期和 setState 机制，因此自定义组件是在生命周期的环境中进行更新属性、内容和子节点的操作。这些更新操作与 ReactDOMComponent 的操作类似，在此不再赘述。</p>
<h2 id="初探-React-生命周期"><a href="#初探-React-生命周期" class="headerlink" title="初探 React 生命周期"></a>初探 React 生命周期</h2><ol>
<li>当首次挂载组件时，按顺序执行 getDefaultProps、getInitialState、componentWillMount、render 和 componentDidMount</li>
<li>当卸载组件时，执行 componentWillUnmount</li>
<li>当重新挂载组件时，此时按顺序执行 getInitialState、componentWillMount、render 和 componentDidMount，不执行 getDefaultProps</li>
<li>当再次渲染组件时，组件接受到更新状态，此时按顺序执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate</li>
</ol>
<p>在 ES6 语法中，static defaultProps = {} 就是调用的内部 getDefaultProps，constructor 中的 this.state = {}就是调用内部的 getInitialState。</p>
<h2 id="详解-React-生命周期"><a href="#详解-React-生命周期" class="headerlink" title="详解 React 生命周期"></a>详解 React 生命周期</h2><p>自定义组件（ReactCompositeComponent）的生命周期主要通过 3 个阶段进行管理——MOUNTING、RECEIVE_PROPS 和 UNMOUNTING。这个 3 个阶段对应 3 种方法，分别为：mountComponent、updateComponent、unmountComponent,每个方法都提供了几种处理方法，其中带 will 前缀的方法在进入状态之前调用，带 did 前缀的方法在进入状态之后调用。3 个阶段共包括 5 种处理方法，还有两种特殊状态的处理方法。</p>
<h2 id="1-使用-createClass-创建自定义组件"><a href="#1-使用-createClass-创建自定义组件" class="headerlink" title="1.使用 createClass 创建自定义组件"></a>1.使用 createClass 创建自定义组件</h2><p>createClass 是创建自定义组件的入口方法，负责管理生命周期的 getDefaultProps。该方法在整个生命周期中只执行一次，这样所有实例初始化的 props 将会被共享。<br>通过 createClass 创建自定义组件，利用原型继承 ReactClassComponent 父类，按顺序合并 mixin，设置初始化 defaultProps,返回构造函数。<br>class MyComponent extends React.Component 其实就是调用内部方法 createClass 创建组件。</p>
<h2 id="2-阶段一：MOUNTING"><a href="#2-阶段一：MOUNTING" class="headerlink" title="2.阶段一：MOUNTING"></a>2.阶段一：MOUNTING</h2><p>mountComponent 负责管理生命周期中的 getInitialState、componentWillMount、render 和 componentDidMount。<br>由于 getDefaultProps 是通过构造函数进行管理的，所以在整个生命周期中最先开始执行，也解释了为什么它只执行一次。<br>由于通过 ReactCompositeComponentBase 返回的是一个虚拟节点，所以需要利用 instantiateReactComponent 去得到实例，再使用 mountComponent 拿到结果作为当前自定义元素的结果。</p>
<p>通过 mountComponent 挂载组件，初始化序号、标记等参数，判断是否为无状态组件，并进行对应组件初始化工作，比如初始化 props、context 等参数。利用 getInitialState 获取初始化 state、初始化更新队列和更新状态。</p>
<p>若存在 componentWillMount，则执行。如果此时在 componentWillMount 中调用 setState 方法，是不是触发 re-render 的，而是会进行 state 合并，且 inst.state = this._processPendingState(inst.props, inst.context)是在 componentWillMount 之后执行的，因此 componentWillMount 中的 this.state 并不是最新的，在 render 中才可以获取更新后的 this.state。</p>
<p>因此，React 是利用更新队列 this._pendingStateQueue 以及更新状态 this._pendingReplaceState 和 this._pendingForceUpdate 来实现 setState 的异步更新机制。</p>
<p>当渲染完成后，若存在 ComponentDidMount,则调用。这就解释了 componentWillMount、render、componentDidMountzz 这三者之间的执行顺序。</p>
<p>其实，mountComponent 本质上是通过递归渲染内容的，由于递归的特性，父组件的 componentWillMount 在其子组件的 componentWillMount 之前调用，而 componentDidMount 在子组件的 componentDidMount 之后调用。</p>
<h2 id="3-阶段二：RECEIVE-PROPS"><a href="#3-阶段二：RECEIVE-PROPS" class="headerlink" title="3.阶段二：RECEIVE_PROPS"></a>3.阶段二：RECEIVE_PROPS</h2><p>updateComponent 负责管理生命周期中的 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate。</p>
<p>首先通过 updateComponent 更新组件，如果前后元素不一致，说明需要进行组件更新。</p>
<p>若存在 componentWillReceiveProps,则执行。如果此时在 componentWillReceiveProps 中调用 setState,是不会触发 re-render 的，而是会进行 state 合并。且在 componentWillReceiveProps、shouldComponentUpdate 和 componentWillUpdate 中也还是无法获取到更新后的 this.state,即此时访问的 this.state 仍然是未更新的数据，需要设置 inst.state = nextState 后才可以，因此只有在 render 和 componentDidUpdate 中才能获取到更新后的 this.state。</p>
<p>调用 shouldComponentUpdate 判断是否需要进行组件更新，如果存在 componentWillUpdate 则执行。</p>
<p>updateComponent 本质上也是通过递归渲染内容的，由于递归的特性，父组件的 componentWillUpdate 是其子组件的 componentWillUpdate 之前调用的，componentDidUpdate 在之后调用。</p>
<p>当渲染完成后，若存在 componentDidUpdate，则触发。</p>
<p>禁止在 shouldComponentUpdate 和 componentWillUpdate 中调用 setState，这会造成循环调用，直至耗光浏览器内存后崩溃。</p>
<h2 id="4-阶段三：UNMOUNTING"><a href="#4-阶段三：UNMOUNTING" class="headerlink" title="4.阶段三：UNMOUNTING"></a>4.阶段三：UNMOUNTING</h2><p>unmountComponnet 负责管理生命周期中的 componentWillUnmount。</p>
<p>如果存在 componentWillUnmount,则执行并重置所有相关参数、更新队列以及更新状态，如果此时在 componentWillUnmount 中调用 setState，是不会触发 re-render 的，这是因为所有更新队列和更新状态都被重置为 null，并清除了公共类，完成了组件卸载操作。</p>
<h2 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h2><p>无状态组件只是一个 render 方法，并没有组件类的实例化过程，也没有实例返回。</p>
<p>无状态组件没有状态，没有生命周期，只是简单接受 props 渲染生成 DOM 结构，是一个纯粹为渲染而生的组件。</p>
<h2 id="setState-异步更新"><a href="#setState-异步更新" class="headerlink" title="setState 异步更新"></a>setState 异步更新</h2><p>setState 通过一个队列机制实现 state 更新。当执行 setState 时，会将需要更新的 state 合并后放入状态队列，而不会立刻更新 this.state，队列机制可以高效地批量更新 state。如果不通过 setState 而直接修改 this.state 的值，那么该 state 将不会被放入状态队列中，当下次调用 setState 并对状态队列进行合并时，将会忽略之前直接被修改的 state。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将新的state合并到状态更新队列中</span></span><br><span class="line"><span class="keyword">var</span> nextState = <span class="keyword">this</span>._processPendingState(nextProps, nextContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据更新队列和shouldComponentUpdate的状态来判断是否需要更新组件</span></span><br><span class="line"><span class="keyword">var</span> shouldUpdate =</span><br><span class="line">  <span class="keyword">this</span>._pendingForceUpate ||</span><br><span class="line">  !inst.shouldComponentUpdate ||</span><br><span class="line">  inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br></pre></td></tr></table></figure>
<h2 id="setState-循环调用风险"><a href="#setState-循环调用风险" class="headerlink" title="setState 循环调用风险"></a>setState 循环调用风险</h2><p>当调用 setState 时，实际上会执行 enqueueSetState 方法，并对 partialState 以及_pendingStateQueue 更新队列进行合并操作，最终通过 enqueueUpdate 执行 state 更新。</p>
<p>而 performUpdateIfNecessary 方法会获取_pendingElement、_pendingStateQueue、_pendingForeUpdate,并调用 receiveComponent 和 updateComponent 方法进行组件更新。</p>
<p>如果在 shouldComponentUpdate 或 componentWillUpdate 方法中调用 setState，此时 this._pendingStateQueue != null,则 performUpdateIfNecessary 方法就会调用 updateComponent 方法进行组件更新，但 updateComponent 方法又会调用 shouldComponentUpdate 和 componentWillUpdate 方法，因此造成循环调用。</p>
<h2 id="setState-调用栈"><a href="#setState-调用栈" class="headerlink" title="setState 调用栈"></a>setState 调用栈</h2><p>setState 最终是通过 enqueueUpdate 执行 state 更新的，那么 enqueueUpdate 到底是如何更新 state 的呢？<br>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不处于批量更新模式</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果处于批量更新模式，则将该组件保存在dirtyComponents中</span></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>batchingStrategy 其实只是一个简单对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="初识事务"><a href="#初识事务" class="headerlink" title="初识事务"></a>初识事务</h2><p>事务就是将需要执行的方法使用 wrapper 封装起来，再通过事务提供的 perform 方法执行。而在 perform 之前，先执行所有 wrapper 中的 initialize 方法，执行完 perform 之后（即执行 method 方法吧之后）再执行所有的 close 方法。一组 initialize 及 close 方法称为一个 wrapper，事务支持多个 wrapper 叠加。</p>
<p>到实现上，事务提供了一个 mixin 方法供其他模块实现自己需要的事务。而要使用事务的模块，除了需要把 mixin 混入自己的事务实现中，还要额外实现一个抽象的 getTransactionWrappers 接口。这个接口用来获取所有需要封装的前置方法（initialize）和收尾方法（close）,因此它需要返回一个数组的对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">"./Transaction"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们自己定义的事务</span></span><br><span class="line"><span class="keyword">var</span> MyTransaction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyTransaction.prototype, Transaction.Mixin, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"before method"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"after method"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> MyTransaction();</span><br><span class="line"><span class="keyword">var</span> testMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">transaction.perform(testMethod);</span><br><span class="line"><span class="comment">// 打印出</span></span><br><span class="line"><span class="comment">// before method</span></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// after method</span></span><br></pre></td></tr></table></figure>
<p>???需补充 setState 状态的方法</p>
<h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><h1 id="Redux-基于-v3-5-2-版本"><a href="#Redux-基于-v3-5-2-版本" class="headerlink" title="Redux(基于 v3.5.2 版本)"></a>Redux(基于 v3.5.2 版本)</h1><h2 id="Redux-是什么"><a href="#Redux-是什么" class="headerlink" title="Redux 是什么"></a>Redux 是什么</h2><p>redux 是一个”可预测的状态容器”。</p>
<h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><p>1.单一数据源 2.状态是只读的 3.状态修改均由纯函数完成<br>没有副作用、可以每次数据变化前后的状态，可以时间旅行调试。</p>
<h2 id="Redux-核心-API"><a href="#Redux-核心-API" class="headerlink" title="Redux 核心 API"></a>Redux 核心 API</h2><p><code>createStore(reducers[,initialState])</code><br>在 redux 中，负责响应 action 并修改数据的角色是 reducer。reducer 本质是纯函数。<br>`reducer(previousState, action) =&gt; newState<br>createStore 创建的 store 是一个对象，包含 4 个方法<br>1.getState()<br>2.dispatch(action)<br>3.subscribe(listener)<br>4.replaceReducer(nextReducer):更新当前 store 里的 reducer，一般只会在开发模式中调用。</p>
<h2 id="与-React-绑定"><a href="#与-React-绑定" class="headerlink" title="与 React 绑定"></a>与 React 绑定</h2><p>react-redux 提供了一个组件(<code>&lt;Provider&gt;</code>)和一个 API(connect())帮助 Redux 和 React 进行绑定。</p>
<h2 id="Redux-middleware"><a href="#Redux-middleware" class="headerlink" title="Redux middleware"></a>Redux middleware</h2><p>middleware 提供了一个分类处理 action 的机会。在 middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会。</p>
<h2 id="理解-middleware-机制"><a href="#理解-middleware-机制" class="headerlink" title="理解 middleware 机制"></a>理解 middleware 机制</h2><p>Redux 提供了 applyMiddleware 方法来加载 middleware:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compose.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">      rest.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), last(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">"./compose"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">reducer, initialState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, initialState, enhancer);</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch;</span><br><span class="line">    <span class="keyword">var</span> chain = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function"><span class="params">action</span> =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现一个 logger middleware：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"dispatch:"</span>, action);</span><br><span class="line">  next(action);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"finish:"</span>, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，我们分 4 步来深入解析 middleware 的运行原理 1.函数式编程思想设计<br>middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的 curring，它是一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地将 store 和 next 的参数赋值。<br>curring 的 middleware 结构的好处主要有以下两点</p>
<ol>
<li>易串联：通过 currying 形成的 middleware 可以累积参数，再配合组合（compose）的方式，很容易形成 pipeling 来处理数据流。</li>
<li>共享 store: 在 applyMiddleware 执行的过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middleware 内部拿到的 store 是最新且相同的。</li>
</ol>
<p>2.给 middleware 分发 store<br>通过如下方式创建一个普通的 store:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newStore = applyMiddleWare(mid1, mid2, ...)(createStore)(reducer, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h2 id="解读-Redux"><a href="#解读-Redux" class="headerlink" title="解读 Redux"></a>解读 Redux</h2><p>createStore 几乎囊括了 Redux 的核心功能。</p>
<h2 id="参数归一化"><a href="#参数归一化" class="headerlink" title="参数归一化"></a>参数归一化</h2><p>先看看 createStore 的函数签名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, initialState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前两个参数比较常见，那么 enhancer 扮演了什么角色呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  enhancer = initialState;</span><br><span class="line">  initialState = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Expected the enhancer to be a function."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enhancer(createStore)(reducer, initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 enhancer(createStore)(reducer, initialState)调用中，enhancer 对 createStore 的能力进行了增强，最终返回 store。<br>典型使用案例是 redux-devtools-extension,它将 Redux DevTools 做成浏览器插件。</p>
<h2 id="初始状态及-getState"><a href="#初始状态及-getState" class="headerlink" title="初始状态及 getState"></a>初始状态及 getState</h2><p>完成基本参数校验后，在 createStore 中声明了如下变量及 getState 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentReducer = reducer;</span><br><span class="line"><span class="keyword">var</span> currentState = initialState;</span><br><span class="line"><span class="keyword">var</span> currentListeners = [];</span><br><span class="line"><span class="keyword">var</span> nextListeners = currentListeners;</span><br><span class="line"><span class="keyword">var</span> isDispatching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">    nextListeners = currentListeners.slice();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>currentReducer:当前的 reducer,支持通过 store.replaceReducer 方式动态替换 reducer,为代码热替换提供了可能。</li>
<li>currentState:应用的当前状态，默认为初始化时的状态。</li>
<li>currentListeners、nextListeners：监听器</li>
<li>isDispatching：某个 action 是否处于分发的处理过程中</li>
</ol>
<p>getState 方法用于返回当前状态。</p>
<h2 id="subscribe、unsubscribe"><a href="#subscribe、unsubscribe" class="headerlink" title="subscribe、unsubscribe"></a>subscribe、unsubscribe</h2><p>在 getState 之后定义了 store 的 subscribe 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Expected listener to be a function."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> isSubscribed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  ensureCanMutateNextListeners();</span><br><span class="line">  nextListeners.push(listener);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners();</span><br><span class="line">    <span class="keyword">var</span> index = nextListeners.indexOf(listener);</span><br><span class="line">    nextListeners.splice(index, <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>subscribe 将 listener 添加到 nextListeners 中，unsubscribe 可以删除这个 listener。</p>
<h2 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h2><p>接下来就是 dispatch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">"Actions must be plain objects. "</span> +</span><br><span class="line">        <span class="string">"Use custom middleware for async actions."</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">        <span class="string">"Have you misspelled a constant?"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Reducers may not dispatch actions."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">true</span>;</span><br><span class="line">    currentState = currentReducer(currentState, action);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> listeners = (currentListeners = nextListeners);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    listeners[i]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先是一些校验，然后将当前的状态和 action 传给当前的 reducer,用于生成最新的 state。再依次调用所有的监听器，通知状态的变更。最后返回 action</p>
<h2 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h2><p>这个方法主要用于 reducer 的热替换，在开发过程中很少使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Expected the nextReducer to be a function."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentReducer = nextReducer;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch({ type: ActionTypes.INIT })是为了拿到所有 reducer 中的初始状态，只用所有状态都成功获取后，Redux 应用才能有条不紊地运作。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/react/" rel="tag"># react</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/08/CommonJS规范/" rel="next" title="CommonJS规范">
                <i class="fa fa-chevron-left"></i> CommonJS规范
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/16/埋点/" rel="prev" title="埋点">
                埋点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDUxMi8xMTA1MA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="小光">
            
              <p class="site-author-name" itemprop="name">小光</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/mfaying" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1213560387@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#React-简介"><span class="nav-number">1.</span> <span class="nav-text">React 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#专注视图层"><span class="nav-number">1.1.</span> <span class="nav-text">专注视图层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-DOM"><span class="nav-number">1.2.</span> <span class="nav-text">Virtual DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程"><span class="nav-number">1.3.</span> <span class="nav-text">函数式编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSX-语法"><span class="nav-number">2.</span> <span class="nav-text">JSX 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM-元素和组件元素"><span class="nav-number">2.1.</span> <span class="nav-text">DOM 元素和组件元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM-元素"><span class="nav-number">2.2.</span> <span class="nav-text">DOM 元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件元素"><span class="nav-number">2.3.</span> <span class="nav-text">组件元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSX-基本语法"><span class="nav-number">2.4.</span> <span class="nav-text">JSX 基本语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XML-基本语法"><span class="nav-number">2.5.</span> <span class="nav-text">XML 基本语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素类型"><span class="nav-number">2.6.</span> <span class="nav-text">元素类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素属性"><span class="nav-number">2.7.</span> <span class="nav-text">元素属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React-组件"><span class="nav-number">3.</span> <span class="nav-text">React 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#组件的演变"><span class="nav-number">3.1.</span> <span class="nav-text">组件的演变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-组件的构建"><span class="nav-number">3.2.</span> <span class="nav-text">React 组件的构建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React-数据流"><span class="nav-number">4.</span> <span class="nav-text">React 数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#state"><span class="nav-number">4.1.</span> <span class="nav-text">state</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#props"><span class="nav-number">4.2.</span> <span class="nav-text">props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子组件-prop"><span class="nav-number">4.3.</span> <span class="nav-text">子组件 prop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件props"><span class="nav-number">4.4.</span> <span class="nav-text">组件props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用function-prop与父组件通信"><span class="nav-number">4.5.</span> <span class="nav-text">用function prop与父组件通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#propTypes"><span class="nav-number">4.6.</span> <span class="nav-text">propTypes</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React生命周期"><span class="nav-number">5.</span> <span class="nav-text">React生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#挂载和卸载过程"><span class="nav-number">5.1.</span> <span class="nav-text">挂载和卸载过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据更新过程"><span class="nav-number">5.2.</span> <span class="nav-text">数据更新过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React与DOM"><span class="nav-number">6.</span> <span class="nav-text">React与DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReactDOM"><span class="nav-number">6.1.</span> <span class="nav-text">ReactDOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#render"><span class="nav-number">6.2.</span> <span class="nav-text">render</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReactDOM的不稳定方法"><span class="nav-number">6.3.</span> <span class="nav-text">ReactDOM的不稳定方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#refs"><span class="nav-number">6.4.</span> <span class="nav-text">refs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React之外的DOM操作"><span class="nav-number">6.5.</span> <span class="nav-text">React之外的DOM操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件系统"><span class="nav-number">7.</span> <span class="nav-text">事件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#合成事件的绑定方式"><span class="nav-number">7.1.</span> <span class="nav-text">合成事件的绑定方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合成事件的实现机制"><span class="nav-number">7.2.</span> <span class="nav-text">合成事件的实现机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在React中使用原生事件"><span class="nav-number">7.3.</span> <span class="nav-text">在React中使用原生事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对比React合成事件与JavaScript原生事件"><span class="nav-number">7.4.</span> <span class="nav-text">对比React合成事件与JavaScript原生事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表单"><span class="nav-number">8.</span> <span class="nav-text">表单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用表单组件"><span class="nav-number">8.1.</span> <span class="nav-text">应用表单组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#受控组件"><span class="nav-number">8.2.</span> <span class="nav-text">受控组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非受控组件"><span class="nav-number">8.3.</span> <span class="nav-text">非受控组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对比受控组件和非受控组件"><span class="nav-number">8.4.</span> <span class="nav-text">对比受控组件和非受控组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表单组件的几个重要属性"><span class="nav-number">8.5.</span> <span class="nav-text">表单组件的几个重要属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#样式处理"><span class="nav-number">9.</span> <span class="nav-text">样式处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本样式设置"><span class="nav-number">9.1.</span> <span class="nav-text">基本样式设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用classnames库"><span class="nav-number">9.2.</span> <span class="nav-text">使用classnames库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-Modules"><span class="nav-number">9.3.</span> <span class="nav-text">CSS Modules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启用CSS-Modules"><span class="nav-number">9.4.</span> <span class="nav-text">启用CSS Modules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#样式默认局部"><span class="nav-number">9.5.</span> <span class="nav-text">样式默认局部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用composes来组合样式"><span class="nav-number">9.6.</span> <span class="nav-text">使用composes来组合样式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class命名技巧"><span class="nav-number">9.7.</span> <span class="nav-text">class命名技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现CSS与JavaScript变量共享"><span class="nav-number">9.8.</span> <span class="nav-text">实现CSS与JavaScript变量共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-Modules使用技巧"><span class="nav-number">9.9.</span> <span class="nav-text">CSS Modules使用技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-Modules结合历史遗留项目实践"><span class="nav-number">9.10.</span> <span class="nav-text">CSS Modules结合历史遗留项目实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-Modules结合React实践"><span class="nav-number">9.11.</span> <span class="nav-text">CSS Modules结合React实践</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件间通信"><span class="nav-number">10.</span> <span class="nav-text">组件间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#父组件向子组件通信"><span class="nav-number">10.1.</span> <span class="nav-text">父组件向子组件通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子组件向父组件通信"><span class="nav-number">10.2.</span> <span class="nav-text">子组件向父组件通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跨级组件通信"><span class="nav-number">10.3.</span> <span class="nav-text">跨级组件通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#没有嵌套关系的组件通信"><span class="nav-number">10.4.</span> <span class="nav-text">没有嵌套关系的组件通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件间抽象"><span class="nav-number">11.</span> <span class="nav-text">组件间抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装mixin方法"><span class="nav-number">11.1.</span> <span class="nav-text">封装mixin方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在React中使用mixin"><span class="nav-number">11.2.</span> <span class="nav-text">在React中使用mixin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-Classes与decorator"><span class="nav-number">11.3.</span> <span class="nav-text">ES6 Classes与decorator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mixin的问题"><span class="nav-number">11.4.</span> <span class="nav-text">mixin的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶组件"><span class="nav-number">11.5.</span> <span class="nav-text">高阶组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反向继承"><span class="nav-number">11.6.</span> <span class="nav-text">反向继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件命名"><span class="nav-number">11.7.</span> <span class="nav-text">组件命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件参数"><span class="nav-number">11.8.</span> <span class="nav-text">组件参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合式组件开发实践"><span class="nav-number">11.9.</span> <span class="nav-text">组合式组件开发实践</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件性能优化"><span class="nav-number">12.</span> <span class="nav-text">组件性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#纯函数"><span class="nav-number">12.1.</span> <span class="nav-text">纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PureRender"><span class="nav-number">12.2.</span> <span class="nav-text">PureRender</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Immutable"><span class="nav-number">12.3.</span> <span class="nav-text">Immutable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Immutable的优点"><span class="nav-number">12.4.</span> <span class="nav-text">Immutable的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Immutable的缺点"><span class="nav-number">12.5.</span> <span class="nav-text">使用Immutable的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Immutable-js"><span class="nav-number">12.6.</span> <span class="nav-text">Immutable.js</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Immutable与cursor"><span class="nav-number">12.7.</span> <span class="nav-text">Immutable与cursor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Immutable与PureRender"><span class="nav-number">12.8.</span> <span class="nav-text">Immutable与PureRender</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Immutable与setState"><span class="nav-number">12.9.</span> <span class="nav-text">Immutable与setState</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key"><span class="nav-number">12.10.</span> <span class="nav-text">key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-addons-perf"><span class="nav-number">12.11.</span> <span class="nav-text">react-addons-perf</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解读-React-源码"><span class="nav-number">13.</span> <span class="nav-text">解读 React 源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-DOM-1"><span class="nav-number">13.1.</span> <span class="nav-text">Virtual DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-React-元素"><span class="nav-number">13.2.</span> <span class="nav-text">创建 React 元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化组件入口"><span class="nav-number">13.3.</span> <span class="nav-text">初始化组件入口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本组件"><span class="nav-number">13.4.</span> <span class="nav-text">文本组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM-标签组件"><span class="nav-number">13.5.</span> <span class="nav-text">DOM 标签组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新属性"><span class="nav-number">13.6.</span> <span class="nav-text">更新属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新子节点"><span class="nav-number">13.7.</span> <span class="nav-text">更新子节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义组件"><span class="nav-number">13.8.</span> <span class="nav-text">自定义组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初探-React-生命周期"><span class="nav-number">13.9.</span> <span class="nav-text">初探 React 生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#详解-React-生命周期"><span class="nav-number">13.10.</span> <span class="nav-text">详解 React 生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-使用-createClass-创建自定义组件"><span class="nav-number">13.11.</span> <span class="nav-text">1.使用 createClass 创建自定义组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-阶段一：MOUNTING"><span class="nav-number">13.12.</span> <span class="nav-text">2.阶段一：MOUNTING</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-阶段二：RECEIVE-PROPS"><span class="nav-number">13.13.</span> <span class="nav-text">3.阶段二：RECEIVE_PROPS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-阶段三：UNMOUNTING"><span class="nav-number">13.14.</span> <span class="nav-text">4.阶段三：UNMOUNTING</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无状态组件"><span class="nav-number">13.15.</span> <span class="nav-text">无状态组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setState-异步更新"><span class="nav-number">13.16.</span> <span class="nav-text">setState 异步更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setState-循环调用风险"><span class="nav-number">13.17.</span> <span class="nav-text">setState 循环调用风险</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setState-调用栈"><span class="nav-number">13.18.</span> <span class="nav-text">setState 调用栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初识事务"><span class="nav-number">13.19.</span> <span class="nav-text">初识事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff-算法"><span class="nav-number">13.20.</span> <span class="nav-text">diff 算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redux-基于-v3-5-2-版本"><span class="nav-number">14.</span> <span class="nav-text">Redux(基于 v3.5.2 版本)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux-是什么"><span class="nav-number">14.1.</span> <span class="nav-text">Redux 是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux-三大原则"><span class="nav-number">14.2.</span> <span class="nav-text">Redux 三大原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux-核心-API"><span class="nav-number">14.3.</span> <span class="nav-text">Redux 核心 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与-React-绑定"><span class="nav-number">14.4.</span> <span class="nav-text">与 React 绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux-middleware"><span class="nav-number">14.5.</span> <span class="nav-text">Redux middleware</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解-middleware-机制"><span class="nav-number">14.6.</span> <span class="nav-text">理解 middleware 机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解读-Redux"><span class="nav-number">14.7.</span> <span class="nav-text">解读 Redux</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数归一化"><span class="nav-number">14.8.</span> <span class="nav-text">参数归一化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始状态及-getState"><span class="nav-number">14.9.</span> <span class="nav-text">初始状态及 getState</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#subscribe、unsubscribe"><span class="nav-number">14.10.</span> <span class="nav-text">subscribe、unsubscribe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch"><span class="nav-number">14.11.</span> <span class="nav-text">dispatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#replaceReducer"><span class="nav-number">14.12.</span> <span class="nav-text">replaceReducer</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    by
  </span>
  <span class="author" itemprop="copyrightHolder">小光</span>

  
</div>













        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("rXDtthwfyBtPIDbpKrjcpxmS-gzGzoHsz", "5fvqAap2dh7V6AXxOQgVSqSU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

  <script>
    $('.blur-bg').css('height', $(document).height() + 130);
    var blogClearTimer = setInterval(function () {
      if (!(localStorage.getItem('mfaying') === 'blog')) {
        window.document.write("");
      } else {
        clearInterval(blogClearTimer);
      }
    }, 500);
  </script>
</body>
</html>
